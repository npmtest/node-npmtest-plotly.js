{"/home/travis/build/npmtest/node-npmtest-plotly.js/test.js":"/* istanbul instrument in package npmtest_plotly_js */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-plotly.js/lib.npmtest_plotly.js.js":"/* istanbul instrument in package npmtest_plotly_js */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_plotly_js = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_plotly_js = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-plotly.js/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-plotly.js && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_plotly_js */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_plotly_js\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_plotly_js.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_plotly_js.rollup.js'] =\n            local.assetsDict['/assets.npmtest_plotly_js.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_plotly_js.__dirname + '/lib.npmtest_plotly_js.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/lib/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Plotly = require('./core');\n\n// traces\nPlotly.register([\n    require('./bar'),\n    require('./box'),\n    require('./heatmap'),\n    require('./histogram'),\n    require('./histogram2d'),\n    require('./histogram2dcontour'),\n    require('./pie'),\n    require('./contour'),\n    require('./scatterternary'),\n\n    require('./scatter3d'),\n    require('./surface'),\n    require('./mesh3d'),\n\n    require('./scattergeo'),\n    require('./choropleth'),\n\n    require('./scattergl'),\n    require('./pointcloud'),\n    require('./heatmapgl'),\n    require('./parcoords'),\n\n    require('./scattermapbox'),\n\n    require('./carpet'),\n    require('./scattercarpet'),\n    require('./contourcarpet'),\n\n    require('./ohlc'),\n    require('./candlestick')\n]);\n\n// transforms\n//\n// Please note that all *transform* methods are executed before\n// all *calcTransform* methods - which could possibly lead to\n// unexpected results when applying multiple transforms of different types\n// to a given trace.\n//\n// For more info, see:\n// https://github.com/plotly/plotly.js/pull/978#pullrequestreview-2403353\n//\nPlotly.register([\n    require('./filter'),\n    require('./groupby')\n]);\n\n// components\nPlotly.register([\n    require('./calendars')\n]);\n\nmodule.exports = Plotly;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/lib/core.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = require('../src/core');\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/core.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n/*\n * Export the plotly.js API methods.\n */\n\nvar Plotly = require('./plotly');\n\n// package version injected by `npm run preprocess`\nexports.version = '1.26.1';\n\n// inject promise polyfill\nrequire('es6-promise').polyfill();\n\n// inject plot css\nrequire('../build/plotcss');\n\n// inject default MathJax config\nrequire('./fonts/mathjax_config');\n\n// plot api\nexports.plot = Plotly.plot;\nexports.newPlot = Plotly.newPlot;\nexports.restyle = Plotly.restyle;\nexports.relayout = Plotly.relayout;\nexports.redraw = Plotly.redraw;\nexports.update = Plotly.update;\nexports.extendTraces = Plotly.extendTraces;\nexports.prependTraces = Plotly.prependTraces;\nexports.addTraces = Plotly.addTraces;\nexports.deleteTraces = Plotly.deleteTraces;\nexports.moveTraces = Plotly.moveTraces;\nexports.purge = Plotly.purge;\nexports.setPlotConfig = require('./plot_api/set_plot_config');\nexports.register = require('./plot_api/register');\nexports.toImage = require('./plot_api/to_image');\nexports.downloadImage = require('./snapshot/download');\nexports.validate = require('./plot_api/validate');\nexports.addFrames = Plotly.addFrames;\nexports.deleteFrames = Plotly.deleteFrames;\nexports.animate = Plotly.animate;\n\n// scatter is the only trace included by default\nexports.register(require('./traces/scatter'));\n\n// register all registrable components modules\nexports.register([\n    require('./components/legend'),\n    require('./components/annotations'),\n    require('./components/shapes'),\n    require('./components/images'),\n    require('./components/updatemenus'),\n    require('./components/sliders'),\n    require('./components/rangeslider'),\n    require('./components/rangeselector')\n]);\n\n// plot icons\nexports.Icons = require('../build/ploticon');\n\n// unofficial 'beta' plot methods, use at your own risk\nexports.Plots = Plotly.Plots;\nexports.Fx = Plotly.Fx;\nexports.Snapshot = require('./snapshot');\nexports.PlotSchema = require('./plot_api/plot_schema');\nexports.Queue = require('./lib/queue');\n\n// export d3 used in the bundle\nexports.d3 = require('d3');\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plotly.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n/*\n * Pack internal modules unto an object.\n *\n * This object is require'ed in as 'Plotly' in numerous src and test files.\n * Require'ing 'Plotly' bypasses circular dependencies.\n *\n * Future development should move away from this pattern.\n *\n */\n\n// configuration\nexports.defaultConfig = require('./plot_api/plot_config');\n\n// plots\nexports.Plots = require('./plots/plots');\nexports.Axes = require('./plots/cartesian/axes');\nexports.Fx = require('./plots/cartesian/graph_interact');\nexports.ModeBar = require('./components/modebar');\n\n// plot api\nrequire('./plot_api/plot_api');\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plot_api/plot_config.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n/* eslint-disable no-console */\n\n/**\n * This will be transferred over to gd and overridden by\n * config args to Plotly.plot.\n *\n * The defaults are the appropriate settings for plotly.js,\n * so we get the right experience without any config argument.\n */\n\nmodule.exports = {\n\n    // no interactivity, for export or image generation\n    staticPlot: false,\n\n    // we can edit titles, move annotations, etc\n    editable: false,\n\n    // DO autosize once regardless of layout.autosize\n    // (use default width or height values otherwise)\n    autosizable: false,\n\n    // set the length of the undo/redo queue\n    queueLength: 0,\n\n    // if we DO autosize, do we fill the container or the screen?\n    fillFrame: false,\n\n    // if we DO autosize, set the frame margins in percents of plot size\n    frameMargins: 0,\n\n    // mousewheel or two-finger scroll zooms the plot\n    scrollZoom: false,\n\n    // double click interaction (false, 'reset', 'autosize' or 'reset+autosize')\n    doubleClick: 'reset+autosize',\n\n    // new users see some hints about interactivity\n    showTips: true,\n\n    // enable axis pan/zoom drag handles\n    showAxisDragHandles: true,\n\n    // enable direct range entry at the pan/zoom drag points (drag handles must be enabled above)\n    showAxisRangeEntryBoxes: true,\n\n    // link to open this plot in plotly\n    showLink: false,\n\n    // if we show a link, does it contain data or just link to a plotly file?\n    sendData: true,\n\n    // text appearing in the sendData link\n    linkText: 'Edit chart',\n\n    // false or function adding source(s) to linkText <text>\n    showSources: false,\n\n    // display the mode bar (true, false, or 'hover')\n    displayModeBar: 'hover',\n\n    // remove mode bar button by name\n    // (see ./components/modebar/buttons.js for the list of names)\n    modeBarButtonsToRemove: [],\n\n    // add mode bar button using config objects\n    // (see ./components/modebar/buttons.js for list of arguments)\n    modeBarButtonsToAdd: [],\n\n    // fully custom mode bar buttons as nested array,\n    // where the outer arrays represents button groups, and\n    // the inner arrays have buttons config objects or names of default buttons\n    // (see ./components/modebar/buttons.js for more info)\n    modeBarButtons: false,\n\n    // add the plotly logo on the end of the mode bar\n    displaylogo: true,\n\n    // increase the pixel ratio for Gl plot images\n    plotGlPixelRatio: 2,\n\n    // function to add the background color to a different container\n    // or 'opaque' to ensure there's white behind it\n    setBackground: defaultSetBackground,\n\n    // URL to topojson files used in geo charts\n    topojsonURL: 'https://cdn.plot.ly/',\n\n    // Mapbox access token (required to plot mapbox trace types)\n    // If using an Mapbox Atlas server, set this option to '',\n    // so that plotly.js won't attempt to authenticate to the public Mapbox server.\n    mapboxAccessToken: null,\n\n    // Turn all console logging on or off (errors will be thrown)\n    // This should ONLY be set via Plotly.setPlotConfig\n    logging: false,\n\n    // Set global transform to be applied to all traces with no\n    // specification needed\n    globalTransforms: []\n};\n\n// where and how the background gets set can be overridden by context\n// so we define the default (plotly.js) behavior here\nfunction defaultSetBackground(gd, bgColor) {\n    try {\n        gd._fullLayout._paper.style('background', bgColor);\n    }\n    catch(e) {\n        if(module.exports.logging > 0) {\n            console.error(e);\n        }\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/plots.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\nvar isNumeric = require('fast-isnumeric');\n\nvar Plotly = require('../plotly');\nvar Registry = require('../registry');\nvar Lib = require('../lib');\nvar Color = require('../components/color');\nvar BADNUM = require('../constants/numerical').BADNUM;\n\nvar plots = module.exports = {};\n\nvar animationAttrs = require('./animation_attributes');\nvar frameAttrs = require('./frame_attributes');\n\nvar relinkPrivateKeys = Lib.relinkPrivateKeys;\n\n// Expose registry methods on Plots for backward-compatibility\nLib.extendFlat(plots, Registry);\n\nplots.attributes = require('./attributes');\nplots.attributes.type.values = plots.allTypes;\nplots.fontAttrs = require('./font_attributes');\nplots.layoutAttributes = require('./layout_attributes');\n\n// TODO make this a plot attribute?\nplots.fontWeight = 'normal';\n\nvar subplotsRegistry = plots.subplotsRegistry;\nvar transformsRegistry = plots.transformsRegistry;\n\nvar ErrorBars = require('../components/errorbars');\n\nvar commandModule = require('./command');\nplots.executeAPICommand = commandModule.executeAPICommand;\nplots.computeAPICommandBindings = commandModule.computeAPICommandBindings;\nplots.manageCommandObserver = commandModule.manageCommandObserver;\nplots.hasSimpleAPICommandBindings = commandModule.hasSimpleAPICommandBindings;\n\n/**\n * Find subplot ids in data.\n * Meant to be used in the defaults step.\n *\n * Use plots.getSubplotIds to grab the current\n * subplot ids later on in Plotly.plot.\n *\n * @param {array} data plotly data array\n *      (intended to be _fullData, but does not have to be).\n * @param {string} type subplot type to look for.\n *\n * @return {array} list of subplot ids (strings).\n *      N.B. these ids possibly un-ordered.\n *\n * TODO incorporate cartesian/gl2d axis finders in this paradigm.\n */\nplots.findSubplotIds = function findSubplotIds(data, type) {\n    var subplotIds = [];\n\n    if(!plots.subplotsRegistry[type]) return subplotIds;\n\n    var attr = plots.subplotsRegistry[type].attr;\n\n    for(var i = 0; i < data.length; i++) {\n        var trace = data[i];\n\n        if(plots.traceIs(trace, type) && subplotIds.indexOf(trace[attr]) === -1) {\n            subplotIds.push(trace[attr]);\n        }\n    }\n\n    return subplotIds;\n};\n\n/**\n * Get the ids of the current subplots.\n *\n * @param {object} layout plotly full layout object.\n * @param {string} type subplot type to look for.\n *\n * @return {array} list of ordered subplot ids (strings).\n *\n */\nplots.getSubplotIds = function getSubplotIds(layout, type) {\n    var _module = plots.subplotsRegistry[type];\n\n    if(!_module) return [];\n\n    // layout must be 'fullLayout' here\n    if(type === 'cartesian' && (!layout._has || !layout._has('cartesian'))) return [];\n    if(type === 'gl2d' && (!layout._has || !layout._has('gl2d'))) return [];\n    if(type === 'cartesian' || type === 'gl2d') {\n        return Object.keys(layout._plots || {});\n    }\n\n    var idRegex = _module.idRegex,\n        layoutKeys = Object.keys(layout),\n        subplotIds = [];\n\n    for(var i = 0; i < layoutKeys.length; i++) {\n        var layoutKey = layoutKeys[i];\n\n        if(idRegex.test(layoutKey)) subplotIds.push(layoutKey);\n    }\n\n    // order the ids\n    var idLen = _module.idRoot.length;\n    subplotIds.sort(function(a, b) {\n        var aNum = +(a.substr(idLen) || 1),\n            bNum = +(b.substr(idLen) || 1);\n        return aNum - bNum;\n    });\n\n    return subplotIds;\n};\n\n/**\n * Get the data trace(s) associated with a given subplot.\n *\n * @param {array} data  plotly full data array.\n * @param {string} type subplot type to look for.\n * @param {string} subplotId subplot id to look for.\n *\n * @return {array} list of trace objects.\n *\n */\nplots.getSubplotData = function getSubplotData(data, type, subplotId) {\n    if(!plots.subplotsRegistry[type]) return [];\n\n    var attr = plots.subplotsRegistry[type].attr,\n        subplotData = [],\n        trace;\n\n    for(var i = 0; i < data.length; i++) {\n        trace = data[i];\n\n        if(type === 'gl2d' && plots.traceIs(trace, 'gl2d')) {\n            var spmatch = Plotly.Axes.subplotMatch,\n                subplotX = 'x' + subplotId.match(spmatch)[1],\n                subplotY = 'y' + subplotId.match(spmatch)[2];\n\n            if(trace[attr[0]] === subplotX && trace[attr[1]] === subplotY) {\n                subplotData.push(trace);\n            }\n        }\n        else {\n            if(trace[attr] === subplotId) subplotData.push(trace);\n        }\n    }\n\n    return subplotData;\n};\n\n/**\n * Get calcdata traces(s) associated with a given subplot\n *\n * @param {array} calcData (as in gd.calcdata)\n * @param {string} type subplot type\n * @param {string} subplotId subplot id to look for\n *\n * @return {array} array of calcdata traces\n */\nplots.getSubplotCalcData = function(calcData, type, subplotId) {\n    if(!plots.subplotsRegistry[type]) return [];\n\n    var attr = plots.subplotsRegistry[type].attr;\n    var subplotCalcData = [];\n\n    for(var i = 0; i < calcData.length; i++) {\n        var calcTrace = calcData[i],\n            trace = calcTrace[0].trace;\n\n        if(trace[attr] === subplotId) subplotCalcData.push(calcTrace);\n    }\n\n    return subplotCalcData;\n};\n\n// in some cases the browser doesn't seem to know how big\n// the text is at first, so it needs to draw it,\n// then wait a little, then draw it again\nplots.redrawText = function(gd) {\n\n    // do not work if polar is present\n    if((gd.data && gd.data[0] && gd.data[0].r)) return;\n\n    return new Promise(function(resolve) {\n        setTimeout(function() {\n            Registry.getComponentMethod('annotations', 'draw')(gd);\n            Registry.getComponentMethod('legend', 'draw')(gd);\n\n            (gd.calcdata || []).forEach(function(d) {\n                if(d[0] && d[0].t && d[0].t.cb) d[0].t.cb();\n            });\n\n            resolve(plots.previousPromises(gd));\n        }, 300);\n    });\n};\n\n// resize plot about the container size\nplots.resize = function(gd) {\n    return new Promise(function(resolve, reject) {\n\n        if(!gd || d3.select(gd).style('display') === 'none') {\n            reject(new Error('Resize must be passed a plot div element.'));\n        }\n\n        if(gd._redrawTimer) clearTimeout(gd._redrawTimer);\n\n        gd._redrawTimer = setTimeout(function() {\n            // return if there is nothing to resize\n            if(gd.layout.width && gd.layout.height) {\n                resolve(gd);\n                return;\n            }\n\n            delete gd.layout.width;\n            delete gd.layout.height;\n\n            // autosizing doesn't count as a change that needs saving\n            var oldchanged = gd.changed;\n\n            // nor should it be included in the undo queue\n            gd.autoplay = true;\n\n            Plotly.relayout(gd, { autosize: true }).then(function() {\n                gd.changed = oldchanged;\n                resolve(gd);\n            });\n        }, 100);\n    });\n};\n\n\n// for use in Lib.syncOrAsync, check if there are any\n// pending promises in this plot and wait for them\nplots.previousPromises = function(gd) {\n    if((gd._promises || []).length) {\n        return Promise.all(gd._promises)\n            .then(function() { gd._promises = []; });\n    }\n};\n\n/**\n * Adds the 'Edit chart' link.\n * Note that now Plotly.plot() calls this so it can regenerate whenever it replots\n *\n * Add source links to your graph inside the 'showSources' config argument.\n */\nplots.addLinks = function(gd) {\n    // Do not do anything if showLink and showSources are not set to true in config\n    if(!gd._context.showLink && !gd._context.showSources) return;\n\n    var fullLayout = gd._fullLayout;\n\n    var linkContainer = fullLayout._paper\n        .selectAll('text.js-plot-link-container').data([0]);\n\n    linkContainer.enter().append('text')\n        .classed('js-plot-link-container', true)\n        .style({\n            'font-family': '\"Open Sans\", Arial, sans-serif',\n            'font-size': '12px',\n            'fill': Color.defaultLine,\n            'pointer-events': 'all'\n        })\n        .each(function() {\n            var links = d3.select(this);\n            links.append('tspan').classed('js-link-to-tool', true);\n            links.append('tspan').classed('js-link-spacer', true);\n            links.append('tspan').classed('js-sourcelinks', true);\n        });\n\n    // The text node inside svg\n    var text = linkContainer.node(),\n        attrs = {\n            y: fullLayout._paper.attr('height') - 9\n        };\n\n    // If text's width is bigger than the layout\n    // Check that text is a child node or document.body\n    // because otherwise IE/Edge might throw an exception\n    // when calling getComputedTextLength().\n    // Apparently offsetParent is null for invisibles.\n    if(document.body.contains(text) && text.getComputedTextLength() >= (fullLayout.width - 20)) {\n        // Align the text at the left\n        attrs['text-anchor'] = 'start';\n        attrs.x = 5;\n    }\n    else {\n        // Align the text at the right\n        attrs['text-anchor'] = 'end';\n        attrs.x = fullLayout._paper.attr('width') - 7;\n    }\n\n    linkContainer.attr(attrs);\n\n    var toolspan = linkContainer.select('.js-link-to-tool'),\n        spacespan = linkContainer.select('.js-link-spacer'),\n        sourcespan = linkContainer.select('.js-sourcelinks');\n\n    if(gd._context.showSources) gd._context.showSources(gd);\n\n    // 'view in plotly' link for embedded plots\n    if(gd._context.showLink) positionPlayWithData(gd, toolspan);\n\n    // separator if we have both sources and tool link\n    spacespan.text((toolspan.text() && sourcespan.text()) ? ' - ' : '');\n};\n\n// note that now this function is only adding the brand in\n// iframes and 3rd-party apps\nfunction positionPlayWithData(gd, container) {\n    container.text('');\n    var link = container.append('a')\n        .attr({\n            'xlink:xlink:href': '#',\n            'class': 'link--impt link--embedview',\n            'font-weight': 'bold'\n        })\n        .text(gd._context.linkText + ' ' + String.fromCharCode(187));\n\n    if(gd._context.sendData) {\n        link.on('click', function() {\n            plots.sendDataToCloud(gd);\n        });\n    }\n    else {\n        var path = window.location.pathname.split('/');\n        var query = window.location.search;\n        link.attr({\n            'xlink:xlink:show': 'new',\n            'xlink:xlink:href': '/' + path[2].split('.')[0] + '/' + path[1] + query\n        });\n    }\n}\n\nplots.sendDataToCloud = function(gd) {\n    gd.emit('plotly_beforeexport');\n\n    var baseUrl = (window.PLOTLYENV && window.PLOTLYENV.BASE_URL) || 'https://plot.ly';\n\n    var hiddenformDiv = d3.select(gd)\n        .append('div')\n        .attr('id', 'hiddenform')\n        .style('display', 'none');\n\n    var hiddenform = hiddenformDiv\n        .append('form')\n        .attr({\n            action: baseUrl + '/external',\n            method: 'post',\n            target: '_blank'\n        });\n\n    var hiddenformInput = hiddenform\n        .append('input')\n        .attr({\n            type: 'text',\n            name: 'data'\n        });\n\n    hiddenformInput.node().value = plots.graphJson(gd, false, 'keepdata');\n    hiddenform.node().submit();\n    hiddenformDiv.remove();\n\n    gd.emit('plotly_afterexport');\n    return false;\n};\n\n// Fill in default values:\n//\n// gd.data, gd.layout:\n//   are precisely what the user specified,\n//   these fields shouldn't be modified nor used directly\n//   after the supply defaults step.\n//\n// gd._fullData, gd._fullLayout:\n//   are complete descriptions of how to draw the plot,\n//   use these fields in all required computations.\n//\n// gd._fullLayout._modules\n//   is a list of all the trace modules required to draw the plot.\n//\n// gd._fullLayout._basePlotModules\n//   is a list of all the plot modules required to draw the plot.\n//\n// gd._fullLayout._transformModules\n//   is a list of all the transform modules invoked.\n//\nplots.supplyDefaults = function(gd) {\n    var oldFullLayout = gd._fullLayout || {},\n        newFullLayout = gd._fullLayout = {},\n        newLayout = gd.layout || {};\n\n    var oldFullData = gd._fullData || [],\n        newFullData = gd._fullData = [],\n        newData = gd.data || [];\n\n    var i;\n\n    // Create all the storage space for frames, but only if doesn't already exist\n    if(!gd._transitionData) plots.createTransitionData(gd);\n\n    // first fill in what we can of layout without looking at data\n    // because fullData needs a few things from layout\n\n    if(oldFullLayout._initialAutoSizeIsDone) {\n\n        // coerce the updated layout while preserving width and height\n        var oldWidth = oldFullLayout.width,\n            oldHeight = oldFullLayout.height;\n\n        plots.supplyLayoutGlobalDefaults(newLayout, newFullLayout);\n\n        if(!newLayout.width) newFullLayout.width = oldWidth;\n        if(!newLayout.height) newFullLayout.height = oldHeight;\n    }\n    else {\n\n        // coerce the updated layout and autosize if needed\n        plots.supplyLayoutGlobalDefaults(newLayout, newFullLayout);\n\n        var missingWidthOrHeight = (!newLayout.width || !newLayout.height),\n            autosize = newFullLayout.autosize,\n            autosizable = gd._context && gd._context.autosizable,\n            initialAutoSize = missingWidthOrHeight && (autosize || autosizable);\n\n        if(initialAutoSize) plots.plotAutoSize(gd, newLayout, newFullLayout);\n        else if(missingWidthOrHeight) plots.sanitizeMargins(gd);\n\n        // for backwards-compatibility with Plotly v1.x.x\n        if(!autosize && missingWidthOrHeight) {\n            newLayout.width = newFullLayout.width;\n            newLayout.height = newFullLayout.height;\n        }\n    }\n\n    newFullLayout._initialAutoSizeIsDone = true;\n\n    // keep track of how many traces are inputted\n    newFullLayout._dataLength = newData.length;\n\n    // then do the data\n    newFullLayout._globalTransforms = (gd._context || {}).globalTransforms;\n    plots.supplyDataDefaults(newData, newFullData, newLayout, newFullLayout);\n\n    // attach helper method to check whether a plot type is present on graph\n    newFullLayout._has = plots._hasPlotType.bind(newFullLayout);\n\n    // special cases that introduce interactions between traces\n    var _modules = newFullLayout._modules;\n    for(i = 0; i < _modules.length; i++) {\n        var _module = _modules[i];\n        if(_module.cleanData) _module.cleanData(newFullData);\n    }\n\n    if(oldFullData.length === newData.length) {\n        for(i = 0; i < newFullData.length; i++) {\n            relinkPrivateKeys(newFullData[i], oldFullData[i]);\n        }\n    }\n\n    // finally, fill in the pieces of layout that may need to look at data\n    plots.supplyLayoutModuleDefaults(newLayout, newFullLayout, newFullData, gd._transitionData);\n\n    // TODO remove in v2.0.0\n    // add has-plot-type refs to fullLayout for backward compatibility\n    newFullLayout._hasCartesian = newFullLayout._has('cartesian');\n    newFullLayout._hasGeo = newFullLayout._has('geo');\n    newFullLayout._hasGL3D = newFullLayout._has('gl3d');\n    newFullLayout._hasGL2D = newFullLayout._has('gl2d');\n    newFullLayout._hasTernary = newFullLayout._has('ternary');\n    newFullLayout._hasPie = newFullLayout._has('pie');\n\n    // clean subplots and other artifacts from previous plot calls\n    plots.cleanPlot(newFullData, newFullLayout, oldFullData, oldFullLayout);\n\n    // relink / initialize subplot axis objects\n    plots.linkSubplots(newFullData, newFullLayout, oldFullData, oldFullLayout);\n\n    // relink functions and _ attributes to promote consistency between plots\n    relinkPrivateKeys(newFullLayout, oldFullLayout);\n\n    // TODO may return a promise\n    plots.doAutoMargin(gd);\n\n    // set scale after auto margin routine\n    var axList = Plotly.Axes.list(gd);\n    for(i = 0; i < axList.length; i++) {\n        var ax = axList[i];\n        ax.setScale();\n    }\n\n    // update object references in calcdata\n    if((gd.calcdata || []).length === newFullData.length) {\n        for(i = 0; i < newFullData.length; i++) {\n            var trace = newFullData[i];\n            (gd.calcdata[i][0] || {}).trace = trace;\n        }\n    }\n};\n\n// Create storage for all of the data related to frames and transitions:\nplots.createTransitionData = function(gd) {\n    // Set up the default keyframe if it doesn't exist:\n    if(!gd._transitionData) {\n        gd._transitionData = {};\n    }\n\n    if(!gd._transitionData._frames) {\n        gd._transitionData._frames = [];\n    }\n\n    if(!gd._transitionData._frameHash) {\n        gd._transitionData._frameHash = {};\n    }\n\n    if(!gd._transitionData._counter) {\n        gd._transitionData._counter = 0;\n    }\n\n    if(!gd._transitionData._interruptCallbacks) {\n        gd._transitionData._interruptCallbacks = [];\n    }\n};\n\n// helper function to be bound to fullLayout to check\n// whether a certain plot type is present on plot\nplots._hasPlotType = function(category) {\n    var basePlotModules = this._basePlotModules || [];\n\n    for(var i = 0; i < basePlotModules.length; i++) {\n        var _module = basePlotModules[i];\n\n        if(_module.name === category) return true;\n    }\n\n    return false;\n};\n\nplots.cleanPlot = function(newFullData, newFullLayout, oldFullData, oldFullLayout) {\n    var i, j;\n\n    var basePlotModules = oldFullLayout._basePlotModules || [];\n    for(i = 0; i < basePlotModules.length; i++) {\n        var _module = basePlotModules[i];\n\n        if(_module.clean) {\n            _module.clean(newFullData, newFullLayout, oldFullData, oldFullLayout);\n        }\n    }\n\n    var hasPaper = !!oldFullLayout._paper;\n    var hasInfoLayer = !!oldFullLayout._infolayer;\n\n    oldLoop:\n    for(i = 0; i < oldFullData.length; i++) {\n        var oldTrace = oldFullData[i],\n            oldUid = oldTrace.uid;\n\n        for(j = 0; j < newFullData.length; j++) {\n            var newTrace = newFullData[j];\n\n            if(oldUid === newTrace.uid) continue oldLoop;\n        }\n\n        var query = (\n            '.hm' + oldUid +\n            ',.contour' + oldUid +\n            ',.carpet' + oldUid +\n            ',#clip' + oldUid +\n            ',.trace' + oldUid\n        );\n\n        // clean old heatmap, contour traces and clip paths\n        // that rely on uid identifiers\n        if(hasPaper) {\n            oldFullLayout._paper.selectAll(query).remove();\n        }\n\n        // clean old colorbars and range slider plot\n        if(hasInfoLayer) {\n            oldFullLayout._infolayer.selectAll('.cb' + oldUid).remove();\n\n            oldFullLayout._infolayer.selectAll('g.rangeslider-container')\n                .selectAll(query).remove();\n        }\n    }\n};\n\nplots.linkSubplots = function(newFullData, newFullLayout, oldFullData, oldFullLayout) {\n    var oldSubplots = oldFullLayout._plots || {},\n        newSubplots = newFullLayout._plots = {};\n\n    var mockGd = {\n        _fullData: newFullData,\n        _fullLayout: newFullLayout\n    };\n\n    var ids = Plotly.Axes.getSubplots(mockGd);\n\n    for(var i = 0; i < ids.length; i++) {\n        var id = ids[i],\n            oldSubplot = oldSubplots[id],\n            plotinfo;\n\n        if(oldSubplot) {\n            plotinfo = newSubplots[id] = oldSubplot;\n\n            if(plotinfo._scene2d) {\n                plotinfo._scene2d.updateRefs(newFullLayout);\n            }\n        }\n        else {\n            plotinfo = newSubplots[id] = {};\n            plotinfo.id = id;\n        }\n\n        plotinfo.xaxis = Plotly.Axes.getFromId(mockGd, id, 'x');\n        plotinfo.yaxis = Plotly.Axes.getFromId(mockGd, id, 'y');\n    }\n};\n\nplots.supplyDataDefaults = function(dataIn, dataOut, layout, fullLayout) {\n    var i, fullTrace, trace;\n    var modules = fullLayout._modules = [],\n        basePlotModules = fullLayout._basePlotModules = [],\n        cnt = 0;\n\n    fullLayout._transformModules = [];\n\n    function pushModule(fullTrace) {\n        dataOut.push(fullTrace);\n\n        var _module = fullTrace._module;\n        if(!_module) return;\n\n        Lib.pushUnique(modules, _module);\n        Lib.pushUnique(basePlotModules, fullTrace._module.basePlotModule);\n\n        cnt++;\n    }\n\n    var carpetIndex = {};\n    var carpetDependents = [];\n\n    for(i = 0; i < dataIn.length; i++) {\n        trace = dataIn[i];\n        fullTrace = plots.supplyTraceDefaults(trace, cnt, fullLayout, i);\n\n        fullTrace.index = i;\n        fullTrace._input = trace;\n        fullTrace._expandedIndex = cnt;\n\n        if(fullTrace.transforms && fullTrace.transforms.length) {\n            var expandedTraces = applyTransforms(fullTrace, dataOut, layout, fullLayout);\n\n            for(var j = 0; j < expandedTraces.length; j++) {\n                var expandedTrace = expandedTraces[j],\n                    fullExpandedTrace = plots.supplyTraceDefaults(expandedTrace, cnt, fullLayout, i);\n\n                // mutate uid here using parent uid and expanded index\n                // to promote consistency between update calls\n                expandedTrace.uid = fullExpandedTrace.uid = fullTrace.uid + j;\n\n                // add info about parent data trace\n                fullExpandedTrace.index = i;\n                fullExpandedTrace._input = trace;\n                fullExpandedTrace._fullInput = fullTrace;\n\n                // add info about the expanded data\n                fullExpandedTrace._expandedIndex = cnt;\n                fullExpandedTrace._expandedInput = expandedTrace;\n\n                pushModule(fullExpandedTrace);\n            }\n        }\n        else {\n\n            // add identify refs for consistency with transformed traces\n            fullTrace._fullInput = fullTrace;\n            fullTrace._expandedInput = fullTrace;\n\n            pushModule(fullTrace);\n        }\n\n        if(Registry.traceIs(fullTrace, 'carpetAxis')) {\n            carpetIndex[fullTrace.carpet] = fullTrace;\n        }\n\n        if(Registry.traceIs(fullTrace, 'carpetDependent')) {\n            carpetDependents.push(i);\n        }\n    }\n\n    for(i = 0; i < carpetDependents.length; i++) {\n        fullTrace = dataOut[carpetDependents[i]];\n\n        if(!fullTrace.visible) continue;\n\n        var carpetAxis = carpetIndex[fullTrace.carpet];\n        fullTrace._carpet = carpetAxis;\n\n        if(!carpetAxis || !carpetAxis.visible) {\n            fullTrace.visible = false;\n            continue;\n        }\n\n        fullTrace.xaxis = carpetAxis.xaxis;\n        fullTrace.yaxis = carpetAxis.yaxis;\n    }\n};\n\nplots.supplyAnimationDefaults = function(opts) {\n    opts = opts || {};\n    var i;\n    var optsOut = {};\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(opts || {}, optsOut, animationAttrs, attr, dflt);\n    }\n\n    coerce('mode');\n    coerce('direction');\n    coerce('fromcurrent');\n\n    if(Array.isArray(opts.frame)) {\n        optsOut.frame = [];\n        for(i = 0; i < opts.frame.length; i++) {\n            optsOut.frame[i] = plots.supplyAnimationFrameDefaults(opts.frame[i] || {});\n        }\n    } else {\n        optsOut.frame = plots.supplyAnimationFrameDefaults(opts.frame || {});\n    }\n\n    if(Array.isArray(opts.transition)) {\n        optsOut.transition = [];\n        for(i = 0; i < opts.transition.length; i++) {\n            optsOut.transition[i] = plots.supplyAnimationTransitionDefaults(opts.transition[i] || {});\n        }\n    } else {\n        optsOut.transition = plots.supplyAnimationTransitionDefaults(opts.transition || {});\n    }\n\n    return optsOut;\n};\n\nplots.supplyAnimationFrameDefaults = function(opts) {\n    var optsOut = {};\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(opts || {}, optsOut, animationAttrs.frame, attr, dflt);\n    }\n\n    coerce('duration');\n    coerce('redraw');\n\n    return optsOut;\n};\n\nplots.supplyAnimationTransitionDefaults = function(opts) {\n    var optsOut = {};\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(opts || {}, optsOut, animationAttrs.transition, attr, dflt);\n    }\n\n    coerce('duration');\n    coerce('easing');\n\n    return optsOut;\n};\n\nplots.supplyFrameDefaults = function(frameIn) {\n    var frameOut = {};\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(frameIn, frameOut, frameAttrs, attr, dflt);\n    }\n\n    coerce('group');\n    coerce('name');\n    coerce('traces');\n    coerce('baseframe');\n    coerce('data');\n    coerce('layout');\n\n    return frameOut;\n};\n\nplots.supplyTraceDefaults = function(traceIn, traceOutIndex, layout, traceInIndex) {\n    var traceOut = {},\n        defaultColor = Color.defaults[traceOutIndex % Color.defaults.length];\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(traceIn, traceOut, plots.attributes, attr, dflt);\n    }\n\n    function coerceSubplotAttr(subplotType, subplotAttr) {\n        if(!plots.traceIs(traceOut, subplotType)) return;\n\n        return Lib.coerce(traceIn, traceOut,\n            plots.subplotsRegistry[subplotType].attributes, subplotAttr);\n    }\n\n    var visible = coerce('visible');\n\n    coerce('type');\n    coerce('uid');\n    coerce('name', 'trace ' + traceInIndex);\n\n    // coerce subplot attributes of all registered subplot types\n    var subplotTypes = Object.keys(subplotsRegistry);\n    for(var i = 0; i < subplotTypes.length; i++) {\n        var subplotType = subplotTypes[i];\n\n        // done below (only when visible is true)\n        // TODO unified this pattern\n        if(['cartesian', 'gl2d'].indexOf(subplotType) !== -1) continue;\n\n        var attr = subplotsRegistry[subplotType].attr;\n\n        if(attr) coerceSubplotAttr(subplotType, attr);\n    }\n\n    if(visible) {\n        var _module = plots.getModule(traceOut);\n        traceOut._module = _module;\n\n        // gets overwritten in pie, geo and ternary modules\n        coerce('hoverinfo', (layout._dataLength === 1) ? 'x+y+z+text' : undefined);\n\n        if(plots.traceIs(traceOut, 'showLegend')) {\n            coerce('showlegend');\n            coerce('legendgroup');\n        }\n\n        // TODO add per-base-plot-module trace defaults step\n\n        if(_module) _module.supplyDefaults(traceIn, traceOut, defaultColor, layout);\n\n        if(!plots.traceIs(traceOut, 'noOpacity')) coerce('opacity');\n\n        coerceSubplotAttr('cartesian', 'xaxis');\n        coerceSubplotAttr('cartesian', 'yaxis');\n\n        coerceSubplotAttr('gl2d', 'xaxis');\n        coerceSubplotAttr('gl2d', 'yaxis');\n\n        if(plots.traceIs(traceOut, 'notLegendIsolatable')) {\n            // This clears out the legendonly state for traces like carpet that\n            // cannot be isolated in the legend\n            traceOut.visible = !!traceOut.visible;\n        }\n\n        plots.supplyTransformDefaults(traceIn, traceOut, layout);\n    }\n\n    return traceOut;\n};\n\nplots.supplyTransformDefaults = function(traceIn, traceOut, layout) {\n    var globalTransforms = layout._globalTransforms || [];\n    var transformModules = layout._transformModules || [];\n\n    if(!Array.isArray(traceIn.transforms) && globalTransforms.length === 0) return;\n\n    var containerIn = traceIn.transforms || [],\n        transformList = globalTransforms.concat(containerIn),\n        containerOut = traceOut.transforms = [];\n\n    for(var i = 0; i < transformList.length; i++) {\n        var transformIn = transformList[i],\n            type = transformIn.type,\n            _module = transformsRegistry[type],\n            transformOut;\n\n        if(!_module) Lib.warn('Unrecognized transform type ' + type + '.');\n\n        if(_module && _module.supplyDefaults) {\n            transformOut = _module.supplyDefaults(transformIn, traceOut, layout, traceIn);\n            transformOut.type = type;\n            transformOut._module = _module;\n\n            Lib.pushUnique(transformModules, _module);\n        }\n        else {\n            transformOut = Lib.extendFlat({}, transformIn);\n        }\n\n        containerOut.push(transformOut);\n    }\n};\n\nfunction applyTransforms(fullTrace, fullData, layout, fullLayout) {\n    var container = fullTrace.transforms,\n        dataOut = [fullTrace];\n\n    for(var i = 0; i < container.length; i++) {\n        var transform = container[i],\n            _module = transformsRegistry[transform.type];\n\n        if(_module && _module.transform) {\n            dataOut = _module.transform(dataOut, {\n                transform: transform,\n                fullTrace: fullTrace,\n                fullData: fullData,\n                layout: layout,\n                fullLayout: fullLayout,\n                transformIndex: i\n            });\n        }\n    }\n\n    return dataOut;\n}\n\nplots.supplyLayoutGlobalDefaults = function(layoutIn, layoutOut) {\n    function coerce(attr, dflt) {\n        return Lib.coerce(layoutIn, layoutOut, plots.layoutAttributes, attr, dflt);\n    }\n\n    var globalFont = Lib.coerceFont(coerce, 'font');\n\n    coerce('title');\n\n    Lib.coerceFont(coerce, 'titlefont', {\n        family: globalFont.family,\n        size: Math.round(globalFont.size * 1.4),\n        color: globalFont.color\n    });\n\n    // Make sure that autosize is defaulted to *true*\n    // on layouts with no set width and height for backward compatibly,\n    // in particular https://plot.ly/javascript/responsive-fluid-layout/\n    //\n    // Before https://github.com/plotly/plotly.js/pull/635 ,\n    // layouts with no set width and height were set temporary set to 'initial'\n    // to pass through the autosize routine\n    //\n    // This behavior is subject to change in v2.\n    coerce('autosize', !(layoutIn.width && layoutIn.height));\n\n    coerce('width');\n    coerce('height');\n    coerce('margin.l');\n    coerce('margin.r');\n    coerce('margin.t');\n    coerce('margin.b');\n    coerce('margin.pad');\n    coerce('margin.autoexpand');\n\n    if(layoutIn.width && layoutIn.height) plots.sanitizeMargins(layoutOut);\n\n    coerce('paper_bgcolor');\n\n    coerce('separators');\n    coerce('hidesources');\n    coerce('smith');\n\n    var handleCalendarDefaults = Registry.getComponentMethod('calendars', 'handleDefaults');\n    handleCalendarDefaults(layoutIn, layoutOut, 'calendar');\n};\n\nplots.plotAutoSize = function plotAutoSize(gd, layout, fullLayout) {\n    var context = gd._context || {},\n        frameMargins = context.frameMargins,\n        newWidth,\n        newHeight;\n\n    var isPlotDiv = Lib.isPlotDiv(gd);\n\n    if(isPlotDiv) gd.emit('plotly_autosize');\n\n    // embedded in an iframe - just take the full iframe size\n    // if we get to this point, with no aspect ratio restrictions\n    if(context.fillFrame) {\n        newWidth = window.innerWidth;\n        newHeight = window.innerHeight;\n\n        // somehow we get a few extra px height sometimes...\n        // just hide it\n        document.body.style.overflow = 'hidden';\n    }\n    else if(isNumeric(frameMargins) && frameMargins > 0) {\n        var reservedMargins = calculateReservedMargins(gd._boundingBoxMargins),\n            reservedWidth = reservedMargins.left + reservedMargins.right,\n            reservedHeight = reservedMargins.bottom + reservedMargins.top,\n            factor = 1 - 2 * frameMargins;\n\n        var gdBB = fullLayout._container && fullLayout._container.node ?\n            fullLayout._container.node().getBoundingClientRect() : {\n                width: fullLayout.width,\n                height: fullLayout.height\n            };\n\n        newWidth = Math.round(factor * (gdBB.width - reservedWidth));\n        newHeight = Math.round(factor * (gdBB.height - reservedHeight));\n    }\n    else {\n        // plotly.js - let the developers do what they want, either\n        // provide height and width for the container div,\n        // specify size in layout, or take the defaults,\n        // but don't enforce any ratio restrictions\n        var computedStyle = isPlotDiv ? window.getComputedStyle(gd) : {};\n\n        newWidth = parseFloat(computedStyle.width) || fullLayout.width;\n        newHeight = parseFloat(computedStyle.height) || fullLayout.height;\n    }\n\n    var minWidth = plots.layoutAttributes.width.min,\n        minHeight = plots.layoutAttributes.height.min;\n    if(newWidth < minWidth) newWidth = minWidth;\n    if(newHeight < minHeight) newHeight = minHeight;\n\n    var widthHasChanged = !layout.width &&\n            (Math.abs(fullLayout.width - newWidth) > 1),\n        heightHasChanged = !layout.height &&\n            (Math.abs(fullLayout.height - newHeight) > 1);\n\n    if(heightHasChanged || widthHasChanged) {\n        if(widthHasChanged) fullLayout.width = newWidth;\n        if(heightHasChanged) fullLayout.height = newHeight;\n    }\n\n    // cache initial autosize value, used in relayout when\n    // width or height values are set to null\n    if(!gd._initialAutoSize) {\n        gd._initialAutoSize = { width: newWidth, height: newHeight };\n    }\n\n    plots.sanitizeMargins(fullLayout);\n};\n\n/**\n * Reduce all reserved margin objects to a single required margin reservation.\n *\n * @param {Object} margins\n * @returns {{left: number, right: number, bottom: number, top: number}}\n */\nfunction calculateReservedMargins(margins) {\n    var resultingMargin = {left: 0, right: 0, bottom: 0, top: 0},\n        marginName;\n\n    if(margins) {\n        for(marginName in margins) {\n            if(margins.hasOwnProperty(marginName)) {\n                resultingMargin.left += margins[marginName].left || 0;\n                resultingMargin.right += margins[marginName].right || 0;\n                resultingMargin.bottom += margins[marginName].bottom || 0;\n                resultingMargin.top += margins[marginName].top || 0;\n            }\n        }\n    }\n    return resultingMargin;\n}\n\nplots.supplyLayoutModuleDefaults = function(layoutIn, layoutOut, fullData, transitionData) {\n    var i, _module;\n\n    // can't be be part of basePlotModules loop\n    // in order to handle the orphan axes case\n    Plotly.Axes.supplyLayoutDefaults(layoutIn, layoutOut, fullData);\n\n    // base plot module layout defaults\n    var basePlotModules = layoutOut._basePlotModules;\n    for(i = 0; i < basePlotModules.length; i++) {\n        _module = basePlotModules[i];\n\n        // done above already\n        if(_module.name === 'cartesian') continue;\n\n        // e.g. gl2d does not have a layout-defaults step\n        if(_module.supplyLayoutDefaults) {\n            _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData);\n        }\n    }\n\n    // trace module layout defaults\n    var modules = layoutOut._modules;\n    for(i = 0; i < modules.length; i++) {\n        _module = modules[i];\n\n        if(_module.supplyLayoutDefaults) {\n            _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData);\n        }\n    }\n\n    // transform module layout defaults\n    var transformModules = layoutOut._transformModules;\n    for(i = 0; i < transformModules.length; i++) {\n        _module = transformModules[i];\n\n        if(_module.supplyLayoutDefaults) {\n            _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData, transitionData);\n        }\n    }\n\n    // should FX be a component?\n    Plotly.Fx.supplyLayoutDefaults(layoutIn, layoutOut, fullData);\n\n    var components = Object.keys(Registry.componentsRegistry);\n    for(i = 0; i < components.length; i++) {\n        _module = Registry.componentsRegistry[components[i]];\n\n        if(_module.supplyLayoutDefaults) {\n            _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData);\n        }\n    }\n};\n\n// Remove all plotly attributes from a div so it can be replotted fresh\n// TODO: these really need to be encapsulated into a much smaller set...\nplots.purge = function(gd) {\n\n    // note: we DO NOT remove _context because it doesn't change when we insert\n    // a new plot, and may have been set outside of our scope.\n\n    var fullLayout = gd._fullLayout || {};\n    if(fullLayout._glcontainer !== undefined) fullLayout._glcontainer.remove();\n    if(fullLayout._geocontainer !== undefined) fullLayout._geocontainer.remove();\n\n    // remove modebar\n    if(fullLayout._modeBar) fullLayout._modeBar.destroy();\n\n    if(gd._transitionData) {\n        // Ensure any dangling callbacks are simply dropped if the plot is purged.\n        // This is more or less only actually important for testing.\n        if(gd._transitionData._interruptCallbacks) {\n            gd._transitionData._interruptCallbacks.length = 0;\n        }\n\n        if(gd._transitionData._animationRaf) {\n            window.cancelAnimationFrame(gd._transitionData._animationRaf);\n        }\n    }\n\n    // data and layout\n    delete gd.data;\n    delete gd.layout;\n    delete gd._fullData;\n    delete gd._fullLayout;\n    delete gd.calcdata;\n    delete gd.framework;\n    delete gd.empty;\n\n    delete gd.fid;\n\n    delete gd.undoqueue; // action queue\n    delete gd.undonum;\n    delete gd.autoplay; // are we doing an action that doesn't go in undo queue?\n    delete gd.changed;\n\n    // these get recreated on Plotly.plot anyway, but just to be safe\n    // (and to have a record of them...)\n    delete gd._tester;\n    delete gd._testref;\n    delete gd._promises;\n    delete gd._redrawTimer;\n    delete gd.firstscatter;\n    delete gd.hmlumcount;\n    delete gd.hmpixcount;\n    delete gd.numboxes;\n    delete gd._hoverTimer;\n    delete gd._lastHoverTime;\n    delete gd._transitionData;\n    delete gd._transitioning;\n    delete gd._initialAutoSize;\n\n    // remove all event listeners\n    if(gd.removeAllListeners) gd.removeAllListeners();\n};\n\nplots.style = function(gd) {\n    var _modules = gd._fullLayout._modules;\n\n    for(var i = 0; i < _modules.length; i++) {\n        var _module = _modules[i];\n\n        if(_module.style) _module.style(gd);\n    }\n};\n\nplots.sanitizeMargins = function(fullLayout) {\n    // polar doesn't do margins...\n    if(!fullLayout || !fullLayout.margin) return;\n\n    var width = fullLayout.width,\n        height = fullLayout.height,\n        margin = fullLayout.margin,\n        plotWidth = width - (margin.l + margin.r),\n        plotHeight = height - (margin.t + margin.b),\n        correction;\n\n    // if margin.l + margin.r = 0 then plotWidth > 0\n    // as width >= 10 by supplyDefaults\n    // similarly for margin.t + margin.b\n\n    if(plotWidth < 0) {\n        correction = (width - 1) / (margin.l + margin.r);\n        margin.l = Math.floor(correction * margin.l);\n        margin.r = Math.floor(correction * margin.r);\n    }\n\n    if(plotHeight < 0) {\n        correction = (height - 1) / (margin.t + margin.b);\n        margin.t = Math.floor(correction * margin.t);\n        margin.b = Math.floor(correction * margin.b);\n    }\n};\n\n// called by components to see if we need to\n// expand the margins to show them\n// o is {x,l,r,y,t,b} where x and y are plot fractions,\n// the rest are pixels in each direction\n// or leave o out to delete this entry (like if it's hidden)\nplots.autoMargin = function(gd, id, o) {\n    var fullLayout = gd._fullLayout;\n\n    if(!fullLayout._pushmargin) fullLayout._pushmargin = {};\n\n    if(fullLayout.margin.autoexpand !== false) {\n        if(!o) delete fullLayout._pushmargin[id];\n        else {\n            var pad = o.pad === undefined ? 12 : o.pad;\n\n            // if the item is too big, just give it enough automargin to\n            // make sure you can still grab it and bring it back\n            if(o.l + o.r > fullLayout.width * 0.5) o.l = o.r = 0;\n            if(o.b + o.t > fullLayout.height * 0.5) o.b = o.t = 0;\n\n            fullLayout._pushmargin[id] = {\n                l: {val: o.x, size: o.l + pad},\n                r: {val: o.x, size: o.r + pad},\n                b: {val: o.y, size: o.b + pad},\n                t: {val: o.y, size: o.t + pad}\n            };\n        }\n\n        if(!fullLayout._replotting) plots.doAutoMargin(gd);\n    }\n};\n\nplots.doAutoMargin = function(gd) {\n    var fullLayout = gd._fullLayout;\n    if(!fullLayout._size) fullLayout._size = {};\n    if(!fullLayout._pushmargin) fullLayout._pushmargin = {};\n\n    var gs = fullLayout._size,\n        oldmargins = JSON.stringify(gs);\n\n    // adjust margins for outside components\n    // fullLayout.margin is the requested margin,\n    // fullLayout._size has margins and plotsize after adjustment\n    var ml = Math.max(fullLayout.margin.l || 0, 0),\n        mr = Math.max(fullLayout.margin.r || 0, 0),\n        mt = Math.max(fullLayout.margin.t || 0, 0),\n        mb = Math.max(fullLayout.margin.b || 0, 0),\n        pm = fullLayout._pushmargin;\n\n    if(fullLayout.margin.autoexpand !== false) {\n\n        // fill in the requested margins\n        pm.base = {\n            l: {val: 0, size: ml},\n            r: {val: 1, size: mr},\n            t: {val: 1, size: mt},\n            b: {val: 0, size: mb}\n        };\n\n        // now cycle through all the combinations of l and r\n        // (and t and b) to find the required margins\n\n        var pmKeys = Object.keys(pm);\n\n        for(var i = 0; i < pmKeys.length; i++) {\n            var k1 = pmKeys[i];\n\n            var pushleft = pm[k1].l || {},\n                pushbottom = pm[k1].b || {},\n                fl = pushleft.val,\n                pl = pushleft.size,\n                fb = pushbottom.val,\n                pb = pushbottom.size;\n\n            for(var j = 0; j < pmKeys.length; j++) {\n                var k2 = pmKeys[j];\n\n                if(isNumeric(pl) && pm[k2].r) {\n                    var fr = pm[k2].r.val,\n                        pr = pm[k2].r.size;\n\n                    if(fr > fl) {\n                        var newl = (pl * fr +\n                                (pr - fullLayout.width) * fl) / (fr - fl),\n                            newr = (pr * (1 - fl) +\n                                (pl - fullLayout.width) * (1 - fr)) / (fr - fl);\n                        if(newl >= 0 && newr >= 0 && newl + newr > ml + mr) {\n                            ml = newl;\n                            mr = newr;\n                        }\n                    }\n                }\n\n                if(isNumeric(pb) && pm[k2].t) {\n                    var ft = pm[k2].t.val,\n                        pt = pm[k2].t.size;\n\n                    if(ft > fb) {\n                        var newb = (pb * ft +\n                                (pt - fullLayout.height) * fb) / (ft - fb),\n                            newt = (pt * (1 - fb) +\n                                (pb - fullLayout.height) * (1 - ft)) / (ft - fb);\n                        if(newb >= 0 && newt >= 0 && newb + newt > mb + mt) {\n                            mb = newb;\n                            mt = newt;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    gs.l = Math.round(ml);\n    gs.r = Math.round(mr);\n    gs.t = Math.round(mt);\n    gs.b = Math.round(mb);\n    gs.p = Math.round(fullLayout.margin.pad);\n    gs.w = Math.round(fullLayout.width) - gs.l - gs.r;\n    gs.h = Math.round(fullLayout.height) - gs.t - gs.b;\n\n    // if things changed and we're not already redrawing, trigger a redraw\n    if(!fullLayout._replotting && oldmargins !== '{}' &&\n            oldmargins !== JSON.stringify(fullLayout._size)) {\n        return Plotly.plot(gd);\n    }\n};\n\n/**\n * JSONify the graph data and layout\n *\n * This function needs to recurse because some src can be inside\n * sub-objects.\n *\n * It also strips out functions and private (starts with _) elements.\n * Therefore, we can add temporary things to data and layout that don't\n * get saved.\n *\n * @param gd The graphDiv\n * @param {Boolean} dataonly If true, don't return layout.\n * @param {'keepref'|'keepdata'|'keepall'} [mode='keepref'] Filter what's kept\n *      keepref: remove data for which there's a src present\n *          eg if there's xsrc present (and xsrc is well-formed,\n *          ie has : and some chars before it), strip out x\n *      keepdata: remove all src tags, don't remove the data itself\n *      keepall: keep data and src\n * @param {String} output If you specify 'object', the result will not be stringified\n * @param {Boolean} useDefaults If truthy, use _fullLayout and _fullData\n * @returns {Object|String}\n */\nplots.graphJson = function(gd, dataonly, mode, output, useDefaults) {\n    // if the defaults aren't supplied yet, we need to do that...\n    if((useDefaults && dataonly && !gd._fullData) ||\n            (useDefaults && !dataonly && !gd._fullLayout)) {\n        plots.supplyDefaults(gd);\n    }\n\n    var data = (useDefaults) ? gd._fullData : gd.data,\n        layout = (useDefaults) ? gd._fullLayout : gd.layout,\n        frames = (gd._transitionData || {})._frames;\n\n    function stripObj(d) {\n        if(typeof d === 'function') {\n            return null;\n        }\n        if(Lib.isPlainObject(d)) {\n            var o = {}, v, src;\n            for(v in d) {\n                // remove private elements and functions\n                // _ is for private, [ is a mistake ie [object Object]\n                if(typeof d[v] === 'function' ||\n                        ['_', '['].indexOf(v.charAt(0)) !== -1) {\n                    continue;\n                }\n\n                // look for src/data matches and remove the appropriate one\n                if(mode === 'keepdata') {\n                    // keepdata: remove all ...src tags\n                    if(v.substr(v.length - 3) === 'src') {\n                        continue;\n                    }\n                }\n                else if(mode === 'keepstream') {\n                    // keep sourced data if it's being streamed.\n                    // similar to keepref, but if the 'stream' object exists\n                    // in a trace, we will keep the data array.\n                    src = d[v + 'src'];\n                    if(typeof src === 'string' && src.indexOf(':') > 0) {\n                        if(!Lib.isPlainObject(d.stream)) {\n                            continue;\n                        }\n                    }\n                }\n                else if(mode !== 'keepall') {\n                    // keepref: remove sourced data but only\n                    // if the source tag is well-formed\n                    src = d[v + 'src'];\n                    if(typeof src === 'string' && src.indexOf(':') > 0) {\n                        continue;\n                    }\n                }\n\n                // OK, we're including this... recurse into it\n                o[v] = stripObj(d[v]);\n            }\n            return o;\n        }\n\n        if(Array.isArray(d)) {\n            return d.map(stripObj);\n        }\n\n        // convert native dates to date strings...\n        // mostly for external users exporting to plotly\n        if(Lib.isJSDate(d)) return Lib.ms2DateTimeLocal(+d);\n\n        return d;\n    }\n\n    var obj = {\n        data: (data || []).map(function(v) {\n            var d = stripObj(v);\n            // fit has some little arrays in it that don't contain data,\n            // just fit params and meta\n            if(dataonly) { delete d.fit; }\n            return d;\n        })\n    };\n    if(!dataonly) { obj.layout = stripObj(layout); }\n\n    if(gd.framework && gd.framework.isPolar) obj = gd.framework.getConfig();\n\n    if(frames) obj.frames = stripObj(frames);\n\n    return (output === 'object') ? obj : JSON.stringify(obj);\n};\n\n/**\n * Modify a keyframe using a list of operations:\n *\n * @param {array of objects} operations\n *      Sequence of operations to be performed on the keyframes\n */\nplots.modifyFrames = function(gd, operations) {\n    var i, op, frame;\n    var _frames = gd._transitionData._frames;\n    var _hash = gd._transitionData._frameHash;\n\n    for(i = 0; i < operations.length; i++) {\n        op = operations[i];\n\n        switch(op.type) {\n            // No reason this couldn't exist, but is currently unused/untested:\n            /* case 'rename':\n                frame = _frames[op.index];\n                delete _hash[frame.name];\n                _hash[op.name] = frame;\n                frame.name = op.name;\n                break;*/\n            case 'replace':\n                frame = op.value;\n                var oldName = (_frames[op.index] || {}).name;\n                var newName = frame.name;\n                _frames[op.index] = _hash[newName] = frame;\n\n                if(newName !== oldName) {\n                    // If name has changed in addition to replacement, then update\n                    // the lookup table:\n                    delete _hash[oldName];\n                    _hash[newName] = frame;\n                }\n\n                break;\n            case 'insert':\n                frame = op.value;\n                _hash[frame.name] = frame;\n                _frames.splice(op.index, 0, frame);\n                break;\n            case 'delete':\n                frame = _frames[op.index];\n                delete _hash[frame.name];\n                _frames.splice(op.index, 1);\n                break;\n        }\n    }\n\n    return Promise.resolve();\n};\n\n/*\n * Compute a keyframe. Merge a keyframe into its base frame(s) and\n * expand properties.\n *\n * @param {object} frameLookup\n *      An object containing frames keyed by name (i.e. gd._transitionData._frameHash)\n * @param {string} frame\n *      The name of the keyframe to be computed\n *\n * Returns: a new object with the merged content\n */\nplots.computeFrame = function(gd, frameName) {\n    var frameLookup = gd._transitionData._frameHash;\n    var i, traceIndices, traceIndex, destIndex;\n\n    // Null or undefined will fail on .toString(). We'll allow numbers since we\n    // make it clear frames must be given string names, but we'll allow numbers\n    // here since they're otherwise fine for looking up frames as long as they're\n    // properly cast to strings. We really just want to ensure here that this\n    // 1) doesn't fail, and\n    // 2) doens't give an incorrect answer (which String(frameName) would)\n    if(!frameName) {\n        throw new Error('computeFrame must be given a string frame name');\n    }\n\n    var framePtr = frameLookup[frameName.toString()];\n\n    // Return false if the name is invalid:\n    if(!framePtr) {\n        return false;\n    }\n\n    var frameStack = [framePtr];\n    var frameNameStack = [framePtr.name];\n\n    // Follow frame pointers:\n    while(framePtr.baseframe && (framePtr = frameLookup[framePtr.baseframe.toString()])) {\n        // Avoid infinite loops:\n        if(frameNameStack.indexOf(framePtr.name) !== -1) break;\n\n        frameStack.push(framePtr);\n        frameNameStack.push(framePtr.name);\n    }\n\n    // A new object for the merged result:\n    var result = {};\n\n    // Merge, starting with the last and ending with the desired frame:\n    while((framePtr = frameStack.pop())) {\n        if(framePtr.layout) {\n            result.layout = plots.extendLayout(result.layout, framePtr.layout);\n        }\n\n        if(framePtr.data) {\n            if(!result.data) {\n                result.data = [];\n            }\n            traceIndices = framePtr.traces;\n\n            if(!traceIndices) {\n                // If not defined, assume serial order starting at zero\n                traceIndices = [];\n                for(i = 0; i < framePtr.data.length; i++) {\n                    traceIndices[i] = i;\n                }\n            }\n\n            if(!result.traces) {\n                result.traces = [];\n            }\n\n            for(i = 0; i < framePtr.data.length; i++) {\n                // Loop through this frames data, find out where it should go,\n                // and merge it!\n                traceIndex = traceIndices[i];\n                if(traceIndex === undefined || traceIndex === null) {\n                    continue;\n                }\n\n                destIndex = result.traces.indexOf(traceIndex);\n                if(destIndex === -1) {\n                    destIndex = result.data.length;\n                    result.traces[destIndex] = traceIndex;\n                }\n\n                result.data[destIndex] = plots.extendTrace(result.data[destIndex], framePtr.data[i]);\n            }\n        }\n    }\n\n    return result;\n};\n\n/*\n * Recompute the lookup table that maps frame name -> frame object. addFrames/\n * deleteFrames already manages this data one at a time, so the only time this\n * is necessary is if you poke around manually in `gd._transitionData._frames`\n * and create and haven't updated the lookup table.\n */\nplots.recomputeFrameHash = function(gd) {\n    var hash = gd._transitionData._frameHash = {};\n    var frames = gd._transitionData._frames;\n    for(var i = 0; i < frames.length; i++) {\n        var frame = frames[i];\n        if(frame && frame.name) {\n            hash[frame.name] = frame;\n        }\n    }\n};\n\n/**\n * Extend an object, treating container arrays very differently by extracting\n * their contents and merging them separately.\n *\n * This exists so that we can extendDeepNoArrays and avoid stepping into data\n * arrays without knowledge of the plot schema, but so that we may also manually\n * recurse into known container arrays, such as transforms.\n *\n * See extendTrace and extendLayout below for usage.\n */\nplots.extendObjectWithContainers = function(dest, src, containerPaths) {\n    var containerProp, containerVal, i, j, srcProp, destProp, srcContainer, destContainer;\n    var copy = Lib.extendDeepNoArrays({}, src || {});\n    var expandedObj = Lib.expandObjectPaths(copy);\n    var containerObj = {};\n\n    // Step through and extract any container properties. Otherwise extendDeepNoArrays\n    // will clobber any existing properties with an empty array and then supplyDefaults\n    // will reset everything to defaults.\n    if(containerPaths && containerPaths.length) {\n        for(i = 0; i < containerPaths.length; i++) {\n            containerProp = Lib.nestedProperty(expandedObj, containerPaths[i]);\n            containerVal = containerProp.get();\n\n            if(containerVal === undefined) {\n                Lib.nestedProperty(containerObj, containerPaths[i]).set(null);\n            }\n            else {\n                containerProp.set(null);\n                Lib.nestedProperty(containerObj, containerPaths[i]).set(containerVal);\n            }\n        }\n    }\n\n    dest = Lib.extendDeepNoArrays(dest || {}, expandedObj);\n\n    if(containerPaths && containerPaths.length) {\n        for(i = 0; i < containerPaths.length; i++) {\n            srcProp = Lib.nestedProperty(containerObj, containerPaths[i]);\n            srcContainer = srcProp.get();\n\n            if(!srcContainer) continue;\n\n            destProp = Lib.nestedProperty(dest, containerPaths[i]);\n            destContainer = destProp.get();\n\n            if(!Array.isArray(destContainer)) {\n                destContainer = [];\n                destProp.set(destContainer);\n            }\n\n            for(j = 0; j < srcContainer.length; j++) {\n                var srcObj = srcContainer[j];\n\n                if(srcObj === null) destContainer[j] = null;\n                else {\n                    destContainer[j] = plots.extendObjectWithContainers(destContainer[j], srcObj);\n                }\n            }\n\n            destProp.set(destContainer);\n        }\n    }\n\n    return dest;\n};\n\nplots.dataArrayContainers = ['transforms'];\nplots.layoutArrayContainers = Registry.layoutArrayContainers;\n\n/*\n * Extend a trace definition. This method:\n *\n *  1. directly transfers any array references\n *  2. manually recurses into container arrays like transforms\n *\n * The result is the original object reference with the new contents merged in.\n */\nplots.extendTrace = function(destTrace, srcTrace) {\n    return plots.extendObjectWithContainers(destTrace, srcTrace, plots.dataArrayContainers);\n};\n\n/*\n * Extend a layout definition. This method:\n *\n *  1. directly transfers any array references (not critically important for\n *     layout since there aren't really data arrays)\n *  2. manually recurses into container arrays like annotations\n *\n * The result is the original object reference with the new contents merged in.\n */\nplots.extendLayout = function(destLayout, srcLayout) {\n    return plots.extendObjectWithContainers(destLayout, srcLayout, plots.layoutArrayContainers);\n};\n\n/**\n * Transition to a set of new data and layout properties\n *\n * @param {DOM element} gd\n *      the DOM element of the graph container div\n * @param {Object[]} data\n *      an array of data objects following the normal Plotly data definition format\n * @param {Object} layout\n *      a layout object, following normal Plotly layout format\n * @param {Number[]} traces\n *      indices of the corresponding traces specified in `data`\n * @param {Object} frameOpts\n *      options for the frame (i.e. whether to redraw post-transition)\n * @param {Object} transitionOpts\n *      options for the transition\n */\nplots.transition = function(gd, data, layout, traces, frameOpts, transitionOpts) {\n    var i, traceIdx;\n\n    var dataLength = Array.isArray(data) ? data.length : 0;\n    var traceIndices = traces.slice(0, dataLength);\n\n    var transitionedTraces = [];\n\n    function prepareTransitions() {\n        var i;\n\n        for(i = 0; i < traceIndices.length; i++) {\n            var traceIdx = traceIndices[i];\n            var trace = gd._fullData[traceIdx];\n            var module = trace._module;\n\n            // There's nothing to do if this module is not defined:\n            if(!module) continue;\n\n            // Don't register the trace as transitioned if it doens't know what to do.\n            // If it *is* registered, it will receive a callback that it's responsible\n            // for calling in order to register the transition as having completed.\n            if(module.animatable) {\n                transitionedTraces.push(traceIdx);\n            }\n\n            gd.data[traceIndices[i]] = plots.extendTrace(gd.data[traceIndices[i]], data[i]);\n        }\n\n        // Follow the same procedure. Clone it so we don't mangle the input, then\n        // expand any object paths so we can merge deep into gd.layout:\n        var layoutUpdate = Lib.expandObjectPaths(Lib.extendDeepNoArrays({}, layout));\n\n        // Before merging though, we need to modify the incoming layout. We only\n        // know how to *transition* layout ranges, so it's imperative that a new\n        // range not be sent to the layout before the transition has started. So\n        // we must remove the things we can transition:\n        var axisAttrRe = /^[xy]axis[0-9]*$/;\n        for(var attr in layoutUpdate) {\n            if(!axisAttrRe.test(attr)) continue;\n            delete layoutUpdate[attr].range;\n        }\n\n        plots.extendLayout(gd.layout, layoutUpdate);\n\n        // Supply defaults after applying the incoming properties. Note that any attempt\n        // to simplify this step and reduce the amount of work resulted in the reconstruction\n        // of essentially the whole supplyDefaults step, so that it seems sensible to just use\n        // supplyDefaults even though it's heavier than would otherwise be desired for\n        // transitions:\n        plots.supplyDefaults(gd);\n\n        plots.doCalcdata(gd);\n\n        ErrorBars.calc(gd);\n\n        return Promise.resolve();\n    }\n\n    function executeCallbacks(list) {\n        var p = Promise.resolve();\n        if(!list) return p;\n        while(list.length) {\n            p = p.then((list.shift()));\n        }\n        return p;\n    }\n\n    function flushCallbacks(list) {\n        if(!list) return;\n        while(list.length) {\n            list.shift();\n        }\n    }\n\n    var aborted = false;\n\n    function executeTransitions() {\n\n        gd.emit('plotly_transitioning', []);\n\n        return new Promise(function(resolve) {\n            // This flag is used to disabled things like autorange:\n            gd._transitioning = true;\n\n            // When instantaneous updates are coming through quickly, it's too much to simply disable\n            // all interaction, so store this flag so we can disambiguate whether mouse interactions\n            // should be fully disabled or not:\n            if(transitionOpts.duration > 0) {\n                gd._transitioningWithDuration = true;\n            }\n\n\n            // If another transition is triggered, this callback will be executed simply because it's\n            // in the interruptCallbacks queue. If this transition completes, it will instead flush\n            // that queue and forget about this callback.\n            gd._transitionData._interruptCallbacks.push(function() {\n                aborted = true;\n            });\n\n            if(frameOpts.redraw) {\n                gd._transitionData._interruptCallbacks.push(function() {\n                    return Plotly.redraw(gd);\n                });\n            }\n\n            // Emit this and make sure it happens last:\n            gd._transitionData._interruptCallbacks.push(function() {\n                gd.emit('plotly_transitioninterrupted', []);\n            });\n\n            // Construct callbacks that are executed on transition end. This ensures the d3 transitions\n            // are *complete* before anything else is done.\n            var numCallbacks = 0;\n            var numCompleted = 0;\n            function makeCallback() {\n                numCallbacks++;\n                return function() {\n                    numCompleted++;\n                    // When all are complete, perform a redraw:\n                    if(!aborted && numCompleted === numCallbacks) {\n                        completeTransition(resolve);\n                    }\n                };\n            }\n\n            var traceTransitionOpts;\n            var j;\n            var basePlotModules = gd._fullLayout._basePlotModules;\n            var hasAxisTransition = false;\n\n            if(layout) {\n                for(j = 0; j < basePlotModules.length; j++) {\n                    if(basePlotModules[j].transitionAxes) {\n                        var newLayout = Lib.expandObjectPaths(layout);\n                        hasAxisTransition = basePlotModules[j].transitionAxes(gd, newLayout, transitionOpts, makeCallback) || hasAxisTransition;\n                    }\n                }\n            }\n\n            // Here handle the exception that we refuse to animate scales and axes at the same\n            // time. In other words, if there's an axis transition, then set the data transition\n            // to instantaneous.\n            if(hasAxisTransition) {\n                traceTransitionOpts = Lib.extendFlat({}, transitionOpts);\n                traceTransitionOpts.duration = 0;\n            } else {\n                traceTransitionOpts = transitionOpts;\n            }\n\n            for(j = 0; j < basePlotModules.length; j++) {\n                // Note that we pass a callback to *create* the callback that must be invoked on completion.\n                // This is since not all traces know about transitions, so it greatly simplifies matters if\n                // the trace is responsible for creating a callback, if needed, and then executing it when\n                // the time is right.\n                basePlotModules[j].plot(gd, transitionedTraces, traceTransitionOpts, makeCallback);\n            }\n\n            // If nothing else creates a callback, then this will trigger the completion in the next tick:\n            setTimeout(makeCallback());\n\n        });\n    }\n\n    function completeTransition(callback) {\n        // This a simple workaround for tests which purge the graph before animations\n        // have completed. That's not a very common case, so this is the simplest\n        // fix.\n        if(!gd._transitionData) return;\n\n        flushCallbacks(gd._transitionData._interruptCallbacks);\n\n        return Promise.resolve().then(function() {\n            if(frameOpts.redraw) {\n                return Plotly.redraw(gd);\n            }\n        }).then(function() {\n            // Set transitioning false again once the redraw has occurred. This is used, for example,\n            // to prevent the trailing redraw from autoranging:\n            gd._transitioning = false;\n            gd._transitioningWithDuration = false;\n\n            gd.emit('plotly_transitioned', []);\n        }).then(callback);\n    }\n\n    function interruptPreviousTransitions() {\n        // Fail-safe against purged plot:\n        if(!gd._transitionData) return;\n\n        // If a transition is interrupted, set this to false. At the moment, the only thing that would\n        // interrupt a transition is another transition, so that it will momentarily be set to true\n        // again, but this determines whether autorange or dragbox work, so it's for the sake of\n        // cleanliness:\n        gd._transitioning = false;\n\n        return executeCallbacks(gd._transitionData._interruptCallbacks);\n    }\n\n    for(i = 0; i < traceIndices.length; i++) {\n        traceIdx = traceIndices[i];\n        var contFull = gd._fullData[traceIdx];\n        var module = contFull._module;\n\n        if(!module) continue;\n\n        if(!module.animatable) {\n            var thisUpdate = {};\n\n            for(var ai in data[i]) {\n                thisUpdate[ai] = [data[i][ai]];\n            }\n        }\n    }\n\n    var seq = [plots.previousPromises, interruptPreviousTransitions, prepareTransitions, plots.rehover, executeTransitions];\n\n    var transitionStarting = Lib.syncOrAsync(seq, gd);\n\n    if(!transitionStarting || !transitionStarting.then) {\n        transitionStarting = Promise.resolve();\n    }\n\n    return transitionStarting.then(function() {\n        return gd;\n    });\n};\n\nplots.doCalcdata = function(gd, traces) {\n    var axList = Plotly.Axes.list(gd),\n        fullData = gd._fullData,\n        fullLayout = gd._fullLayout;\n\n    var trace, _module, i, j;\n\n    var hasCategoryAxis = false;\n\n    // XXX: Is this correct? Needs a closer look so that *some* traces can be recomputed without\n    // *all* needing doCalcdata:\n    var calcdata = new Array(fullData.length);\n    var oldCalcdata = (gd.calcdata || []).slice(0);\n    gd.calcdata = calcdata;\n\n    // extra helper variables\n    // firstscatter: fill-to-next on the first trace goes to zero\n    gd.firstscatter = true;\n\n    // how many box plots do we have (in case they're grouped)\n    gd.numboxes = 0;\n\n    // for calculating avg luminosity of heatmaps\n    gd._hmpixcount = 0;\n    gd._hmlumcount = 0;\n\n    // for sharing colors across pies (and for legend)\n    fullLayout._piecolormap = {};\n    fullLayout._piedefaultcolorcount = 0;\n\n    // initialize the category list, if there is one, so we start over\n    // to be filled in later by ax.d2c\n    for(i = 0; i < axList.length; i++) {\n        axList[i]._categories = axList[i]._initialCategories.slice();\n\n        // Build the lookup map for initialized categories\n        axList[i]._categoriesMap = {};\n        for(j = 0; j < axList[i]._categories.length; j++) {\n            axList[i]._categoriesMap[axList[i]._categories[j]] = j;\n        }\n\n        if(axList[i].type === 'category') hasCategoryAxis = true;\n    }\n\n    // If traces were specified and this trace was not included,\n    // then transfer it over from the old calcdata:\n    for(i = 0; i < fullData.length; i++) {\n        if(Array.isArray(traces) && traces.indexOf(i) === -1) {\n            calcdata[i] = oldCalcdata[i];\n            continue;\n        }\n    }\n\n    var hasCalcTransform = false;\n\n    // transform loop\n    for(i = 0; i < fullData.length; i++) {\n        trace = fullData[i];\n\n        if(trace.visible === true && trace.transforms) {\n            _module = trace._module;\n\n            // we need one round of trace module calc before\n            // the calc transform to 'fill in' the categories list\n            // used for example in the data-to-coordinate method\n            if(_module && _module.calc) _module.calc(gd, trace);\n\n            for(j = 0; j < trace.transforms.length; j++) {\n                var transform = trace.transforms[j];\n\n                _module = transformsRegistry[transform.type];\n                if(_module && _module.calcTransform) {\n                    hasCalcTransform = true;\n                    _module.calcTransform(gd, trace, transform);\n                }\n            }\n        }\n    }\n\n    // clear stuff that should recomputed in 'regular' loop\n    if(hasCalcTransform) {\n        for(i = 0; i < axList.length; i++) {\n            axList[i]._min = [];\n            axList[i]._max = [];\n            axList[i]._categories = [];\n            // Reset the look up map\n            axList[i]._categoriesMap = {};\n        }\n    }\n\n    // 'regular' loop\n    for(i = 0; i < fullData.length; i++) {\n        var cd = [];\n\n        trace = fullData[i];\n\n        if(trace.visible === true) {\n            _module = trace._module;\n            if(_module && _module.calc) cd = _module.calc(gd, trace);\n        }\n\n        // Make sure there is a first point.\n        //\n        // This ensures there is a calcdata item for every trace,\n        // even if cartesian logic doesn't handle it (for things like legends).\n        if(!Array.isArray(cd) || !cd[0]) {\n            cd = [{x: BADNUM, y: BADNUM}];\n        }\n\n        // add the trace-wide properties to the first point,\n        // per point properties to every point\n        // t is the holder for trace-wide properties\n        if(!cd[0].t) cd[0].t = {};\n        cd[0].trace = trace;\n\n        calcdata[i] = cd;\n    }\n\n    // To handle the case of components using category names as coordinates, we\n    // need to re-supply defaults for these objects now, after calc has\n    // finished populating the category mappings\n    // Any component that uses `Axes.coercePosition` falls into this category\n    if(hasCategoryAxis) {\n        var dataReferencedComponents = ['annotations', 'shapes', 'images'];\n        for(i = 0; i < dataReferencedComponents.length; i++) {\n            Registry.getComponentMethod(dataReferencedComponents[i], 'supplyLayoutDefaults')(\n                gd.layout, fullLayout, fullData);\n        }\n    }\n};\n\nplots.rehover = function(gd) {\n    if(gd._fullLayout._rehover) {\n        gd._fullLayout._rehover();\n    }\n};\n\nplots.generalUpdatePerTraceModule = function(subplot, subplotCalcData, subplotLayout) {\n    var traceHashOld = subplot.traceHash,\n        traceHash = {},\n        i;\n\n    function filterVisible(calcDataIn) {\n        var calcDataOut = [];\n\n        for(var i = 0; i < calcDataIn.length; i++) {\n            var calcTrace = calcDataIn[i],\n                trace = calcTrace[0].trace;\n\n            if(trace.visible === true) calcDataOut.push(calcTrace);\n        }\n\n        return calcDataOut;\n    }\n\n    // build up moduleName -> calcData hash\n    for(i = 0; i < subplotCalcData.length; i++) {\n        var calcTraces = subplotCalcData[i],\n            trace = calcTraces[0].trace;\n\n        // skip over visible === false traces\n        // as they don't have `_module` ref\n        if(trace.visible) {\n            traceHash[trace.type] = traceHash[trace.type] || [];\n            traceHash[trace.type].push(calcTraces);\n        }\n    }\n\n    var moduleNamesOld = Object.keys(traceHashOld);\n    var moduleNames = Object.keys(traceHash);\n\n    // when a trace gets deleted, make sure that its module's\n    // plot method is called so that it is properly\n    // removed from the DOM.\n    for(i = 0; i < moduleNamesOld.length; i++) {\n        var moduleName = moduleNamesOld[i];\n\n        if(moduleNames.indexOf(moduleName) === -1) {\n            var fakeCalcTrace = traceHashOld[moduleName][0],\n                fakeTrace = fakeCalcTrace[0].trace;\n\n            fakeTrace.visible = false;\n            traceHash[moduleName] = [fakeCalcTrace];\n        }\n    }\n\n    // update list of module names to include 'fake' traces added above\n    moduleNames = Object.keys(traceHash);\n\n    // call module plot method\n    for(i = 0; i < moduleNames.length; i++) {\n        var moduleCalcData = traceHash[moduleNames[i]],\n            _module = moduleCalcData[0][0].trace._module;\n\n        _module.plot(subplot, filterVisible(moduleCalcData), subplotLayout);\n    }\n\n    // update moduleName -> calcData hash\n    subplot.traceHash = traceHash;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/registry.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Loggers = require('./lib/loggers');\nvar noop = require('./lib/noop');\nvar pushUnique = require('./lib/push_unique');\nvar basePlotAttributes = require('./plots/attributes');\n\nexports.modules = {};\nexports.allCategories = {};\nexports.allTypes = [];\nexports.subplotsRegistry = {};\nexports.transformsRegistry = {};\nexports.componentsRegistry = {};\nexports.layoutArrayContainers = [];\nexports.layoutArrayRegexes = [];\n\n/**\n * register a module as the handler for a trace type\n *\n * @param {object} _module the module that will handle plotting this trace type\n * @param {string} thisType\n * @param {array of strings} categoriesIn all the categories this type is in,\n *     tested by calls: traceIs(trace, oneCategory)\n * @param {object} meta meta information about the trace type\n */\nexports.register = function(_module, thisType, categoriesIn, meta) {\n    if(exports.modules[thisType]) {\n        Loggers.log('Type ' + thisType + ' already registered');\n        return;\n    }\n\n    var categoryObj = {};\n    for(var i = 0; i < categoriesIn.length; i++) {\n        categoryObj[categoriesIn[i]] = true;\n        exports.allCategories[categoriesIn[i]] = true;\n    }\n\n    exports.modules[thisType] = {\n        _module: _module,\n        categories: categoryObj\n    };\n\n    if(meta && Object.keys(meta).length) {\n        exports.modules[thisType].meta = meta;\n    }\n\n    exports.allTypes.push(thisType);\n};\n\n/**\n * register a subplot type\n *\n * @param {object} _module subplot module:\n *\n *      @param {string or array of strings} attr\n *          attribute name in traces and layout\n *      @param {string or array of strings} idRoot\n *          root of id (setting the possible value for attrName)\n *      @param {object} attributes\n *          attribute(s) for traces of this subplot type\n *\n * In trace objects `attr` is the object key taking a valid `id` as value\n * (the set of all valid ids is generated below and stored in idRegex).\n *\n * In the layout object, a or several valid `attr` name(s) can be keys linked\n * to a nested attribute objects\n * (the set of all valid attr names is generated below and stored in attrRegex).\n */\nexports.registerSubplot = function(_module) {\n    var plotType = _module.name;\n\n    if(exports.subplotsRegistry[plotType]) {\n        Loggers.log('Plot type ' + plotType + ' already registered.');\n        return;\n    }\n\n    // relayout array handling will look for component module methods with this\n    // name and won't find them because this is a subplot module... but that\n    // should be fine, it will just fall back on redrawing the plot.\n    findArrayRegexps(_module);\n\n    // not sure what's best for the 'cartesian' type at this point\n    exports.subplotsRegistry[plotType] = _module;\n};\n\nexports.registerComponent = function(_module) {\n    var name = _module.name;\n\n    exports.componentsRegistry[name] = _module;\n\n    if(_module.layoutAttributes) {\n        if(_module.layoutAttributes._isLinkedToArray) {\n            pushUnique(exports.layoutArrayContainers, name);\n        }\n        findArrayRegexps(_module);\n    }\n};\n\nfunction findArrayRegexps(_module) {\n    if(_module.layoutAttributes) {\n        var arrayAttrRegexps = _module.layoutAttributes._arrayAttrRegexps;\n        if(arrayAttrRegexps) {\n            for(var i = 0; i < arrayAttrRegexps.length; i++) {\n                pushUnique(exports.layoutArrayRegexes, arrayAttrRegexps[i]);\n            }\n        }\n    }\n}\n\n/**\n * Get registered module using trace object or trace type\n *\n * @param {object||string} trace\n *  trace object with prop 'type' or trace type as a string\n * @return {object}\n *  module object corresponding to trace type\n */\nexports.getModule = function(trace) {\n    if(trace.r !== undefined) {\n        Loggers.warn('Tried to put a polar trace ' +\n            'on an incompatible graph of cartesian ' +\n            'data. Ignoring this dataset.', trace\n        );\n        return false;\n    }\n\n    var _module = exports.modules[getTraceType(trace)];\n    if(!_module) return false;\n    return _module._module;\n};\n\n/**\n * Determine if this trace type is in a given category\n *\n * @param {object||string} traceType\n *  a trace (object) or trace type (string)\n * @param {string} category\n *  category in question\n * @return {boolean}\n */\nexports.traceIs = function(traceType, category) {\n    traceType = getTraceType(traceType);\n\n    // old plot.ly workspace hack, nothing to see here\n    if(traceType === 'various') return false;\n\n    var _module = exports.modules[traceType];\n\n    if(!_module) {\n        if(traceType && traceType !== 'area') {\n            Loggers.log('Unrecognized trace type ' + traceType + '.');\n        }\n\n        _module = exports.modules[basePlotAttributes.type.dflt];\n    }\n\n    return !!_module.categories[category];\n};\n\n/**\n * Retrieve component module method. Falls back on noop if either the\n * module or the method is missing, so the result can always be safely called\n *\n * @param {string} name\n *  name of component (as declared in component module)\n * @param {string} method\n *  name of component module method\n * @return {function}\n */\nexports.getComponentMethod = function(name, method) {\n    var _module = exports.componentsRegistry[name];\n\n    if(!_module) return noop;\n    return _module[method] || noop;\n};\n\nfunction getTraceType(traceType) {\n    if(typeof traceType === 'object') traceType = traceType.type;\n    return traceType;\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/lib/loggers.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n/* eslint-disable no-console */\n\nvar config = require('../plot_api/plot_config');\n\nvar loggers = module.exports = {};\n\n/**\n * ------------------------------------------\n * debugging tools\n * ------------------------------------------\n */\n\nloggers.log = function() {\n    if(config.logging > 1) {\n        var messages = ['LOG:'];\n\n        for(var i = 0; i < arguments.length; i++) {\n            messages.push(arguments[i]);\n        }\n\n        apply(console.trace || console.log, messages);\n    }\n};\n\nloggers.warn = function() {\n    if(config.logging > 0) {\n        var messages = ['WARN:'];\n\n        for(var i = 0; i < arguments.length; i++) {\n            messages.push(arguments[i]);\n        }\n\n        apply(console.trace || console.log, messages);\n    }\n};\n\nloggers.error = function() {\n    if(config.logging > 0) {\n        var messages = ['ERROR:'];\n\n        for(var i = 0; i < arguments.length; i++) {\n            messages.push(arguments[i]);\n        }\n\n        apply(console.error, messages);\n    }\n};\n\n/*\n * Robust apply, for IE9 where console.log doesn't support\n * apply like other functions do\n */\nfunction apply(f, args) {\n    if(f.apply) {\n        f.apply(f, args);\n    }\n    else {\n        for(var i = 0; i < args.length; i++) {\n            f(args[i]);\n        }\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/lib/noop.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n// Simple helper functions\n// none of these need any external deps\n\nmodule.exports = function noop() {};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/lib/push_unique.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n/**\n * Push array with unique items\n *\n * @param {array} array\n *  array to be filled\n * @param {any} item\n *  item to be or not to be inserted\n * @return {array}\n *  ref to array (now possibly containing one more item)\n *\n */\nmodule.exports = function pushUnique(array, item) {\n    if(item instanceof RegExp) {\n        var itemStr = item.toString(),\n            i;\n        for(i = 0; i < array.length; i++) {\n            if(array[i] instanceof RegExp && array[i].toString() === itemStr) {\n                return array;\n            }\n        }\n        array.push(item);\n    }\n    else if(item && array.indexOf(item) === -1) array.push(item);\n\n    return array;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n\nmodule.exports = {\n    type: {\n        valType: 'enumerated',\n        role: 'info',\n        values: [],     // listed dynamically\n        dflt: 'scatter'\n    },\n    visible: {\n        valType: 'enumerated',\n        values: [true, false, 'legendonly'],\n        role: 'info',\n        dflt: true,\n        description: [\n            'Determines whether or not this trace is visible.',\n            'If *legendonly*, the trace is not drawn,',\n            'but can appear as a legend item',\n            '(provided that the legend itself is visible).'\n        ].join(' ')\n    },\n    showlegend: {\n        valType: 'boolean',\n        role: 'info',\n        dflt: true,\n        description: [\n            'Determines whether or not an item corresponding to this',\n            'trace is shown in the legend.'\n        ].join(' ')\n    },\n    legendgroup: {\n        valType: 'string',\n        role: 'info',\n        dflt: '',\n        description: [\n            'Sets the legend group for this trace.',\n            'Traces part of the same legend group hide/show at the same time',\n            'when toggling legend items.'\n        ].join(' ')\n    },\n    opacity: {\n        valType: 'number',\n        role: 'style',\n        min: 0,\n        max: 1,\n        dflt: 1,\n        description: 'Sets the opacity of the trace.'\n    },\n    name: {\n        valType: 'string',\n        role: 'info',\n        description: [\n            'Sets the trace name.',\n            'The trace name appear as the legend item and on hover.'\n        ].join(' ')\n    },\n    uid: {\n        valType: 'string',\n        role: 'info',\n        dflt: ''\n    },\n    hoverinfo: {\n        valType: 'flaglist',\n        role: 'info',\n        flags: ['x', 'y', 'z', 'text', 'name'],\n        extras: ['all', 'none', 'skip'],\n        dflt: 'all',\n        description: [\n            'Determines which trace information appear on hover.',\n            'If `none` or `skip` are set, no information is displayed upon hovering.',\n            'But, if `none` is set, click and hover events are still fired.'\n        ].join(' ')\n    },\n    stream: {\n        token: {\n            valType: 'string',\n            noBlank: true,\n            strict: true,\n            role: 'info',\n            description: [\n                'The stream id number links a data trace on a plot with a stream.',\n                'See https://plot.ly/settings for more details.'\n            ].join(' ')\n        },\n        maxpoints: {\n            valType: 'number',\n            min: 0,\n            max: 10000,\n            dflt: 500,\n            role: 'info',\n            description: [\n                'Sets the maximum number of points to keep on the plots from an',\n                'incoming stream.',\n                'If `maxpoints` is set to *50*, only the newest 50 points will',\n                'be displayed on the plot.'\n            ].join(' ')\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/lib/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\n\nvar lib = module.exports = {};\n\nlib.nestedProperty = require('./nested_property');\nlib.isPlainObject = require('./is_plain_object');\nlib.isArray = require('./is_array');\nlib.mod = require('./mod');\nlib.toLogRange = require('./to_log_range');\nlib.relinkPrivateKeys = require('./relink_private');\nlib.ensureArray = require('./ensure_array');\n\nvar coerceModule = require('./coerce');\nlib.valObjects = coerceModule.valObjects;\nlib.coerce = coerceModule.coerce;\nlib.coerce2 = coerceModule.coerce2;\nlib.coerceFont = coerceModule.coerceFont;\nlib.validate = coerceModule.validate;\n\nvar datesModule = require('./dates');\nlib.dateTime2ms = datesModule.dateTime2ms;\nlib.isDateTime = datesModule.isDateTime;\nlib.ms2DateTime = datesModule.ms2DateTime;\nlib.ms2DateTimeLocal = datesModule.ms2DateTimeLocal;\nlib.cleanDate = datesModule.cleanDate;\nlib.isJSDate = datesModule.isJSDate;\nlib.formatDate = datesModule.formatDate;\nlib.incrementMonth = datesModule.incrementMonth;\nlib.dateTick0 = datesModule.dateTick0;\nlib.dfltRange = datesModule.dfltRange;\nlib.findExactDates = datesModule.findExactDates;\nlib.MIN_MS = datesModule.MIN_MS;\nlib.MAX_MS = datesModule.MAX_MS;\n\nvar searchModule = require('./search');\nlib.findBin = searchModule.findBin;\nlib.sorterAsc = searchModule.sorterAsc;\nlib.sorterDes = searchModule.sorterDes;\nlib.distinctVals = searchModule.distinctVals;\nlib.roundUp = searchModule.roundUp;\n\nvar statsModule = require('./stats');\nlib.aggNums = statsModule.aggNums;\nlib.len = statsModule.len;\nlib.mean = statsModule.mean;\nlib.variance = statsModule.variance;\nlib.stdev = statsModule.stdev;\nlib.interp = statsModule.interp;\n\nvar matrixModule = require('./matrix');\nlib.init2dArray = matrixModule.init2dArray;\nlib.transposeRagged = matrixModule.transposeRagged;\nlib.dot = matrixModule.dot;\nlib.translationMatrix = matrixModule.translationMatrix;\nlib.rotationMatrix = matrixModule.rotationMatrix;\nlib.rotationXYMatrix = matrixModule.rotationXYMatrix;\nlib.apply2DTransform = matrixModule.apply2DTransform;\nlib.apply2DTransform2 = matrixModule.apply2DTransform2;\n\nvar extendModule = require('./extend');\nlib.extendFlat = extendModule.extendFlat;\nlib.extendDeep = extendModule.extendDeep;\nlib.extendDeepAll = extendModule.extendDeepAll;\nlib.extendDeepNoArrays = extendModule.extendDeepNoArrays;\n\nvar loggersModule = require('./loggers');\nlib.log = loggersModule.log;\nlib.warn = loggersModule.warn;\nlib.error = loggersModule.error;\n\nlib.notifier = require('./notifier');\n\nlib.filterUnique = require('./filter_unique');\nlib.filterVisible = require('./filter_visible');\nlib.pushUnique = require('./push_unique');\n\nlib.cleanNumber = require('./clean_number');\n\nlib.noop = require('./noop');\nlib.identity = require('./identity');\n\n/**\n * swap x and y of the same attribute in container cont\n * specify attr with a ? in place of x/y\n * you can also swap other things than x/y by providing part1 and part2\n */\nlib.swapAttrs = function(cont, attrList, part1, part2) {\n    if(!part1) part1 = 'x';\n    if(!part2) part2 = 'y';\n    for(var i = 0; i < attrList.length; i++) {\n        var attr = attrList[i],\n            xp = lib.nestedProperty(cont, attr.replace('?', part1)),\n            yp = lib.nestedProperty(cont, attr.replace('?', part2)),\n            temp = xp.get();\n        xp.set(yp.get());\n        yp.set(temp);\n    }\n};\n\n/**\n * to prevent event bubbling, in particular text selection during drag.\n * see http://stackoverflow.com/questions/5429827/\n *      how-can-i-prevent-text-element-selection-with-cursor-drag\n * for maximum effect use:\n *      return pauseEvent(e);\n */\nlib.pauseEvent = function(e) {\n    if(e.stopPropagation) e.stopPropagation();\n    if(e.preventDefault) e.preventDefault();\n    e.cancelBubble = true;\n    return false;\n};\n\n// constrain - restrict a number v to be between v0 and v1\nlib.constrain = function(v, v0, v1) {\n    if(v0 > v1) return Math.max(v1, Math.min(v0, v));\n    return Math.max(v0, Math.min(v1, v));\n};\n\n/**\n * do two bounding boxes from getBoundingClientRect,\n * ie {left,right,top,bottom,width,height}, overlap?\n * takes optional padding pixels\n */\nlib.bBoxIntersect = function(a, b, pad) {\n    pad = pad || 0;\n    return (a.left <= b.right + pad &&\n            b.left <= a.right + pad &&\n            a.top <= b.bottom + pad &&\n            b.top <= a.bottom + pad);\n};\n\n/*\n * simpleMap: alternative to Array.map that only\n * passes on the element and up to 2 extra args you\n * provide (but not the array index or the whole array)\n *\n * array: the array to map it to\n * func: the function to apply\n * x1, x2: optional extra args\n */\nlib.simpleMap = function(array, func, x1, x2) {\n    var len = array.length,\n        out = new Array(len);\n    for(var i = 0; i < len; i++) out[i] = func(array[i], x1, x2);\n    return out;\n};\n\n// random string generator\nlib.randstr = function randstr(existing, bits, base) {\n    /*\n     * Include number of bits, the base of the string you want\n     * and an optional array of existing strings to avoid.\n     */\n    if(!base) base = 16;\n    if(bits === undefined) bits = 24;\n    if(bits <= 0) return '0';\n\n    var digits = Math.log(Math.pow(2, bits)) / Math.log(base),\n        res = '',\n        i,\n        b,\n        x;\n\n    for(i = 2; digits === Infinity; i *= 2) {\n        digits = Math.log(Math.pow(2, bits / i)) / Math.log(base) * i;\n    }\n\n    var rem = digits - Math.floor(digits);\n\n    for(i = 0; i < Math.floor(digits); i++) {\n        x = Math.floor(Math.random() * base).toString(base);\n        res = x + res;\n    }\n\n    if(rem) {\n        b = Math.pow(base, rem);\n        x = Math.floor(Math.random() * b).toString(base);\n        res = x + res;\n    }\n\n    var parsed = parseInt(res, base);\n    if((existing && (existing.indexOf(res) > -1)) ||\n         (parsed !== Infinity && parsed >= Math.pow(2, bits))) {\n        return randstr(existing, bits, base);\n    }\n    else return res;\n};\n\nlib.OptionControl = function(opt, optname) {\n    /*\n     * An environment to contain all option setters and\n     * getters that collectively modify opts.\n     *\n     * You can call up opts from any function in new object\n     * as this.optname || this.opt\n     *\n     * See FitOpts for example of usage\n     */\n    if(!opt) opt = {};\n    if(!optname) optname = 'opt';\n\n    var self = {};\n    self.optionList = [];\n\n    self._newoption = function(optObj) {\n        optObj[optname] = opt;\n        self[optObj.name] = optObj;\n        self.optionList.push(optObj);\n    };\n\n    self['_' + optname] = opt;\n    return self;\n};\n\n/**\n * lib.smooth: smooth arrayIn by convolving with\n * a hann window with given full width at half max\n * bounce the ends in, so the output has the same length as the input\n */\nlib.smooth = function(arrayIn, FWHM) {\n    FWHM = Math.round(FWHM) || 0; // only makes sense for integers\n    if(FWHM < 2) return arrayIn;\n\n    var alen = arrayIn.length,\n        alen2 = 2 * alen,\n        wlen = 2 * FWHM - 1,\n        w = new Array(wlen),\n        arrayOut = new Array(alen),\n        i,\n        j,\n        k,\n        v;\n\n    // first make the window array\n    for(i = 0; i < wlen; i++) {\n        w[i] = (1 - Math.cos(Math.PI * (i + 1) / FWHM)) / (2 * FWHM);\n    }\n\n    // now do the convolution\n    for(i = 0; i < alen; i++) {\n        v = 0;\n        for(j = 0; j < wlen; j++) {\n            k = i + j + 1 - FWHM;\n\n            // multibounce\n            if(k < -alen) k -= alen2 * Math.round(k / alen2);\n            else if(k >= alen2) k -= alen2 * Math.floor(k / alen2);\n\n            // single bounce\n            if(k < 0) k = - 1 - k;\n            else if(k >= alen) k = alen2 - 1 - k;\n\n            v += arrayIn[k] * w[j];\n        }\n        arrayOut[i] = v;\n    }\n\n    return arrayOut;\n};\n\n/**\n * syncOrAsync: run a sequence of functions synchronously\n * as long as its returns are not promises (ie have no .then)\n * includes one argument arg to send to all functions...\n * this is mainly just to prevent us having to make wrapper functions\n * when the only purpose of the wrapper is to reference gd\n * and a final step to be executed at the end\n * TODO: if there's an error and everything is sync,\n * this doesn't happen yet because we want to make sure\n * that it gets reported\n */\nlib.syncOrAsync = function(sequence, arg, finalStep) {\n    var ret, fni;\n\n    function continueAsync() {\n        return lib.syncOrAsync(sequence, arg, finalStep);\n    }\n\n    while(sequence.length) {\n        fni = sequence.splice(0, 1)[0];\n        ret = fni(arg);\n\n        if(ret && ret.then) {\n            return ret.then(continueAsync)\n                .then(undefined, lib.promiseError);\n        }\n    }\n\n    return finalStep && finalStep(arg);\n};\n\n\n/**\n * Helper to strip trailing slash, from\n * http://stackoverflow.com/questions/6680825/return-string-without-trailing-slash\n */\nlib.stripTrailingSlash = function(str) {\n    if(str.substr(-1) === '/') return str.substr(0, str.length - 1);\n    return str;\n};\n\nlib.noneOrAll = function(containerIn, containerOut, attrList) {\n    /**\n     * some attributes come together, so if you have one of them\n     * in the input, you should copy the default values of the others\n     * to the input as well.\n     */\n    if(!containerIn) return;\n\n    var hasAny = false,\n        hasAll = true,\n        i,\n        val;\n\n    for(i = 0; i < attrList.length; i++) {\n        val = containerIn[attrList[i]];\n        if(val !== undefined && val !== null) hasAny = true;\n        else hasAll = false;\n    }\n\n    if(hasAny && !hasAll) {\n        for(i = 0; i < attrList.length; i++) {\n            containerIn[attrList[i]] = containerOut[attrList[i]];\n        }\n    }\n};\n\nlib.mergeArray = function(traceAttr, cd, cdAttr) {\n    if(Array.isArray(traceAttr)) {\n        var imax = Math.min(traceAttr.length, cd.length);\n        for(var i = 0; i < imax; i++) cd[i][cdAttr] = traceAttr[i];\n    }\n};\n\n/**\n * modified version of jQuery's extend to strip out private objs and functions,\n * and cut arrays down to first <arraylen> or 1 elements\n * because extend-like algorithms are hella slow\n * obj2 is assumed to already be clean of these things (including no arrays)\n */\nlib.minExtend = function(obj1, obj2) {\n    var objOut = {};\n    if(typeof obj2 !== 'object') obj2 = {};\n    var arrayLen = 3,\n        keys = Object.keys(obj1),\n        i,\n        k,\n        v;\n    for(i = 0; i < keys.length; i++) {\n        k = keys[i];\n        v = obj1[k];\n        if(k.charAt(0) === '_' || typeof v === 'function') continue;\n        else if(k === 'module') objOut[k] = v;\n        else if(Array.isArray(v)) objOut[k] = v.slice(0, arrayLen);\n        else if(v && (typeof v === 'object')) objOut[k] = lib.minExtend(obj1[k], obj2[k]);\n        else objOut[k] = v;\n    }\n\n    keys = Object.keys(obj2);\n    for(i = 0; i < keys.length; i++) {\n        k = keys[i];\n        v = obj2[k];\n        if(typeof v !== 'object' || !(k in objOut) || typeof objOut[k] !== 'object') {\n            objOut[k] = v;\n        }\n    }\n\n    return objOut;\n};\n\nlib.titleCase = function(s) {\n    return s.charAt(0).toUpperCase() + s.substr(1);\n};\n\nlib.containsAny = function(s, fragments) {\n    for(var i = 0; i < fragments.length; i++) {\n        if(s.indexOf(fragments[i]) !== -1) return true;\n    }\n    return false;\n};\n\n// get the parent Plotly plot of any element. Whoo jquery-free tree climbing!\nlib.getPlotDiv = function(el) {\n    for(; el && el.removeAttribute; el = el.parentNode) {\n        if(lib.isPlotDiv(el)) return el;\n    }\n};\n\nlib.isPlotDiv = function(el) {\n    var el3 = d3.select(el);\n    return el3.node() instanceof HTMLElement &&\n        el3.size() &&\n        el3.classed('js-plotly-plot');\n};\n\nlib.removeElement = function(el) {\n    var elParent = el && el.parentNode;\n    if(elParent) elParent.removeChild(el);\n};\n\n/**\n * for dynamically adding style rules\n * makes one stylesheet that contains all rules added\n * by all calls to this function\n */\nlib.addStyleRule = function(selector, styleString) {\n    if(!lib.styleSheet) {\n        var style = document.createElement('style');\n        // WebKit hack :(\n        style.appendChild(document.createTextNode(''));\n        document.head.appendChild(style);\n        lib.styleSheet = style.sheet;\n    }\n    var styleSheet = lib.styleSheet;\n\n    if(styleSheet.insertRule) {\n        styleSheet.insertRule(selector + '{' + styleString + '}', 0);\n    }\n    else if(styleSheet.addRule) {\n        styleSheet.addRule(selector, styleString, 0);\n    }\n    else lib.warn('addStyleRule failed');\n};\n\nlib.isIE = function() {\n    return typeof window.navigator.msSaveBlob !== 'undefined';\n};\n\n/**\n * Duck typing to recognize a d3 selection, mostly for IE9's benefit\n * because it doesn't handle instanceof like modern browsers\n */\nlib.isD3Selection = function(obj) {\n    return obj && (typeof obj.classed === 'function');\n};\n\n\n/**\n * Converts a string path to an object.\n *\n * When given a string containing an array element, it will create a `null`\n * filled array of the given size.\n *\n * @example\n * lib.objectFromPath('nested.test[2].path', 'value');\n * // returns { nested: { test: [null, null, { path: 'value' }]}\n *\n * @param   {string}    path to nested value\n * @param   {*}         any value to be set\n *\n * @return {Object} the constructed object with a full nested path\n */\nlib.objectFromPath = function(path, value) {\n    var keys = path.split('.'),\n        tmpObj,\n        obj = tmpObj = {};\n\n    for(var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var el = null;\n\n        var parts = keys[i].match(/(.*)\\[([0-9]+)\\]/);\n\n        if(parts) {\n            key = parts[1];\n            el = parts[2];\n\n            tmpObj = tmpObj[key] = [];\n\n            if(i === keys.length - 1) {\n                tmpObj[el] = value;\n            } else {\n                tmpObj[el] = {};\n            }\n\n            tmpObj = tmpObj[el];\n        } else {\n\n            if(i === keys.length - 1) {\n                tmpObj[key] = value;\n            } else {\n                tmpObj[key] = {};\n            }\n\n            tmpObj = tmpObj[key];\n        }\n    }\n\n    return obj;\n};\n\n/**\n * Iterate through an object in-place, converting dotted properties to objects.\n *\n * Examples:\n *\n *   lib.expandObjectPaths({'nested.test.path': 'value'});\n *     => { nested: { test: {path: 'value'}}}\n *\n * It also handles array notation, e.g.:\n *\n *   lib.expandObjectPaths({'foo[1].bar': 'value'});\n *     => { foo: [null, {bar: value}] }\n *\n * It handles merges the results when two properties are specified in parallel:\n *\n *   lib.expandObjectPaths({'foo[1].bar': 10, 'foo[0].bar': 20});\n *     => { foo: [{bar: 10}, {bar: 20}] }\n *\n * It does NOT, however, merge mulitple mutliply-nested arrays::\n *\n *   lib.expandObjectPaths({'marker[1].range[1]': 5, 'marker[1].range[0]': 4})\n *     => { marker: [null, {range: 4}] }\n */\n\n// Store this to avoid recompiling regex on *every* prop since this may happen many\n// many times for animations. Could maybe be inside the function. Not sure about\n// scoping vs. recompilation tradeoff, but at least it's not just inlining it into\n// the inner loop.\nvar dottedPropertyRegex = /^([^\\[\\.]+)\\.(.+)?/;\nvar indexedPropertyRegex = /^([^\\.]+)\\[([0-9]+)\\](\\.)?(.+)?/;\n\nlib.expandObjectPaths = function(data) {\n    var match, key, prop, datum, idx, dest, trailingPath;\n    if(typeof data === 'object' && !Array.isArray(data)) {\n        for(key in data) {\n            if(data.hasOwnProperty(key)) {\n                if((match = key.match(dottedPropertyRegex))) {\n                    datum = data[key];\n                    prop = match[1];\n\n                    delete data[key];\n\n                    data[prop] = lib.extendDeepNoArrays(data[prop] || {}, lib.objectFromPath(key, lib.expandObjectPaths(datum))[prop]);\n                } else if((match = key.match(indexedPropertyRegex))) {\n                    datum = data[key];\n\n                    prop = match[1];\n                    idx = parseInt(match[2]);\n\n                    delete data[key];\n\n                    data[prop] = data[prop] || [];\n\n                    if(match[3] === '.') {\n                        // This is the case where theere are subsequent properties into which\n                        // we must recurse, e.g. transforms[0].value\n                        trailingPath = match[4];\n                        dest = data[prop][idx] = data[prop][idx] || {};\n\n                        // NB: Extend deep no arrays prevents this from working on multiple\n                        // nested properties in the same object, e.g.\n                        //\n                        // {\n                        //   foo[0].bar[1].range\n                        //   foo[0].bar[0].range\n                        // }\n                        //\n                        // In this case, the extendDeepNoArrays will overwrite one array with\n                        // the other, so that both properties *will not* be present in the\n                        // result. Fixing this would require a more intelligent tracking\n                        // of changes and merging than extendDeepNoArrays currently accomplishes.\n                        lib.extendDeepNoArrays(dest, lib.objectFromPath(trailingPath, lib.expandObjectPaths(datum)));\n                    } else {\n                        // This is the case where this property is the end of the line,\n                        // e.g. xaxis.range[0]\n                        data[prop][idx] = lib.expandObjectPaths(datum);\n                    }\n                } else {\n                    data[key] = lib.expandObjectPaths(data[key]);\n                }\n            }\n        }\n    }\n\n    return data;\n};\n\n/**\n * Converts value to string separated by the provided separators.\n *\n * @example\n * lib.numSeparate(2016, '.,');\n * // returns '2016'\n *\n * @example\n * lib.numSeparate(3000, '.,', true);\n * // returns '3,000'\n *\n * @example\n * lib.numSeparate(1234.56, '|,')\n * // returns '1,234|56'\n *\n * @param   {string|number} value       the value to be converted\n * @param   {string}    separators  string of decimal, then thousands separators\n * @param   {boolean}    separatethousands  boolean, 4-digit integers are separated if true\n *\n * @return  {string}    the value that has been separated\n */\nlib.numSeparate = function(value, separators, separatethousands) {\n    if(!separatethousands) separatethousands = false;\n\n    if(typeof separators !== 'string' || separators.length === 0) {\n        throw new Error('Separator string required for formatting!');\n    }\n\n    if(typeof value === 'number') {\n        value = String(value);\n    }\n\n    var thousandsRe = /(\\d+)(\\d{3})/,\n        decimalSep = separators.charAt(0),\n        thouSep = separators.charAt(1);\n\n    var x = value.split('.'),\n        x1 = x[0],\n        x2 = x.length > 1 ? decimalSep + x[1] : '';\n\n    // Years are ignored for thousands separators\n    if(thouSep && (x.length > 1 || x1.length > 4 || separatethousands)) {\n        while(thousandsRe.test(x1)) {\n            x1 = x1.replace(thousandsRe, '$1' + thouSep + '$2');\n        }\n    }\n\n    return x1 + x2;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/lib/nested_property.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar isArray = require('./is_array');\nvar isPlainObject = require('./is_plain_object');\nvar containerArrayMatch = require('../plot_api/container_array_match');\n\n/**\n * convert a string s (such as 'xaxis.range[0]')\n * representing a property of nested object into set and get methods\n * also return the string and object so we don't have to keep track of them\n * allows [-1] for an array index, to set a property inside all elements\n * of an array\n * eg if obj = {arr: [{a: 1}, {a: 2}]}\n * you can do p = nestedProperty(obj, 'arr[-1].a')\n * but you cannot set the array itself this way, to do that\n * just set the whole array.\n * eg if obj = {arr: [1, 2, 3]}\n * you can't do nestedProperty(obj, 'arr[-1]').set(5)\n * but you can do nestedProperty(obj, 'arr').set([5, 5, 5])\n */\nmodule.exports = function nestedProperty(container, propStr) {\n    if(isNumeric(propStr)) propStr = String(propStr);\n    else if(typeof propStr !== 'string' ||\n            propStr.substr(propStr.length - 4) === '[-1]') {\n        throw 'bad property string';\n    }\n\n    var j = 0,\n        propParts = propStr.split('.'),\n        indexed,\n        indices,\n        i;\n\n    // check for parts of the nesting hierarchy that are numbers (ie array elements)\n    while(j < propParts.length) {\n        // look for non-bracket chars, then any number of [##] blocks\n        indexed = String(propParts[j]).match(/^([^\\[\\]]*)((\\[\\-?[0-9]*\\])+)$/);\n        if(indexed) {\n            if(indexed[1]) propParts[j] = indexed[1];\n            // allow propStr to start with bracketed array indices\n            else if(j === 0) propParts.splice(0, 1);\n            else throw 'bad property string';\n\n            indices = indexed[2]\n                .substr(1, indexed[2].length - 2)\n                .split('][');\n\n            for(i = 0; i < indices.length; i++) {\n                j++;\n                propParts.splice(j, 0, Number(indices[i]));\n            }\n        }\n        j++;\n    }\n\n    if(typeof container !== 'object') {\n        return badContainer(container, propStr, propParts);\n    }\n\n    return {\n        set: npSet(container, propParts, propStr),\n        get: npGet(container, propParts),\n        astr: propStr,\n        parts: propParts,\n        obj: container\n    };\n};\n\nfunction npGet(cont, parts) {\n    return function() {\n        var curCont = cont,\n            curPart,\n            allSame,\n            out,\n            i,\n            j;\n\n        for(i = 0; i < parts.length - 1; i++) {\n            curPart = parts[i];\n            if(curPart === -1) {\n                allSame = true;\n                out = [];\n                for(j = 0; j < curCont.length; j++) {\n                    out[j] = npGet(curCont[j], parts.slice(i + 1))();\n                    if(out[j] !== out[0]) allSame = false;\n                }\n                return allSame ? out[0] : out;\n            }\n            if(typeof curPart === 'number' && !isArray(curCont)) {\n                return undefined;\n            }\n            curCont = curCont[curPart];\n            if(typeof curCont !== 'object' || curCont === null) {\n                return undefined;\n            }\n        }\n\n        // only hit this if parts.length === 1\n        if(typeof curCont !== 'object' || curCont === null) return undefined;\n\n        out = curCont[parts[i]];\n        if(out === null) return undefined;\n        return out;\n    };\n}\n\n/*\n * Can this value be deleted? We can delete any empty object (null, undefined, [], {})\n * EXCEPT empty data arrays, {} inside an array, or anything INSIDE an *args* array.\n *\n * Info arrays can be safely deleted, but not deleting them has no ill effects other\n * than leaving a trace or layout object with some cruft in it.\n *\n * Deleting data arrays can change the meaning of the object, as `[]` means there is\n * data for this attribute, it's just empty right now while `undefined` means the data\n * should be filled in with defaults to match other data arrays.\n *\n * `{}` inside an array means \"the default object\" which is clearly different from\n * popping it off the end of the array, or setting it `undefined` inside the array.\n *\n * *args* arrays get passed directly to API methods and we should respect precisely\n * what the user has put there - although if the whole *args* array is empty it's fine\n * to delete that.\n *\n * So we do some simple tests here to find known non-data arrays but don't worry too\n * much about not deleting some arrays that would actually be safe to delete.\n */\nvar INFO_PATTERNS = /(^|\\.)((domain|range)(\\.[xy])?|args|parallels)$/;\nvar ARGS_PATTERN = /(^|\\.)args\\[/;\nfunction isDeletable(val, propStr) {\n    if(!emptyObj(val) ||\n        (isPlainObject(val) && propStr.charAt(propStr.length - 1) === ']') ||\n        (propStr.match(ARGS_PATTERN) && val !== undefined)\n    ) {\n        return false;\n    }\n    if(!isArray(val)) return true;\n\n    if(propStr.match(INFO_PATTERNS)) return true;\n\n    var match = containerArrayMatch(propStr);\n    // if propStr matches the container array itself, index is an empty string\n    // otherwise we've matched something inside the container array, which may\n    // still be a data array.\n    return match && (match.index === '');\n}\n\nfunction npSet(cont, parts, propStr) {\n    return function(val) {\n        var curCont = cont,\n            propPart = '',\n            containerLevels = [[cont, propPart]],\n            toDelete = isDeletable(val, propStr),\n            curPart,\n            i;\n\n        for(i = 0; i < parts.length - 1; i++) {\n            curPart = parts[i];\n\n            if(typeof curPart === 'number' && !isArray(curCont)) {\n                throw 'array index but container is not an array';\n            }\n\n            // handle special -1 array index\n            if(curPart === -1) {\n                toDelete = !setArrayAll(curCont, parts.slice(i + 1), val, propStr);\n                if(toDelete) break;\n                else return;\n            }\n\n            if(!checkNewContainer(curCont, curPart, parts[i + 1], toDelete)) {\n                break;\n            }\n\n            curCont = curCont[curPart];\n\n            if(typeof curCont !== 'object' || curCont === null) {\n                throw 'container is not an object';\n            }\n\n            propPart = joinPropStr(propPart, curPart);\n\n            containerLevels.push([curCont, propPart]);\n        }\n\n        if(toDelete) {\n            if(i === parts.length - 1) delete curCont[parts[i]];\n            pruneContainers(containerLevels);\n        }\n        else curCont[parts[i]] = val;\n    };\n}\n\nfunction joinPropStr(propStr, newPart) {\n    var toAdd = newPart;\n    if(isNumeric(newPart)) toAdd = '[' + newPart + ']';\n    else if(propStr) toAdd = '.' + newPart;\n\n    return propStr + toAdd;\n}\n\n// handle special -1 array index\nfunction setArrayAll(containerArray, innerParts, val, propStr) {\n    var arrayVal = isArray(val),\n        allSet = true,\n        thisVal = val,\n        thisPropStr = propStr.replace('-1', 0),\n        deleteThis = arrayVal ? false : isDeletable(val, thisPropStr),\n        firstPart = innerParts[0],\n        i;\n\n    for(i = 0; i < containerArray.length; i++) {\n        thisPropStr = propStr.replace('-1', i);\n        if(arrayVal) {\n            thisVal = val[i % val.length];\n            deleteThis = isDeletable(thisVal, thisPropStr);\n        }\n        if(deleteThis) allSet = false;\n        if(!checkNewContainer(containerArray, i, firstPart, deleteThis)) {\n            continue;\n        }\n        npSet(containerArray[i], innerParts, propStr.replace('-1', i))(thisVal);\n    }\n    return allSet;\n}\n\n/**\n * make new sub-container as needed.\n * returns false if there's no container and none is needed\n * because we're only deleting an attribute\n */\nfunction checkNewContainer(container, part, nextPart, toDelete) {\n    if(container[part] === undefined) {\n        if(toDelete) return false;\n\n        if(typeof nextPart === 'number') container[part] = [];\n        else container[part] = {};\n    }\n    return true;\n}\n\nfunction pruneContainers(containerLevels) {\n    var i,\n        j,\n        curCont,\n        propPart,\n        keys,\n        remainingKeys;\n    for(i = containerLevels.length - 1; i >= 0; i--) {\n        curCont = containerLevels[i][0];\n        propPart = containerLevels[i][1];\n\n        remainingKeys = false;\n        if(isArray(curCont)) {\n            for(j = curCont.length - 1; j >= 0; j--) {\n                if(isDeletable(curCont[j], joinPropStr(propPart, j))) {\n                    if(remainingKeys) curCont[j] = undefined;\n                    else curCont.pop();\n                }\n                else remainingKeys = true;\n            }\n        }\n        else if(typeof curCont === 'object' && curCont !== null) {\n            keys = Object.keys(curCont);\n            remainingKeys = false;\n            for(j = keys.length - 1; j >= 0; j--) {\n                if(isDeletable(curCont[keys[j]], joinPropStr(propPart, keys[j]))) {\n                    delete curCont[keys[j]];\n                }\n                else remainingKeys = true;\n            }\n        }\n        if(remainingKeys) return;\n    }\n}\n\nfunction emptyObj(obj) {\n    if(obj === undefined || obj === null) return true;\n    if(typeof obj !== 'object') return false; // any plain value\n    if(isArray(obj)) return !obj.length; // []\n    return !Object.keys(obj).length; // {}\n}\n\nfunction badContainer(container, propStr, propParts) {\n    return {\n        set: function() { throw 'bad container'; },\n        get: function() {},\n        astr: propStr,\n        parts: propParts,\n        obj: container\n    };\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/lib/is_array.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n/**\n * Return true for arrays, whether they're untyped or not.\n */\n\n// IE9 fallback\nvar ab = (typeof ArrayBuffer === 'undefined' || !ArrayBuffer.isView) ?\n    {isView: function() { return false; }} :\n    ArrayBuffer;\n\nmodule.exports = function isArray(a) {\n    return Array.isArray(a) || ab.isView(a);\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/lib/is_plain_object.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\n// more info: http://stackoverflow.com/questions/18531624/isplainobject-thing\nmodule.exports = function isPlainObject(obj) {\n\n    // We need to be a little less strict in the `imagetest` container because\n    // of how async image requests are handled.\n    //\n    // N.B. isPlainObject(new Constructor()) will return true in `imagetest`\n    if(window && window.process && window.process.versions) {\n        return Object.prototype.toString.call(obj) === '[object Object]';\n    }\n\n    return (\n        Object.prototype.toString.call(obj) === '[object Object]' &&\n        Object.getPrototypeOf(obj) === Object.prototype\n    );\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plot_api/container_array_match.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Registry = require('../registry');\n\n/*\n * containerArrayMatch: does this attribute string point into a\n * layout container array?\n *\n * @param {String} astr: an attribute string, like *annotations[2].text*\n *\n * @returns {Object | false} Returns false if `astr` doesn't match a container\n *  array. If it does, returns:\n *     {array: {String}, index: {Number}, property: {String}}\n *  ie the attribute string for the array, the index within the array (or ''\n *  if the whole array) and the property within that (or '' if the whole array\n *  or the whole object)\n */\nmodule.exports = function containerArrayMatch(astr) {\n    var rootContainers = Registry.layoutArrayContainers,\n        regexpContainers = Registry.layoutArrayRegexes,\n        rootPart = astr.split('[')[0],\n        arrayStr,\n        match;\n\n    // look for regexp matches first, because they may be nested inside root matches\n    // eg updatemenus[i].buttons is nested inside updatemenus\n    for(var i = 0; i < regexpContainers.length; i++) {\n        match = astr.match(regexpContainers[i]);\n        if(match && match.index === 0) {\n            arrayStr = match[0];\n            break;\n        }\n    }\n\n    // now look for root matches\n    if(!arrayStr) arrayStr = rootContainers[rootContainers.indexOf(rootPart)];\n\n    if(!arrayStr) return false;\n\n    var tail = astr.substr(arrayStr.length);\n    if(!tail) return {array: arrayStr, index: '', property: ''};\n\n    match = tail.match(/^\\[(0|[1-9][0-9]*)\\](\\.(.+))?$/);\n    if(!match) return false;\n\n    return {array: arrayStr, index: Number(match[1]), property: match[3] || ''};\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/lib/mod.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n/**\n * sanitized modulus function that always returns in the range [0, d)\n * rather than (-d, 0] if v is negative\n */\nmodule.exports = function mod(v, d) {\n    var out = v % d;\n    return out < 0 ? out + d : out;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/lib/to_log_range.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\n/**\n * convert a linear value into a logged value, folding negative numbers into\n * the given range\n */\nmodule.exports = function toLogRange(val, range) {\n    if(val > 0) return Math.log(val) / Math.LN10;\n\n    // move a negative value reference to a log axis - just put the\n    // result at the lowest range value on the plot (or if the range also went negative,\n    // one millionth of the top of the range)\n    var newVal = Math.log(Math.min(range[0], range[1])) / Math.LN10;\n    if(!isNumeric(newVal)) newVal = Math.log(Math.max(range[0], range[1])) / Math.LN10 - 6;\n    return newVal;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/lib/relink_private.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar isArray = require('./is_array');\nvar isPlainObject = require('./is_plain_object');\n\n/**\n * Relink private _keys and keys with a function value from one container\n * to the new container.\n * Relink means copying if object is pass-by-value and adding a reference\n * if object is pass-by-ref.\n * This prevents deepCopying massive structures like a webgl context.\n */\nmodule.exports = function relinkPrivateKeys(toContainer, fromContainer) {\n    var keys = Object.keys(fromContainer || {});\n\n    for(var i = 0; i < keys.length; i++) {\n        var k = keys[i],\n            fromVal = fromContainer[k],\n            toVal = toContainer[k];\n\n        if(k.charAt(0) === '_' || typeof fromVal === 'function') {\n\n            // if it already exists at this point, it's something\n            // that we recreate each time around, so ignore it\n            if(k in toContainer) continue;\n\n            toContainer[k] = fromVal;\n        }\n        else if(isArray(fromVal) && isArray(toVal) && isPlainObject(fromVal[0])) {\n\n            // recurse into arrays containers\n            for(var j = 0; j < fromVal.length; j++) {\n                if(isPlainObject(fromVal[j]) && isPlainObject(toVal[j])) {\n                    relinkPrivateKeys(toVal[j], fromVal[j]);\n                }\n            }\n        }\n        else if(isPlainObject(fromVal) && isPlainObject(toVal)) {\n\n            // recurse into objects, but only if they still exist\n            relinkPrivateKeys(toVal, fromVal);\n\n            if(!Object.keys(toVal).length) delete toContainer[k];\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/lib/ensure_array.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n/*\n * Ensures an array has the right amount of storage space. If it doesn't\n * exist, it creates an array. If it does exist, it returns it if too\n * short or truncates it in-place.\n *\n * The goal is to just reuse memory to avoid a bit of excessive garbage\n * collection.\n */\nmodule.exports = function ensureArray(out, n) {\n    if(!Array.isArray(out)) out = [];\n\n    // If too long, truncate. (If too short, it will grow\n    // automatically so we don't care about that case)\n    out.length = n;\n\n    return out;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/lib/coerce.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar tinycolor = require('tinycolor2');\n\nvar getColorscale = require('../components/colorscale/get_scale');\nvar colorscaleNames = Object.keys(require('../components/colorscale/scales'));\nvar nestedProperty = require('./nested_property');\n\nvar ID_REGEX = /^([2-9]|[1-9][0-9]+)$/;\n\nexports.valObjects = {\n    data_array: {\n        // You can use *dflt=[] to force said array to exist though.\n        description: [\n            'An {array} of data.',\n            'The value MUST be an {array}, or we ignore it.'\n        ].join(' '),\n        requiredOpts: [],\n        otherOpts: ['dflt'],\n        coerceFunction: function(v, propOut, dflt) {\n            if(Array.isArray(v)) propOut.set(v);\n            else if(dflt !== undefined) propOut.set(dflt);\n        }\n    },\n    enumerated: {\n        description: [\n            'Enumerated value type. The available values are listed',\n            'in `values`.'\n        ].join(' '),\n        requiredOpts: ['values'],\n        otherOpts: ['dflt', 'coerceNumber', 'arrayOk'],\n        coerceFunction: function(v, propOut, dflt, opts) {\n            if(opts.coerceNumber) v = +v;\n            if(opts.values.indexOf(v) === -1) propOut.set(dflt);\n            else propOut.set(v);\n        }\n    },\n    'boolean': {\n        description: 'A boolean (true/false) value.',\n        requiredOpts: [],\n        otherOpts: ['dflt'],\n        coerceFunction: function(v, propOut, dflt) {\n            if(v === true || v === false) propOut.set(v);\n            else propOut.set(dflt);\n        }\n    },\n    number: {\n        description: [\n            'A number or a numeric value',\n            '(e.g. a number inside a string).',\n            'When applicable, values greater (less) than `max` (`min`)',\n            'are coerced to the `dflt`.'\n        ].join(' '),\n        requiredOpts: [],\n        otherOpts: ['dflt', 'min', 'max', 'arrayOk'],\n        coerceFunction: function(v, propOut, dflt, opts) {\n            if(!isNumeric(v) ||\n                    (opts.min !== undefined && v < opts.min) ||\n                    (opts.max !== undefined && v > opts.max)) {\n                propOut.set(dflt);\n            }\n            else propOut.set(+v);\n        }\n    },\n    integer: {\n        description: [\n            'An integer or an integer inside a string.',\n            'When applicable, values greater (less) than `max` (`min`)',\n            'are coerced to the `dflt`.'\n        ].join(' '),\n        requiredOpts: [],\n        otherOpts: ['dflt', 'min', 'max'],\n        coerceFunction: function(v, propOut, dflt, opts) {\n            if(v % 1 || !isNumeric(v) ||\n                    (opts.min !== undefined && v < opts.min) ||\n                    (opts.max !== undefined && v > opts.max)) {\n                propOut.set(dflt);\n            }\n            else propOut.set(+v);\n        }\n    },\n    string: {\n        description: [\n            'A string value.',\n            'Numbers are converted to strings except for attributes with',\n            '`strict` set to true.'\n        ].join(' '),\n        requiredOpts: [],\n        // TODO 'values shouldn't be in there (edge case: 'dash' in Scatter)\n        otherOpts: ['dflt', 'noBlank', 'strict', 'arrayOk', 'values'],\n        coerceFunction: function(v, propOut, dflt, opts) {\n            if(typeof v !== 'string') {\n                var okToCoerce = (typeof v === 'number');\n\n                if(opts.strict === true || !okToCoerce) propOut.set(dflt);\n                else propOut.set(String(v));\n            }\n            else if(opts.noBlank && !v) propOut.set(dflt);\n            else propOut.set(v);\n        }\n    },\n    color: {\n        description: [\n            'A string describing color.',\n            'Supported formats:',\n            '- hex (e.g. \\'#d3d3d3\\')',\n            '- rgb (e.g. \\'rgb(255, 0, 0)\\')',\n            '- rgba (e.g. \\'rgb(255, 0, 0, 0.5)\\')',\n            '- hsl (e.g. \\'hsl(0, 100%, 50%)\\')',\n            '- hsv (e.g. \\'hsv(0, 100%, 100%)\\')',\n            '- named colors (full list: http://www.w3.org/TR/css3-color/#svg-color)'\n        ].join(' '),\n        requiredOpts: [],\n        otherOpts: ['dflt', 'arrayOk'],\n        coerceFunction: function(v, propOut, dflt) {\n            if(tinycolor(v).isValid()) propOut.set(v);\n            else propOut.set(dflt);\n        }\n    },\n    colorscale: {\n        description: [\n            'A Plotly colorscale either picked by a name:',\n            '(any of', colorscaleNames.join(', '), ')',\n            'customized as an {array} of 2-element {arrays} where',\n            'the first element is the normalized color level value',\n            '(starting at *0* and ending at *1*),',\n            'and the second item is a valid color string.'\n        ].join(' '),\n        requiredOpts: [],\n        otherOpts: ['dflt'],\n        coerceFunction: function(v, propOut, dflt) {\n            propOut.set(getColorscale(v, dflt));\n        }\n    },\n    angle: {\n        description: [\n            'A number (in degree) between -180 and 180.'\n        ].join(' '),\n        requiredOpts: [],\n        otherOpts: ['dflt'],\n        coerceFunction: function(v, propOut, dflt) {\n            if(v === 'auto') propOut.set('auto');\n            else if(!isNumeric(v)) propOut.set(dflt);\n            else {\n                if(Math.abs(v) > 180) v -= Math.round(v / 360) * 360;\n                propOut.set(+v);\n            }\n        }\n    },\n    subplotid: {\n        description: [\n            'An id string of a subplot type (given by dflt), optionally',\n            'followed by an integer >1. e.g. if dflt=\\'geo\\', we can have',\n            '\\'geo\\', \\'geo2\\', \\'geo3\\', ...'\n        ].join(' '),\n        requiredOpts: ['dflt'],\n        otherOpts: [],\n        coerceFunction: function(v, propOut, dflt) {\n            var dlen = dflt.length;\n            if(typeof v === 'string' && v.substr(0, dlen) === dflt &&\n                    ID_REGEX.test(v.substr(dlen))) {\n                propOut.set(v);\n                return;\n            }\n            propOut.set(dflt);\n        },\n        validateFunction: function(v, opts) {\n            var dflt = opts.dflt,\n                dlen = dflt.length;\n\n            if(v === dflt) return true;\n            if(typeof v !== 'string') return false;\n            if(v.substr(0, dlen) === dflt && ID_REGEX.test(v.substr(dlen))) {\n                return true;\n            }\n\n            return false;\n        }\n    },\n    flaglist: {\n        description: [\n            'A string representing a combination of flags',\n            '(order does not matter here).',\n            'Combine any of the available `flags` with *+*.',\n            '(e.g. (\\'lines+markers\\')).',\n            'Values in `extras` cannot be combined.'\n        ].join(' '),\n        requiredOpts: ['flags'],\n        otherOpts: ['dflt', 'extras'],\n        coerceFunction: function(v, propOut, dflt, opts) {\n            if(typeof v !== 'string') {\n                propOut.set(dflt);\n                return;\n            }\n            if((opts.extras || []).indexOf(v) !== -1) {\n                propOut.set(v);\n                return;\n            }\n            var vParts = v.split('+'),\n                i = 0;\n            while(i < vParts.length) {\n                var vi = vParts[i];\n                if(opts.flags.indexOf(vi) === -1 || vParts.indexOf(vi) < i) {\n                    vParts.splice(i, 1);\n                }\n                else i++;\n            }\n            if(!vParts.length) propOut.set(dflt);\n            else propOut.set(vParts.join('+'));\n        }\n    },\n    any: {\n        description: 'Any type.',\n        requiredOpts: [],\n        otherOpts: ['dflt', 'values', 'arrayOk'],\n        coerceFunction: function(v, propOut, dflt) {\n            if(v === undefined) propOut.set(dflt);\n            else propOut.set(v);\n        }\n    },\n    info_array: {\n        description: [\n            'An {array} of plot information.'\n        ].join(' '),\n        requiredOpts: ['items'],\n        otherOpts: ['dflt', 'freeLength'],\n        coerceFunction: function(v, propOut, dflt, opts) {\n            if(!Array.isArray(v)) {\n                propOut.set(dflt);\n                return;\n            }\n\n            var items = opts.items,\n                vOut = [];\n            dflt = Array.isArray(dflt) ? dflt : [];\n\n            for(var i = 0; i < items.length; i++) {\n                exports.coerce(v, vOut, items, '[' + i + ']', dflt[i]);\n            }\n\n            propOut.set(vOut);\n        },\n        validateFunction: function(v, opts) {\n            if(!Array.isArray(v)) return false;\n\n            var items = opts.items;\n\n            // when free length is off, input and declared lengths must match\n            if(!opts.freeLength && v.length !== items.length) return false;\n\n            // valid when all input items are valid\n            for(var i = 0; i < v.length; i++) {\n                var isItemValid = exports.validate(v[i], opts.items[i]);\n\n                if(!isItemValid) return false;\n            }\n\n            return true;\n        }\n    }\n};\n\n/**\n * Ensures that container[attribute] has a valid value.\n *\n * attributes[attribute] is an object with possible keys:\n * - valType: data_array, enumerated, boolean, ... as in valObjects\n * - values: (enumerated only) array of allowed vals\n * - min, max: (number, integer only) inclusive bounds on allowed vals\n *      either or both may be omitted\n * - dflt: if attribute is invalid or missing, use this default\n *      if dflt is provided as an argument to lib.coerce it takes precedence\n *      as a convenience, returns the value it finally set\n */\nexports.coerce = function(containerIn, containerOut, attributes, attribute, dflt) {\n    var opts = nestedProperty(attributes, attribute).get(),\n        propIn = nestedProperty(containerIn, attribute),\n        propOut = nestedProperty(containerOut, attribute),\n        v = propIn.get();\n\n    if(dflt === undefined) dflt = opts.dflt;\n\n    /**\n     * arrayOk: value MAY be an array, then we do no value checking\n     * at this point, because it can be more complicated than the\n     * individual form (eg. some array vals can be numbers, even if the\n     * single values must be color strings)\n     */\n    if(opts.arrayOk && Array.isArray(v)) {\n        propOut.set(v);\n        return v;\n    }\n\n    exports.valObjects[opts.valType].coerceFunction(v, propOut, dflt, opts);\n\n    return propOut.get();\n};\n\n/**\n * Variation on coerce\n *\n * Uses coerce to get attribute value if user input is valid,\n * returns attribute default if user input it not valid or\n * returns false if there is no user input.\n */\nexports.coerce2 = function(containerIn, containerOut, attributes, attribute, dflt) {\n    var propIn = nestedProperty(containerIn, attribute),\n        propOut = exports.coerce(containerIn, containerOut, attributes, attribute, dflt),\n        valIn = propIn.get();\n\n    return (valIn !== undefined && valIn !== null) ? propOut : false;\n};\n\n/*\n * Shortcut to coerce the three font attributes\n *\n * 'coerce' is a lib.coerce wrapper with implied first three arguments\n */\nexports.coerceFont = function(coerce, attr, dfltObj) {\n    var out = {};\n\n    dfltObj = dfltObj || {};\n\n    out.family = coerce(attr + '.family', dfltObj.family);\n    out.size = coerce(attr + '.size', dfltObj.size);\n    out.color = coerce(attr + '.color', dfltObj.color);\n\n    return out;\n};\n\nexports.validate = function(value, opts) {\n    var valObject = exports.valObjects[opts.valType];\n\n    if(opts.arrayOk && Array.isArray(value)) return true;\n\n    if(valObject.validateFunction) {\n        return valObject.validateFunction(value, opts);\n    }\n\n    var failed = {},\n        out = failed,\n        propMock = { set: function(v) { out = v; } };\n\n    // 'failed' just something mutable that won't be === anything else\n\n    valObject.coerceFunction(value, propMock, failed, opts);\n    return out !== failed;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/colorscale/get_scale.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar scales = require('./scales');\nvar defaultScale = require('./default_scale');\nvar isValidScaleArray = require('./is_valid_scale_array');\n\n\nmodule.exports = function getScale(scl, dflt) {\n    if(!dflt) dflt = defaultScale;\n    if(!scl) return dflt;\n\n    function parseScale() {\n        try {\n            scl = scales[scl] || JSON.parse(scl);\n        }\n        catch(e) {\n            scl = dflt;\n        }\n    }\n\n    if(typeof scl === 'string') {\n        parseScale();\n        // occasionally scl is double-JSON encoded...\n        if(typeof scl === 'string') parseScale();\n    }\n\n    if(!isValidScaleArray(scl)) return dflt;\n    return scl;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/colorscale/scales.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n\nmodule.exports = {\n    'Greys': [\n        [0, 'rgb(0,0,0)'], [1, 'rgb(255,255,255)']\n    ],\n\n    'YlGnBu': [\n        [0, 'rgb(8,29,88)'], [0.125, 'rgb(37,52,148)'],\n        [0.25, 'rgb(34,94,168)'], [0.375, 'rgb(29,145,192)'],\n        [0.5, 'rgb(65,182,196)'], [0.625, 'rgb(127,205,187)'],\n        [0.75, 'rgb(199,233,180)'], [0.875, 'rgb(237,248,217)'],\n        [1, 'rgb(255,255,217)']\n    ],\n\n    'Greens': [\n        [0, 'rgb(0,68,27)'], [0.125, 'rgb(0,109,44)'],\n        [0.25, 'rgb(35,139,69)'], [0.375, 'rgb(65,171,93)'],\n        [0.5, 'rgb(116,196,118)'], [0.625, 'rgb(161,217,155)'],\n        [0.75, 'rgb(199,233,192)'], [0.875, 'rgb(229,245,224)'],\n        [1, 'rgb(247,252,245)']\n    ],\n\n    'YlOrRd': [\n        [0, 'rgb(128,0,38)'], [0.125, 'rgb(189,0,38)'],\n        [0.25, 'rgb(227,26,28)'], [0.375, 'rgb(252,78,42)'],\n        [0.5, 'rgb(253,141,60)'], [0.625, 'rgb(254,178,76)'],\n        [0.75, 'rgb(254,217,118)'], [0.875, 'rgb(255,237,160)'],\n        [1, 'rgb(255,255,204)']\n    ],\n\n    'Bluered': [\n        [0, 'rgb(0,0,255)'], [1, 'rgb(255,0,0)']\n    ],\n\n    // modified RdBu based on\n    // www.sandia.gov/~kmorel/documents/ColorMaps/ColorMapsExpanded.pdf\n    'RdBu': [\n        [0, 'rgb(5,10,172)'], [0.35, 'rgb(106,137,247)'],\n        [0.5, 'rgb(190,190,190)'], [0.6, 'rgb(220,170,132)'],\n        [0.7, 'rgb(230,145,90)'], [1, 'rgb(178,10,28)']\n    ],\n\n    // Scale for non-negative numeric values\n    'Reds': [\n        [0, 'rgb(220,220,220)'], [0.2, 'rgb(245,195,157)'],\n        [0.4, 'rgb(245,160,105)'], [1, 'rgb(178,10,28)']\n    ],\n\n    // Scale for non-positive numeric values\n    'Blues': [\n        [0, 'rgb(5,10,172)'], [0.35, 'rgb(40,60,190)'],\n        [0.5, 'rgb(70,100,245)'], [0.6, 'rgb(90,120,245)'],\n        [0.7, 'rgb(106,137,247)'], [1, 'rgb(220,220,220)']\n    ],\n\n    'Picnic': [\n        [0, 'rgb(0,0,255)'], [0.1, 'rgb(51,153,255)'],\n        [0.2, 'rgb(102,204,255)'], [0.3, 'rgb(153,204,255)'],\n        [0.4, 'rgb(204,204,255)'], [0.5, 'rgb(255,255,255)'],\n        [0.6, 'rgb(255,204,255)'], [0.7, 'rgb(255,153,255)'],\n        [0.8, 'rgb(255,102,204)'], [0.9, 'rgb(255,102,102)'],\n        [1, 'rgb(255,0,0)']\n    ],\n\n    'Rainbow': [\n        [0, 'rgb(150,0,90)'], [0.125, 'rgb(0,0,200)'],\n        [0.25, 'rgb(0,25,255)'], [0.375, 'rgb(0,152,255)'],\n        [0.5, 'rgb(44,255,150)'], [0.625, 'rgb(151,255,0)'],\n        [0.75, 'rgb(255,234,0)'], [0.875, 'rgb(255,111,0)'],\n        [1, 'rgb(255,0,0)']\n    ],\n\n    'Portland': [\n        [0, 'rgb(12,51,131)'], [0.25, 'rgb(10,136,186)'],\n        [0.5, 'rgb(242,211,56)'], [0.75, 'rgb(242,143,56)'],\n        [1, 'rgb(217,30,30)']\n    ],\n\n    'Jet': [\n        [0, 'rgb(0,0,131)'], [0.125, 'rgb(0,60,170)'],\n        [0.375, 'rgb(5,255,255)'], [0.625, 'rgb(255,255,0)'],\n        [0.875, 'rgb(250,0,0)'], [1, 'rgb(128,0,0)']\n    ],\n\n    'Hot': [\n        [0, 'rgb(0,0,0)'], [0.3, 'rgb(230,0,0)'],\n        [0.6, 'rgb(255,210,0)'], [1, 'rgb(255,255,255)']\n    ],\n\n    'Blackbody': [\n        [0, 'rgb(0,0,0)'], [0.2, 'rgb(230,0,0)'],\n        [0.4, 'rgb(230,210,0)'], [0.7, 'rgb(255,255,255)'],\n        [1, 'rgb(160,200,255)']\n    ],\n\n    'Earth': [\n        [0, 'rgb(0,0,130)'], [0.1, 'rgb(0,180,180)'],\n        [0.2, 'rgb(40,210,40)'], [0.4, 'rgb(230,230,50)'],\n        [0.6, 'rgb(120,70,20)'], [1, 'rgb(255,255,255)']\n    ],\n\n    'Electric': [\n        [0, 'rgb(0,0,0)'], [0.15, 'rgb(30,0,100)'],\n        [0.4, 'rgb(120,0,100)'], [0.6, 'rgb(160,90,0)'],\n        [0.8, 'rgb(230,200,0)'], [1, 'rgb(255,250,220)']\n    ],\n\n    'Viridis': [\n        [0, '#440154'], [0.06274509803921569, '#48186a'],\n        [0.12549019607843137, '#472d7b'], [0.18823529411764706, '#424086'],\n        [0.25098039215686274, '#3b528b'], [0.3137254901960784, '#33638d'],\n        [0.3764705882352941, '#2c728e'], [0.4392156862745098, '#26828e'],\n        [0.5019607843137255, '#21918c'], [0.5647058823529412, '#1fa088'],\n        [0.6274509803921569, '#28ae80'], [0.6901960784313725, '#3fbc73'],\n        [0.7529411764705882, '#5ec962'], [0.8156862745098039, '#84d44b'],\n        [0.8784313725490196, '#addc30'], [0.9411764705882353, '#d8e219'],\n        [1, '#fde725']\n    ]\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/colorscale/default_scale.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar scales = require('./scales');\n\n\nmodule.exports = scales.RdBu;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/colorscale/is_valid_scale_array.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar tinycolor = require('tinycolor2');\n\n\nmodule.exports = function isValidScaleArray(scl) {\n    var highestVal = 0;\n\n    if(!Array.isArray(scl) || scl.length < 2) return false;\n\n    if(!scl[0] || !scl[scl.length - 1]) return false;\n\n    if(+scl[0][0] !== 0 || +scl[scl.length - 1][0] !== 1) return false;\n\n    for(var i = 0; i < scl.length; i++) {\n        var si = scl[i];\n\n        if(si.length !== 2 || +si[0] < highestVal || !tinycolor(si[1]).isValid()) {\n            return false;\n        }\n\n        highestVal = +si[0];\n    }\n\n    return true;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/lib/dates.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\nvar isNumeric = require('fast-isnumeric');\n\nvar logError = require('./loggers').error;\nvar mod = require('./mod');\n\nvar constants = require('../constants/numerical');\nvar BADNUM = constants.BADNUM;\nvar ONEDAY = constants.ONEDAY;\nvar ONEHOUR = constants.ONEHOUR;\nvar ONEMIN = constants.ONEMIN;\nvar ONESEC = constants.ONESEC;\nvar EPOCHJD = constants.EPOCHJD;\n\nvar Registry = require('../registry');\n\nvar utcFormat = d3.time.format.utc;\n\nvar DATETIME_REGEXP = /^\\s*(-?\\d\\d\\d\\d|\\d\\d)(-(\\d?\\d)(-(\\d?\\d)([ Tt]([01]?\\d|2[0-3])(:([0-5]\\d)(:([0-5]\\d(\\.\\d+)?))?(Z|z|[+\\-]\\d\\d:?\\d\\d)?)?)?)?)?\\s*$/m;\n// special regex for chinese calendars to support yyyy-mmi-dd etc for intercalary months\nvar DATETIME_REGEXP_CN = /^\\s*(-?\\d\\d\\d\\d|\\d\\d)(-(\\d?\\di?)(-(\\d?\\d)([ Tt]([01]?\\d|2[0-3])(:([0-5]\\d)(:([0-5]\\d(\\.\\d+)?))?(Z|z|[+\\-]\\d\\d:?\\d\\d)?)?)?)?)?\\s*$/m;\n\n// for 2-digit years, the first year we map them onto\nvar YFIRST = new Date().getFullYear() - 70;\n\nfunction isWorldCalendar(calendar) {\n    return (\n        calendar &&\n        Registry.componentsRegistry.calendars &&\n        typeof calendar === 'string' && calendar !== 'gregorian'\n    );\n}\n\n/*\n * dateTick0: get the canonical tick for this calendar\n *\n * bool sunday is for week ticks, shift it to a Sunday.\n */\nexports.dateTick0 = function(calendar, sunday) {\n    if(isWorldCalendar(calendar)) {\n        return sunday ?\n            Registry.getComponentMethod('calendars', 'CANONICAL_SUNDAY')[calendar] :\n            Registry.getComponentMethod('calendars', 'CANONICAL_TICK')[calendar];\n    }\n    else {\n        return sunday ? '2000-01-02' : '2000-01-01';\n    }\n};\n\n/*\n * dfltRange: for each calendar, give a valid default range\n */\nexports.dfltRange = function(calendar) {\n    if(isWorldCalendar(calendar)) {\n        return Registry.getComponentMethod('calendars', 'DFLTRANGE')[calendar];\n    }\n    else {\n        return ['2000-01-01', '2001-01-01'];\n    }\n};\n\n// is an object a javascript date?\nexports.isJSDate = function(v) {\n    return typeof v === 'object' && v !== null && typeof v.getTime === 'function';\n};\n\n// The absolute limits of our date-time system\n// This is a little weird: we use MIN_MS and MAX_MS in dateTime2ms\n// but we use dateTime2ms to calculate them (after defining it!)\nvar MIN_MS, MAX_MS;\n\n/**\n * dateTime2ms - turn a date object or string s into milliseconds\n * (relative to 1970-01-01, per javascript standard)\n * optional calendar (string) to use a non-gregorian calendar\n *\n * Returns BADNUM if it doesn't find a date\n *\n * strings should have the form:\n *\n *    -?YYYY-mm-dd<sep>HH:MM:SS.sss<tzInfo>?\n *\n * <sep>: space (our normal standard) or T or t (ISO-8601)\n * <tzInfo>: Z, z, or [+\\-]HH:?MM and we THROW IT AWAY\n * this format comes from https://tools.ietf.org/html/rfc3339#section-5.6\n * but we allow it even with a space as the separator\n *\n * May truncate after any full field, and sss can be any length\n * even >3 digits, though javascript dates truncate to milliseconds,\n * we keep as much as javascript numeric precision can hold, but we only\n * report back up to 100 microsecond precision, because most dates support\n * this precision (close to 1970 support more, very far away support less)\n *\n * Expanded to support negative years to -9999 but you must always\n * give 4 digits, except for 2-digit positive years which we assume are\n * near the present time.\n * Note that we follow ISO 8601:2004: there *is* a year 0, which\n * is 1BC/BCE, and -1===2BC etc.\n *\n * World calendars: not all of these *have* agreed extensions to this full range,\n * if you have another calendar system but want a date range outside its validity,\n * you can use a gregorian date string prefixed with 'G' or 'g'.\n *\n * Where to cut off 2-digit years between 1900s and 2000s?\n * from http://support.microsoft.com/kb/244664:\n *   1930-2029 (the most retro of all...)\n * but in my mac chrome from eg. d=new Date(Date.parse('8/19/50')):\n *   1950-2049\n * by Java, from http://stackoverflow.com/questions/2024273/:\n *   now-80 - now+19\n * or FileMaker Pro, from\n *      http://www.filemaker.com/12help/html/add_view_data.4.21.html:\n *   now-70 - now+29\n * but python strptime etc, via\n *      http://docs.python.org/py3k/library/time.html:\n *   1969-2068 (super forward-looking, but static, not sliding!)\n *\n * lets go with now-70 to now+29, and if anyone runs into this problem\n * they can learn the hard way not to use 2-digit years, as no choice we\n * make now will cover all possibilities. mostly this will all be taken\n * care of in initial parsing, should only be an issue for hand-entered data\n * currently (2016) this range is:\n *   1946-2045\n */\nexports.dateTime2ms = function(s, calendar) {\n    // first check if s is a date object\n    if(exports.isJSDate(s)) {\n        // Convert to the UTC milliseconds that give the same\n        // hours as this date has in the local timezone\n        s = Number(s) - s.getTimezoneOffset() * ONEMIN;\n        if(s >= MIN_MS && s <= MAX_MS) return s;\n        return BADNUM;\n    }\n    // otherwise only accept strings and numbers\n    if(typeof s !== 'string' && typeof s !== 'number') return BADNUM;\n\n    s = String(s);\n\n    var isWorld = isWorldCalendar(calendar);\n\n    // to handle out-of-range dates in international calendars, accept\n    // 'G' as a prefix to force the built-in gregorian calendar.\n    var s0 = s.charAt(0);\n    if(isWorld && (s0 === 'G' || s0 === 'g')) {\n        s = s.substr(1);\n        calendar = '';\n    }\n\n    var isChinese = isWorld && calendar.substr(0, 7) === 'chinese';\n\n    var match = s.match(isChinese ? DATETIME_REGEXP_CN : DATETIME_REGEXP);\n    if(!match) return BADNUM;\n    var y = match[1],\n        m = match[3] || '1',\n        d = Number(match[5] || 1),\n        H = Number(match[7] || 0),\n        M = Number(match[9] || 0),\n        S = Number(match[11] || 0);\n\n    if(isWorld) {\n        // disallow 2-digit years for world calendars\n        if(y.length === 2) return BADNUM;\n        y = Number(y);\n\n        var cDate;\n        try {\n            var calInstance = Registry.getComponentMethod('calendars', 'getCal')(calendar);\n            if(isChinese) {\n                var isIntercalary = m.charAt(m.length - 1) === 'i';\n                m = parseInt(m, 10);\n                cDate = calInstance.newDate(y, calInstance.toMonthIndex(y, m, isIntercalary), d);\n            }\n            else {\n                cDate = calInstance.newDate(y, Number(m), d);\n            }\n        }\n        catch(e) { return BADNUM; } // Invalid ... date\n\n        if(!cDate) return BADNUM;\n\n        return ((cDate.toJD() - EPOCHJD) * ONEDAY) +\n            (H * ONEHOUR) + (M * ONEMIN) + (S * ONESEC);\n    }\n\n    if(y.length === 2) {\n        y = (Number(y) + 2000 - YFIRST) % 100 + YFIRST;\n    }\n    else y = Number(y);\n\n    // new Date uses months from 0; subtract 1 here just so we\n    // don't have to do it again during the validity test below\n    m -= 1;\n\n    // javascript takes new Date(0..99,m,d) to mean 1900-1999, so\n    // to support years 0-99 we need to use setFullYear explicitly\n    // Note that 2000 is a leap year.\n    var date = new Date(Date.UTC(2000, m, d, H, M));\n    date.setUTCFullYear(y);\n\n    if(date.getUTCMonth() !== m) return BADNUM;\n    if(date.getUTCDate() !== d) return BADNUM;\n\n    return date.getTime() + S * ONESEC;\n};\n\nMIN_MS = exports.MIN_MS = exports.dateTime2ms('-9999');\nMAX_MS = exports.MAX_MS = exports.dateTime2ms('9999-12-31 23:59:59.9999');\n\n// is string s a date? (see above)\nexports.isDateTime = function(s, calendar) {\n    return (exports.dateTime2ms(s, calendar) !== BADNUM);\n};\n\n// pad a number with zeroes, to given # of digits before the decimal point\nfunction lpad(val, digits) {\n    return String(val + Math.pow(10, digits)).substr(1);\n}\n\n/**\n * Turn ms into string of the form YYYY-mm-dd HH:MM:SS.ssss\n * Crop any trailing zeros in time, except never stop right after hours\n * (we could choose to crop '-01' from date too but for now we always\n * show the whole date)\n * Optional range r is the data range that applies, also in ms.\n * If rng is big, the later parts of time will be omitted\n */\nvar NINETYDAYS = 90 * ONEDAY;\nvar THREEHOURS = 3 * ONEHOUR;\nvar FIVEMIN = 5 * ONEMIN;\nexports.ms2DateTime = function(ms, r, calendar) {\n    if(typeof ms !== 'number' || !(ms >= MIN_MS && ms <= MAX_MS)) return BADNUM;\n\n    if(!r) r = 0;\n\n    var msecTenths = Math.floor(mod(ms + 0.05, 1) * 10),\n        msRounded = Math.round(ms - msecTenths / 10),\n        dateStr, h, m, s, msec10, d;\n\n    if(isWorldCalendar(calendar)) {\n        var dateJD = Math.floor(msRounded / ONEDAY) + EPOCHJD,\n            timeMs = Math.floor(mod(ms, ONEDAY));\n        try {\n            dateStr = Registry.getComponentMethod('calendars', 'getCal')(calendar)\n                .fromJD(dateJD).formatDate('yyyy-mm-dd');\n        }\n        catch(e) {\n            // invalid date in this calendar - fall back to Gyyyy-mm-dd\n            dateStr = utcFormat('G%Y-%m-%d')(new Date(msRounded));\n        }\n\n        // yyyy does NOT guarantee 4-digit years. YYYY mostly does, but does\n        // other things for a few calendars, so we can't trust it. Just pad\n        // it manually (after the '-' if there is one)\n        if(dateStr.charAt(0) === '-') {\n            while(dateStr.length < 11) dateStr = '-0' + dateStr.substr(1);\n        }\n        else {\n            while(dateStr.length < 10) dateStr = '0' + dateStr;\n        }\n\n        // TODO: if this is faster, we could use this block for extracting\n        // the time components of regular gregorian too\n        h = (r < NINETYDAYS) ? Math.floor(timeMs / ONEHOUR) : 0;\n        m = (r < NINETYDAYS) ? Math.floor((timeMs % ONEHOUR) / ONEMIN) : 0;\n        s = (r < THREEHOURS) ? Math.floor((timeMs % ONEMIN) / ONESEC) : 0;\n        msec10 = (r < FIVEMIN) ? (timeMs % ONESEC) * 10 + msecTenths : 0;\n    }\n    else {\n        d = new Date(msRounded);\n\n        dateStr = utcFormat('%Y-%m-%d')(d);\n\n        // <90 days: add hours and minutes - never *only* add hours\n        h = (r < NINETYDAYS) ? d.getUTCHours() : 0;\n        m = (r < NINETYDAYS) ? d.getUTCMinutes() : 0;\n        // <3 hours: add seconds\n        s = (r < THREEHOURS) ? d.getUTCSeconds() : 0;\n        // <5 minutes: add ms (plus one extra digit, this is msec*10)\n        msec10 = (r < FIVEMIN) ? d.getUTCMilliseconds() * 10 + msecTenths : 0;\n    }\n\n    return includeTime(dateStr, h, m, s, msec10);\n};\n\n// For converting old-style milliseconds to date strings,\n// we use the local timezone rather than UTC like we use\n// everywhere else, both for backward compatibility and\n// because that's how people mostly use javasript date objects.\n// Clip one extra day off our date range though so we can't get\n// thrown beyond the range by the timezone shift.\nexports.ms2DateTimeLocal = function(ms) {\n    if(!(ms >= MIN_MS + ONEDAY && ms <= MAX_MS - ONEDAY)) return BADNUM;\n\n    var msecTenths = Math.floor(mod(ms + 0.05, 1) * 10),\n        d = new Date(Math.round(ms - msecTenths / 10)),\n        dateStr = d3.time.format('%Y-%m-%d')(d),\n        h = d.getHours(),\n        m = d.getMinutes(),\n        s = d.getSeconds(),\n        msec10 = d.getUTCMilliseconds() * 10 + msecTenths;\n\n    return includeTime(dateStr, h, m, s, msec10);\n};\n\nfunction includeTime(dateStr, h, m, s, msec10) {\n    // include each part that has nonzero data in or after it\n    if(h || m || s || msec10) {\n        dateStr += ' ' + lpad(h, 2) + ':' + lpad(m, 2);\n        if(s || msec10) {\n            dateStr += ':' + lpad(s, 2);\n            if(msec10) {\n                var digits = 4;\n                while(msec10 % 10 === 0) {\n                    digits -= 1;\n                    msec10 /= 10;\n                }\n                dateStr += '.' + lpad(msec10, digits);\n            }\n        }\n    }\n    return dateStr;\n}\n\n// normalize date format to date string, in case it starts as\n// a Date object or milliseconds\n// optional dflt is the return value if cleaning fails\nexports.cleanDate = function(v, dflt, calendar) {\n    if(exports.isJSDate(v) || typeof v === 'number') {\n        // do not allow milliseconds (old) or jsdate objects (inherently\n        // described as gregorian dates) with world calendars\n        if(isWorldCalendar(calendar)) {\n            logError('JS Dates and milliseconds are incompatible with world calendars', v);\n            return dflt;\n        }\n\n        // NOTE: if someone puts in a year as a number rather than a string,\n        // this will mistakenly convert it thinking it's milliseconds from 1970\n        // that is: '2012' -> Jan. 1, 2012, but 2012 -> 2012 epoch milliseconds\n        v = exports.ms2DateTimeLocal(+v);\n        if(!v && dflt !== undefined) return dflt;\n    }\n    else if(!exports.isDateTime(v, calendar)) {\n        logError('unrecognized date', v);\n        return dflt;\n    }\n    return v;\n};\n\n/*\n *  Date formatting for ticks and hovertext\n */\n\n/*\n * modDateFormat: Support world calendars, and add one item to\n * d3's vocabulary:\n * %{n}f where n is the max number of digits of fractional seconds\n */\nvar fracMatch = /%\\d?f/g;\nfunction modDateFormat(fmt, x, calendar) {\n\n    fmt = fmt.replace(fracMatch, function(match) {\n        var digits = Math.min(+(match.charAt(1)) || 6, 6),\n            fracSecs = ((x / 1000 % 1) + 2)\n                .toFixed(digits)\n                .substr(2).replace(/0+$/, '') || '0';\n        return fracSecs;\n    });\n\n    var d = new Date(Math.floor(x + 0.05));\n\n    if(isWorldCalendar(calendar)) {\n        try {\n            fmt = Registry.getComponentMethod('calendars', 'worldCalFmt')(fmt, x, calendar);\n        }\n        catch(e) {\n            return 'Invalid';\n        }\n    }\n    return utcFormat(fmt)(d);\n}\n\n/*\n * formatTime: create a time string from:\n *   x: milliseconds\n *   tr: tickround ('M', 'S', or # digits)\n * only supports UTC times (where every day is 24 hours and 0 is at midnight)\n */\nvar MAXSECONDS = [59, 59.9, 59.99, 59.999, 59.9999];\nfunction formatTime(x, tr) {\n    var timePart = mod(x + 0.05, ONEDAY);\n\n    var timeStr = lpad(Math.floor(timePart / ONEHOUR), 2) + ':' +\n        lpad(mod(Math.floor(timePart / ONEMIN), 60), 2);\n\n    if(tr !== 'M') {\n        if(!isNumeric(tr)) tr = 0; // should only be 'S'\n\n        /*\n         * this is a weird one - and shouldn't come up unless people\n         * monkey with tick0 in weird ways, but we need to do something!\n         * IN PARTICULAR we had better not display garbage (see below)\n         * for numbers we always round to the nearest increment of the\n         * precision we're showing, and this seems like the right way to\n         * handle seconds and milliseconds, as they have a decimal point\n         * and people will interpret that to mean rounding like numbers.\n         * but for larger increments we floor the value: it's always\n         * 2013 until the ball drops on the new year. We could argue about\n         * which field it is where we start rounding (should 12:08:59\n         * round to 12:09 if we're stopping at minutes?) but for now I'll\n         * say we round seconds but floor everything else. BUT that means\n         * we need to never round up to 60 seconds, ie 23:59:60\n         */\n        var sec = Math.min(mod(x / ONESEC, 60), MAXSECONDS[tr]);\n\n        var secStr = (100 + sec).toFixed(tr).substr(1);\n        if(tr > 0) {\n            secStr = secStr.replace(/0+$/, '').replace(/[\\.]$/, '');\n        }\n\n        timeStr += ':' + secStr;\n    }\n    return timeStr;\n}\n\nvar yearFormat = utcFormat('%Y'),\n    monthFormat = utcFormat('%b %Y'),\n    dayFormat = utcFormat('%b %-d'),\n    yearMonthDayFormat = utcFormat('%b %-d, %Y');\n\nfunction yearFormatWorld(cDate) { return cDate.formatDate('yyyy'); }\nfunction monthFormatWorld(cDate) { return cDate.formatDate('M yyyy'); }\nfunction dayFormatWorld(cDate) { return cDate.formatDate('M d'); }\nfunction yearMonthDayFormatWorld(cDate) { return cDate.formatDate('M d, yyyy'); }\n\n/*\n * formatDate: turn a date into tick or hover label text.\n *\n *   x: milliseconds, the value to convert\n *   fmt: optional, an explicit format string (d3 format, even for world calendars)\n *   tr: tickround ('y', 'm', 'd', 'M', 'S', or # digits)\n *      used if no explicit fmt is provided\n *   calendar: optional string, the world calendar system to use\n *\n * returns the date/time as a string, potentially with the leading portion\n * on a separate line (after '\\n')\n * Note that this means if you provide an explicit format which includes '\\n'\n * the axis may choose to strip things after it when they don't change from\n * one tick to the next (as it does with automatic formatting)\n */\nexports.formatDate = function(x, fmt, tr, calendar) {\n    var headStr,\n        dateStr;\n\n    calendar = isWorldCalendar(calendar) && calendar;\n\n    if(fmt) return modDateFormat(fmt, x, calendar);\n\n    if(calendar) {\n        try {\n            var dateJD = Math.floor((x + 0.05) / ONEDAY) + EPOCHJD,\n                cDate = Registry.getComponentMethod('calendars', 'getCal')(calendar)\n                    .fromJD(dateJD);\n\n            if(tr === 'y') dateStr = yearFormatWorld(cDate);\n            else if(tr === 'm') dateStr = monthFormatWorld(cDate);\n            else if(tr === 'd') {\n                headStr = yearFormatWorld(cDate);\n                dateStr = dayFormatWorld(cDate);\n            }\n            else {\n                headStr = yearMonthDayFormatWorld(cDate);\n                dateStr = formatTime(x, tr);\n            }\n        }\n        catch(e) { return 'Invalid'; }\n    }\n    else {\n        var d = new Date(Math.floor(x + 0.05));\n\n        if(tr === 'y') dateStr = yearFormat(d);\n        else if(tr === 'm') dateStr = monthFormat(d);\n        else if(tr === 'd') {\n            headStr = yearFormat(d);\n            dateStr = dayFormat(d);\n        }\n        else {\n            headStr = yearMonthDayFormat(d);\n            dateStr = formatTime(x, tr);\n        }\n    }\n\n    return dateStr + (headStr ? '\\n' + headStr : '');\n};\n\n/*\n * incrementMonth: make a new milliseconds value from the given one,\n * having changed the month\n *\n * special case for world calendars: multiples of 12 are treated as years,\n * even for calendar systems that don't have (always or ever) 12 months/year\n * TODO: perhaps we need a different code for year increments to support this?\n *\n * ms (number): the initial millisecond value\n * dMonth (int): the (signed) number of months to shift\n * calendar (string): the calendar system to use\n *\n * changing month does not (and CANNOT) always preserve day, since\n * months have different lengths. The worst example of this is:\n *   d = new Date(1970,0,31); d.setMonth(1) -> Feb 31 turns into Mar 3\n *\n * But we want to be able to iterate over the last day of each month,\n * regardless of what its number is.\n * So shift 3 days forward, THEN set the new month, then unshift:\n *   1/31 -> 2/28 (or 29) -> 3/31 -> 4/30 -> ...\n *\n * Note that odd behavior still exists if you start from the 26th-28th:\n *   1/28 -> 2/28 -> 3/31\n * but at least you can't shift any dates into the wrong month,\n * and ticks on these days incrementing by month would be very unusual\n */\nvar THREEDAYS = 3 * ONEDAY;\nexports.incrementMonth = function(ms, dMonth, calendar) {\n    calendar = isWorldCalendar(calendar) && calendar;\n\n    // pull time out and operate on pure dates, then add time back at the end\n    // this gives maximum precision - not that we *normally* care if we're\n    // incrementing by month, but better to be safe!\n    var timeMs = mod(ms, ONEDAY);\n    ms = Math.round(ms - timeMs);\n\n    if(calendar) {\n        try {\n            var dateJD = Math.round(ms / ONEDAY) + EPOCHJD,\n                calInstance = Registry.getComponentMethod('calendars', 'getCal')(calendar),\n                cDate = calInstance.fromJD(dateJD);\n\n            if(dMonth % 12) calInstance.add(cDate, dMonth, 'm');\n            else calInstance.add(cDate, dMonth / 12, 'y');\n\n            return (cDate.toJD() - EPOCHJD) * ONEDAY + timeMs;\n        }\n        catch(e) {\n            logError('invalid ms ' + ms + ' in calendar ' + calendar);\n            // then keep going in gregorian even though the result will be 'Invalid'\n        }\n    }\n\n    var y = new Date(ms + THREEDAYS);\n    return y.setUTCMonth(y.getUTCMonth() + dMonth) + timeMs - THREEDAYS;\n};\n\n/*\n * findExactDates: what fraction of data is exact days, months, or years?\n *\n * data: array of millisecond values\n * calendar (string) the calendar to test against\n */\nexports.findExactDates = function(data, calendar) {\n    var exactYears = 0,\n        exactMonths = 0,\n        exactDays = 0,\n        blankCount = 0,\n        d,\n        di;\n\n    var calInstance = (\n        isWorldCalendar(calendar) &&\n        Registry.getComponentMethod('calendars', 'getCal')(calendar)\n    );\n\n    for(var i = 0; i < data.length; i++) {\n        di = data[i];\n\n        // not date data at all\n        if(!isNumeric(di)) {\n            blankCount ++;\n            continue;\n        }\n\n        // not an exact date\n        if(di % ONEDAY) continue;\n\n        if(calInstance) {\n            try {\n                d = calInstance.fromJD(di / ONEDAY + EPOCHJD);\n                if(d.day() === 1) {\n                    if(d.month() === 1) exactYears++;\n                    else exactMonths++;\n                }\n                else exactDays++;\n            }\n            catch(e) {\n                // invalid date in this calendar - ignore it here.\n            }\n        }\n        else {\n            d = new Date(di);\n            if(d.getUTCDate() === 1) {\n                if(d.getUTCMonth() === 0) exactYears++;\n                else exactMonths++;\n            }\n            else exactDays++;\n        }\n    }\n    exactMonths += exactYears;\n    exactDays += exactMonths;\n\n    var dataCount = data.length - blankCount;\n\n    return {\n        exactYears: exactYears / dataCount,\n        exactMonths: exactMonths / dataCount,\n        exactDays: exactDays / dataCount\n    };\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/constants/numerical.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n\nmodule.exports = {\n    /**\n     * Standardize all missing data in calcdata to use undefined\n     * never null or NaN.\n     * That way we can use !==undefined, or !== BADNUM,\n     * to test for real data\n     */\n    BADNUM: undefined,\n\n    /*\n     * Limit certain operations to well below floating point max value\n     * to avoid glitches: Make sure that even when you multiply it by the\n     * number of pixels on a giant screen it still works\n     */\n    FP_SAFE: Number.MAX_VALUE / 10000,\n\n    /*\n     * conversion of date units to milliseconds\n     * year and month constants are marked \"AVG\"\n     * to remind us that not all years and months\n     * have the same length\n     */\n    ONEAVGYEAR: 31557600000, // 365.25 days\n    ONEAVGMONTH: 2629800000, // 1/12 of ONEAVGYEAR\n    ONEDAY: 86400000,\n    ONEHOUR: 3600000,\n    ONEMIN: 60000,\n    ONESEC: 1000,\n\n    /*\n     * For fast conversion btwn world calendars and epoch ms, the Julian Day Number\n     * of the unix epoch. From calendars.instance().newDate(1970, 1, 1).toJD()\n     */\n    EPOCHJD: 2440587.5,\n\n    /*\n     * Are two values nearly equal? Compare to 1PPM\n     */\n    ALMOST_EQUAL: 1 - 1e-6\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/lib/search.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar loggers = require('./loggers');\n\n\n/**\n * findBin - find the bin for val - note that it can return outside the\n * bin range any pos. or neg. integer for linear bins, or -1 or\n * bins.length-1 for explicit.\n * bins is either an object {start,size,end} or an array length #bins+1\n * bins can be either increasing or decreasing but must be monotonic\n * for linear bins, we can just calculate. For listed bins, run a binary\n * search linelow (truthy) says the bin boundary should be attributed to\n * the lower bin rather than the default upper bin\n */\nexports.findBin = function(val, bins, linelow) {\n    if(isNumeric(bins.start)) {\n        return linelow ?\n            Math.ceil((val - bins.start) / bins.size) - 1 :\n            Math.floor((val - bins.start) / bins.size);\n    }\n    else {\n        var n1 = 0,\n            n2 = bins.length,\n            c = 0,\n            n,\n            test;\n        if(bins[bins.length - 1] >= bins[0]) {\n            test = linelow ? lessThan : lessOrEqual;\n        } else {\n            test = linelow ? greaterOrEqual : greaterThan;\n        }\n        // c is just to avoid infinite loops if there's an error\n        while(n1 < n2 && c++ < 100) {\n            n = Math.floor((n1 + n2) / 2);\n            if(test(bins[n], val)) n1 = n + 1;\n            else n2 = n;\n        }\n        if(c > 90) loggers.log('Long binary search...');\n        return n1 - 1;\n    }\n};\n\nfunction lessThan(a, b) { return a < b; }\nfunction lessOrEqual(a, b) { return a <= b; }\nfunction greaterThan(a, b) { return a > b; }\nfunction greaterOrEqual(a, b) { return a >= b; }\n\nexports.sorterAsc = function(a, b) { return a - b; };\nexports.sorterDes = function(a, b) { return b - a; };\n\n/**\n * find distinct values in an array, lumping together ones that appear to\n * just be off by a rounding error\n * return the distinct values and the minimum difference between any two\n */\nexports.distinctVals = function(valsIn) {\n    var vals = valsIn.slice();  // otherwise we sort the original array...\n    vals.sort(exports.sorterAsc);\n\n    var l = vals.length - 1,\n        minDiff = (vals[l] - vals[0]) || 1,\n        errDiff = minDiff / (l || 1) / 10000,\n        v2 = [vals[0]];\n\n    for(var i = 0; i < l; i++) {\n        // make sure values aren't just off by a rounding error\n        if(vals[i + 1] > vals[i] + errDiff) {\n            minDiff = Math.min(minDiff, vals[i + 1] - vals[i]);\n            v2.push(vals[i + 1]);\n        }\n    }\n\n    return {vals: v2, minDiff: minDiff};\n};\n\n/**\n * return the smallest element from (sorted) array arrayIn that's bigger than val,\n * or (reverse) the largest element smaller than val\n * used to find the best tick given the minimum (non-rounded) tick\n * particularly useful for date/time where things are not powers of 10\n * binary search is probably overkill here...\n */\nexports.roundUp = function(val, arrayIn, reverse) {\n    var low = 0,\n        high = arrayIn.length - 1,\n        mid,\n        c = 0,\n        dlow = reverse ? 0 : 1,\n        dhigh = reverse ? 1 : 0,\n        rounded = reverse ? Math.ceil : Math.floor;\n    // c is just to avoid infinite loops if there's an error\n    while(low < high && c++ < 100) {\n        mid = rounded((low + high) / 2);\n        if(arrayIn[mid] <= val) low = mid + dlow;\n        else high = mid - dhigh;\n    }\n    return arrayIn[low];\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/lib/stats.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\n\n/**\n * aggNums() returns the result of an aggregate function applied to an array of\n * values, where non-numerical values have been tossed out.\n *\n * @param {function} f - aggregation function (e.g., Math.min)\n * @param {Number} v - initial value (continuing from previous calls)\n *      if there's no continuing value, use null for selector-type\n *      functions (max,min), or 0 for summations\n * @param {Array} a - array to aggregate (may be nested, we will recurse,\n *                    but all elements must have the same dimension)\n * @param {Number} len - maximum length of a to aggregate\n * @return {Number} - result of f applied to a starting from v\n */\nexports.aggNums = function(f, v, a, len) {\n    var i,\n        b;\n    if(!len) len = a.length;\n    if(!isNumeric(v)) v = false;\n    if(Array.isArray(a[0])) {\n        b = new Array(len);\n        for(i = 0; i < len; i++) b[i] = exports.aggNums(f, v, a[i]);\n        a = b;\n    }\n\n    for(i = 0; i < len; i++) {\n        if(!isNumeric(v)) v = a[i];\n        else if(isNumeric(a[i])) v = f(+v, +a[i]);\n    }\n    return v;\n};\n\n/**\n * mean & std dev functions using aggNums, so it handles non-numerics nicely\n * even need to use aggNums instead of .length, to toss out non-numerics\n */\nexports.len = function(data) {\n    return exports.aggNums(function(a) { return a + 1; }, 0, data);\n};\n\nexports.mean = function(data, len) {\n    if(!len) len = exports.len(data);\n    return exports.aggNums(function(a, b) { return a + b; }, 0, data) / len;\n};\n\nexports.variance = function(data, len, mean) {\n    if(!len) len = exports.len(data);\n    if(!isNumeric(mean)) mean = exports.mean(data, len);\n\n    return exports.aggNums(function(a, b) {\n        return a + Math.pow(b - mean, 2);\n    }, 0, data) / len;\n};\n\nexports.stdev = function(data, len, mean) {\n    return Math.sqrt(exports.variance(data, len, mean));\n};\n\n/**\n * interp() computes a percentile (quantile) for a given distribution.\n * We interpolate the distribution (to compute quantiles, we follow method #10 here:\n * http://www.amstat.org/publications/jse/v14n3/langford.html).\n * Typically the index or rank (n * arr.length) may be non-integer.\n * For reference: ends are clipped to the extreme values in the array;\n * For box plots: index you get is half a point too high (see\n * http://en.wikipedia.org/wiki/Percentile#Nearest_rank) but note that this definition\n * indexes from 1 rather than 0, so we subtract 1/2 (instead of add).\n *\n * @param {Array} arr - This array contains the values that make up the distribution.\n * @param {Number} n - Between 0 and 1, n = p/100 is such that we compute the p^th percentile.\n * For example, the 50th percentile (or median) corresponds to n = 0.5\n * @return {Number} - percentile\n */\nexports.interp = function(arr, n) {\n    if(!isNumeric(n)) throw 'n should be a finite number';\n    n = n * arr.length - 0.5;\n    if(n < 0) return arr[0];\n    if(n > arr.length - 1) return arr[arr.length - 1];\n    var frac = n % 1;\n    return frac * arr[Math.ceil(n)] + (1 - frac) * arr[Math.floor(n)];\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/lib/matrix.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\n\nexports.init2dArray = function(rowLength, colLength) {\n    var array = new Array(rowLength);\n    for(var i = 0; i < rowLength; i++) array[i] = new Array(colLength);\n    return array;\n};\n\n/**\n * transpose a (possibly ragged) 2d array z. inspired by\n * http://stackoverflow.com/questions/17428587/\n * transposing-a-2d-array-in-javascript\n */\nexports.transposeRagged = function(z) {\n    var maxlen = 0,\n        zlen = z.length,\n        i,\n        j;\n    // Maximum row length:\n    for(i = 0; i < zlen; i++) maxlen = Math.max(maxlen, z[i].length);\n\n    var t = new Array(maxlen);\n    for(i = 0; i < maxlen; i++) {\n        t[i] = new Array(zlen);\n        for(j = 0; j < zlen; j++) t[i][j] = z[j][i];\n    }\n\n    return t;\n};\n\n// our own dot function so that we don't need to include numeric\nexports.dot = function(x, y) {\n    if(!(x.length && y.length) || x.length !== y.length) return null;\n\n    var len = x.length,\n        out,\n        i;\n\n    if(x[0].length) {\n        // mat-vec or mat-mat\n        out = new Array(len);\n        for(i = 0; i < len; i++) out[i] = exports.dot(x[i], y);\n    }\n    else if(y[0].length) {\n        // vec-mat\n        var yTranspose = exports.transposeRagged(y);\n        out = new Array(yTranspose.length);\n        for(i = 0; i < yTranspose.length; i++) out[i] = exports.dot(x, yTranspose[i]);\n    }\n    else {\n        // vec-vec\n        out = 0;\n        for(i = 0; i < len; i++) out += x[i] * y[i];\n    }\n\n    return out;\n};\n\n// translate by (x,y)\nexports.translationMatrix = function(x, y) {\n    return [[1, 0, x], [0, 1, y], [0, 0, 1]];\n};\n\n// rotate by alpha around (0,0)\nexports.rotationMatrix = function(alpha) {\n    var a = alpha * Math.PI / 180;\n    return [[Math.cos(a), -Math.sin(a), 0],\n            [Math.sin(a), Math.cos(a), 0],\n            [0, 0, 1]];\n};\n\n// rotate by alpha around (x,y)\nexports.rotationXYMatrix = function(a, x, y) {\n    return exports.dot(\n        exports.dot(exports.translationMatrix(x, y),\n                    exports.rotationMatrix(a)),\n        exports.translationMatrix(-x, -y));\n};\n\n// applies a 2D transformation matrix to either x and y params or an [x,y] array\nexports.apply2DTransform = function(transform) {\n    return function() {\n        var args = arguments;\n        if(args.length === 3) {\n            args = args[0];\n        }// from map\n        var xy = arguments.length === 1 ? args[0] : [args[0], args[1]];\n        return exports.dot(transform, [xy[0], xy[1], 1]).slice(0, 2);\n    };\n};\n\n// applies a 2D transformation matrix to an [x1,y1,x2,y2] array (to transform a segment)\nexports.apply2DTransform2 = function(transform) {\n    var at = exports.apply2DTransform(transform);\n    return function(xys) {\n        return at(xys.slice(0, 2)).concat(at(xys.slice(2, 4)));\n    };\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/lib/extend.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar isPlainObject = require('./is_plain_object.js');\nvar isArray = Array.isArray;\n\nfunction primitivesLoopSplice(source, target) {\n    var i, value;\n    for(i = 0; i < source.length; i++) {\n        value = source[i];\n        if(value !== null && typeof(value) === 'object') {\n            return false;\n        }\n        if(value !== void(0)) {\n            target[i] = value;\n        }\n    }\n    return true;\n}\n\nexports.extendFlat = function() {\n    return _extend(arguments, false, false, false);\n};\n\nexports.extendDeep = function() {\n    return _extend(arguments, true, false, false);\n};\n\nexports.extendDeepAll = function() {\n    return _extend(arguments, true, true, false);\n};\n\nexports.extendDeepNoArrays = function() {\n    return _extend(arguments, true, false, true);\n};\n\n/*\n * Inspired by https://github.com/justmoon/node-extend/blob/master/index.js\n * All credit to the jQuery authors for perfecting this amazing utility.\n *\n * API difference with jQuery version:\n * - No optional boolean (true -> deep extend) first argument,\n *   use `extendFlat` for first-level only extend and\n *   use `extendDeep` for a deep extend.\n *\n * Other differences with jQuery version:\n * - Uses a modern (and faster) isPlainObject routine.\n * - Expected to work with object {} and array [] arguments only.\n * - Does not check for circular structure.\n *   FYI: jQuery only does a check across one level.\n *   Warning: this might result in infinite loops.\n *\n */\nfunction _extend(inputs, isDeep, keepAllKeys, noArrayCopies) {\n    var target = inputs[0],\n        length = inputs.length;\n\n    var input, key, src, copy, copyIsArray, clone, allPrimitives;\n\n    if(length === 2 && isArray(target) && isArray(inputs[1]) && target.length === 0) {\n\n        allPrimitives = primitivesLoopSplice(inputs[1], target);\n\n        if(allPrimitives) {\n            return target;\n        } else {\n            target.splice(0, target.length); // reset target and continue to next block\n        }\n    }\n\n    for(var i = 1; i < length; i++) {\n        input = inputs[i];\n\n        for(key in input) {\n            src = target[key];\n            copy = input[key];\n\n            // Stop early and just transfer the array if array copies are disallowed:\n            if(noArrayCopies && isArray(copy)) {\n                target[key] = copy;\n            }\n\n            // recurse if we're merging plain objects or arrays\n            else if(isDeep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n                if(copyIsArray) {\n                    copyIsArray = false;\n                    clone = src && isArray(src) ? src : [];\n                } else {\n                    clone = src && isPlainObject(src) ? src : {};\n                }\n\n                // never move original objects, clone them\n                target[key] = _extend([clone, copy], isDeep, keepAllKeys, noArrayCopies);\n            }\n\n            // don't bring in undefined values, except for extendDeepAll\n            else if(typeof copy !== 'undefined' || keepAllKeys) {\n                target[key] = copy;\n            }\n        }\n    }\n\n    return target;\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/lib/notifier.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\nvar isNumeric = require('fast-isnumeric');\n\nvar NOTEDATA = [];\n\n/**\n * notifier\n * @param {String} text The person's user name\n * @param {Number} [delay=1000] The delay time in milliseconds\n *          or 'long' which provides 2000 ms delay time.\n * @return {undefined} this function does not return a value\n */\nmodule.exports = function(text, displayLength) {\n    if(NOTEDATA.indexOf(text) !== -1) return;\n\n    NOTEDATA.push(text);\n\n    var ts = 1000;\n    if(isNumeric(displayLength)) ts = displayLength;\n    else if(displayLength === 'long') ts = 3000;\n\n    var notifierContainer = d3.select('body')\n        .selectAll('.plotly-notifier')\n        .data([0]);\n    notifierContainer.enter()\n        .append('div')\n        .classed('plotly-notifier', true);\n\n    var notes = notifierContainer.selectAll('.notifier-note').data(NOTEDATA);\n\n    function killNote(transition) {\n        transition\n            .duration(700)\n            .style('opacity', 0)\n            .each('end', function(thisText) {\n                var thisIndex = NOTEDATA.indexOf(thisText);\n                if(thisIndex !== -1) NOTEDATA.splice(thisIndex, 1);\n                d3.select(this).remove();\n            });\n    }\n\n    notes.enter().append('div')\n        .classed('notifier-note', true)\n        .style('opacity', 0)\n        .each(function(thisText) {\n            var note = d3.select(this);\n\n            note.append('button')\n                .classed('notifier-close', true)\n                .html('&times;')\n                .on('click', function() {\n                    note.transition().call(killNote);\n                });\n\n            var p = note.append('p');\n            var lines = thisText.split(/<br\\s*\\/?>/g);\n            for(var i = 0; i < lines.length; i++) {\n                if(i) p.append('br');\n                p.append('span').text(lines[i]);\n            }\n\n            note.transition()\n                    .duration(700)\n                    .style('opacity', 1)\n                .transition()\n                    .delay(ts)\n                    .call(killNote);\n        });\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/lib/filter_unique.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\n\n/**\n * Return news array containing only the unique items\n * found in input array.\n *\n * IMPORTANT: Note that items are considered unique\n * if `String({})` is unique. For example;\n *\n *  Lib.filterUnique([ { a: 1 }, { b: 2 } ])\n *\n *  returns [{ a: 1 }]\n *\n * and\n *\n *  Lib.filterUnique([ '1', 1 ])\n *\n *  returns ['1']\n *\n *\n * @param {array} array base array\n * @return {array} new filtered array\n */\nmodule.exports = function filterUnique(array) {\n    var seen = {},\n        out = [],\n        j = 0;\n\n    for(var i = 0; i < array.length; i++) {\n        var item = array[i];\n\n        if(seen[item] !== 1) {\n            seen[item] = 1;\n            out[j++] = item;\n        }\n    }\n\n    return out;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/lib/filter_visible.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\n/** Filter out object items with visible !== true\n *  insider array container.\n *\n *  @param {array of objects} container\n *  @return {array of objects} of length <= container\n *\n */\nmodule.exports = function filterVisible(container) {\n    var out = [];\n\n    for(var i = 0; i < container.length; i++) {\n        var item = container[i];\n\n        if(item.visible === true) out.push(item);\n    }\n\n    return out;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/lib/clean_number.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar BADNUM = require('../constants/numerical').BADNUM;\n\n// precompile for speed\nvar JUNK = /^['\"%,$#\\s']+|[, ]|['\"%,$#\\s']+$/g;\n\n/**\n * cleanNumber: remove common leading and trailing cruft\n * Always returns either a number or BADNUM.\n */\nmodule.exports = function cleanNumber(v) {\n    if(typeof v === 'string') {\n        v = v.replace(JUNK, '');\n    }\n\n    if(isNumeric(v)) return Number(v);\n\n    return BADNUM;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/lib/identity.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n// Simple helper functions\n// none of these need any external deps\n\nmodule.exports = function identity(d) { return d; };\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/color/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar tinycolor = require('tinycolor2');\nvar isNumeric = require('fast-isnumeric');\n\nvar color = module.exports = {};\n\nvar colorAttrs = require('./attributes');\ncolor.defaults = colorAttrs.defaults;\nvar defaultLine = color.defaultLine = colorAttrs.defaultLine;\ncolor.lightLine = colorAttrs.lightLine;\nvar background = color.background = colorAttrs.background;\n\n/*\n * tinyRGB: turn a tinycolor into an rgb string, but\n * unlike the built-in tinycolor.toRgbString this never includes alpha\n */\ncolor.tinyRGB = function(tc) {\n    var c = tc.toRgb();\n    return 'rgb(' + Math.round(c.r) + ', ' +\n        Math.round(c.g) + ', ' + Math.round(c.b) + ')';\n};\n\ncolor.rgb = function(cstr) { return color.tinyRGB(tinycolor(cstr)); };\n\ncolor.opacity = function(cstr) { return cstr ? tinycolor(cstr).getAlpha() : 0; };\n\ncolor.addOpacity = function(cstr, op) {\n    var c = tinycolor(cstr).toRgb();\n    return 'rgba(' + Math.round(c.r) + ', ' +\n        Math.round(c.g) + ', ' + Math.round(c.b) + ', ' + op + ')';\n};\n\n// combine two colors into one apparent color\n// if back has transparency or is missing,\n// color.background is assumed behind it\ncolor.combine = function(front, back) {\n    var fc = tinycolor(front).toRgb();\n    if(fc.a === 1) return tinycolor(front).toRgbString();\n\n    var bc = tinycolor(back || background).toRgb(),\n        bcflat = bc.a === 1 ? bc : {\n            r: 255 * (1 - bc.a) + bc.r * bc.a,\n            g: 255 * (1 - bc.a) + bc.g * bc.a,\n            b: 255 * (1 - bc.a) + bc.b * bc.a\n        },\n        fcflat = {\n            r: bcflat.r * (1 - fc.a) + fc.r * fc.a,\n            g: bcflat.g * (1 - fc.a) + fc.g * fc.a,\n            b: bcflat.b * (1 - fc.a) + fc.b * fc.a\n        };\n    return tinycolor(fcflat).toRgbString();\n};\n\n/*\n * Create a color that contrasts with cstr.\n *\n * If cstr is a dark color, we lighten it; if it's light, we darken.\n *\n * If lightAmount / darkAmount are used, we adjust by these percentages,\n * otherwise we go all the way to white or black.\n */\ncolor.contrast = function(cstr, lightAmount, darkAmount) {\n    var tc = tinycolor(cstr);\n\n    if(tc.getAlpha() !== 1) tc = tinycolor(color.combine(cstr, background));\n\n    var newColor = tc.isDark() ?\n        (lightAmount ? tc.lighten(lightAmount) : background) :\n        (darkAmount ? tc.darken(darkAmount) : defaultLine);\n\n    return newColor.toString();\n};\n\ncolor.stroke = function(s, c) {\n    var tc = tinycolor(c);\n    s.style({'stroke': color.tinyRGB(tc), 'stroke-opacity': tc.getAlpha()});\n};\n\ncolor.fill = function(s, c) {\n    var tc = tinycolor(c);\n    s.style({\n        'fill': color.tinyRGB(tc),\n        'fill-opacity': tc.getAlpha()\n    });\n};\n\n// search container for colors with the deprecated rgb(fractions) format\n// and convert them to rgb(0-255 values)\ncolor.clean = function(container) {\n    if(!container || typeof container !== 'object') return;\n\n    var keys = Object.keys(container),\n        i,\n        j,\n        key,\n        val;\n\n    for(i = 0; i < keys.length; i++) {\n        key = keys[i];\n        val = container[key];\n\n        // only sanitize keys that end in \"color\" or \"colorscale\"\n        if(key.substr(key.length - 5) === 'color') {\n            if(Array.isArray(val)) {\n                for(j = 0; j < val.length; j++) val[j] = cleanOne(val[j]);\n            }\n            else container[key] = cleanOne(val);\n        }\n        else if(key.substr(key.length - 10) === 'colorscale' && Array.isArray(val)) {\n            // colorscales have the format [[0, color1], [frac, color2], ... [1, colorN]]\n            for(j = 0; j < val.length; j++) {\n                if(Array.isArray(val[j])) val[j][1] = cleanOne(val[j][1]);\n            }\n        }\n        // recurse into arrays of objects, and plain objects\n        else if(Array.isArray(val)) {\n            var el0 = val[0];\n            if(!Array.isArray(el0) && el0 && typeof el0 === 'object') {\n                for(j = 0; j < val.length; j++) color.clean(val[j]);\n            }\n        }\n        else if(val && typeof val === 'object') color.clean(val);\n    }\n};\n\nfunction cleanOne(val) {\n    if(isNumeric(val) || typeof val !== 'string') return val;\n\n    var valTrim = val.trim();\n    if(valTrim.substr(0, 3) !== 'rgb') return val;\n\n    var match = valTrim.match(/^rgba?\\s*\\(([^()]*)\\)$/);\n    if(!match) return val;\n\n    var parts = match[1].trim().split(/\\s*[\\s,]\\s*/),\n        rgba = valTrim.charAt(3) === 'a' && parts.length === 4;\n    if(!rgba && parts.length !== 3) return val;\n\n    for(var i = 0; i < parts.length; i++) {\n        if(!parts[i].length) return val;\n        parts[i] = Number(parts[i]);\n\n        // all parts must be non-negative numbers\n        if(!(parts[i] >= 0)) return val;\n        // alpha>1 gets clipped to 1\n        if(i === 3) {\n            if(parts[i] > 1) parts[i] = 1;\n        }\n        // r, g, b must be < 1 (ie 1 itself is not allowed)\n        else if(parts[i] >= 1) return val;\n    }\n\n    var rgbStr = Math.round(parts[0] * 255) + ', ' +\n        Math.round(parts[1] * 255) + ', ' +\n        Math.round(parts[2] * 255);\n\n    if(rgba) return 'rgba(' + rgbStr + ', ' + parts[3] + ')';\n    return 'rgb(' + rgbStr + ')';\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/color/attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n\n// IMPORTANT - default colors should be in hex for compatibility\nexports.defaults = [\n    '#1f77b4',  // muted blue\n    '#ff7f0e',  // safety orange\n    '#2ca02c',  // cooked asparagus green\n    '#d62728',  // brick red\n    '#9467bd',  // muted purple\n    '#8c564b',  // chestnut brown\n    '#e377c2',  // raspberry yogurt pink\n    '#7f7f7f',  // middle gray\n    '#bcbd22',  // curry yellow-green\n    '#17becf'   // blue-teal\n];\n\nexports.defaultLine = '#444';\n\nexports.lightLine = '#eee';\n\nexports.background = '#fff';\n\nexports.borderLine = '#BEC8D9';\n\n// with axis.color and Color.interp we aren't using lightLine\n// itself anymore, instead interpolating between axis.color\n// and the background color using tinycolor.mix. lightFraction\n// gives back exactly lightLine if the other colors are defaults.\nexports.lightFraction = 100 * (0xe - 0x4) / (0xf - 0x4);\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/animation_attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = {\n    mode: {\n        valType: 'enumerated',\n        dflt: 'afterall',\n        role: 'info',\n        values: ['immediate', 'next', 'afterall'],\n        description: [\n            'Describes how a new animate call interacts with currently-running',\n            'animations. If `immediate`, current animations are interrupted and',\n            'the new animation is started. If `next`, the current frame is allowed',\n            'to complete, after which the new animation is started. If `afterall`',\n            'all existing frames are animated to completion before the new animation',\n            'is started.'\n        ].join(' ')\n    },\n    direction: {\n        valType: 'enumerated',\n        role: 'info',\n        values: ['forward', 'reverse'],\n        dflt: 'forward',\n        description: [\n            'The direction in which to play the frames triggered by the animation call'\n        ].join(' ')\n    },\n    fromcurrent: {\n        valType: 'boolean',\n        dflt: false,\n        role: 'info',\n        description: [\n            'Play frames starting at the current frame instead of the beginning.'\n        ].join(' ')\n    },\n    frame: {\n        duration: {\n            valType: 'number',\n            role: 'info',\n            min: 0,\n            dflt: 500,\n            description: [\n                'The duration in milliseconds of each frame. If greater than the frame',\n                'duration, it will be limited to the frame duration.'\n            ].join(' ')\n        },\n        redraw: {\n            valType: 'boolean',\n            role: 'info',\n            dflt: true,\n            description: [\n                'Redraw the plot at completion of the transition. This is desirable',\n                'for transitions that include properties that cannot be transitioned,',\n                'but may significantly slow down updates that do not require a full',\n                'redraw of the plot'\n            ].join(' ')\n        },\n    },\n    transition: {\n        duration: {\n            valType: 'number',\n            role: 'info',\n            min: 0,\n            dflt: 500,\n            description: [\n                'The duration of the transition, in milliseconds. If equal to zero,',\n                'updates are synchronous.'\n            ].join(' ')\n        },\n        easing: {\n            valType: 'enumerated',\n            dflt: 'cubic-in-out',\n            values: [\n                'linear',\n                'quad',\n                'cubic',\n                'sin',\n                'exp',\n                'circle',\n                'elastic',\n                'back',\n                'bounce',\n                'linear-in',\n                'quad-in',\n                'cubic-in',\n                'sin-in',\n                'exp-in',\n                'circle-in',\n                'elastic-in',\n                'back-in',\n                'bounce-in',\n                'linear-out',\n                'quad-out',\n                'cubic-out',\n                'sin-out',\n                'exp-out',\n                'circle-out',\n                'elastic-out',\n                'back-out',\n                'bounce-out',\n                'linear-in-out',\n                'quad-in-out',\n                'cubic-in-out',\n                'sin-in-out',\n                'exp-in-out',\n                'circle-in-out',\n                'elastic-in-out',\n                'back-in-out',\n                'bounce-in-out'\n            ],\n            role: 'info',\n            description: 'The easing function used for the transition'\n        },\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/frame_attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = {\n    _isLinkedToArray: 'frames_entry',\n\n    group: {\n        valType: 'string',\n        role: 'info',\n        description: [\n            'An identifier that specifies the group to which the frame belongs,',\n            'used by animate to select a subset of frames.'\n        ].join(' ')\n    },\n    name: {\n        valType: 'string',\n        role: 'info',\n        description: 'A label by which to identify the frame'\n    },\n    traces: {\n        valType: 'any',\n        role: 'info',\n        description: [\n            'A list of trace indices that identify the respective traces in the',\n            'data attribute'\n        ].join(' ')\n    },\n    baseframe: {\n        valType: 'string',\n        role: 'info',\n        description: [\n            'The name of the frame into which this frame\\'s properties are merged',\n            'before applying. This is used to unify properties and avoid needing',\n            'to specify the same values for the same properties in multiple frames.'\n        ].join(' ')\n    },\n    data: {\n        valType: 'any',\n        role: 'object',\n        description: [\n            'A list of traces this frame modifies. The format is identical to the',\n            'normal trace definition.'\n        ].join(' ')\n    },\n    layout: {\n        valType: 'any',\n        role: 'object',\n        description: [\n            'Layout properties which this frame modifies. The format is identical',\n            'to the normal layout definition.'\n        ].join(' ')\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/font_attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n\nmodule.exports = {\n    family: {\n        valType: 'string',\n        role: 'style',\n        noBlank: true,\n        strict: true,\n        description: [\n            'HTML font family - the typeface that will be applied by the web browser.',\n            'The web browser will only be able to apply a font if it is available on the system',\n            'which it operates. Provide multiple font families, separated by commas, to indicate',\n            'the preference in which to apply fonts if they aren\\'t available on the system.',\n            'The plotly service (at https://plot.ly or on-premise) generates images on a server,',\n            'where only a select number of',\n            'fonts are installed and supported.',\n            'These include *Arial*, *Balto*, *Courier New*, *Droid Sans*,, *Droid Serif*,',\n            '*Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*,',\n            '*PT Sans Narrow*, *Raleway*, *Times New Roman*.'\n        ].join(' ')\n    },\n    size: {\n        valType: 'number',\n        role: 'style',\n        min: 1\n    },\n    color: {\n        valType: 'color',\n        role: 'style'\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/layout_attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../lib');\nvar extendFlat = Lib.extendFlat;\n\nvar fontAttrs = require('./font_attributes');\nvar colorAttrs = require('../components/color/attributes');\n\nmodule.exports = {\n    font: {\n        family: extendFlat({}, fontAttrs.family, {\n            dflt: '\"Open Sans\", verdana, arial, sans-serif'\n        }),\n        size: extendFlat({}, fontAttrs.size, {\n            dflt: 12\n        }),\n        color: extendFlat({}, fontAttrs.color, {\n            dflt: colorAttrs.defaultLine\n        }),\n        description: [\n            'Sets the global font.',\n            'Note that fonts used in traces and other',\n            'layout components inherit from the global font.'\n        ].join(' ')\n    },\n    title: {\n        valType: 'string',\n        role: 'info',\n        dflt: 'Click to enter Plot title',\n        description: [\n            'Sets the plot\\'s title.'\n        ].join(' ')\n    },\n    titlefont: extendFlat({}, fontAttrs, {\n        description: 'Sets the title font.'\n    }),\n    autosize: {\n        valType: 'boolean',\n        role: 'info',\n        dflt: false,\n        description: [\n            'Determines whether or not a layout width or height',\n            'that has been left undefined by the user',\n            'is initialized on each relayout.',\n\n            'Note that, regardless of this attribute,',\n            'an undefined layout width or height',\n            'is always initialized on the first call to plot.'\n        ].join(' ')\n    },\n    width: {\n        valType: 'number',\n        role: 'info',\n        min: 10,\n        dflt: 700,\n        description: [\n            'Sets the plot\\'s width (in px).'\n        ].join(' ')\n    },\n    height: {\n        valType: 'number',\n        role: 'info',\n        min: 10,\n        dflt: 450,\n        description: [\n            'Sets the plot\\'s height (in px).'\n        ].join(' ')\n    },\n    margin: {\n        l: {\n            valType: 'number',\n            role: 'info',\n            min: 0,\n            dflt: 80,\n            description: 'Sets the left margin (in px).'\n        },\n        r: {\n            valType: 'number',\n            role: 'info',\n            min: 0,\n            dflt: 80,\n            description: 'Sets the right margin (in px).'\n        },\n        t: {\n            valType: 'number',\n            role: 'info',\n            min: 0,\n            dflt: 100,\n            description: 'Sets the top margin (in px).'\n        },\n        b: {\n            valType: 'number',\n            role: 'info',\n            min: 0,\n            dflt: 80,\n            description: 'Sets the bottom margin (in px).'\n        },\n        pad: {\n            valType: 'number',\n            role: 'info',\n            min: 0,\n            dflt: 0,\n            description: [\n                'Sets the amount of padding (in px)',\n                'between the plotting area and the axis lines'\n            ].join(' ')\n        },\n        autoexpand: {\n            valType: 'boolean',\n            role: 'info',\n            dflt: true\n        }\n    },\n    paper_bgcolor: {\n        valType: 'color',\n        role: 'style',\n        dflt: colorAttrs.background,\n        description: 'Sets the color of paper where the graph is drawn.'\n    },\n    plot_bgcolor: {\n        // defined here, but set in Axes.supplyLayoutDefaults\n        // because it needs to know if there are (2D) axes or not\n        valType: 'color',\n        role: 'style',\n        dflt: colorAttrs.background,\n        description: [\n            'Sets the color of plotting area in-between x and y axes.'\n        ].join(' ')\n    },\n    separators: {\n        valType: 'string',\n        role: 'style',\n        dflt: '.,',\n        description: [\n            'Sets the decimal and thousand separators.',\n            'For example, *. * puts a \\'.\\' before decimals and',\n            'a space between thousands.'\n        ].join(' ')\n    },\n    hidesources: {\n        valType: 'boolean',\n        role: 'info',\n        dflt: false,\n        description: [\n            'Determines whether or not a text link citing the data source is',\n            'placed at the bottom-right cored of the figure.',\n            'Has only an effect only on graphs that have been generated via',\n            'forked graphs from the plotly service (at https://plot.ly or on-premise).'\n        ].join(' ')\n    },\n    smith: {\n        // will become a boolean if/when we implement this\n        valType: 'enumerated',\n        role: 'info',\n        values: [false],\n        dflt: false\n    },\n    showlegend: {\n        // handled in legend.supplyLayoutDefaults\n        // but included here because it's not in the legend object\n        valType: 'boolean',\n        role: 'info',\n        description: 'Determines whether or not a legend is drawn.'\n    },\n    dragmode: {\n        valType: 'enumerated',\n        role: 'info',\n        values: ['zoom', 'pan', 'select', 'lasso', 'orbit', 'turntable'],\n        dflt: 'zoom',\n        description: [\n            'Determines the mode of drag interactions.',\n            '*select* and *lasso* apply only to scatter traces with',\n            'markers or text. *orbit* and *turntable* apply only to',\n            '3D scenes.'\n        ].join(' ')\n    },\n    hovermode: {\n        valType: 'enumerated',\n        role: 'info',\n        values: ['x', 'y', 'closest', false],\n        description: 'Determines the mode of hover interactions.'\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/errorbars/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar errorBars = module.exports = {};\n\nerrorBars.attributes = require('./attributes');\n\nerrorBars.supplyDefaults = require('./defaults');\n\nerrorBars.calc = require('./calc');\n\nerrorBars.calcFromTrace = function(trace, layout) {\n    var x = trace.x || [],\n        y = trace.y || [],\n        len = x.length || y.length;\n\n    var calcdataMock = new Array(len);\n\n    for(var i = 0; i < len; i++) {\n        calcdataMock[i] = {\n            x: x[i],\n            y: y[i]\n        };\n    }\n\n    calcdataMock[0].trace = trace;\n\n    errorBars.calc({\n        calcdata: [calcdataMock],\n        _fullLayout: layout\n    });\n\n    return calcdataMock;\n};\n\nerrorBars.plot = require('./plot');\n\nerrorBars.style = require('./style');\n\nerrorBars.hoverInfo = function(calcPoint, trace, hoverPoint) {\n    if((trace.error_y || {}).visible) {\n        hoverPoint.yerr = calcPoint.yh - calcPoint.y;\n        if(!trace.error_y.symmetric) hoverPoint.yerrneg = calcPoint.y - calcPoint.ys;\n    }\n    if((trace.error_x || {}).visible) {\n        hoverPoint.xerr = calcPoint.xh - calcPoint.x;\n        if(!trace.error_x.symmetric) hoverPoint.xerrneg = calcPoint.x - calcPoint.xs;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/errorbars/attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n\nmodule.exports = {\n    visible: {\n        valType: 'boolean',\n        role: 'info',\n        description: [\n            'Determines whether or not this set of error bars is visible.'\n        ].join(' ')\n    },\n    type: {\n        valType: 'enumerated',\n        values: ['percent', 'constant', 'sqrt', 'data'],\n        role: 'info',\n        description: [\n            'Determines the rule used to generate the error bars.',\n\n            'If *constant`, the bar lengths are of a constant value.',\n            'Set this constant in `value`.',\n\n            'If *percent*, the bar lengths correspond to a percentage of',\n            'underlying data. Set this percentage in `value`.',\n\n            'If *sqrt*, the bar lengths correspond to the sqaure of the',\n            'underlying data.',\n\n            'If *array*, the bar lengths are set with data set `array`.'\n        ].join(' ')\n    },\n    symmetric: {\n        valType: 'boolean',\n        role: 'info',\n        description: [\n            'Determines whether or not the error bars have the same length',\n            'in both direction',\n            '(top/bottom for vertical bars, left/right for horizontal bars.'\n        ].join(' ')\n    },\n    array: {\n        valType: 'data_array',\n        description: [\n            'Sets the data corresponding the length of each error bar.',\n            'Values are plotted relative to the underlying data.'\n        ].join(' ')\n    },\n    arrayminus: {\n        valType: 'data_array',\n        description: [\n            'Sets the data corresponding the length of each error bar in the',\n            'bottom (left) direction for vertical (horizontal) bars',\n            'Values are plotted relative to the underlying data.'\n        ].join(' ')\n    },\n    value: {\n        valType: 'number',\n        min: 0,\n        dflt: 10,\n        role: 'info',\n        description: [\n            'Sets the value of either the percentage',\n            '(if `type` is set to *percent*) or the constant',\n            '(if `type` is set to *constant*) corresponding to the lengths of',\n            'the error bars.'\n        ].join(' ')\n    },\n    valueminus: {\n        valType: 'number',\n        min: 0,\n        dflt: 10,\n        role: 'info',\n        description: [\n            'Sets the value of either the percentage',\n            '(if `type` is set to *percent*) or the constant',\n            '(if `type` is set to *constant*) corresponding to the lengths of',\n            'the error bars in the',\n            'bottom (left) direction for vertical (horizontal) bars'\n        ].join(' ')\n    },\n    traceref: {\n        valType: 'integer',\n        min: 0,\n        dflt: 0,\n        role: 'info'\n    },\n    tracerefminus: {\n        valType: 'integer',\n        min: 0,\n        dflt: 0,\n        role: 'info'\n    },\n    copy_ystyle: {\n        valType: 'boolean',\n        role: 'style'\n    },\n    copy_zstyle: {\n        valType: 'boolean',\n        role: 'style'\n    },\n    color: {\n        valType: 'color',\n        role: 'style',\n        description: 'Sets the stoke color of the error bars.'\n    },\n    thickness: {\n        valType: 'number',\n        min: 0,\n        dflt: 2,\n        role: 'style',\n        description: 'Sets the thickness (in px) of the error bars.'\n    },\n    width: {\n        valType: 'number',\n        min: 0,\n        role: 'style',\n        description: [\n            'Sets the width (in px) of the cross-bar at both ends',\n            'of the error bars.'\n        ].join(' ')\n    },\n\n    _deprecated: {\n        opacity: {\n            valType: 'number',\n            role: 'style',\n            description: [\n                'Obsolete.',\n                'Use the alpha channel in error bar `color` to set the opacity.'\n            ].join(' ')\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/errorbars/defaults.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\n\nvar attributes = require('./attributes');\n\n\nmodule.exports = function(traceIn, traceOut, defaultColor, opts) {\n    var objName = 'error_' + opts.axis,\n        containerOut = traceOut[objName] = {},\n        containerIn = traceIn[objName] || {};\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(containerIn, containerOut, attributes, attr, dflt);\n    }\n\n    var hasErrorBars = (\n        containerIn.array !== undefined ||\n        containerIn.value !== undefined ||\n        containerIn.type === 'sqrt'\n    );\n\n    var visible = coerce('visible', hasErrorBars);\n\n    if(visible === false) return;\n\n    var type = coerce('type', 'array' in containerIn ? 'data' : 'percent'),\n        symmetric = true;\n\n    if(type !== 'sqrt') {\n        symmetric = coerce('symmetric',\n            !((type === 'data' ? 'arrayminus' : 'valueminus') in containerIn));\n    }\n\n    if(type === 'data') {\n        var array = coerce('array');\n        if(!array) containerOut.array = [];\n        coerce('traceref');\n        if(!symmetric) {\n            var arrayminus = coerce('arrayminus');\n            if(!arrayminus) containerOut.arrayminus = [];\n            coerce('tracerefminus');\n        }\n    }\n    else if(type === 'percent' || type === 'constant') {\n        coerce('value');\n        if(!symmetric) coerce('valueminus');\n    }\n\n    var copyAttr = 'copy_' + opts.inherit + 'style';\n    if(opts.inherit) {\n        var inheritObj = traceOut['error_' + opts.inherit];\n        if((inheritObj || {}).visible) {\n            coerce(copyAttr, !(containerIn.color ||\n                               isNumeric(containerIn.thickness) ||\n                               isNumeric(containerIn.width)));\n        }\n    }\n    if(!opts.inherit || !containerOut[copyAttr]) {\n        coerce('color', defaultColor);\n        coerce('thickness');\n        coerce('width', Registry.traceIs(traceOut, 'gl3d') ? 0 : 4);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/errorbars/calc.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Registry = require('../../registry');\nvar Axes = require('../../plots/cartesian/axes');\n\nvar makeComputeError = require('./compute_error');\n\n\nmodule.exports = function calc(gd) {\n    var calcdata = gd.calcdata;\n\n    for(var i = 0; i < calcdata.length; i++) {\n        var calcTrace = calcdata[i],\n            trace = calcTrace[0].trace;\n\n        if(!Registry.traceIs(trace, 'errorBarsOK')) continue;\n\n        var xa = Axes.getFromId(gd, trace.xaxis),\n            ya = Axes.getFromId(gd, trace.yaxis);\n\n        calcOneAxis(calcTrace, trace, xa, 'x');\n        calcOneAxis(calcTrace, trace, ya, 'y');\n    }\n};\n\nfunction calcOneAxis(calcTrace, trace, axis, coord) {\n    var opts = trace['error_' + coord] || {},\n        isVisible = (opts.visible && ['linear', 'log'].indexOf(axis.type) !== -1),\n        vals = [];\n\n    if(!isVisible) return;\n\n    var computeError = makeComputeError(opts);\n\n    for(var i = 0; i < calcTrace.length; i++) {\n        var calcPt = calcTrace[i],\n            calcCoord = calcPt[coord];\n\n        if(!isNumeric(axis.c2l(calcCoord))) continue;\n\n        var errors = computeError(calcCoord, i);\n        if(isNumeric(errors[0]) && isNumeric(errors[1])) {\n            var shoe = calcPt[coord + 's'] = calcCoord - errors[0],\n                hat = calcPt[coord + 'h'] = calcCoord + errors[1];\n            vals.push(shoe, hat);\n        }\n    }\n\n    Axes.expand(axis, vals, {padded: true});\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/cartesian/axes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\nvar isNumeric = require('fast-isnumeric');\n\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar Titles = require('../../components/titles');\nvar Color = require('../../components/color');\nvar Drawing = require('../../components/drawing');\n\nvar constants = require('../../constants/numerical');\nvar FP_SAFE = constants.FP_SAFE;\nvar ONEAVGYEAR = constants.ONEAVGYEAR;\nvar ONEAVGMONTH = constants.ONEAVGMONTH;\nvar ONEDAY = constants.ONEDAY;\nvar ONEHOUR = constants.ONEHOUR;\nvar ONEMIN = constants.ONEMIN;\nvar ONESEC = constants.ONESEC;\nvar BADNUM = constants.BADNUM;\n\n\nvar axes = module.exports = {};\n\naxes.layoutAttributes = require('./layout_attributes');\naxes.supplyLayoutDefaults = require('./layout_defaults');\n\naxes.setConvert = require('./set_convert');\n\nvar axisIds = require('./axis_ids');\naxes.id2name = axisIds.id2name;\naxes.cleanId = axisIds.cleanId;\naxes.list = axisIds.list;\naxes.listIds = axisIds.listIds;\naxes.getFromId = axisIds.getFromId;\naxes.getFromTrace = axisIds.getFromTrace;\n\n\n/*\n * find the list of possible axes to reference with an xref or yref attribute\n * and coerce it to that list\n *\n * attr: the attribute we're generating a reference for. Should end in 'x' or 'y'\n *     but can be prefixed, like 'ax' for annotation's arrow x\n * dflt: the default to coerce to, or blank to use the first axis (falling back on\n *     extraOption if there is no axis)\n * extraOption: aside from existing axes with this letter, what non-axis value is allowed?\n *     Only required if it's different from `dflt`\n */\naxes.coerceRef = function(containerIn, containerOut, gd, attr, dflt, extraOption) {\n    var axLetter = attr.charAt(attr.length - 1),\n        axlist = axes.listIds(gd, axLetter),\n        refAttr = attr + 'ref',\n        attrDef = {};\n\n    if(!dflt) dflt = axlist[0] || extraOption;\n    if(!extraOption) extraOption = dflt;\n\n    // data-ref annotations are not supported in gl2d yet\n\n    attrDef[refAttr] = {\n        valType: 'enumerated',\n        values: axlist.concat(extraOption ? [extraOption] : []),\n        dflt: dflt\n    };\n\n    // xref, yref\n    return Lib.coerce(containerIn, containerOut, attrDef, refAttr);\n};\n\n/*\n * coerce position attributes (range-type) that can be either on axes or absolute\n * (paper or pixel) referenced. The biggest complication here is that we don't know\n * before looking at the axis whether the value must be a number or not (it may be\n * a date string), so we can't use the regular valType='number' machinery\n *\n * axRef (string): the axis this position is referenced to, or:\n *     paper: fraction of the plot area\n *     pixel: pixels relative to some starting position\n * attr (string): the attribute in containerOut we are coercing\n * dflt (number): the default position, as a fraction or pixels. If the attribute\n *     is to be axis-referenced, this will be converted to an axis data value\n *\n * Also cleans the values, since the attribute definition itself has to say\n * valType: 'any' to handle date axes. This allows us to accept:\n * - for category axes: category names, and convert them here into serial numbers.\n *   Note that this will NOT work for axis range endpoints, because we don't know\n *   the category list yet (it's set by ax.makeCalcdata during calc)\n *   but it works for component (note, shape, images) positions.\n * - for date axes: JS Dates or milliseconds, and convert to date strings\n * - for other types: coerce them to numbers\n */\naxes.coercePosition = function(containerOut, gd, coerce, axRef, attr, dflt) {\n    var pos,\n        newPos;\n\n    if(axRef === 'paper' || axRef === 'pixel') {\n        pos = coerce(attr, dflt);\n    }\n    else {\n        var ax = axes.getFromId(gd, axRef);\n\n        dflt = ax.fraction2r(dflt);\n        pos = coerce(attr, dflt);\n\n        if(ax.type === 'category') {\n            // if position is given as a category name, convert it to a number\n            if(typeof pos === 'string' && (ax._categories || []).length) {\n                newPos = ax._categories.indexOf(pos);\n                containerOut[attr] = (newPos === -1) ? dflt : newPos;\n                return;\n            }\n        }\n        else if(ax.type === 'date') {\n            containerOut[attr] = Lib.cleanDate(pos, BADNUM, ax.calendar);\n            return;\n        }\n    }\n    // finally make sure we have a number (unless date type already returned a string)\n    containerOut[attr] = isNumeric(pos) ? Number(pos) : dflt;\n};\n\n// empty out types for all axes containing these traces\n// so we auto-set them again\naxes.clearTypes = function(gd, traces) {\n    if(!Array.isArray(traces) || !traces.length) {\n        traces = (gd._fullData).map(function(d, i) { return i; });\n    }\n    traces.forEach(function(tracenum) {\n        var trace = gd.data[tracenum];\n        delete (axes.getFromId(gd, trace.xaxis) || {}).type;\n        delete (axes.getFromId(gd, trace.yaxis) || {}).type;\n    });\n};\n\n// get counteraxis letter for this axis (name or id)\n// this can also be used as the id for default counter axis\naxes.counterLetter = function(id) {\n    var axLetter = id.charAt(0);\n    if(axLetter === 'x') return 'y';\n    if(axLetter === 'y') return 'x';\n};\n\n// incorporate a new minimum difference and first tick into\n// forced\n// note that _forceTick0 is linearized, so needs to be turned into\n// a range value for setting tick0\naxes.minDtick = function(ax, newDiff, newFirst, allow) {\n    // doesn't make sense to do forced min dTick on log or category axes,\n    // and the plot itself may decide to cancel (ie non-grouped bars)\n    if(['log', 'category'].indexOf(ax.type) !== -1 || !allow) {\n        ax._minDtick = 0;\n    }\n    // undefined means there's nothing there yet\n    else if(ax._minDtick === undefined) {\n        ax._minDtick = newDiff;\n        ax._forceTick0 = newFirst;\n    }\n    else if(ax._minDtick) {\n        // existing minDtick is an integer multiple of newDiff\n        // (within rounding err)\n        // and forceTick0 can be shifted to newFirst\n        if((ax._minDtick / newDiff + 1e-6) % 1 < 2e-6 &&\n                (((newFirst - ax._forceTick0) / newDiff % 1) +\n                    1.000001) % 1 < 2e-6) {\n            ax._minDtick = newDiff;\n            ax._forceTick0 = newFirst;\n        }\n        // if the converse is true (newDiff is a multiple of minDtick and\n        // newFirst can be shifted to forceTick0) then do nothing - same\n        // forcing stands. Otherwise, cancel forced minimum\n        else if((newDiff / ax._minDtick + 1e-6) % 1 > 2e-6 ||\n                (((newFirst - ax._forceTick0) / ax._minDtick % 1) +\n                    1.000001) % 1 > 2e-6) {\n            ax._minDtick = 0;\n        }\n    }\n};\n\n// Find the autorange for this axis\n//\n// assumes ax._min and ax._max have already been set by calling axes.expand\n// using calcdata from all traces. These are arrays of:\n// {val: calcdata value, pad: extra pixels beyond this value}\n//\n// Returns an array of [min, max]. These are calcdata for log and category axes\n// and data for linear and date axes.\n//\n// TODO: we want to change log to data as well, but it's hard to do this\n// maintaining backward compatibility. category will always have to use calcdata\n// though, because otherwise values between categories (or outside all categories)\n// would be impossible.\naxes.getAutoRange = function(ax) {\n    var newRange = [];\n\n    var minmin = ax._min[0].val,\n        maxmax = ax._max[0].val,\n        i;\n\n    for(i = 1; i < ax._min.length; i++) {\n        if(minmin !== maxmax) break;\n        minmin = Math.min(minmin, ax._min[i].val);\n    }\n    for(i = 1; i < ax._max.length; i++) {\n        if(minmin !== maxmax) break;\n        maxmax = Math.max(maxmax, ax._max[i].val);\n    }\n\n    var j, minpt, maxpt, minbest, maxbest, dp, dv,\n        mbest = 0,\n        axReverse = false;\n\n    if(ax.range) {\n        var rng = Lib.simpleMap(ax.range, ax.r2l);\n        axReverse = rng[1] < rng[0];\n    }\n\n    // one-time setting to easily reverse the axis\n    // when plotting from code\n    if(ax.autorange === 'reversed') {\n        axReverse = true;\n        ax.autorange = true;\n    }\n\n    for(i = 0; i < ax._min.length; i++) {\n        minpt = ax._min[i];\n        for(j = 0; j < ax._max.length; j++) {\n            maxpt = ax._max[j];\n            dv = maxpt.val - minpt.val;\n            dp = ax._length - minpt.pad - maxpt.pad;\n            if(dv > 0 && dp > 0 && dv / dp > mbest) {\n                minbest = minpt;\n                maxbest = maxpt;\n                mbest = dv / dp;\n            }\n        }\n    }\n\n    if(minmin === maxmax) {\n        var lower = minmin - 1;\n        var upper = minmin + 1;\n        if(ax.rangemode === 'tozero') {\n            newRange = minmin < 0 ? [lower, 0] : [0, upper];\n        }\n        else if(ax.rangemode === 'nonnegative') {\n            newRange = [Math.max(0, lower), Math.max(0, upper)];\n        }\n        else {\n            newRange = [lower, upper];\n        }\n    }\n    else if(mbest) {\n        if(ax.type === 'linear' || ax.type === '-') {\n            if(ax.rangemode === 'tozero') {\n                if(minbest.val >= 0) {\n                    minbest = {val: 0, pad: 0};\n                }\n                if(maxbest.val <= 0) {\n                    maxbest = {val: 0, pad: 0};\n                }\n            }\n            else if(ax.rangemode === 'nonnegative') {\n                if(minbest.val - mbest * minbest.pad < 0) {\n                    minbest = {val: 0, pad: 0};\n                }\n                if(maxbest.val < 0) {\n                    maxbest = {val: 1, pad: 0};\n                }\n            }\n\n            // in case it changed again...\n            mbest = (maxbest.val - minbest.val) /\n                (ax._length - minbest.pad - maxbest.pad);\n\n        }\n\n        newRange = [\n            minbest.val - mbest * minbest.pad,\n            maxbest.val + mbest * maxbest.pad\n        ];\n    }\n\n    // don't let axis have zero size, while still respecting tozero and nonnegative\n    if(newRange[0] === newRange[1]) {\n        if(ax.rangemode === 'tozero') {\n            if(newRange[0] < 0) {\n                newRange = [newRange[0], 0];\n            }\n            else if(newRange[0] > 0) {\n                newRange = [0, newRange[0]];\n            }\n            else {\n                newRange = [0, 1];\n            }\n        }\n        else {\n            newRange = [newRange[0] - 1, newRange[0] + 1];\n            if(ax.rangemode === 'nonnegative') {\n                newRange[0] = Math.max(0, newRange[0]);\n            }\n        }\n    }\n\n    // maintain reversal\n    if(axReverse) newRange.reverse();\n\n    return Lib.simpleMap(newRange, ax.l2r || Number);\n};\n\naxes.doAutoRange = function(ax) {\n    if(!ax._length) ax.setScale();\n\n    // TODO do we really need this?\n    var hasDeps = (ax._min && ax._max && ax._min.length && ax._max.length);\n\n    if(ax.autorange && hasDeps) {\n        ax.range = axes.getAutoRange(ax);\n\n        // doAutoRange will get called on fullLayout,\n        // but we want to report its results back to layout\n\n        var axIn = ax._input;\n        axIn.range = ax.range.slice();\n        axIn.autorange = ax.autorange;\n    }\n};\n\n// save a copy of the initial axis ranges in fullLayout\n// use them in mode bar and dblclick events\naxes.saveRangeInitial = function(gd, overwrite) {\n    var axList = axes.list(gd, '', true),\n        hasOneAxisChanged = false;\n\n    for(var i = 0; i < axList.length; i++) {\n        var ax = axList[i];\n\n        var isNew = (ax._rangeInitial === undefined);\n        var hasChanged = (\n            isNew || !(\n                ax.range[0] === ax._rangeInitial[0] &&\n                ax.range[1] === ax._rangeInitial[1]\n            )\n        );\n\n        if((isNew && ax.autorange === false) || (overwrite && hasChanged)) {\n            ax._rangeInitial = ax.range.slice();\n            hasOneAxisChanged = true;\n        }\n    }\n\n    return hasOneAxisChanged;\n};\n\n// save a copy of the initial spike visibility\naxes.saveShowSpikeInitial = function(gd, overwrite) {\n    var axList = axes.list(gd, '', true),\n        hasOneAxisChanged = false,\n        allEnabled = 'on';\n\n    for(var i = 0; i < axList.length; i++) {\n        var ax = axList[i];\n\n        var isNew = (ax._showSpikeInitial === undefined);\n        var hasChanged = (\n            isNew || !(\n                ax.showspikes === ax._showspikes\n            )\n        );\n\n        if((isNew) || (overwrite && hasChanged)) {\n            ax._showSpikeInitial = ax.showspikes;\n            hasOneAxisChanged = true;\n        }\n\n        if(allEnabled === 'on' && !ax.showspikes) {\n            allEnabled = 'off';\n        }\n    }\n    gd._fullLayout._cartesianSpikesEnabled = allEnabled;\n    return hasOneAxisChanged;\n};\n\n// axes.expand: if autoranging, include new data in the outer limits\n// for this axis\n// data is an array of numbers (ie already run through ax.d2c)\n// available options:\n//      vpad: (number or number array) pad values (data value +-vpad)\n//      ppad: (number or number array) pad pixels (pixel location +-ppad)\n//      ppadplus, ppadminus, vpadplus, vpadminus:\n//          separate padding for each side, overrides symmetric\n//      padded: (boolean) add 5% padding to both ends\n//          (unless one end is overridden by tozero)\n//      tozero: (boolean) make sure to include zero if axis is linear,\n//          and make it a tight bound if possible\naxes.expand = function(ax, data, options) {\n    var needsAutorange = (\n        ax.autorange ||\n        !!Lib.nestedProperty(ax, 'rangeslider.autorange').get()\n    );\n\n    if(!needsAutorange || !data) return;\n\n    if(!ax._min) ax._min = [];\n    if(!ax._max) ax._max = [];\n    if(!options) options = {};\n    if(!ax._m) ax.setScale();\n\n    var len = data.length,\n        extrappad = options.padded ? ax._length * 0.05 : 0,\n        tozero = options.tozero && (ax.type === 'linear' || ax.type === '-'),\n        i, j, v, di, dmin, dmax,\n        ppadiplus, ppadiminus, includeThis, vmin, vmax;\n\n    function getPad(item) {\n        if(Array.isArray(item)) {\n            return function(i) { return Math.max(Number(item[i]||0), 0); };\n        }\n        else {\n            var v = Math.max(Number(item||0), 0);\n            return function() { return v; };\n        }\n    }\n    var ppadplus = getPad((ax._m > 0 ?\n            options.ppadplus : options.ppadminus) || options.ppad || 0),\n        ppadminus = getPad((ax._m > 0 ?\n            options.ppadminus : options.ppadplus) || options.ppad || 0),\n        vpadplus = getPad(options.vpadplus || options.vpad),\n        vpadminus = getPad(options.vpadminus || options.vpad);\n\n    function addItem(i) {\n        di = data[i];\n        if(!isNumeric(di)) return;\n        ppadiplus = ppadplus(i) + extrappad;\n        ppadiminus = ppadminus(i) + extrappad;\n        vmin = di - vpadminus(i);\n        vmax = di + vpadplus(i);\n        // special case for log axes: if vpad makes this object span\n        // more than an order of mag, clip it to one order. This is so\n        // we don't have non-positive errors or absurdly large lower\n        // range due to rounding errors\n        if(ax.type === 'log' && vmin < vmax / 10) { vmin = vmax / 10; }\n\n        dmin = ax.c2l(vmin);\n        dmax = ax.c2l(vmax);\n\n        if(tozero) {\n            dmin = Math.min(0, dmin);\n            dmax = Math.max(0, dmax);\n        }\n\n        // In order to stop overflow errors, don't consider points\n        // too close to the limits of js floating point\n        function goodNumber(v) {\n            return isNumeric(v) && Math.abs(v) < FP_SAFE;\n        }\n\n        if(goodNumber(dmin)) {\n            includeThis = true;\n            // take items v from ax._min and compare them to the\n            // presently active point:\n            // - if the item supercedes the new point, set includethis false\n            // - if the new pt supercedes the item, delete it from ax._min\n            for(j = 0; j < ax._min.length && includeThis; j++) {\n                v = ax._min[j];\n                if(v.val <= dmin && v.pad >= ppadiminus) {\n                    includeThis = false;\n                }\n                else if(v.val >= dmin && v.pad <= ppadiminus) {\n                    ax._min.splice(j, 1);\n                    j--;\n                }\n            }\n            if(includeThis) {\n                ax._min.push({\n                    val: dmin,\n                    pad: (tozero && dmin === 0) ? 0 : ppadiminus\n                });\n            }\n        }\n\n        if(goodNumber(dmax)) {\n            includeThis = true;\n            for(j = 0; j < ax._max.length && includeThis; j++) {\n                v = ax._max[j];\n                if(v.val >= dmax && v.pad >= ppadiplus) {\n                    includeThis = false;\n                }\n                else if(v.val <= dmax && v.pad <= ppadiplus) {\n                    ax._max.splice(j, 1);\n                    j--;\n                }\n            }\n            if(includeThis) {\n                ax._max.push({\n                    val: dmax,\n                    pad: (tozero && dmax === 0) ? 0 : ppadiplus\n                });\n            }\n        }\n    }\n\n    // For efficiency covering monotonic or near-monotonic data,\n    // check a few points at both ends first and then sweep\n    // through the middle\n    for(i = 0; i < 6; i++) addItem(i);\n    for(i = len - 1; i > 5; i--) addItem(i);\n\n};\n\naxes.autoBin = function(data, ax, nbins, is2d, calendar) {\n    var dataMin = Lib.aggNums(Math.min, null, data),\n        dataMax = Lib.aggNums(Math.max, null, data);\n\n    if(!calendar) calendar = ax.calendar;\n\n    if(ax.type === 'category') {\n        return {\n            start: dataMin - 0.5,\n            end: dataMax + 0.5,\n            size: 1\n        };\n    }\n\n    var size0;\n    if(nbins) size0 = ((dataMax - dataMin) / nbins);\n    else {\n        // totally auto: scale off std deviation so the highest bin is\n        // somewhat taller than the total number of bins, but don't let\n        // the size get smaller than the 'nice' rounded down minimum\n        // difference between values\n        var distinctData = Lib.distinctVals(data),\n            msexp = Math.pow(10, Math.floor(\n                Math.log(distinctData.minDiff) / Math.LN10)),\n            minSize = msexp * Lib.roundUp(\n                distinctData.minDiff / msexp, [0.9, 1.9, 4.9, 9.9], true);\n        size0 = Math.max(minSize, 2 * Lib.stdev(data) /\n            Math.pow(data.length, is2d ? 0.25 : 0.4));\n\n        // fallback if ax.d2c output BADNUMs\n        // e.g. when user try to plot categorical bins\n        // on a layout.xaxis.type: 'linear'\n        if(!isNumeric(size0)) size0 = 1;\n    }\n\n    // piggyback off autotick code to make \"nice\" bin sizes\n    var dummyAx;\n    if(ax.type === 'log') {\n        dummyAx = {\n            type: 'linear',\n            range: [dataMin, dataMax]\n        };\n    }\n    else {\n        dummyAx = {\n            type: ax.type,\n            range: Lib.simpleMap([dataMin, dataMax], ax.c2r, 0, calendar),\n            calendar: calendar\n        };\n    }\n    axes.setConvert(dummyAx);\n\n    axes.autoTicks(dummyAx, size0);\n    var binStart = axes.tickIncrement(\n            axes.tickFirst(dummyAx), dummyAx.dtick, 'reverse', calendar),\n        binEnd;\n\n    // check for too many data points right at the edges of bins\n    // (>50% within 1% of bin edges) or all data points integral\n    // and offset the bins accordingly\n    if(typeof dummyAx.dtick === 'number') {\n        binStart = autoShiftNumericBins(binStart, data, dummyAx, dataMin, dataMax);\n\n        var bincount = 1 + Math.floor((dataMax - binStart) / dummyAx.dtick);\n        binEnd = binStart + bincount * dummyAx.dtick;\n    }\n    else {\n        // month ticks - should be the only nonlinear kind we have at this point.\n        // dtick (as supplied by axes.autoTick) only has nonlinear values on\n        // date and log axes, but even if you display a histogram on a log axis\n        // we bin it on a linear axis (which one could argue against, but that's\n        // a separate issue)\n        if(dummyAx.dtick.charAt(0) === 'M') {\n            binStart = autoShiftMonthBins(binStart, data, dummyAx.dtick, dataMin, calendar);\n        }\n\n        // calculate the endpoint for nonlinear ticks - you have to\n        // just increment until you're done\n        binEnd = binStart;\n        while(binEnd <= dataMax) {\n            binEnd = axes.tickIncrement(binEnd, dummyAx.dtick, false, calendar);\n        }\n    }\n\n    return {\n        start: ax.c2r(binStart, 0, calendar),\n        end: ax.c2r(binEnd, 0, calendar),\n        size: dummyAx.dtick\n    };\n};\n\n\nfunction autoShiftNumericBins(binStart, data, ax, dataMin, dataMax) {\n    var edgecount = 0,\n        midcount = 0,\n        intcount = 0,\n        blankCount = 0;\n\n    function nearEdge(v) {\n        // is a value within 1% of a bin edge?\n        return (1 + (v - binStart) * 100 / ax.dtick) % 100 < 2;\n    }\n\n    for(var i = 0; i < data.length; i++) {\n        if(data[i] % 1 === 0) intcount++;\n        else if(!isNumeric(data[i])) blankCount++;\n\n        if(nearEdge(data[i])) edgecount++;\n        if(nearEdge(data[i] + ax.dtick / 2)) midcount++;\n    }\n    var dataCount = data.length - blankCount;\n\n    if(intcount === dataCount && ax.type !== 'date') {\n        // all integers: if bin size is <1, it's because\n        // that was specifically requested (large nbins)\n        // so respect that... but center the bins containing\n        // integers on those integers\n        if(ax.dtick < 1) {\n            binStart = dataMin - 0.5 * ax.dtick;\n        }\n        // otherwise start half an integer down regardless of\n        // the bin size, just enough to clear up endpoint\n        // ambiguity about which integers are in which bins.\n        else {\n            binStart -= 0.5;\n            if(binStart + ax.dtick < dataMin) binStart += ax.dtick;\n        }\n    }\n    else if(midcount < dataCount * 0.1) {\n        if(edgecount > dataCount * 0.3 ||\n                nearEdge(dataMin) || nearEdge(dataMax)) {\n            // lots of points at the edge, not many in the middle\n            // shift half a bin\n            var binshift = ax.dtick / 2;\n            binStart += (binStart + binshift < dataMin) ? binshift : -binshift;\n        }\n    }\n    return binStart;\n}\n\n\nfunction autoShiftMonthBins(binStart, data, dtick, dataMin, calendar) {\n    var stats = Lib.findExactDates(data, calendar);\n    // number of data points that needs to be an exact value\n    // to shift that increment to (near) the bin center\n    var threshold = 0.8;\n\n    if(stats.exactDays > threshold) {\n        var numMonths = Number(dtick.substr(1));\n\n        if((stats.exactYears > threshold) && (numMonths % 12 === 0)) {\n            // The exact middle of a non-leap-year is 1.5 days into July\n            // so if we start the bins here, all but leap years will\n            // get hover-labeled as exact years.\n            binStart = axes.tickIncrement(binStart, 'M6', 'reverse') + ONEDAY * 1.5;\n        }\n        else if(stats.exactMonths > threshold) {\n            // Months are not as clean, but if we shift half the *longest*\n            // month (31/2 days) then 31-day months will get labeled exactly\n            // and shorter months will get labeled with the correct month\n            // but shifted 12-36 hours into it.\n            binStart = axes.tickIncrement(binStart, 'M1', 'reverse') + ONEDAY * 15.5;\n        }\n        else {\n            // Shifting half a day is exact, but since these are month bins it\n            // will always give a somewhat odd-looking label, until we do something\n            // smarter like showing the bin boundaries (or the bounds of the actual\n            // data in each bin)\n            binStart -= ONEDAY / 2;\n        }\n        var nextBinStart = axes.tickIncrement(binStart, dtick);\n\n        if(nextBinStart <= dataMin) return nextBinStart;\n    }\n    return binStart;\n}\n\n// ----------------------------------------------------\n// Ticks and grids\n// ----------------------------------------------------\n\n// calculate the ticks: text, values, positioning\n// if ticks are set to automatic, determine the right values (tick0,dtick)\n// in any case, set tickround to # of digits to round tick labels to,\n// or codes to this effect for log and date scales\naxes.calcTicks = function calcTicks(ax) {\n    var rng = Lib.simpleMap(ax.range, ax.r2l);\n\n    // calculate max number of (auto) ticks to display based on plot size\n    if(ax.tickmode === 'auto' || !ax.dtick) {\n        var nt = ax.nticks,\n            minPx;\n        if(!nt) {\n            if(ax.type === 'category') {\n                minPx = ax.tickfont ? (ax.tickfont.size || 12) * 1.2 : 15;\n                nt = ax._length / minPx;\n            }\n            else {\n                minPx = ax._id.charAt(0) === 'y' ? 40 : 80;\n                nt = Lib.constrain(ax._length / minPx, 4, 9) + 1;\n            }\n        }\n\n        // add a couple of extra digits for filling in ticks when we\n        // have explicit tickvals without tick text\n        if(ax.tickmode === 'array') nt *= 100;\n\n        axes.autoTicks(ax, Math.abs(rng[1] - rng[0]) / nt);\n        // check for a forced minimum dtick\n        if(ax._minDtick > 0 && ax.dtick < ax._minDtick * 2) {\n            ax.dtick = ax._minDtick;\n            ax.tick0 = ax.l2r(ax._forceTick0);\n        }\n    }\n\n    // check for missing tick0\n    if(!ax.tick0) {\n        ax.tick0 = (ax.type === 'date') ? '2000-01-01' : 0;\n    }\n\n    // now figure out rounding of tick values\n    autoTickRound(ax);\n\n    // now that we've figured out the auto values for formatting\n    // in case we're missing some ticktext, we can break out for array ticks\n    if(ax.tickmode === 'array') return arrayTicks(ax);\n\n    // find the first tick\n    ax._tmin = axes.tickFirst(ax);\n\n    // check for reversed axis\n    var axrev = (rng[1] < rng[0]);\n\n    // return the full set of tick vals\n    var vals = [],\n        // add a tiny bit so we get ticks which may have rounded out\n        endtick = rng[1] * 1.0001 - rng[0] * 0.0001;\n    if(ax.type === 'category') {\n        endtick = (axrev) ? Math.max(-0.5, endtick) :\n            Math.min(ax._categories.length - 0.5, endtick);\n    }\n    for(var x = ax._tmin;\n            (axrev) ? (x >= endtick) : (x <= endtick);\n            x = axes.tickIncrement(x, ax.dtick, axrev, ax.calendar)) {\n        vals.push(x);\n\n        // prevent infinite loops\n        if(vals.length > 1000) break;\n    }\n\n    // save the last tick as well as first, so we can\n    // show the exponent only on the last one\n    ax._tmax = vals[vals.length - 1];\n\n    // for showing the rest of a date when the main tick label is only the\n    // latter part: ax._prevDateHead holds what we showed most recently.\n    // Start with it cleared and mark that we're in calcTicks (ie calculating a\n    // whole string of these so we should care what the previous date head was!)\n    ax._prevDateHead = '';\n    ax._inCalcTicks = true;\n\n    var ticksOut = new Array(vals.length);\n    for(var i = 0; i < vals.length; i++) ticksOut[i] = axes.tickText(ax, vals[i]);\n\n    ax._inCalcTicks = false;\n\n    return ticksOut;\n};\n\nfunction arrayTicks(ax) {\n    var vals = ax.tickvals,\n        text = ax.ticktext,\n        ticksOut = new Array(vals.length),\n        rng = Lib.simpleMap(ax.range, ax.r2l),\n        r0expanded = rng[0] * 1.0001 - rng[1] * 0.0001,\n        r1expanded = rng[1] * 1.0001 - rng[0] * 0.0001,\n        tickMin = Math.min(r0expanded, r1expanded),\n        tickMax = Math.max(r0expanded, r1expanded),\n        vali,\n        i,\n        j = 0;\n\n    // without a text array, just format the given values as any other ticks\n    // except with more precision to the numbers\n    if(!Array.isArray(text)) text = [];\n\n    // make sure showing ticks doesn't accidentally add new categories\n    var tickVal2l = ax.type === 'category' ? ax.d2l_noadd : ax.d2l;\n\n    // array ticks on log axes always show the full number\n    // (if no explicit ticktext overrides it)\n    if(ax.type === 'log' && String(ax.dtick).charAt(0) !== 'L') {\n        ax.dtick = 'L' + Math.pow(10, Math.floor(Math.min(ax.range[0], ax.range[1])) - 1);\n    }\n\n    for(i = 0; i < vals.length; i++) {\n        vali = tickVal2l(vals[i]);\n        if(vali > tickMin && vali < tickMax) {\n            if(text[i] === undefined) ticksOut[j] = axes.tickText(ax, vali);\n            else ticksOut[j] = tickTextObj(ax, vali, String(text[i]));\n            j++;\n        }\n    }\n\n    if(j < vals.length) ticksOut.splice(j, vals.length - j);\n\n    return ticksOut;\n}\n\nvar roundBase10 = [2, 5, 10],\n    roundBase24 = [1, 2, 3, 6, 12],\n    roundBase60 = [1, 2, 5, 10, 15, 30],\n    // 2&3 day ticks are weird, but need something btwn 1&7\n    roundDays = [1, 2, 3, 7, 14],\n    // approx. tick positions for log axes, showing all (1) and just 1, 2, 5 (2)\n    // these don't have to be exact, just close enough to round to the right value\n    roundLog1 = [-0.046, 0, 0.301, 0.477, 0.602, 0.699, 0.778, 0.845, 0.903, 0.954, 1],\n    roundLog2 = [-0.301, 0, 0.301, 0.699, 1];\n\nfunction roundDTick(roughDTick, base, roundingSet) {\n    return base * Lib.roundUp(roughDTick / base, roundingSet);\n}\n\n// autoTicks: calculate best guess at pleasant ticks for this axis\n// inputs:\n//      ax - an axis object\n//      roughDTick - rough tick spacing (to be turned into a nice round number)\n// outputs (into ax):\n//   tick0: starting point for ticks (not necessarily on the graph)\n//      usually 0 for numeric (=10^0=1 for log) or jan 1, 2000 for dates\n//   dtick: the actual, nice round tick spacing, usually a little larger than roughDTick\n//      if the ticks are spaced linearly (linear scale, categories,\n//          log with only full powers, date ticks < month),\n//          this will just be a number\n//      months: M#\n//      years: M# where # is 12*number of years\n//      log with linear ticks: L# where # is the linear tick spacing\n//      log showing powers plus some intermediates:\n//          D1 shows all digits, D2 shows 2 and 5\naxes.autoTicks = function(ax, roughDTick) {\n    var base;\n\n    if(ax.type === 'date') {\n        ax.tick0 = Lib.dateTick0(ax.calendar);\n        // the criteria below are all based on the rough spacing we calculate\n        // being > half of the final unit - so precalculate twice the rough val\n        var roughX2 = 2 * roughDTick;\n\n        if(roughX2 > ONEAVGYEAR) {\n            roughDTick /= ONEAVGYEAR;\n            base = Math.pow(10, Math.floor(Math.log(roughDTick) / Math.LN10));\n            ax.dtick = 'M' + (12 * roundDTick(roughDTick, base, roundBase10));\n        }\n        else if(roughX2 > ONEAVGMONTH) {\n            roughDTick /= ONEAVGMONTH;\n            ax.dtick = 'M' + roundDTick(roughDTick, 1, roundBase24);\n        }\n        else if(roughX2 > ONEDAY) {\n            ax.dtick = roundDTick(roughDTick, ONEDAY, roundDays);\n            // get week ticks on sunday\n            // this will also move the base tick off 2000-01-01 if dtick is\n            // 2 or 3 days... but that's a weird enough case that we'll ignore it.\n            ax.tick0 = Lib.dateTick0(ax.calendar, true);\n        }\n        else if(roughX2 > ONEHOUR) {\n            ax.dtick = roundDTick(roughDTick, ONEHOUR, roundBase24);\n        }\n        else if(roughX2 > ONEMIN) {\n            ax.dtick = roundDTick(roughDTick, ONEMIN, roundBase60);\n        }\n        else if(roughX2 > ONESEC) {\n            ax.dtick = roundDTick(roughDTick, ONESEC, roundBase60);\n        }\n        else {\n            // milliseconds\n            base = Math.pow(10, Math.floor(Math.log(roughDTick) / Math.LN10));\n            ax.dtick = roundDTick(roughDTick, base, roundBase10);\n        }\n    }\n    else if(ax.type === 'log') {\n        ax.tick0 = 0;\n        var rng = Lib.simpleMap(ax.range, ax.r2l);\n\n        if(roughDTick > 0.7) {\n            // only show powers of 10\n            ax.dtick = Math.ceil(roughDTick);\n        }\n        else if(Math.abs(rng[1] - rng[0]) < 1) {\n            // span is less than one power of 10\n            var nt = 1.5 * Math.abs((rng[1] - rng[0]) / roughDTick);\n\n            // ticks on a linear scale, labeled fully\n            roughDTick = Math.abs(Math.pow(10, rng[1]) -\n                Math.pow(10, rng[0])) / nt;\n            base = Math.pow(10, Math.floor(Math.log(roughDTick) / Math.LN10));\n            ax.dtick = 'L' + roundDTick(roughDTick, base, roundBase10);\n        }\n        else {\n            // include intermediates between powers of 10,\n            // labeled with small digits\n            // ax.dtick = \"D2\" (show 2 and 5) or \"D1\" (show all digits)\n            ax.dtick = (roughDTick > 0.3) ? 'D2' : 'D1';\n        }\n    }\n    else if(ax.type === 'category') {\n        ax.tick0 = 0;\n        ax.dtick = Math.ceil(Math.max(roughDTick, 1));\n    }\n    else {\n        // auto ticks always start at 0\n        ax.tick0 = 0;\n        base = Math.pow(10, Math.floor(Math.log(roughDTick) / Math.LN10));\n        ax.dtick = roundDTick(roughDTick, base, roundBase10);\n    }\n\n    // prevent infinite loops\n    if(ax.dtick === 0) ax.dtick = 1;\n\n    // TODO: this is from log axis histograms with autorange off\n    if(!isNumeric(ax.dtick) && typeof ax.dtick !== 'string') {\n        var olddtick = ax.dtick;\n        ax.dtick = 1;\n        throw 'ax.dtick error: ' + String(olddtick);\n    }\n};\n\n// after dtick is already known, find tickround = precision\n// to display in tick labels\n//   for numeric ticks, integer # digits after . to round to\n//   for date ticks, the last date part to show (y,m,d,H,M,S)\n//      or an integer # digits past seconds\nfunction autoTickRound(ax) {\n    var dtick = ax.dtick;\n\n    ax._tickexponent = 0;\n    if(!isNumeric(dtick) && typeof dtick !== 'string') {\n        dtick = 1;\n    }\n\n    if(ax.type === 'category') {\n        ax._tickround = null;\n    }\n    if(ax.type === 'date') {\n        // If tick0 is unusual, give tickround a bit more information\n        // not necessarily *all* the information in tick0 though, if it's really odd\n        // minimal string length for tick0: 'd' is 10, 'M' is 16, 'S' is 19\n        // take off a leading minus (year < 0) and i (intercalary month) so length is consistent\n        var tick0ms = ax.r2l(ax.tick0),\n            tick0str = ax.l2r(tick0ms).replace(/(^-|i)/g, ''),\n            tick0len = tick0str.length;\n\n        if(String(dtick).charAt(0) === 'M') {\n            // any tick0 more specific than a year: alway show the full date\n            if(tick0len > 10 || tick0str.substr(5) !== '01-01') ax._tickround = 'd';\n            // show the month unless ticks are full multiples of a year\n            else ax._tickround = (+(dtick.substr(1)) % 12 === 0) ? 'y' : 'm';\n        }\n        else if((dtick >= ONEDAY && tick0len <= 10) || (dtick >= ONEDAY * 15)) ax._tickround = 'd';\n        else if((dtick >= ONEMIN && tick0len <= 16) || (dtick >= ONEHOUR)) ax._tickround = 'M';\n        else if((dtick >= ONESEC && tick0len <= 19) || (dtick >= ONEMIN)) ax._tickround = 'S';\n        else {\n            // tickround is a number of digits of fractional seconds\n            // of any two adjacent ticks, at least one will have the maximum fractional digits\n            // of all possible ticks - so take the max. length of tick0 and the next one\n            var tick1len = ax.l2r(tick0ms + dtick).replace(/^-/, '').length;\n            ax._tickround = Math.max(tick0len, tick1len) - 20;\n        }\n    }\n    else if(isNumeric(dtick) || dtick.charAt(0) === 'L') {\n        // linear or log (except D1, D2)\n        var rng = ax.range.map(ax.r2d || Number);\n        if(!isNumeric(dtick)) dtick = Number(dtick.substr(1));\n        // 2 digits past largest digit of dtick\n        ax._tickround = 2 - Math.floor(Math.log(dtick) / Math.LN10 + 0.01);\n\n        var maxend = Math.max(Math.abs(rng[0]), Math.abs(rng[1]));\n\n        var rangeexp = Math.floor(Math.log(maxend) / Math.LN10 + 0.01);\n        if(Math.abs(rangeexp) > 3) {\n            if(ax.exponentformat === 'SI' || ax.exponentformat === 'B') {\n                ax._tickexponent = 3 * Math.round((rangeexp - 1) / 3);\n            }\n            else ax._tickexponent = rangeexp;\n        }\n    }\n    // D1 or D2 (log)\n    else ax._tickround = null;\n}\n\n// months and years don't have constant millisecond values\n// (but a year is always 12 months so we only need months)\n// log-scale ticks are also not consistently spaced, except\n// for pure powers of 10\n// numeric ticks always have constant differences, other datetime ticks\n// can all be calculated as constant number of milliseconds\naxes.tickIncrement = function(x, dtick, axrev, calendar) {\n    var axSign = axrev ? -1 : 1;\n\n    // includes linear, all dates smaller than month, and pure 10^n in log\n    if(isNumeric(dtick)) return x + axSign * dtick;\n\n    // everything else is a string, one character plus a number\n    var tType = dtick.charAt(0),\n        dtSigned = axSign * Number(dtick.substr(1));\n\n    // Dates: months (or years - see Lib.incrementMonth)\n    if(tType === 'M') return Lib.incrementMonth(x, dtSigned, calendar);\n\n    // Log scales: Linear, Digits\n    else if(tType === 'L') return Math.log(Math.pow(10, x) + dtSigned) / Math.LN10;\n\n    // log10 of 2,5,10, or all digits (logs just have to be\n    // close enough to round)\n    else if(tType === 'D') {\n        var tickset = (dtick === 'D2') ? roundLog2 : roundLog1,\n            x2 = x + axSign * 0.01,\n            frac = Lib.roundUp(Lib.mod(x2, 1), tickset, axrev);\n\n        return Math.floor(x2) +\n            Math.log(d3.round(Math.pow(10, frac), 1)) / Math.LN10;\n    }\n    else throw 'unrecognized dtick ' + String(dtick);\n};\n\n// calculate the first tick on an axis\naxes.tickFirst = function(ax) {\n    var r2l = ax.r2l || Number,\n        rng = Lib.simpleMap(ax.range, r2l),\n        axrev = rng[1] < rng[0],\n        sRound = axrev ? Math.floor : Math.ceil,\n        // add a tiny extra bit to make sure we get ticks\n        // that may have been rounded out\n        r0 = rng[0] * 1.0001 - rng[1] * 0.0001,\n        dtick = ax.dtick,\n        tick0 = r2l(ax.tick0);\n\n    if(isNumeric(dtick)) {\n        var tmin = sRound((r0 - tick0) / dtick) * dtick + tick0;\n\n        // make sure no ticks outside the category list\n        if(ax.type === 'category') {\n            tmin = Lib.constrain(tmin, 0, ax._categories.length - 1);\n        }\n        return tmin;\n    }\n\n    var tType = dtick.charAt(0),\n        dtNum = Number(dtick.substr(1));\n\n    // Dates: months (or years)\n    if(tType === 'M') {\n        var cnt = 0,\n            t0 = tick0,\n            t1,\n            mult,\n            newDTick;\n\n        // This algorithm should work for *any* nonlinear (but close to linear!)\n        // tick spacing. Limit to 10 iterations, for gregorian months it's normally <=3.\n        while(cnt < 10) {\n            t1 = axes.tickIncrement(t0, dtick, axrev, ax.calendar);\n            if((t1 - r0) * (t0 - r0) <= 0) {\n                // t1 and t0 are on opposite sides of r0! we've succeeded!\n                if(axrev) return Math.min(t0, t1);\n                return Math.max(t0, t1);\n            }\n            mult = (r0 - ((t0 + t1) / 2)) / (t1 - t0);\n            newDTick = tType + ((Math.abs(Math.round(mult)) || 1) * dtNum);\n            t0 = axes.tickIncrement(t0, newDTick, mult < 0 ? !axrev : axrev, ax.calendar);\n            cnt++;\n        }\n        Lib.error('tickFirst did not converge', ax);\n        return t0;\n    }\n\n    // Log scales: Linear, Digits\n    else if(tType === 'L') {\n        return Math.log(sRound(\n            (Math.pow(10, r0) - tick0) / dtNum) * dtNum + tick0) / Math.LN10;\n    }\n    else if(tType === 'D') {\n        var tickset = (dtick === 'D2') ? roundLog2 : roundLog1,\n            frac = Lib.roundUp(Lib.mod(r0, 1), tickset, axrev);\n\n        return Math.floor(r0) +\n            Math.log(d3.round(Math.pow(10, frac), 1)) / Math.LN10;\n    }\n    else throw 'unrecognized dtick ' + String(dtick);\n};\n\n// draw the text for one tick.\n// px,py are the location on gd.paper\n// prefix is there so the x axis ticks can be dropped a line\n// ax is the axis layout, x is the tick value\n// hover is a (truthy) flag for whether to show numbers with a bit\n// more precision for hovertext\naxes.tickText = function(ax, x, hover) {\n    var out = tickTextObj(ax, x),\n        hideexp,\n        arrayMode = ax.tickmode === 'array',\n        extraPrecision = hover || arrayMode,\n        i,\n        tickVal2l = ax.type === 'category' ? ax.d2l_noadd : ax.d2l;\n\n    if(arrayMode && Array.isArray(ax.ticktext)) {\n        var rng = Lib.simpleMap(ax.range, ax.r2l),\n            minDiff = Math.abs(rng[1] - rng[0]) / 10000;\n        for(i = 0; i < ax.ticktext.length; i++) {\n            if(Math.abs(x - tickVal2l(ax.tickvals[i])) < minDiff) break;\n        }\n        if(i < ax.ticktext.length) {\n            out.text = String(ax.ticktext[i]);\n            return out;\n        }\n    }\n\n    function isHidden(showAttr) {\n        var first_or_last;\n\n        if(showAttr === undefined) return true;\n        if(hover) return showAttr === 'none';\n\n        first_or_last = {\n            first: ax._tmin,\n            last: ax._tmax\n        }[showAttr];\n\n        return showAttr !== 'all' && x !== first_or_last;\n    }\n\n    hideexp = ax.exponentformat !== 'none' && isHidden(ax.showexponent) ? 'hide' : '';\n\n    if(ax.type === 'date') formatDate(ax, out, hover, extraPrecision);\n    else if(ax.type === 'log') formatLog(ax, out, hover, extraPrecision, hideexp);\n    else if(ax.type === 'category') formatCategory(ax, out);\n    else formatLinear(ax, out, hover, extraPrecision, hideexp);\n\n    // add prefix and suffix\n    if(ax.tickprefix && !isHidden(ax.showtickprefix)) out.text = ax.tickprefix + out.text;\n    if(ax.ticksuffix && !isHidden(ax.showticksuffix)) out.text += ax.ticksuffix;\n\n    return out;\n};\n\nfunction tickTextObj(ax, x, text) {\n    var tf = ax.tickfont || {};\n\n    return {\n        x: x,\n        dx: 0,\n        dy: 0,\n        text: text || '',\n        fontSize: tf.size,\n        font: tf.family,\n        fontColor: tf.color\n    };\n}\n\nfunction formatDate(ax, out, hover, extraPrecision) {\n    var tr = ax._tickround,\n        fmt = (hover && ax.hoverformat) || ax.tickformat;\n\n    if(extraPrecision) {\n        // second or sub-second precision: extra always shows max digits.\n        // for other fields, extra precision just adds one field.\n        if(isNumeric(tr)) tr = 4;\n        else tr = {y: 'm', m: 'd', d: 'M', M: 'S', S: 4}[tr];\n    }\n\n    var dateStr = Lib.formatDate(out.x, fmt, tr, ax.calendar),\n        headStr;\n\n    var splitIndex = dateStr.indexOf('\\n');\n    if(splitIndex !== -1) {\n        headStr = dateStr.substr(splitIndex + 1);\n        dateStr = dateStr.substr(0, splitIndex);\n    }\n\n    if(extraPrecision) {\n        // if extraPrecision led to trailing zeros, strip them off\n        // actually, this can lead to removing even more zeros than\n        // in the original rounding, but that's fine because in these\n        // contexts uniformity is not so important (if there's even\n        // anything to be uniform with!)\n\n        // can we remove the whole time part?\n        if(dateStr === '00:00:00' || dateStr === '00:00') {\n            dateStr = headStr;\n            headStr = '';\n        }\n        else if(dateStr.length === 8) {\n            // strip off seconds if they're zero (zero fractional seconds\n            // are already omitted)\n            // but we never remove minutes and leave just hours\n            dateStr = dateStr.replace(/:00$/, '');\n        }\n    }\n\n    if(headStr) {\n        if(hover) {\n            // hover puts it all on one line, so headPart works best up front\n            // except for year headPart: turn this into \"Jan 1, 2000\" etc.\n            if(tr === 'd') dateStr += ', ' + headStr;\n            else dateStr = headStr + (dateStr ? ', ' + dateStr : '');\n        }\n        else if(!ax._inCalcTicks || (headStr !== ax._prevDateHead)) {\n            dateStr += '<br>' + headStr;\n            ax._prevDateHead = headStr;\n        }\n    }\n\n    out.text = dateStr;\n}\n\nfunction formatLog(ax, out, hover, extraPrecision, hideexp) {\n    var dtick = ax.dtick,\n        x = out.x;\n    if(extraPrecision && ((typeof dtick !== 'string') || dtick.charAt(0) !== 'L')) dtick = 'L3';\n\n    if(ax.tickformat || (typeof dtick === 'string' && dtick.charAt(0) === 'L')) {\n        out.text = numFormat(Math.pow(10, x), ax, hideexp, extraPrecision);\n    }\n    else if(isNumeric(dtick) || ((dtick.charAt(0) === 'D') && (Lib.mod(x + 0.01, 1) < 0.1))) {\n        if(['e', 'E', 'power'].indexOf(ax.exponentformat) !== -1) {\n            var p = Math.round(x);\n            if(p === 0) out.text = 1;\n            else if(p === 1) out.text = '10';\n            else if(p > 1) out.text = '10<sup>' + p + '</sup>';\n            else out.text = '10<sup>\\u2212' + -p + '</sup>';\n\n            out.fontSize *= 1.25;\n        }\n        else {\n            out.text = numFormat(Math.pow(10, x), ax, '', 'fakehover');\n            if(dtick === 'D1' && ax._id.charAt(0) === 'y') {\n                out.dy -= out.fontSize / 6;\n            }\n        }\n    }\n    else if(dtick.charAt(0) === 'D') {\n        out.text = String(Math.round(Math.pow(10, Lib.mod(x, 1))));\n        out.fontSize *= 0.75;\n    }\n    else throw 'unrecognized dtick ' + String(dtick);\n\n    // if 9's are printed on log scale, move the 10's away a bit\n    if(ax.dtick === 'D1') {\n        var firstChar = String(out.text).charAt(0);\n        if(firstChar === '0' || firstChar === '1') {\n            if(ax._id.charAt(0) === 'y') {\n                out.dx -= out.fontSize / 4;\n            }\n            else {\n                out.dy += out.fontSize / 2;\n                out.dx += (ax.range[1] > ax.range[0] ? 1 : -1) *\n                    out.fontSize * (x < 0 ? 0.5 : 0.25);\n            }\n        }\n    }\n}\n\nfunction formatCategory(ax, out) {\n    var tt = ax._categories[Math.round(out.x)];\n    if(tt === undefined) tt = '';\n    out.text = String(tt);\n}\n\nfunction formatLinear(ax, out, hover, extraPrecision, hideexp) {\n    // don't add an exponent to zero if we're showing all exponents\n    // so the only reason you'd show an exponent on zero is if it's the\n    // ONLY tick to get an exponent (first or last)\n    if(ax.showexponent === 'all' && Math.abs(out.x / ax.dtick) < 1e-6) {\n        hideexp = 'hide';\n    }\n    out.text = numFormat(out.x, ax, hideexp, extraPrecision);\n}\n\n// format a number (tick value) according to the axis settings\n// new, more reliable procedure than d3.round or similar:\n// add half the rounding increment, then stringify and truncate\n// also automatically switch to sci. notation\nvar SIPREFIXES = ['f', 'p', 'n', '', 'm', '', 'k', 'M', 'G', 'T'];\n\nfunction numFormat(v, ax, fmtoverride, hover) {\n        // negative?\n    var isNeg = v < 0,\n        // max number of digits past decimal point to show\n        tickRound = ax._tickround,\n        exponentFormat = fmtoverride || ax.exponentformat || 'B',\n        exponent = ax._tickexponent,\n        tickformat = ax.tickformat,\n        separatethousands = ax.separatethousands;\n\n    // special case for hover: set exponent just for this value, and\n    // add a couple more digits of precision over tick labels\n    if(hover) {\n        // make a dummy axis obj to get the auto rounding and exponent\n        var ah = {\n            exponentformat: ax.exponentformat,\n            dtick: ax.showexponent === 'none' ? ax.dtick :\n                (isNumeric(v) ? Math.abs(v) || 1 : 1),\n            // if not showing any exponents, don't change the exponent\n            // from what we calculate\n            range: ax.showexponent === 'none' ? ax.range.map(ax.r2d) : [0, v || 1]\n        };\n        autoTickRound(ah);\n        tickRound = (Number(ah._tickround) || 0) + 4;\n        exponent = ah._tickexponent;\n        if(ax.hoverformat) tickformat = ax.hoverformat;\n    }\n\n    if(tickformat) return d3.format(tickformat)(v).replace(/-/g, '\\u2212');\n\n    // 'epsilon' - rounding increment\n    var e = Math.pow(10, -tickRound) / 2;\n\n    // exponentFormat codes:\n    // 'e' (1.2e+6, default)\n    // 'E' (1.2E+6)\n    // 'SI' (1.2M)\n    // 'B' (same as SI except 10^9=B not G)\n    // 'none' (1200000)\n    // 'power' (1.2x10^6)\n    // 'hide' (1.2, use 3rd argument=='hide' to eg\n    //      only show exponent on last tick)\n    if(exponentFormat === 'none') exponent = 0;\n\n    // take the sign out, put it back manually at the end\n    // - makes cases easier\n    v = Math.abs(v);\n    if(v < e) {\n        // 0 is just 0, but may get exponent if it's the last tick\n        v = '0';\n        isNeg = false;\n    }\n    else {\n        v += e;\n        // take out a common exponent, if any\n        if(exponent) {\n            v *= Math.pow(10, -exponent);\n            tickRound += exponent;\n        }\n        // round the mantissa\n        if(tickRound === 0) v = String(Math.floor(v));\n        else if(tickRound < 0) {\n            v = String(Math.round(v));\n            v = v.substr(0, v.length + tickRound);\n            for(var i = tickRound; i < 0; i++) v += '0';\n        }\n        else {\n            v = String(v);\n            var dp = v.indexOf('.') + 1;\n            if(dp) v = v.substr(0, dp + tickRound).replace(/\\.?0+$/, '');\n        }\n        // insert appropriate decimal point and thousands separator\n        v = Lib.numSeparate(v, ax._separators, separatethousands);\n    }\n\n    // add exponent\n    if(exponent && exponentFormat !== 'hide') {\n        var signedExponent;\n        if(exponent < 0) signedExponent = '\\u2212' + -exponent;\n        else if(exponentFormat !== 'power') signedExponent = '+' + exponent;\n        else signedExponent = String(exponent);\n\n        if(exponentFormat === 'e' ||\n                ((exponentFormat === 'SI' || exponentFormat === 'B') &&\n                 (exponent > 12 || exponent < -15))) {\n            v += 'e' + signedExponent;\n        }\n        else if(exponentFormat === 'E') {\n            v += 'E' + signedExponent;\n        }\n        else if(exponentFormat === 'power') {\n            v += '10<sup>' + signedExponent + '</sup>';\n        }\n        else if(exponentFormat === 'B' && exponent === 9) {\n            v += 'B';\n        }\n        else if(exponentFormat === 'SI' || exponentFormat === 'B') {\n            v += SIPREFIXES[exponent / 3 + 5];\n        }\n    }\n\n    // put sign back in and return\n    // replace standard minus character (which is technically a hyphen)\n    // with a true minus sign\n    if(isNeg) return '\\u2212' + v;\n    return v;\n}\n\n\naxes.subplotMatch = /^x([0-9]*)y([0-9]*)$/;\n\n// getSubplots - extract all combinations of axes we need to make plots for\n// as an array of items like 'xy', 'x2y', 'x2y2'...\n// sorted by x (x,x2,x3...) then y\n// optionally restrict to only subplots containing axis object ax\n// looks both for combinations of x and y found in the data\n// and at axes and their anchors\naxes.getSubplots = function(gd, ax) {\n    var subplots = [];\n    var i, j, sp;\n\n    // look for subplots in the data\n    var data = gd._fullData || gd.data || [];\n\n    for(i = 0; i < data.length; i++) {\n        var trace = data[i];\n\n        if(trace.visible === false || trace.visible === 'legendonly' ||\n            !(Registry.traceIs(trace, 'cartesian') || Registry.traceIs(trace, 'gl2d'))\n        ) continue;\n\n        var xId = trace.xaxis || 'x',\n            yId = trace.yaxis || 'y';\n        sp = xId + yId;\n\n        if(subplots.indexOf(sp) === -1) subplots.push(sp);\n    }\n\n    // look for subplots in the axes/anchors, so that we at least draw all axes\n    var axesList = axes.list(gd, '', true);\n\n    function hasAx2(sp, ax2) {\n        return sp.indexOf(ax2._id) !== -1;\n    }\n\n    for(i = 0; i < axesList.length; i++) {\n        var ax2 = axesList[i],\n            ax2Letter = ax2._id.charAt(0),\n            ax3Id = (ax2.anchor === 'free') ?\n                ((ax2Letter === 'x') ? 'y' : 'x') :\n                ax2.anchor,\n            ax3 = axes.getFromId(gd, ax3Id);\n\n        // look if ax2 is already represented in the data\n        var foundAx2 = false;\n        for(j = 0; j < subplots.length; j++) {\n            if(hasAx2(subplots[j], ax2)) {\n                foundAx2 = true;\n                break;\n            }\n        }\n\n        // ignore free axes that already represented in the data\n        if(ax2.anchor === 'free' && foundAx2) continue;\n\n        // ignore anchor-less axes\n        if(!ax3) continue;\n\n        sp = (ax2Letter === 'x') ?\n            ax2._id + ax3._id :\n            ax3._id + ax2._id;\n\n        if(subplots.indexOf(sp) === -1) subplots.push(sp);\n    }\n\n    // filter invalid subplots\n    var spMatch = axes.subplotMatch,\n        allSubplots = [];\n\n    for(i = 0; i < subplots.length; i++) {\n        sp = subplots[i];\n        if(spMatch.test(sp)) allSubplots.push(sp);\n    }\n\n    // sort the subplot ids\n    allSubplots.sort(function(a, b) {\n        var aMatch = a.match(spMatch),\n            bMatch = b.match(spMatch);\n\n        if(aMatch[1] === bMatch[1]) {\n            return +(aMatch[2] || 1) - (bMatch[2] || 1);\n        }\n\n        return +(aMatch[1]||0) - (bMatch[1]||0);\n    });\n\n    if(ax) return axes.findSubplotsWithAxis(allSubplots, ax);\n    return allSubplots;\n};\n\n// find all subplots with axis 'ax'\naxes.findSubplotsWithAxis = function(subplots, ax) {\n    var axMatch = new RegExp(\n        (ax._id.charAt(0) === 'x') ? ('^' + ax._id + 'y') : (ax._id + '$')\n    );\n    var subplotsWithAxis = [];\n\n    for(var i = 0; i < subplots.length; i++) {\n        var sp = subplots[i];\n        if(axMatch.test(sp)) subplotsWithAxis.push(sp);\n    }\n\n    return subplotsWithAxis;\n};\n\n// makeClipPaths: prepare clipPaths for all single axes and all possible xy pairings\naxes.makeClipPaths = function(gd) {\n    var fullLayout = gd._fullLayout,\n        defs = fullLayout._defs,\n        fullWidth = {_offset: 0, _length: fullLayout.width, _id: ''},\n        fullHeight = {_offset: 0, _length: fullLayout.height, _id: ''},\n        xaList = axes.list(gd, 'x', true),\n        yaList = axes.list(gd, 'y', true),\n        clipList = [],\n        i,\n        j;\n\n    for(i = 0; i < xaList.length; i++) {\n        clipList.push({x: xaList[i], y: fullHeight});\n        for(j = 0; j < yaList.length; j++) {\n            if(i === 0) clipList.push({x: fullWidth, y: yaList[j]});\n            clipList.push({x: xaList[i], y: yaList[j]});\n        }\n    }\n\n    var defGroup = defs.selectAll('g.clips')\n        .data([0]);\n\n    defGroup.enter().append('g')\n        .classed('clips', true);\n\n    // selectors don't work right with camelCase tags,\n    // have to use class instead\n    // https://groups.google.com/forum/#!topic/d3-js/6EpAzQ2gU9I\n    var axClips = defGroup.selectAll('.axesclip')\n        .data(clipList, function(d) { return d.x._id + d.y._id; });\n\n    axClips.enter().append('clipPath')\n        .classed('axesclip', true)\n        .attr('id', function(d) { return 'clip' + fullLayout._uid + d.x._id + d.y._id; })\n      .append('rect');\n\n    axClips.exit().remove();\n\n    axClips.each(function(d) {\n        d3.select(this).select('rect').attr({\n            x: d.x._offset || 0,\n            y: d.y._offset || 0,\n            width: d.x._length || 1,\n            height: d.y._length || 1\n        });\n    });\n};\n\n\n// doTicks: draw ticks, grids, and tick labels\n// axid: 'x', 'y', 'x2' etc,\n//     blank to do all,\n//     'redraw' to force full redraw, and reset:\n//          ax._r (stored range for use by zoom/pan)\n//          ax._rl (stored linearized range for use by zoom/pan)\n//     or can pass in an axis object directly\naxes.doTicks = function(gd, axid, skipTitle) {\n    var fullLayout = gd._fullLayout,\n        ax,\n        independent = false;\n\n    // allow passing an independent axis object instead of id\n    if(typeof axid === 'object') {\n        ax = axid;\n        axid = ax._id;\n        independent = true;\n    }\n    else {\n        ax = axes.getFromId(gd, axid);\n\n        if(axid === 'redraw') {\n            fullLayout._paper.selectAll('g.subplot').each(function(subplot) {\n                var plotinfo = fullLayout._plots[subplot],\n                    xa = plotinfo.xaxis,\n                    ya = plotinfo.yaxis;\n\n                plotinfo.xaxislayer\n                    .selectAll('.' + xa._id + 'tick').remove();\n                plotinfo.yaxislayer\n                    .selectAll('.' + ya._id + 'tick').remove();\n                plotinfo.gridlayer\n                    .selectAll('path').remove();\n                plotinfo.zerolinelayer\n                    .selectAll('path').remove();\n            });\n        }\n\n        if(!axid || axid === 'redraw') {\n            return Lib.syncOrAsync(axes.list(gd, '', true).map(function(ax) {\n                return function() {\n                    if(!ax._id) return;\n                    var axDone = axes.doTicks(gd, ax._id);\n                    if(axid === 'redraw') {\n                        ax._r = ax.range.slice();\n                        ax._rl = Lib.simpleMap(ax._r, ax.r2l);\n                    }\n                    return axDone;\n                };\n            }));\n        }\n    }\n\n    // make sure we only have allowed options for exponents\n    // (others can make confusing errors)\n    if(!ax.tickformat) {\n        if(['none', 'e', 'E', 'power', 'SI', 'B'].indexOf(ax.exponentformat) === -1) {\n            ax.exponentformat = 'e';\n        }\n        if(['all', 'first', 'last', 'none'].indexOf(ax.showexponent) === -1) {\n            ax.showexponent = 'all';\n        }\n    }\n\n    // set scaling to pixels\n    ax.setScale();\n\n    var axLetter = axid.charAt(0),\n        counterLetter = axes.counterLetter(axid),\n        vals = axes.calcTicks(ax),\n        datafn = function(d) { return [d.text, d.x, ax.mirror].join('_'); },\n        tcls = axid + 'tick',\n        gcls = axid + 'grid',\n        zcls = axid + 'zl',\n        pad = (ax.linewidth || 1) / 2,\n        labelStandoff =\n            (ax.ticks === 'outside' ? ax.ticklen : 1) + (ax.linewidth || 0),\n        labelShift = 0,\n        gridWidth = Drawing.crispRound(gd, ax.gridwidth, 1),\n        zeroLineWidth = Drawing.crispRound(gd, ax.zerolinewidth, gridWidth),\n        tickWidth = Drawing.crispRound(gd, ax.tickwidth, 1),\n        sides, transfn, tickpathfn, subplots,\n        i;\n\n    if(ax._counterangle && ax.ticks === 'outside') {\n        var caRad = ax._counterangle * Math.PI / 180;\n        labelStandoff = ax.ticklen * Math.cos(caRad) + (ax.linewidth || 0);\n        labelShift = ax.ticklen * Math.sin(caRad);\n    }\n\n    // positioning arguments for x vs y axes\n    if(axLetter === 'x') {\n        sides = ['bottom', 'top'];\n        transfn = function(d) {\n            return 'translate(' + ax.l2p(d.x) + ',0)';\n        };\n        tickpathfn = function(shift, len) {\n            if(ax._counterangle) {\n                var caRad = ax._counterangle * Math.PI / 180;\n                return 'M0,' + shift + 'l' + (Math.sin(caRad) * len) + ',' + (Math.cos(caRad) * len);\n            }\n            else return 'M0,' + shift + 'v' + len;\n        };\n    }\n    else if(axLetter === 'y') {\n        sides = ['left', 'right'];\n        transfn = function(d) {\n            return 'translate(0,' + ax.l2p(d.x) + ')';\n        };\n        tickpathfn = function(shift, len) {\n            if(ax._counterangle) {\n                var caRad = ax._counterangle * Math.PI / 180;\n                return 'M' + shift + ',0l' + (Math.cos(caRad) * len) + ',' + (-Math.sin(caRad) * len);\n            }\n            else return 'M' + shift + ',0h' + len;\n        };\n    }\n    else {\n        Lib.warn('Unrecognized doTicks axis:', axid);\n        return;\n    }\n    var axside = ax.side || sides[0],\n    // which direction do the side[0], side[1], and free ticks go?\n    // then we flip if outside XOR y axis\n        ticksign = [-1, 1, axside === sides[1] ? 1 : -1];\n    if((ax.ticks !== 'inside') === (axLetter === 'x')) {\n        ticksign = ticksign.map(function(v) { return -v; });\n    }\n\n    if(!ax.visible) return;\n\n    // remove zero lines, grid lines, and inside ticks if they're within\n    // 1 pixel of the end\n    // The key case here is removing zero lines when the axis bound is zero.\n    function clipEnds(d) {\n        var p = ax.l2p(d.x);\n        return (p > 1 && p < ax._length - 1);\n    }\n    var valsClipped = vals.filter(clipEnds);\n\n    function drawTicks(container, tickpath) {\n        var ticks = container.selectAll('path.' + tcls)\n            .data(ax.ticks === 'inside' ? valsClipped : vals, datafn);\n        if(tickpath && ax.ticks) {\n            ticks.enter().append('path').classed(tcls, 1).classed('ticks', 1)\n                .classed('crisp', 1)\n                .call(Color.stroke, ax.tickcolor)\n                .style('stroke-width', tickWidth + 'px')\n                .attr('d', tickpath);\n            ticks.attr('transform', transfn);\n            ticks.exit().remove();\n        }\n        else ticks.remove();\n    }\n\n    function drawLabels(container, position) {\n        // tick labels - for now just the main labels.\n        // TODO: mirror labels, esp for subplots\n        var tickLabels = container.selectAll('g.' + tcls).data(vals, datafn);\n        if(!ax.showticklabels || !isNumeric(position)) {\n            tickLabels.remove();\n            drawAxTitle();\n            return;\n        }\n\n        var labelx, labely, labelanchor, labelpos0, flipit;\n        if(axLetter === 'x') {\n            flipit = (axside === 'bottom') ? 1 : -1;\n            labelx = function(d) { return d.dx + labelShift * flipit; };\n            labelpos0 = position + (labelStandoff + pad) * flipit;\n            labely = function(d) {\n                return d.dy + labelpos0 + d.fontSize *\n                    ((axside === 'bottom') ? 1 : -0.5);\n            };\n            labelanchor = function(angle) {\n                if(!isNumeric(angle) || angle === 0 || angle === 180) {\n                    return 'middle';\n                }\n                return (angle * flipit < 0) ? 'end' : 'start';\n            };\n        }\n        else {\n            flipit = (axside === 'right') ? 1 : -1;\n            labely = function(d) { return d.dy + d.fontSize / 2 - labelShift * flipit; };\n            labelx = function(d) {\n                return d.dx + position + (labelStandoff + pad +\n                    ((Math.abs(ax.tickangle) === 90) ? d.fontSize / 2 : 0)) * flipit;\n            };\n            labelanchor = function(angle) {\n                if(isNumeric(angle) && Math.abs(angle) === 90) {\n                    return 'middle';\n                }\n                return axside === 'right' ? 'start' : 'end';\n            };\n        }\n        var maxFontSize = 0,\n            autoangle = 0,\n            labelsReady = [];\n        tickLabels.enter().append('g').classed(tcls, 1)\n            .append('text')\n                // only so tex has predictable alignment that we can\n                // alter later\n                .attr('text-anchor', 'middle')\n                .each(function(d) {\n                    var thisLabel = d3.select(this),\n                        newPromise = gd._promises.length;\n                    thisLabel\n                        .call(Drawing.setPosition, labelx(d), labely(d))\n                        .call(Drawing.font, d.font, d.fontSize, d.fontColor)\n                        .text(d.text)\n                        .call(svgTextUtils.convertToTspans);\n                    newPromise = gd._promises[newPromise];\n                    if(newPromise) {\n                        // if we have an async label, we'll deal with that\n                        // all here so take it out of gd._promises and\n                        // instead position the label and promise this in\n                        // labelsReady\n                        labelsReady.push(gd._promises.pop().then(function() {\n                            positionLabels(thisLabel, ax.tickangle);\n                        }));\n                    }\n                    else {\n                        // sync label: just position it now.\n                        positionLabels(thisLabel, ax.tickangle);\n                    }\n                });\n        tickLabels.exit().remove();\n\n        tickLabels.each(function(d) {\n            maxFontSize = Math.max(maxFontSize, d.fontSize);\n        });\n\n        function positionLabels(s, angle) {\n            s.each(function(d) {\n                var anchor = labelanchor(angle);\n                var thisLabel = d3.select(this),\n                    mathjaxGroup = thisLabel.select('.text-math-group'),\n                    transform = transfn(d) +\n                        ((isNumeric(angle) && +angle !== 0) ?\n                        (' rotate(' + angle + ',' + labelx(d) + ',' +\n                            (labely(d) - d.fontSize / 2) + ')') :\n                        '');\n                if(mathjaxGroup.empty()) {\n                    var txt = thisLabel.select('text').attr({\n                        transform: transform,\n                        'text-anchor': anchor\n                    });\n\n                    if(!txt.empty()) {\n                        txt.selectAll('tspan.line').attr({\n                            x: txt.attr('x'),\n                            y: txt.attr('y')\n                        });\n                    }\n                }\n                else {\n                    var mjShift =\n                        Drawing.bBox(mathjaxGroup.node()).width *\n                            {end: -0.5, start: 0.5}[anchor];\n                    mathjaxGroup.attr('transform', transform +\n                        (mjShift ? 'translate(' + mjShift + ',0)' : ''));\n                }\n            });\n        }\n\n        // make sure all labels are correctly positioned at their base angle\n        // the positionLabels call above is only for newly drawn labels.\n        // do this without waiting, using the last calculated angle to\n        // minimize flicker, then do it again when we know all labels are\n        // there, putting back the prescribed angle to check for overlaps.\n        positionLabels(tickLabels, ax._lastangle || ax.tickangle);\n\n        function allLabelsReady() {\n            return labelsReady.length && Promise.all(labelsReady);\n        }\n\n        function fixLabelOverlaps() {\n            positionLabels(tickLabels, ax.tickangle);\n\n            // check for auto-angling if x labels overlap\n            // don't auto-angle at all for log axes with\n            // base and digit format\n            if(axLetter === 'x' && !isNumeric(ax.tickangle) &&\n                    (ax.type !== 'log' || String(ax.dtick).charAt(0) !== 'D')) {\n                var lbbArray = [];\n                tickLabels.each(function(d) {\n                    var s = d3.select(this),\n                        thisLabel = s.select('.text-math-group'),\n                        x = ax.l2p(d.x);\n                    if(thisLabel.empty()) thisLabel = s.select('text');\n\n                    var bb = Drawing.bBox(thisLabel.node());\n\n                    lbbArray.push({\n                        // ignore about y, just deal with x overlaps\n                        top: 0,\n                        bottom: 10,\n                        height: 10,\n                        left: x - bb.width / 2,\n                        // impose a 2px gap\n                        right: x + bb.width / 2 + 2,\n                        width: bb.width + 2\n                    });\n                });\n                for(i = 0; i < lbbArray.length - 1; i++) {\n                    if(Lib.bBoxIntersect(lbbArray[i], lbbArray[i + 1])) {\n                        // any overlap at all - set 30 degrees\n                        autoangle = 30;\n                        break;\n                    }\n                }\n                if(autoangle) {\n                    var tickspacing = Math.abs(\n                            (vals[vals.length - 1].x - vals[0].x) * ax._m\n                        ) / (vals.length - 1);\n                    if(tickspacing < maxFontSize * 2.5) {\n                        autoangle = 90;\n                    }\n                    positionLabels(tickLabels, autoangle);\n                }\n                ax._lastangle = autoangle;\n            }\n\n            // update the axis title\n            // (so it can move out of the way if needed)\n            // TODO: separate out scoot so we don't need to do\n            // a full redraw of the title (mostly relevant for MathJax)\n            drawAxTitle();\n            return axid + ' done';\n        }\n\n        function calcBoundingBox() {\n            var bBox = container.node().getBoundingClientRect();\n            var gdBB = gd.getBoundingClientRect();\n\n            /*\n             * the way we're going to use this, the positioning that matters\n             * is relative to the origin of gd. This is important particularly\n             * if gd is scrollable, and may have been scrolled between the time\n             * we calculate this and the time we use it\n             */\n            ax._boundingBox = {\n                width: bBox.width,\n                height: bBox.height,\n                left: bBox.left - gdBB.left,\n                right: bBox.right - gdBB.left,\n                top: bBox.top - gdBB.top,\n                bottom: bBox.bottom - gdBB.top\n            };\n\n            /*\n             * for spikelines: what's the full domain of positions in the\n             * opposite direction that are associated with this axis?\n             * This means any axes that we make a subplot with, plus the\n             * position of the axis itself if it's free.\n             */\n            if(subplots) {\n                var fullRange = ax._counterSpan = [Infinity, -Infinity];\n\n                for(i = 0; i < subplots.length; i++) {\n                    var subplot = fullLayout._plots[subplots[i]];\n                    var counterAxis = subplot[(axLetter === 'x') ? 'yaxis' : 'xaxis'];\n\n                    extendRange(fullRange, [\n                        counterAxis._offset,\n                        counterAxis._offset + counterAxis._length\n                    ]);\n                }\n\n                if(ax.anchor === 'free') {\n                    extendRange(fullRange, (axLetter === 'x') ?\n                        [ax._boundingBox.bottom, ax._boundingBox.top] :\n                        [ax._boundingBox.right, ax._boundingBox.left]);\n                }\n            }\n\n            function extendRange(range, newRange) {\n                range[0] = Math.min(range[0], newRange[0]);\n                range[1] = Math.max(range[1], newRange[1]);\n            }\n        }\n\n        var done = Lib.syncOrAsync([\n            allLabelsReady,\n            fixLabelOverlaps,\n            calcBoundingBox\n        ]);\n        if(done && done.then) gd._promises.push(done);\n        return done;\n    }\n\n    function drawAxTitle() {\n        if(skipTitle) return;\n\n        // now this only applies to regular cartesian axes; colorbars and\n        // others ALWAYS call doTicks with skipTitle=true so they can\n        // configure their own titles.\n        var ax = axisIds.getFromId(gd, axid),\n            avoidSelection = d3.select(gd).selectAll('g.' + axid + 'tick'),\n            avoid = {\n                selection: avoidSelection,\n                side: ax.side\n            },\n            axLetter = axid.charAt(0),\n            gs = gd._fullLayout._size,\n            offsetBase = 1.5,\n            fontSize = ax.titlefont.size,\n            transform,\n            counterAxis,\n            x,\n            y;\n        if(avoidSelection.size()) {\n            var translation = Drawing.getTranslate(avoidSelection.node().parentNode);\n            avoid.offsetLeft = translation.x;\n            avoid.offsetTop = translation.y;\n        }\n\n        if(axLetter === 'x') {\n            counterAxis = (ax.anchor === 'free') ?\n                {_offset: gs.t + (1 - (ax.position || 0)) * gs.h, _length: 0} :\n                axisIds.getFromId(gd, ax.anchor);\n\n            x = ax._offset + ax._length / 2;\n            y = counterAxis._offset + ((ax.side === 'top') ?\n                -10 - fontSize * (offsetBase + (ax.showticklabels ? 1 : 0)) :\n                counterAxis._length + 10 +\n                    fontSize * (offsetBase + (ax.showticklabels ? 1.5 : 0.5)));\n\n            if(ax.rangeslider && ax.rangeslider.visible && ax._boundingBox) {\n                y += (fullLayout.height - fullLayout.margin.b - fullLayout.margin.t) *\n                    ax.rangeslider.thickness + ax._boundingBox.height;\n            }\n\n            if(!avoid.side) avoid.side = 'bottom';\n        }\n        else {\n            counterAxis = (ax.anchor === 'free') ?\n                {_offset: gs.l + (ax.position || 0) * gs.w, _length: 0} :\n                axisIds.getFromId(gd, ax.anchor);\n\n            y = ax._offset + ax._length / 2;\n            x = counterAxis._offset + ((ax.side === 'right') ?\n                counterAxis._length + 10 +\n                    fontSize * (offsetBase + (ax.showticklabels ? 1 : 0.5)) :\n                -10 - fontSize * (offsetBase + (ax.showticklabels ? 0.5 : 0)));\n\n            transform = {rotate: '-90', offset: 0};\n            if(!avoid.side) avoid.side = 'left';\n        }\n\n        Titles.draw(gd, axid + 'title', {\n            propContainer: ax,\n            propName: ax._name + '.title',\n            dfltName: axLetter.toUpperCase() + ' axis',\n            avoid: avoid,\n            transform: transform,\n            attributes: {x: x, y: y, 'text-anchor': 'middle'}\n        });\n    }\n\n    function traceHasBarsOrFill(trace, subplot) {\n        if(trace.visible !== true || trace.xaxis + trace.yaxis !== subplot) return false;\n        if(Registry.traceIs(trace, 'bar') && trace.orientation === {x: 'h', y: 'v'}[axLetter]) return true;\n        return trace.fill && trace.fill.charAt(trace.fill.length - 1) === axLetter;\n    }\n\n    function drawGrid(plotinfo, counteraxis, subplot) {\n        var gridcontainer = plotinfo.gridlayer,\n            zlcontainer = plotinfo.zerolinelayer,\n            gridvals = plotinfo['hidegrid' + axLetter] ? [] : valsClipped,\n            gridpath = ax._gridpath ||\n                'M0,0' + ((axLetter === 'x') ? 'v' : 'h') + counteraxis._length,\n            grid = gridcontainer.selectAll('path.' + gcls)\n                .data((ax.showgrid === false) ? [] : gridvals, datafn);\n        grid.enter().append('path').classed(gcls, 1)\n            .classed('crisp', 1)\n            .attr('d', gridpath)\n            .each(function(d) {\n                if(ax.zeroline && (ax.type === 'linear' || ax.type === '-') &&\n                        Math.abs(d.x) < ax.dtick / 100) {\n                    d3.select(this).remove();\n                }\n            });\n        grid.attr('transform', transfn)\n            .call(Color.stroke, ax.gridcolor || '#ddd')\n            .style('stroke-width', gridWidth + 'px');\n        grid.exit().remove();\n\n        // zero line\n        if(zlcontainer) {\n            var hasBarsOrFill = false;\n            for(var i = 0; i < gd._fullData.length; i++) {\n                if(traceHasBarsOrFill(gd._fullData[i], subplot)) {\n                    hasBarsOrFill = true;\n                    break;\n                }\n            }\n            var rng = Lib.simpleMap(ax.range, ax.r2l),\n                showZl = (rng[0] * rng[1] <= 0) && ax.zeroline &&\n                (ax.type === 'linear' || ax.type === '-') && gridvals.length &&\n                (hasBarsOrFill || clipEnds({x: 0}) || !ax.showline);\n            var zl = zlcontainer.selectAll('path.' + zcls)\n                .data(showZl ? [{x: 0}] : []);\n            zl.enter().append('path').classed(zcls, 1).classed('zl', 1)\n                .classed('crisp', 1)\n                .attr('d', gridpath);\n            zl.attr('transform', transfn)\n                .call(Color.stroke, ax.zerolinecolor || Color.defaultLine)\n                .style('stroke-width', zeroLineWidth + 'px');\n            zl.exit().remove();\n        }\n    }\n\n    if(independent) {\n        drawTicks(ax._axislayer, tickpathfn(ax._pos + pad * ticksign[2], ticksign[2] * ax.ticklen));\n        if(ax._counteraxis) {\n            var fictionalPlotinfo = {\n                gridlayer: ax._gridlayer,\n                zerolinelayer: ax._zerolinelayer\n            };\n            drawGrid(fictionalPlotinfo, ax._counteraxis);\n        }\n        return drawLabels(ax._axislayer, ax._pos);\n    }\n    else {\n        subplots = axes.getSubplots(gd, ax);\n        var alldone = subplots.map(function(subplot) {\n            var plotinfo = fullLayout._plots[subplot];\n\n            if(!fullLayout._has('cartesian')) return;\n\n            var container = plotinfo[axLetter + 'axislayer'],\n\n                // [bottom or left, top or right, free, main]\n                linepositions = ax._linepositions[subplot] || [],\n                counteraxis = plotinfo[counterLetter + 'axis'],\n                mainSubplot = counteraxis._id === ax.anchor,\n                ticksides = [false, false, false],\n                tickpath = '';\n\n            // ticks\n            if(ax.mirror === 'allticks') ticksides = [true, true, false];\n            else if(mainSubplot) {\n                if(ax.mirror === 'ticks') ticksides = [true, true, false];\n                else ticksides[sides.indexOf(axside)] = true;\n            }\n            if(ax.mirrors) {\n                for(i = 0; i < 2; i++) {\n                    var thisMirror = ax.mirrors[counteraxis._id + sides[i]];\n                    if(thisMirror === 'ticks' || thisMirror === 'labels') {\n                        ticksides[i] = true;\n                    }\n                }\n            }\n\n            // free axis ticks\n            if(linepositions[2] !== undefined) ticksides[2] = true;\n\n            ticksides.forEach(function(showside, sidei) {\n                var pos = linepositions[sidei],\n                    tsign = ticksign[sidei];\n                if(showside && isNumeric(pos)) {\n                    tickpath += tickpathfn(pos + pad * tsign, tsign * ax.ticklen);\n                }\n            });\n\n            drawTicks(container, tickpath);\n            drawGrid(plotinfo, counteraxis, subplot);\n            return drawLabels(container, linepositions[3]);\n        }).filter(function(onedone) { return onedone && onedone.then; });\n\n        return alldone.length ? Promise.all(alldone) : 0;\n    }\n};\n\n// swap all the presentation attributes of the axes showing these traces\naxes.swap = function(gd, traces) {\n    var axGroups = makeAxisGroups(gd, traces);\n\n    for(var i = 0; i < axGroups.length; i++) {\n        swapAxisGroup(gd, axGroups[i].x, axGroups[i].y);\n    }\n};\n\nfunction makeAxisGroups(gd, traces) {\n    var groups = [],\n        i,\n        j;\n\n    for(i = 0; i < traces.length; i++) {\n        var groupsi = [],\n            xi = gd._fullData[traces[i]].xaxis,\n            yi = gd._fullData[traces[i]].yaxis;\n        if(!xi || !yi) continue; // not a 2D cartesian trace?\n\n        for(j = 0; j < groups.length; j++) {\n            if(groups[j].x.indexOf(xi) !== -1 || groups[j].y.indexOf(yi) !== -1) {\n                groupsi.push(j);\n            }\n        }\n\n        if(!groupsi.length) {\n            groups.push({x: [xi], y: [yi]});\n            continue;\n        }\n\n        var group0 = groups[groupsi[0]],\n            groupj;\n\n        if(groupsi.length > 1) {\n            for(j = 1; j < groupsi.length; j++) {\n                groupj = groups[groupsi[j]];\n                mergeAxisGroups(group0.x, groupj.x);\n                mergeAxisGroups(group0.y, groupj.y);\n            }\n        }\n        mergeAxisGroups(group0.x, [xi]);\n        mergeAxisGroups(group0.y, [yi]);\n    }\n\n    return groups;\n}\n\nfunction mergeAxisGroups(intoSet, fromSet) {\n    for(var i = 0; i < fromSet.length; i++) {\n        if(intoSet.indexOf(fromSet[i]) === -1) intoSet.push(fromSet[i]);\n    }\n}\n\nfunction swapAxisGroup(gd, xIds, yIds) {\n    var i,\n        j,\n        xFullAxes = [],\n        yFullAxes = [],\n        layout = gd.layout;\n\n    for(i = 0; i < xIds.length; i++) xFullAxes.push(axes.getFromId(gd, xIds[i]));\n    for(i = 0; i < yIds.length; i++) yFullAxes.push(axes.getFromId(gd, yIds[i]));\n\n    var allAxKeys = Object.keys(xFullAxes[0]),\n        noSwapAttrs = [\n            'anchor', 'domain', 'overlaying', 'position', 'side', 'tickangle'\n        ],\n        numericTypes = ['linear', 'log'];\n\n    for(i = 0; i < allAxKeys.length; i++) {\n        var keyi = allAxKeys[i],\n            xVal = xFullAxes[0][keyi],\n            yVal = yFullAxes[0][keyi],\n            allEqual = true,\n            coerceLinearX = false,\n            coerceLinearY = false;\n        if(keyi.charAt(0) === '_' || typeof xVal === 'function' ||\n                noSwapAttrs.indexOf(keyi) !== -1) {\n            continue;\n        }\n        for(j = 1; j < xFullAxes.length && allEqual; j++) {\n            var xVali = xFullAxes[j][keyi];\n            if(keyi === 'type' && numericTypes.indexOf(xVal) !== -1 &&\n                    numericTypes.indexOf(xVali) !== -1 && xVal !== xVali) {\n                // type is special - if we find a mixture of linear and log,\n                // coerce them all to linear on flipping\n                coerceLinearX = true;\n            }\n            else if(xVali !== xVal) allEqual = false;\n        }\n        for(j = 1; j < yFullAxes.length && allEqual; j++) {\n            var yVali = yFullAxes[j][keyi];\n            if(keyi === 'type' && numericTypes.indexOf(yVal) !== -1 &&\n                    numericTypes.indexOf(yVali) !== -1 && yVal !== yVali) {\n                // type is special - if we find a mixture of linear and log,\n                // coerce them all to linear on flipping\n                coerceLinearY = true;\n            }\n            else if(yFullAxes[j][keyi] !== yVal) allEqual = false;\n        }\n        if(allEqual) {\n            if(coerceLinearX) layout[xFullAxes[0]._name].type = 'linear';\n            if(coerceLinearY) layout[yFullAxes[0]._name].type = 'linear';\n            swapAxisAttrs(layout, keyi, xFullAxes, yFullAxes);\n        }\n    }\n\n    // now swap x&y for any annotations anchored to these x & y\n    for(i = 0; i < gd._fullLayout.annotations.length; i++) {\n        var ann = gd._fullLayout.annotations[i];\n        if(xIds.indexOf(ann.xref) !== -1 &&\n                yIds.indexOf(ann.yref) !== -1) {\n            Lib.swapAttrs(layout.annotations[i], ['?']);\n        }\n    }\n}\n\nfunction swapAxisAttrs(layout, key, xFullAxes, yFullAxes) {\n    // in case the value is the default for either axis,\n    // look at the first axis in each list and see if\n    // this key's value is undefined\n    var np = Lib.nestedProperty,\n        xVal = np(layout[xFullAxes[0]._name], key).get(),\n        yVal = np(layout[yFullAxes[0]._name], key).get(),\n        i;\n    if(key === 'title') {\n        // special handling of placeholder titles\n        if(xVal === 'Click to enter X axis title') {\n            xVal = 'Click to enter Y axis title';\n        }\n        if(yVal === 'Click to enter Y axis title') {\n            yVal = 'Click to enter X axis title';\n        }\n    }\n\n    for(i = 0; i < xFullAxes.length; i++) {\n        np(layout, xFullAxes[i]._name + '.' + key).set(yVal);\n    }\n    for(i = 0; i < yFullAxes.length; i++) {\n        np(layout, yFullAxes[i]._name + '.' + key).set(xVal);\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/lib/svg_text_utils.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\n/* global MathJax:false */\n\nvar d3 = require('d3');\n\nvar Lib = require('../lib');\nvar xmlnsNamespaces = require('../constants/xmlns_namespaces');\nvar stringMappings = require('../constants/string_mappings');\n\n// Append SVG\n\nd3.selection.prototype.appendSVG = function(_svgString) {\n    var skeleton = [\n        '<svg xmlns=\"', xmlnsNamespaces.svg, '\" ',\n        'xmlns:xlink=\"', xmlnsNamespaces.xlink, '\">',\n        _svgString,\n        '</svg>'\n    ].join('');\n\n    var dom = new DOMParser().parseFromString(skeleton, 'application/xml'),\n        childNode = dom.documentElement.firstChild;\n\n    while(childNode) {\n        this.node().appendChild(this.node().ownerDocument.importNode(childNode, true));\n        childNode = childNode.nextSibling;\n    }\n    if(dom.querySelector('parsererror')) {\n        Lib.log(dom.querySelector('parsererror div').textContent);\n        return null;\n    }\n    return d3.select(this.node().lastChild);\n};\n\n// Text utilities\n\nexports.html_entity_decode = function(s) {\n    var hiddenDiv = d3.select('body').append('div').style({display: 'none'}).html('');\n    var replaced = s.replace(/(&[^;]*;)/gi, function(d) {\n        if(d === '&lt;') { return '&#60;'; } // special handling for brackets\n        if(d === '&rt;') { return '&#62;'; }\n        if(d.indexOf('<') !== -1 || d.indexOf('>') !== -1) { return ''; }\n        return hiddenDiv.html(d).text(); // everything else, let the browser decode it to unicode\n    });\n    hiddenDiv.remove();\n    return replaced;\n};\n\nexports.xml_entity_encode = function(str) {\n    return str.replace(/&(?!\\w+;|\\#[0-9]+;| \\#x[0-9A-F]+;)/g, '&amp;');\n};\n\n// text converter\n\nfunction getSize(_selection, _dimension) {\n    return _selection.node().getBoundingClientRect()[_dimension];\n}\n\nexports.convertToTspans = function(_context, _callback) {\n    var str = _context.text();\n    var converted = convertToSVG(str);\n    var that = _context;\n\n    // Until we get tex integrated more fully (so it can be used along with non-tex)\n    // allow some elements to prohibit it by attaching 'data-notex' to the original\n    var tex = (!that.attr('data-notex')) && converted.match(/([^$]*)([$]+[^$]*[$]+)([^$]*)/);\n    var result = str;\n    var parent = d3.select(that.node().parentNode);\n    if(parent.empty()) return;\n    var svgClass = (that.attr('class')) ? that.attr('class').split(' ')[0] : 'text';\n    svgClass += '-math';\n    parent.selectAll('svg.' + svgClass).remove();\n    parent.selectAll('g.' + svgClass + '-group').remove();\n    _context.style({visibility: null});\n    for(var up = _context.node(); up && up.removeAttribute; up = up.parentNode) {\n        up.removeAttribute('data-bb');\n    }\n\n    function showText() {\n        if(!parent.empty()) {\n            svgClass = that.attr('class') + '-math';\n            parent.select('svg.' + svgClass).remove();\n        }\n        _context.text('')\n            .style({\n                visibility: 'inherit',\n                'white-space': 'pre'\n            });\n\n        result = _context.appendSVG(converted);\n\n        if(!result) _context.text(str);\n\n        if(_context.select('a').size()) {\n            // at least in Chrome, pointer-events does not seem\n            // to be honored in children of <text> elements\n            // so if we have an anchor, we have to make the\n            // whole element respond\n            _context.style('pointer-events', 'all');\n        }\n\n        if(_callback) _callback.call(that);\n    }\n\n    if(tex) {\n        var gd = Lib.getPlotDiv(that.node());\n        ((gd && gd._promises) || []).push(new Promise(function(resolve) {\n            that.style({visibility: 'hidden'});\n            var config = {fontSize: parseInt(that.style('font-size'), 10)};\n\n            texToSVG(tex[2], config, function(_svgEl, _glyphDefs, _svgBBox) {\n                parent.selectAll('svg.' + svgClass).remove();\n                parent.selectAll('g.' + svgClass + '-group').remove();\n\n                var newSvg = _svgEl && _svgEl.select('svg');\n                if(!newSvg || !newSvg.node()) {\n                    showText();\n                    resolve();\n                    return;\n                }\n\n                var mathjaxGroup = parent.append('g')\n                    .classed(svgClass + '-group', true)\n                    .attr({'pointer-events': 'none'});\n\n                mathjaxGroup.node().appendChild(newSvg.node());\n\n                // stitch the glyph defs\n                if(_glyphDefs && _glyphDefs.node()) {\n                    newSvg.node().insertBefore(_glyphDefs.node().cloneNode(true),\n                                               newSvg.node().firstChild);\n                }\n\n                newSvg.attr({\n                    'class': svgClass,\n                    height: _svgBBox.height,\n                    preserveAspectRatio: 'xMinYMin meet'\n                })\n                .style({overflow: 'visible', 'pointer-events': 'none'});\n\n                var fill = that.style('fill') || 'black';\n                newSvg.select('g').attr({fill: fill, stroke: fill});\n\n                var newSvgW = getSize(newSvg, 'width'),\n                    newSvgH = getSize(newSvg, 'height'),\n                    newX = +that.attr('x') - newSvgW *\n                        {start: 0, middle: 0.5, end: 1}[that.attr('text-anchor') || 'start'],\n                    // font baseline is about 1/4 fontSize below centerline\n                    textHeight = parseInt(that.style('font-size'), 10) ||\n                        getSize(that, 'height'),\n                    dy = -textHeight / 4;\n\n                if(svgClass[0] === 'y') {\n                    mathjaxGroup.attr({\n                        transform: 'rotate(' + [-90, +that.attr('x'), +that.attr('y')] +\n                        ') translate(' + [-newSvgW / 2, dy - newSvgH / 2] + ')'\n                    });\n                    newSvg.attr({x: +that.attr('x'), y: +that.attr('y')});\n                }\n                else if(svgClass[0] === 'l') {\n                    newSvg.attr({x: that.attr('x'), y: dy - (newSvgH / 2)});\n                }\n                else if(svgClass[0] === 'a') {\n                    newSvg.attr({x: 0, y: dy});\n                }\n                else {\n                    newSvg.attr({x: newX, y: (+that.attr('y') + dy - newSvgH / 2)});\n                }\n\n                if(_callback) _callback.call(that, mathjaxGroup);\n                resolve(mathjaxGroup);\n            });\n        }));\n    }\n    else showText();\n\n    return _context;\n};\n\n\n// MathJax\n\nfunction cleanEscapesForTex(s) {\n    return s.replace(/(<|&lt;|&#60;)/g, '\\\\lt ')\n        .replace(/(>|&gt;|&#62;)/g, '\\\\gt ');\n}\n\nfunction texToSVG(_texString, _config, _callback) {\n    var randomID = 'math-output-' + Lib.randstr([], 64);\n    var tmpDiv = d3.select('body').append('div')\n        .attr({id: randomID})\n        .style({visibility: 'hidden', position: 'absolute'})\n        .style({'font-size': _config.fontSize + 'px'})\n        .text(cleanEscapesForTex(_texString));\n\n    MathJax.Hub.Queue(['Typeset', MathJax.Hub, tmpDiv.node()], function() {\n        var glyphDefs = d3.select('body').select('#MathJax_SVG_glyphs');\n\n        if(tmpDiv.select('.MathJax_SVG').empty() || !tmpDiv.select('svg').node()) {\n            Lib.log('There was an error in the tex syntax.', _texString);\n            _callback();\n        }\n        else {\n            var svgBBox = tmpDiv.select('svg').node().getBoundingClientRect();\n            _callback(tmpDiv.select('.MathJax_SVG'), glyphDefs, svgBBox);\n        }\n\n        tmpDiv.remove();\n    });\n}\n\nvar TAG_STYLES = {\n    // would like to use baseline-shift but FF doesn't support it yet\n    // so we need to use dy along with the uber hacky shift-back-to\n    // baseline below\n    sup: 'font-size:70%\" dy=\"-0.6em',\n    sub: 'font-size:70%\" dy=\"0.3em',\n    b: 'font-weight:bold',\n    i: 'font-style:italic',\n    a: '',\n    span: '',\n    br: '',\n    em: 'font-style:italic;font-weight:bold'\n};\n\nvar PROTOCOLS = ['http:', 'https:', 'mailto:'];\n\nvar STRIP_TAGS = new RegExp('</?(' + Object.keys(TAG_STYLES).join('|') + ')( [^>]*)?/?>', 'g');\n\nvar ENTITY_TO_UNICODE = Object.keys(stringMappings.entityToUnicode).map(function(k) {\n    return {\n        regExp: new RegExp('&' + k + ';', 'g'),\n        sub: stringMappings.entityToUnicode[k]\n    };\n});\n\nvar UNICODE_TO_ENTITY = Object.keys(stringMappings.unicodeToEntity).map(function(k) {\n    return {\n        regExp: new RegExp(k, 'g'),\n        sub: '&' + stringMappings.unicodeToEntity[k] + ';'\n    };\n});\n\nvar NEWLINES = /(\\r\\n?|\\n)/g;\n\nexports.plainText = function(_str) {\n    // strip out our pseudo-html so we have a readable\n    // version to put into text fields\n    return (_str || '').replace(STRIP_TAGS, ' ');\n};\n\nfunction replaceFromMapObject(_str, list) {\n    var out = _str || '';\n\n    for(var i = 0; i < list.length; i++) {\n        var item = list[i];\n        out = out.replace(item.regExp, item.sub);\n    }\n\n    return out;\n}\n\nfunction convertEntities(_str) {\n    return replaceFromMapObject(_str, ENTITY_TO_UNICODE);\n}\n\nfunction encodeForHTML(_str) {\n    return replaceFromMapObject(_str, UNICODE_TO_ENTITY);\n}\n\nfunction convertToSVG(_str) {\n    _str = convertEntities(_str);\n\n    // normalize behavior between IE and others wrt newlines and whitespace:pre\n    // this combination makes IE barf https://github.com/plotly/plotly.js/issues/746\n    // Chrome and FF display \\n, \\r, or \\r\\n as a space in this mode.\n    // I feel like at some point we turned these into <br> but currently we don't so\n    // I'm just going to cement what we do now in Chrome and FF\n    _str = _str.replace(NEWLINES, ' ');\n\n    var result = _str\n        .split(/(<[^<>]*>)/).map(function(d) {\n            var match = d.match(/<(\\/?)([^ >]*)\\s*(.*)>/i),\n                tag = match && match[2].toLowerCase(),\n                style = TAG_STYLES[tag];\n\n            if(style !== undefined) {\n                var close = match[1],\n                    extra = match[3],\n                    /**\n                     * extraStyle: any random extra css (that's supported by svg)\n                     * use this like <span style=\"font-family:Arial\"> to change font in the middle\n                     *\n                     * at one point we supported <font family=\"...\" size=\"...\"> but as this isn't even\n                     * valid HTML anymore and we dropped it accidentally for many months, we will not\n                     * resurrect it.\n                     */\n                    extraStyle = extra.match(/^style\\s*=\\s*\"([^\"]+)\"\\s*/i);\n\n                // anchor and br are the only ones that don't turn into a tspan\n                if(tag === 'a') {\n                    if(close) return '</a>';\n                    else if(extra.substr(0, 4).toLowerCase() !== 'href') return '<a>';\n                    else {\n                        // remove quotes, leading '=', replace '&' with '&amp;'\n                        var href = extra.substr(4)\n                            .replace(/[\"']/g, '')\n                            .replace(/=/, '');\n\n                        // check protocol\n                        var dummyAnchor = document.createElement('a');\n                        dummyAnchor.href = href;\n                        if(PROTOCOLS.indexOf(dummyAnchor.protocol) === -1) return '<a>';\n\n                        return '<a xlink:show=\"new\" xlink:href=\"' + encodeForHTML(href) + '\">';\n                    }\n                }\n                else if(tag === 'br') return '<br>';\n                else if(close) {\n                    // closing tag\n\n                    // sub/sup: extra tspan with zero-width space to get back to the right baseline\n                    if(tag === 'sup') return '</tspan><tspan dy=\"0.42em\">&#x200b;</tspan>';\n                    if(tag === 'sub') return '</tspan><tspan dy=\"-0.21em\">&#x200b;</tspan>';\n                    else return '</tspan>';\n                }\n                else {\n                    var tspanStart = '<tspan';\n\n                    if(tag === 'sup' || tag === 'sub') {\n                        // sub/sup: extra zero-width space, fixes problem if new line starts with sub/sup\n                        tspanStart = '&#x200b;' + tspanStart;\n                    }\n\n                    if(extraStyle) {\n                        // most of the svg css users will care about is just like html,\n                        // but font color is different. Let our users ignore this.\n                        extraStyle = extraStyle[1].replace(/(^|;)\\s*color:/, '$1 fill:');\n                        style = encodeForHTML(extraStyle) + (style ? ';' + style : '');\n                    }\n\n                    return tspanStart + (style ? ' style=\"' + style + '\"' : '') + '>';\n                }\n            }\n            else {\n                return exports.xml_entity_encode(d).replace(/</g, '&lt;');\n            }\n        });\n\n    var indices = [];\n    for(var index = result.indexOf('<br>'); index > 0; index = result.indexOf('<br>', index + 1)) {\n        indices.push(index);\n    }\n    var count = 0;\n    indices.forEach(function(d) {\n        var brIndex = d + count;\n        var search = result.slice(0, brIndex);\n        var previousOpenTag = '';\n        for(var i2 = search.length - 1; i2 >= 0; i2--) {\n            var isTag = search[i2].match(/<(\\/?).*>/i);\n            if(isTag && search[i2] !== '<br>') {\n                if(!isTag[1]) previousOpenTag = search[i2];\n                break;\n            }\n        }\n        if(previousOpenTag) {\n            result.splice(brIndex + 1, 0, previousOpenTag);\n            result.splice(brIndex, 0, '</tspan>');\n            count += 2;\n        }\n    });\n\n    var joined = result.join('');\n    var splitted = joined.split(/<br>/gi);\n    if(splitted.length > 1) {\n        result = splitted.map(function(d, i) {\n            // TODO: figure out max font size of this line and alter dy\n            // this requires either:\n            // 1) bringing the base font size into convertToTspans, or\n            // 2) only allowing relative percentage font sizes.\n            // I think #2 is the way to go\n            return '<tspan class=\"line\" dy=\"' + (i * 1.3) + 'em\">' + d + '</tspan>';\n        });\n    }\n\n    return result.join('');\n}\n\nfunction alignHTMLWith(_base, container, options) {\n    var alignH = options.horizontalAlign,\n        alignV = options.verticalAlign || 'top',\n        bRect = _base.node().getBoundingClientRect(),\n        cRect = container.node().getBoundingClientRect(),\n        thisRect,\n        getTop,\n        getLeft;\n\n    if(alignV === 'bottom') {\n        getTop = function() { return bRect.bottom - thisRect.height; };\n    } else if(alignV === 'middle') {\n        getTop = function() { return bRect.top + (bRect.height - thisRect.height) / 2; };\n    } else { // default: top\n        getTop = function() { return bRect.top; };\n    }\n\n    if(alignH === 'right') {\n        getLeft = function() { return bRect.right - thisRect.width; };\n    } else if(alignH === 'center') {\n        getLeft = function() { return bRect.left + (bRect.width - thisRect.width) / 2; };\n    } else { // default: left\n        getLeft = function() { return bRect.left; };\n    }\n\n    return function() {\n        thisRect = this.node().getBoundingClientRect();\n        this.style({\n            top: (getTop() - cRect.top) + 'px',\n            left: (getLeft() - cRect.left) + 'px',\n            'z-index': 1000\n        });\n        return this;\n    };\n}\n\n// Editable title\n\nexports.makeEditable = function(context, _delegate, options) {\n    if(!options) options = {};\n    var that = this;\n    var dispatch = d3.dispatch('edit', 'input', 'cancel');\n    var textSelection = d3.select(this.node())\n        .style({'pointer-events': 'all'});\n\n    var handlerElement = _delegate || textSelection;\n    if(_delegate) textSelection.style({'pointer-events': 'none'});\n\n    function handleClick() {\n        appendEditable();\n        that.style({opacity: 0});\n        // also hide any mathjax svg\n        var svgClass = handlerElement.attr('class'),\n            mathjaxClass;\n        if(svgClass) mathjaxClass = '.' + svgClass.split(' ')[0] + '-math-group';\n        else mathjaxClass = '[class*=-math-group]';\n        if(mathjaxClass) {\n            d3.select(that.node().parentNode).select(mathjaxClass).style({opacity: 0});\n        }\n    }\n\n    function selectElementContents(_el) {\n        var el = _el.node();\n        var range = document.createRange();\n        range.selectNodeContents(el);\n        var sel = window.getSelection();\n        sel.removeAllRanges();\n        sel.addRange(range);\n        el.focus();\n    }\n\n    function appendEditable() {\n        var gd = Lib.getPlotDiv(that.node()),\n            plotDiv = d3.select(gd),\n            container = plotDiv.select('.svg-container'),\n            div = container.append('div');\n        div.classed('plugin-editable editable', true)\n            .style({\n                position: 'absolute',\n                'font-family': that.style('font-family') || 'Arial',\n                'font-size': that.style('font-size') || 12,\n                color: options.fill || that.style('fill') || 'black',\n                opacity: 1,\n                'background-color': options.background || 'transparent',\n                outline: '#ffffff33 1px solid',\n                margin: [-parseFloat(that.style('font-size')) / 8 + 1, 0, 0, -1].join('px ') + 'px',\n                padding: '0',\n                'box-sizing': 'border-box'\n            })\n            .attr({contenteditable: true})\n            .text(options.text || that.attr('data-unformatted'))\n            .call(alignHTMLWith(that, container, options))\n            .on('blur', function() {\n                gd._editing = false;\n                that.text(this.textContent)\n                    .style({opacity: 1});\n                var svgClass = d3.select(this).attr('class'),\n                    mathjaxClass;\n                if(svgClass) mathjaxClass = '.' + svgClass.split(' ')[0] + '-math-group';\n                else mathjaxClass = '[class*=-math-group]';\n                if(mathjaxClass) {\n                    d3.select(that.node().parentNode).select(mathjaxClass).style({opacity: 0});\n                }\n                var text = this.textContent;\n                d3.select(this).transition().duration(0).remove();\n                d3.select(document).on('mouseup', null);\n                dispatch.edit.call(that, text);\n            })\n            .on('focus', function() {\n                var context = this;\n                gd._editing = true;\n                d3.select(document).on('mouseup', function() {\n                    if(d3.event.target === context) return false;\n                    if(document.activeElement === div.node()) div.node().blur();\n                });\n            })\n            .on('keyup', function() {\n                if(d3.event.which === 27) {\n                    gd._editing = false;\n                    that.style({opacity: 1});\n                    d3.select(this)\n                        .style({opacity: 0})\n                        .on('blur', function() { return false; })\n                        .transition().remove();\n                    dispatch.cancel.call(that, this.textContent);\n                }\n                else {\n                    dispatch.input.call(that, this.textContent);\n                    d3.select(this).call(alignHTMLWith(that, container, options));\n                }\n            })\n            .on('keydown', function() {\n                if(d3.event.which === 13) this.blur();\n            })\n            .call(selectElementContents);\n    }\n\n    if(options.immediate) handleClick();\n    else handlerElement.on('click', handleClick);\n\n    return d3.rebind(this, dispatch, 'on');\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/constants/xmlns_namespaces.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\n\nexports.xmlns = 'http://www.w3.org/2000/xmlns/';\nexports.svg = 'http://www.w3.org/2000/svg';\nexports.xlink = 'http://www.w3.org/1999/xlink';\n\n// the 'old' d3 quirk got fix in v3.5.7\n// https://github.com/mbostock/d3/commit/a6f66e9dd37f764403fc7c1f26be09ab4af24fed\nexports.svgAttrs = {\n    xmlns: exports.svg,\n    'xmlns:xlink': exports.xlink\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/constants/string_mappings.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\n// N.B. HTML entities are listed without the leading '&' and trailing ';'\n\nmodule.exports = {\n\n    entityToUnicode: {\n        'mu': '',\n        'amp': '&',\n        'lt': '<',\n        'gt': '>',\n        'nbsp': '',\n        'times': '',\n        'plusmn': '',\n        'deg': ''\n    },\n\n    unicodeToEntity: {\n        '&': 'amp',\n        '<': 'lt',\n        '>': 'gt',\n        '\"': 'quot',\n        '\\'': '#x27',\n        '\\/': '#x2F'\n    }\n\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/titles/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\nvar isNumeric = require('fast-isnumeric');\n\nvar Plotly = require('../../plotly');\nvar Plots = require('../../plots/plots');\nvar Lib = require('../../lib');\nvar Drawing = require('../drawing');\nvar Color = require('../color');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar interactConstants = require('../../constants/interactions');\n\n\nvar Titles = module.exports = {};\n\n/**\n * Titles - (re)draw titles on the axes and plot:\n * @param {DOM element} gd - the graphDiv\n * @param {string} titleClass - the css class of this title\n * @param {object} options - how and what to draw\n *      propContainer - the layout object containing `title` and `titlefont`\n *          attributes that apply to this title\n *      propName - the full name of the title property (for Plotly.relayout)\n *      [traceIndex] - include only if this property applies to one trace\n *          (such as a colorbar title) - then editing pipes to Plotly.restyle\n *          instead of Plotly.relayout\n *      dfltName - the name of the title in placeholder text\n *      [avoid] {object} - include if this title should move to avoid other elements\n *          selection - d3 selection of elements to avoid\n *          side - which direction to move if there is a conflict\n *          [offsetLeft] - if these elements are subject to a translation\n *              wrt the title element\n *          [offsetTop]\n *      attributes {object} - position and alignment attributes\n *          x - pixels\n *          y - pixels\n *          text-anchor - start|middle|end\n *      transform {object} - how to transform the title after positioning\n *          rotate - degrees\n *          offset - shift up/down in the rotated frame (unused?)\n *      containerGroup - if an svg <g> element already exists to hold this\n *          title, include here. Otherwise it will go in fullLayout._infolayer\n */\nTitles.draw = function(gd, titleClass, options) {\n    var cont = options.propContainer,\n        prop = options.propName,\n        traceIndex = options.traceIndex,\n        name = options.dfltName,\n        avoid = options.avoid || {},\n        attributes = options.attributes,\n        transform = options.transform,\n        group = options.containerGroup,\n\n        fullLayout = gd._fullLayout,\n        font = cont.titlefont.family,\n        fontSize = cont.titlefont.size,\n        fontColor = cont.titlefont.color,\n\n        opacity = 1,\n        isplaceholder = false,\n        txt = cont.title.trim();\n    if(txt === '') opacity = 0;\n    if(txt.match(/Click to enter .+ title/)) {\n        opacity = 0.2;\n        isplaceholder = true;\n    }\n\n    if(!group) {\n        group = fullLayout._infolayer.selectAll('.g-' + titleClass)\n            .data([0]);\n        group.enter().append('g')\n            .classed('g-' + titleClass, true);\n    }\n\n    var el = group.selectAll('text')\n        .data([0]);\n    el.enter().append('text');\n    el.text(txt)\n        // this is hacky, but convertToTspans uses the class\n        // to determine whether to rotate mathJax...\n        // so we need to clear out any old class and put the\n        // correct one (only relevant for colorbars, at least\n        // for now) - ie don't use .classed\n        .attr('class', titleClass);\n\n    function titleLayout(titleEl) {\n        Lib.syncOrAsync([drawTitle, scootTitle], titleEl);\n    }\n\n    function drawTitle(titleEl) {\n        titleEl.attr('transform', transform ?\n            'rotate(' + [transform.rotate, attributes.x, attributes.y] +\n                ') translate(0, ' + transform.offset + ')' :\n            null);\n\n        titleEl.style({\n            'font-family': font,\n            'font-size': d3.round(fontSize, 2) + 'px',\n            fill: Color.rgb(fontColor),\n            opacity: opacity * Color.opacity(fontColor),\n            'font-weight': Plots.fontWeight\n        })\n        .attr(attributes)\n        .call(svgTextUtils.convertToTspans)\n        .attr(attributes);\n\n        titleEl.selectAll('tspan.line')\n            .attr(attributes);\n        return Plots.previousPromises(gd);\n    }\n\n    function scootTitle(titleElIn) {\n        var titleGroup = d3.select(titleElIn.node().parentNode);\n\n        if(avoid && avoid.selection && avoid.side && txt) {\n            titleGroup.attr('transform', null);\n\n            // move toward avoid.side (= left, right, top, bottom) if needed\n            // can include pad (pixels, default 2)\n            var shift = 0,\n                backside = {\n                    left: 'right',\n                    right: 'left',\n                    top: 'bottom',\n                    bottom: 'top'\n                }[avoid.side],\n                shiftSign = (['left', 'top'].indexOf(avoid.side) !== -1) ?\n                    -1 : 1,\n                pad = isNumeric(avoid.pad) ? avoid.pad : 2,\n                titlebb = Drawing.bBox(titleGroup.node()),\n                paperbb = {\n                    left: 0,\n                    top: 0,\n                    right: fullLayout.width,\n                    bottom: fullLayout.height\n                },\n                maxshift = avoid.maxShift || (\n                    (paperbb[avoid.side] - titlebb[avoid.side]) *\n                    ((avoid.side === 'left' || avoid.side === 'top') ? -1 : 1));\n            // Prevent the title going off the paper\n            if(maxshift < 0) shift = maxshift;\n            else {\n                // so we don't have to offset each avoided element,\n                // give the title the opposite offset\n                var offsetLeft = avoid.offsetLeft || 0,\n                    offsetTop = avoid.offsetTop || 0;\n                titlebb.left -= offsetLeft;\n                titlebb.right -= offsetLeft;\n                titlebb.top -= offsetTop;\n                titlebb.bottom -= offsetTop;\n\n                // iterate over a set of elements (avoid.selection)\n                // to avoid collisions with\n                avoid.selection.each(function() {\n                    var avoidbb = Drawing.bBox(this);\n\n                    if(Lib.bBoxIntersect(titlebb, avoidbb, pad)) {\n                        shift = Math.max(shift, shiftSign * (\n                            avoidbb[avoid.side] - titlebb[backside]) + pad);\n                    }\n                });\n                shift = Math.min(maxshift, shift);\n            }\n            if(shift > 0 || maxshift < 0) {\n                var shiftTemplate = {\n                    left: [-shift, 0],\n                    right: [shift, 0],\n                    top: [0, -shift],\n                    bottom: [0, shift]\n                }[avoid.side];\n                titleGroup.attr('transform',\n                    'translate(' + shiftTemplate + ')');\n            }\n        }\n    }\n\n    el.attr({'data-unformatted': txt})\n        .call(titleLayout);\n\n    var placeholderText = 'Click to enter ' + name + ' title';\n\n    function setPlaceholder() {\n        opacity = 0;\n        isplaceholder = true;\n        txt = placeholderText;\n        el.attr({'data-unformatted': txt})\n            .text(txt)\n            .on('mouseover.opacity', function() {\n                d3.select(this).transition()\n                    .duration(interactConstants.SHOW_PLACEHOLDER).style('opacity', 1);\n            })\n            .on('mouseout.opacity', function() {\n                d3.select(this).transition()\n                    .duration(interactConstants.HIDE_PLACEHOLDER).style('opacity', 0);\n            });\n    }\n\n    if(gd._context.editable) {\n        if(!txt) setPlaceholder();\n        else el.on('.opacity', null);\n\n        el.call(svgTextUtils.makeEditable)\n            .on('edit', function(text) {\n                if(traceIndex !== undefined) Plotly.restyle(gd, prop, text, traceIndex);\n                else Plotly.relayout(gd, prop, text);\n            })\n            .on('cancel', function() {\n                this.text(this.attr('data-unformatted'))\n                    .call(titleLayout);\n            })\n            .on('input', function(d) {\n                this.text(d || ' ').attr(attributes)\n                    .selectAll('tspan.line')\n                        .attr(attributes);\n            });\n    }\n    else if(!txt || txt.match(/Click to enter .+ title/)) {\n        el.remove();\n    }\n    el.classed('js-placeholder', isplaceholder);\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/drawing/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\nvar isNumeric = require('fast-isnumeric');\n\nvar Registry = require('../../registry');\nvar Color = require('../color');\nvar Colorscale = require('../colorscale');\nvar Lib = require('../../lib');\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar xmlnsNamespaces = require('../../constants/xmlns_namespaces');\nvar subTypes = require('../../traces/scatter/subtypes');\nvar makeBubbleSizeFn = require('../../traces/scatter/make_bubble_size_func');\n\nvar drawing = module.exports = {};\n\n// -----------------------------------------------------\n// styling functions for plot elements\n// -----------------------------------------------------\n\ndrawing.font = function(s, family, size, color) {\n    // also allow the form font(s, {family, size, color})\n    if(family && family.family) {\n        color = family.color;\n        size = family.size;\n        family = family.family;\n    }\n    if(family) s.style('font-family', family);\n    if(size + 1) s.style('font-size', size + 'px');\n    if(color) s.call(Color.fill, color);\n};\n\ndrawing.setPosition = function(s, x, y) { s.attr('x', x).attr('y', y); };\ndrawing.setSize = function(s, w, h) { s.attr('width', w).attr('height', h); };\ndrawing.setRect = function(s, x, y, w, h) {\n    s.call(drawing.setPosition, x, y).call(drawing.setSize, w, h);\n};\n\ndrawing.translatePoint = function(d, sel, xa, ya) {\n    // put xp and yp into d if pixel scaling is already done\n    var x = d.xp || xa.c2p(d.x),\n        y = d.yp || ya.c2p(d.y);\n\n    if(isNumeric(x) && isNumeric(y) && sel.node()) {\n        // for multiline text this works better\n        if(sel.node().nodeName === 'text') {\n            sel.attr('x', x).attr('y', y);\n        } else {\n            sel.attr('transform', 'translate(' + x + ',' + y + ')');\n        }\n    }\n    else sel.remove();\n};\n\ndrawing.translatePoints = function(s, xa, ya, trace) {\n    s.each(function(d) {\n        var sel = d3.select(this);\n        drawing.translatePoint(d, sel, xa, ya, trace);\n    });\n};\n\ndrawing.getPx = function(s, styleAttr) {\n    // helper to pull out a px value from a style that may contain px units\n    // s is a d3 selection (will pull from the first one)\n    return Number(s.style(styleAttr).replace(/px$/, ''));\n};\n\ndrawing.crispRound = function(gd, lineWidth, dflt) {\n    // for lines that disable antialiasing we want to\n    // make sure the width is an integer, and at least 1 if it's nonzero\n\n    if(!lineWidth || !isNumeric(lineWidth)) return dflt || 0;\n\n    // but not for static plots - these don't get antialiased anyway.\n    if(gd._context.staticPlot) return lineWidth;\n\n    if(lineWidth < 1) return 1;\n    return Math.round(lineWidth);\n};\n\ndrawing.singleLineStyle = function(d, s, lw, lc, ld) {\n    s.style('fill', 'none');\n    var line = (((d || [])[0] || {}).trace || {}).line || {},\n        lw1 = lw || line.width||0,\n        dash = ld || line.dash || '';\n\n    Color.stroke(s, lc || line.color);\n    drawing.dashLine(s, dash, lw1);\n};\n\ndrawing.lineGroupStyle = function(s, lw, lc, ld) {\n    s.style('fill', 'none')\n    .each(function(d) {\n        var line = (((d || [])[0] || {}).trace || {}).line || {},\n            lw1 = lw || line.width||0,\n            dash = ld || line.dash || '';\n\n        d3.select(this)\n            .call(Color.stroke, lc || line.color)\n            .call(drawing.dashLine, dash, lw1);\n    });\n};\n\ndrawing.dashLine = function(s, dash, lineWidth) {\n    lineWidth = +lineWidth || 0;\n\n    dash = drawing.dashStyle(dash, lineWidth);\n\n    s.style({\n        'stroke-dasharray': dash,\n        'stroke-width': lineWidth + 'px'\n    });\n};\n\ndrawing.dashStyle = function(dash, lineWidth) {\n    lineWidth = +lineWidth || 1;\n    var dlw = Math.max(lineWidth, 3);\n\n    if(dash === 'solid') dash = '';\n    else if(dash === 'dot') dash = dlw + 'px,' + dlw + 'px';\n    else if(dash === 'dash') dash = (3 * dlw) + 'px,' + (3 * dlw) + 'px';\n    else if(dash === 'longdash') dash = (5 * dlw) + 'px,' + (5 * dlw) + 'px';\n    else if(dash === 'dashdot') {\n        dash = (3 * dlw) + 'px,' + dlw + 'px,' + dlw + 'px,' + dlw + 'px';\n    }\n    else if(dash === 'longdashdot') {\n        dash = (5 * dlw) + 'px,' + (2 * dlw) + 'px,' + dlw + 'px,' + (2 * dlw) + 'px';\n    }\n    // otherwise user wrote the dasharray themselves - leave it be\n\n    return dash;\n};\n\ndrawing.fillGroupStyle = function(s) {\n    s.style('stroke-width', 0)\n    .each(function(d) {\n        var shape = d3.select(this);\n        try {\n            shape.call(Color.fill, d[0].trace.fillcolor);\n        }\n        catch(e) {\n            Lib.error(e, s);\n            shape.remove();\n        }\n    });\n};\n\nvar SYMBOLDEFS = require('./symbol_defs');\n\ndrawing.symbolNames = [];\ndrawing.symbolFuncs = [];\ndrawing.symbolNeedLines = {};\ndrawing.symbolNoDot = {};\ndrawing.symbolList = [];\n\nObject.keys(SYMBOLDEFS).forEach(function(k) {\n    var symDef = SYMBOLDEFS[k];\n    drawing.symbolList = drawing.symbolList.concat(\n        [symDef.n, k, symDef.n + 100, k + '-open']);\n    drawing.symbolNames[symDef.n] = k;\n    drawing.symbolFuncs[symDef.n] = symDef.f;\n    if(symDef.needLine) {\n        drawing.symbolNeedLines[symDef.n] = true;\n    }\n    if(symDef.noDot) {\n        drawing.symbolNoDot[symDef.n] = true;\n    }\n    else {\n        drawing.symbolList = drawing.symbolList.concat(\n            [symDef.n + 200, k + '-dot', symDef.n + 300, k + '-open-dot']);\n    }\n});\nvar MAXSYMBOL = drawing.symbolNames.length,\n    // add a dot in the middle of the symbol\n    DOTPATH = 'M0,0.5L0.5,0L0,-0.5L-0.5,0Z';\n\ndrawing.symbolNumber = function(v) {\n    if(typeof v === 'string') {\n        var vbase = 0;\n        if(v.indexOf('-open') > 0) {\n            vbase = 100;\n            v = v.replace('-open', '');\n        }\n        if(v.indexOf('-dot') > 0) {\n            vbase += 200;\n            v = v.replace('-dot', '');\n        }\n        v = drawing.symbolNames.indexOf(v);\n        if(v >= 0) { v += vbase; }\n    }\n    if((v % 100 >= MAXSYMBOL) || v >= 400) { return 0; }\n    return Math.floor(Math.max(v, 0));\n};\n\nfunction singlePointStyle(d, sel, trace, markerScale, lineScale, marker, markerLine) {\n    // only scatter & box plots get marker path and opacity\n    // bars, histograms don't\n    if(Registry.traceIs(trace, 'symbols')) {\n        var sizeFn = makeBubbleSizeFn(trace);\n\n        sel.attr('d', function(d) {\n            var r;\n\n            // handle multi-trace graph edit case\n            if(d.ms === 'various' || marker.size === 'various') r = 3;\n            else {\n                r = subTypes.isBubble(trace) ?\n                        sizeFn(d.ms) : (marker.size || 6) / 2;\n            }\n\n            // store the calculated size so hover can use it\n            d.mrc = r;\n\n            // turn the symbol into a sanitized number\n            var x = drawing.symbolNumber(d.mx || marker.symbol) || 0,\n                xBase = x % 100;\n\n            // save if this marker is open\n            // because that impacts how to handle colors\n            d.om = x % 200 >= 100;\n\n            return drawing.symbolFuncs[xBase](r) +\n                (x >= 200 ? DOTPATH : '');\n        })\n        .style('opacity', function(d) {\n            return (d.mo + 1 || marker.opacity + 1) - 1;\n        });\n    }\n\n    // 'so' is suspected outliers, for box plots\n    var fillColor,\n        lineColor,\n        lineWidth;\n    if(d.so) {\n        lineWidth = markerLine.outlierwidth;\n        lineColor = markerLine.outliercolor;\n        fillColor = marker.outliercolor;\n    }\n    else {\n        lineWidth = (d.mlw + 1 || markerLine.width + 1 ||\n            // TODO: we need the latter for legends... can we get rid of it?\n            (d.trace ? d.trace.marker.line.width : 0) + 1) - 1;\n\n        if('mlc' in d) lineColor = d.mlcc = lineScale(d.mlc);\n        // weird case: array wasn't long enough to apply to every point\n        else if(Array.isArray(markerLine.color)) lineColor = Color.defaultLine;\n        else lineColor = markerLine.color;\n\n        if('mc' in d) fillColor = d.mcc = markerScale(d.mc);\n        else if(Array.isArray(marker.color)) fillColor = Color.defaultLine;\n        else fillColor = marker.color || 'rgba(0,0,0,0)';\n    }\n\n    if(d.om) {\n        // open markers can't have zero linewidth, default to 1px,\n        // and use fill color as stroke color\n        sel.call(Color.stroke, fillColor)\n            .style({\n                'stroke-width': (lineWidth || 1) + 'px',\n                fill: 'none'\n            });\n    }\n    else {\n        sel.style('stroke-width', lineWidth + 'px')\n            .call(Color.fill, fillColor);\n        if(lineWidth) {\n            sel.call(Color.stroke, lineColor);\n        }\n    }\n}\n\ndrawing.singlePointStyle = function(d, sel, trace) {\n    var marker = trace.marker,\n        markerLine = marker.line;\n\n    // allow array marker and marker line colors to be\n    // scaled by given max and min to colorscales\n    var markerScale = drawing.tryColorscale(marker, ''),\n        lineScale = drawing.tryColorscale(marker, 'line');\n\n    singlePointStyle(d, sel, trace, markerScale, lineScale, marker, markerLine);\n\n};\n\ndrawing.pointStyle = function(s, trace) {\n    if(!s.size()) return;\n\n    // allow array marker and marker line colors to be\n    // scaled by given max and min to colorscales\n    var marker = trace.marker;\n    var markerScale = drawing.tryColorscale(marker, ''),\n        lineScale = drawing.tryColorscale(marker, 'line');\n\n    s.each(function(d) {\n        drawing.singlePointStyle(d, d3.select(this), trace, markerScale, lineScale);\n    });\n};\n\ndrawing.tryColorscale = function(marker, prefix) {\n    var cont = prefix ? Lib.nestedProperty(marker, prefix).get() : marker,\n        scl = cont.colorscale,\n        colorArray = cont.color;\n\n    if(scl && Array.isArray(colorArray)) {\n        return Colorscale.makeColorScaleFunc(\n            Colorscale.extractScale(scl, cont.cmin, cont.cmax)\n        );\n    }\n    else return Lib.identity;\n};\n\n// draw text at points\nvar TEXTOFFSETSIGN = {start: 1, end: -1, middle: 0, bottom: 1, top: -1},\n    LINEEXPAND = 1.3;\ndrawing.textPointStyle = function(s, trace) {\n    s.each(function(d) {\n        var p = d3.select(this),\n            text = d.tx || trace.text;\n\n        if(!text || Array.isArray(text)) {\n            // isArray test handles the case of (intentionally) missing\n            // or empty text within a text array\n            p.remove();\n            return;\n        }\n\n        var pos = d.tp || trace.textposition,\n            v = pos.indexOf('top') !== -1 ? 'top' :\n                pos.indexOf('bottom') !== -1 ? 'bottom' : 'middle',\n            h = pos.indexOf('left') !== -1 ? 'end' :\n                pos.indexOf('right') !== -1 ? 'start' : 'middle',\n            fontSize = d.ts || trace.textfont.size,\n            // if markers are shown, offset a little more than\n            // the nominal marker size\n            // ie 2/1.6 * nominal, bcs some markers are a bit bigger\n            r = d.mrc ? (d.mrc / 0.8 + 1) : 0;\n\n        fontSize = (isNumeric(fontSize) && fontSize > 0) ? fontSize : 0;\n\n        p.call(drawing.font,\n                d.tf || trace.textfont.family,\n                fontSize,\n                d.tc || trace.textfont.color)\n            .attr('text-anchor', h)\n            .text(text)\n            .call(svgTextUtils.convertToTspans);\n        var pgroup = d3.select(this.parentNode),\n            tspans = p.selectAll('tspan.line'),\n            numLines = ((tspans[0].length || 1) - 1) * LINEEXPAND + 1,\n            dx = TEXTOFFSETSIGN[h] * r,\n            dy = fontSize * 0.75 + TEXTOFFSETSIGN[v] * r +\n                (TEXTOFFSETSIGN[v] - 1) * numLines * fontSize / 2;\n\n        // fix the overall text group position\n        pgroup.attr('transform', 'translate(' + dx + ',' + dy + ')');\n\n        // then fix multiline text\n        if(numLines > 1) {\n            tspans.attr({ x: p.attr('x'), y: p.attr('y') });\n        }\n    });\n};\n\n// generalized Catmull-Rom splines, per\n// http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\nvar CatmullRomExp = 0.5;\ndrawing.smoothopen = function(pts, smoothness) {\n    if(pts.length < 3) { return 'M' + pts.join('L');}\n    var path = 'M' + pts[0],\n        tangents = [], i;\n    for(i = 1; i < pts.length - 1; i++) {\n        tangents.push(makeTangent(pts[i - 1], pts[i], pts[i + 1], smoothness));\n    }\n    path += 'Q' + tangents[0][0] + ' ' + pts[1];\n    for(i = 2; i < pts.length - 1; i++) {\n        path += 'C' + tangents[i - 2][1] + ' ' + tangents[i - 1][0] + ' ' + pts[i];\n    }\n    path += 'Q' + tangents[pts.length - 3][1] + ' ' + pts[pts.length - 1];\n    return path;\n};\n\ndrawing.smoothclosed = function(pts, smoothness) {\n    if(pts.length < 3) { return 'M' + pts.join('L') + 'Z'; }\n    var path = 'M' + pts[0],\n        pLast = pts.length - 1,\n        tangents = [makeTangent(pts[pLast],\n                        pts[0], pts[1], smoothness)],\n        i;\n    for(i = 1; i < pLast; i++) {\n        tangents.push(makeTangent(pts[i - 1], pts[i], pts[i + 1], smoothness));\n    }\n    tangents.push(\n        makeTangent(pts[pLast - 1], pts[pLast], pts[0], smoothness)\n    );\n\n    for(i = 1; i <= pLast; i++) {\n        path += 'C' + tangents[i - 1][1] + ' ' + tangents[i][0] + ' ' + pts[i];\n    }\n    path += 'C' + tangents[pLast][1] + ' ' + tangents[0][0] + ' ' + pts[0] + 'Z';\n    return path;\n};\n\nfunction makeTangent(prevpt, thispt, nextpt, smoothness) {\n    var d1x = prevpt[0] - thispt[0],\n        d1y = prevpt[1] - thispt[1],\n        d2x = nextpt[0] - thispt[0],\n        d2y = nextpt[1] - thispt[1],\n        d1a = Math.pow(d1x * d1x + d1y * d1y, CatmullRomExp / 2),\n        d2a = Math.pow(d2x * d2x + d2y * d2y, CatmullRomExp / 2),\n        numx = (d2a * d2a * d1x - d1a * d1a * d2x) * smoothness,\n        numy = (d2a * d2a * d1y - d1a * d1a * d2y) * smoothness,\n        denom1 = 3 * d2a * (d1a + d2a),\n        denom2 = 3 * d1a * (d1a + d2a);\n    return [\n        [\n            d3.round(thispt[0] + (denom1 && numx / denom1), 2),\n            d3.round(thispt[1] + (denom1 && numy / denom1), 2)\n        ], [\n            d3.round(thispt[0] - (denom2 && numx / denom2), 2),\n            d3.round(thispt[1] - (denom2 && numy / denom2), 2)\n        ]\n    ];\n}\n\n// step paths - returns a generator function for paths\n// with the given step shape\nvar STEPPATH = {\n    hv: function(p0, p1) {\n        return 'H' + d3.round(p1[0], 2) + 'V' + d3.round(p1[1], 2);\n    },\n    vh: function(p0, p1) {\n        return 'V' + d3.round(p1[1], 2) + 'H' + d3.round(p1[0], 2);\n    },\n    hvh: function(p0, p1) {\n        return 'H' + d3.round((p0[0] + p1[0]) / 2, 2) + 'V' +\n            d3.round(p1[1], 2) + 'H' + d3.round(p1[0], 2);\n    },\n    vhv: function(p0, p1) {\n        return 'V' + d3.round((p0[1] + p1[1]) / 2, 2) + 'H' +\n            d3.round(p1[0], 2) + 'V' + d3.round(p1[1], 2);\n    }\n};\nvar STEPLINEAR = function(p0, p1) {\n    return 'L' + d3.round(p1[0], 2) + ',' + d3.round(p1[1], 2);\n};\ndrawing.steps = function(shape) {\n    var onestep = STEPPATH[shape] || STEPLINEAR;\n    return function(pts) {\n        var path = 'M' + d3.round(pts[0][0], 2) + ',' + d3.round(pts[0][1], 2);\n        for(var i = 1; i < pts.length; i++) {\n            path += onestep(pts[i - 1], pts[i]);\n        }\n        return path;\n    };\n};\n\n// off-screen svg render testing element, shared by the whole page\n// uses the id 'js-plotly-tester' and stores it in gd._tester\n// makes a hash of cached text items in tester.node()._cache\n// so we can add references to rendered text (including all info\n// needed to fully determine its bounding rect)\ndrawing.makeTester = function(gd) {\n    var tester = d3.select('body')\n        .selectAll('#js-plotly-tester')\n        .data([0]);\n\n    tester.enter().append('svg')\n        .attr('id', 'js-plotly-tester')\n        .attr(xmlnsNamespaces.svgAttrs)\n        .style({\n            position: 'absolute',\n            left: '-10000px',\n            top: '-10000px',\n            width: '9000px',\n            height: '9000px',\n            'z-index': '1'\n        });\n\n    // browsers differ on how they describe the bounding rect of\n    // the svg if its contents spill over... so make a 1x1px\n    // reference point we can measure off of.\n    var testref = tester.selectAll('.js-reference-point').data([0]);\n    testref.enter().append('path')\n        .classed('js-reference-point', true)\n        .attr('d', 'M0,0H1V1H0Z')\n        .style({\n            'stroke-width': 0,\n            fill: 'black'\n        });\n\n    if(!tester.node()._cache) {\n        tester.node()._cache = {};\n    }\n\n    gd._tester = tester;\n    gd._testref = testref;\n};\n\n// use our offscreen tester to get a clientRect for an element,\n// in a reference frame where it isn't translated and its anchor\n// point is at (0,0)\n// always returns a copy of the bbox, so the caller can modify it safely\nvar savedBBoxes = [],\n    maxSavedBBoxes = 10000;\ndrawing.bBox = function(node) {\n    // cache elements we've already measured so we don't have to\n    // remeasure the same thing many times\n    var saveNum = node.attributes['data-bb'];\n    if(saveNum && saveNum.value) {\n        return Lib.extendFlat({}, savedBBoxes[saveNum.value]);\n    }\n\n    var test3 = d3.select('#js-plotly-tester'),\n        tester = test3.node();\n\n    // copy the node to test into the tester\n    var testNode = node.cloneNode(true);\n    tester.appendChild(testNode);\n    // standardize its position... do we really want to do this?\n    d3.select(testNode).attr({\n        x: 0,\n        y: 0,\n        transform: ''\n    });\n\n    var testRect = testNode.getBoundingClientRect(),\n        refRect = test3.select('.js-reference-point')\n            .node().getBoundingClientRect();\n\n    tester.removeChild(testNode);\n\n    var bb = {\n        height: testRect.height,\n        width: testRect.width,\n        left: testRect.left - refRect.left,\n        top: testRect.top - refRect.top,\n        right: testRect.right - refRect.left,\n        bottom: testRect.bottom - refRect.top\n    };\n\n    // make sure we don't have too many saved boxes,\n    // or a long session could overload on memory\n    // by saving boxes for long-gone elements\n    if(savedBBoxes.length >= maxSavedBBoxes) {\n        d3.selectAll('[data-bb]').attr('data-bb', null);\n        savedBBoxes = [];\n    }\n\n    // cache this bbox\n    node.setAttribute('data-bb', savedBBoxes.length);\n    savedBBoxes.push(bb);\n\n    return Lib.extendFlat({}, bb);\n};\n\n/*\n * make a robust clipPath url from a local id\n * note! We'd better not be exporting from a page\n * with a <base> or the svg will not be portable!\n */\ndrawing.setClipUrl = function(s, localId) {\n    if(!localId) {\n        s.attr('clip-path', null);\n        return;\n    }\n\n    var url = '#' + localId,\n        base = d3.select('base');\n\n    // add id to location href w/o hashes if any)\n    if(base.size() && base.attr('href')) {\n        url = window.location.href.split('#')[0] + url;\n    }\n\n    s.attr('clip-path', 'url(' + url + ')');\n};\n\ndrawing.getTranslate = function(element) {\n    // Note the separator [^\\d] between x and y in this regex\n    // We generally use ',' but IE will convert it to ' '\n    var re = /.*\\btranslate\\((-?\\d*\\.?\\d*)[^-\\d]*(-?\\d*\\.?\\d*)[^\\d].*/,\n        getter = element.attr ? 'attr' : 'getAttribute',\n        transform = element[getter]('transform') || '';\n\n    var translate = transform.replace(re, function(match, p1, p2) {\n        return [p1, p2].join(' ');\n    })\n    .split(' ');\n\n    return {\n        x: +translate[0] || 0,\n        y: +translate[1] || 0\n    };\n};\n\ndrawing.setTranslate = function(element, x, y) {\n\n    var re = /(\\btranslate\\(.*?\\);?)/,\n        getter = element.attr ? 'attr' : 'getAttribute',\n        setter = element.attr ? 'attr' : 'setAttribute',\n        transform = element[getter]('transform') || '';\n\n    x = x || 0;\n    y = y || 0;\n\n    transform = transform.replace(re, '').trim();\n    transform += ' translate(' + x + ', ' + y + ')';\n    transform = transform.trim();\n\n    element[setter]('transform', transform);\n\n    return transform;\n};\n\ndrawing.getScale = function(element) {\n\n    var re = /.*\\bscale\\((\\d*\\.?\\d*)[^\\d]*(\\d*\\.?\\d*)[^\\d].*/,\n        getter = element.attr ? 'attr' : 'getAttribute',\n        transform = element[getter]('transform') || '';\n\n    var translate = transform.replace(re, function(match, p1, p2) {\n        return [p1, p2].join(' ');\n    })\n    .split(' ');\n\n    return {\n        x: +translate[0] || 1,\n        y: +translate[1] || 1\n    };\n};\n\ndrawing.setScale = function(element, x, y) {\n\n    var re = /(\\bscale\\(.*?\\);?)/,\n        getter = element.attr ? 'attr' : 'getAttribute',\n        setter = element.attr ? 'attr' : 'setAttribute',\n        transform = element[getter]('transform') || '';\n\n    x = x || 1;\n    y = y || 1;\n\n    transform = transform.replace(re, '').trim();\n    transform += ' scale(' + x + ', ' + y + ')';\n    transform = transform.trim();\n\n    element[setter]('transform', transform);\n\n    return transform;\n};\n\ndrawing.setPointGroupScale = function(selection, x, y) {\n    var t, scale, re;\n\n    x = x || 1;\n    y = y || 1;\n\n    if(x === 1 && y === 1) {\n        scale = '';\n    } else {\n        // The same scale transform for every point:\n        scale = ' scale(' + x + ',' + y + ')';\n    }\n\n    // A regex to strip any existing scale:\n    re = /\\s*sc.*/;\n\n    selection.each(function() {\n        // Get the transform:\n        t = (this.getAttribute('transform') || '').replace(re, '');\n        t += scale;\n        t = t.trim();\n\n        // Append the scale transform\n        this.setAttribute('transform', t);\n    });\n\n    return scale;\n};\n\ndrawing.measureText = function(tester, text, font) {\n    var dummyText = tester.append('text')\n        .text(text)\n        .call(drawing.font, font);\n\n    var bbox = drawing.bBox(dummyText.node());\n    dummyText.remove();\n    return bbox;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/colorscale/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nexports.scales = require('./scales');\n\nexports.defaultScale = require('./default_scale');\n\nexports.attributes = require('./attributes');\n\nexports.handleDefaults = require('./defaults');\n\nexports.calc = require('./calc');\n\nexports.hasColorscale = require('./has_colorscale');\n\nexports.isValidScale = require('./is_valid_scale');\n\nexports.getScale = require('./get_scale');\n\nexports.flipScale = require('./flip_scale');\n\nexports.extractScale = require('./extract_scale');\n\nexports.makeColorScaleFunc = require('./make_color_scale_func');\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/colorscale/attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = {\n    zauto: {\n        valType: 'boolean',\n        role: 'info',\n        dflt: true,\n        description: [\n            'Determines the whether or not the color domain is computed',\n            'with respect to the input data.'\n        ].join(' ')\n    },\n    zmin: {\n        valType: 'number',\n        role: 'info',\n        dflt: null,\n        description: 'Sets the lower bound of color domain.'\n    },\n    zmax: {\n        valType: 'number',\n        role: 'info',\n        dflt: null,\n        description: 'Sets the upper bound of color domain.'\n    },\n    colorscale: {\n        valType: 'colorscale',\n        role: 'style',\n        description: [\n            'Sets the colorscale.',\n            'The colorscale must be an array containing',\n            'arrays mapping a normalized value to an',\n            'rgb, rgba, hex, hsl, hsv, or named color string.',\n            'At minimum, a mapping for the lowest (0) and highest (1)',\n            'values are required. For example,',\n            '`[[0, \\'rgb(0,0,255)\\', [1, \\'rgb(255,0,0)\\']]`.',\n            'To control the bounds of the colorscale in z space,',\n            'use zmin and zmax'\n        ].join(' ')\n    },\n    autocolorscale: {\n        valType: 'boolean',\n        role: 'style',\n        dflt: true,  // gets overrode in 'heatmap' & 'surface' for backwards comp.\n        description: [\n            'Determines whether or not the colorscale is picked using the sign of',\n            'the input z values.'\n        ].join(' ')\n    },\n    reversescale: {\n        valType: 'boolean',\n        role: 'style',\n        dflt: false,\n        description: 'Reverses the colorscale.'\n    },\n    showscale: {\n        valType: 'boolean',\n        role: 'info',\n        dflt: true,\n        description: [\n            'Determines whether or not a colorbar is displayed for this trace.'\n        ].join(' ')\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/colorscale/defaults.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\n\nvar hasColorbar = require('../colorbar/has_colorbar');\nvar colorbarDefaults = require('../colorbar/defaults');\nvar isValidScale = require('./is_valid_scale');\nvar flipScale = require('./flip_scale');\n\n\nmodule.exports = function colorScaleDefaults(traceIn, traceOut, layout, coerce, opts) {\n    var prefix = opts.prefix,\n        cLetter = opts.cLetter,\n        containerStr = prefix.slice(0, prefix.length - 1),\n        containerIn = prefix ?\n            Lib.nestedProperty(traceIn, containerStr).get() || {} :\n            traceIn,\n        containerOut = prefix ?\n            Lib.nestedProperty(traceOut, containerStr).get() || {} :\n            traceOut,\n        minIn = containerIn[cLetter + 'min'],\n        maxIn = containerIn[cLetter + 'max'],\n        sclIn = containerIn.colorscale;\n\n    var validMinMax = isNumeric(minIn) && isNumeric(maxIn) && (minIn < maxIn);\n    coerce(prefix + cLetter + 'auto', !validMinMax);\n    coerce(prefix + cLetter + 'min');\n    coerce(prefix + cLetter + 'max');\n\n    // handles both the trace case (autocolorscale is false by default) and\n    // the marker and marker.line case (autocolorscale is true by default)\n    var autoColorscaleDftl;\n    if(sclIn !== undefined) autoColorscaleDftl = !isValidScale(sclIn);\n    coerce(prefix + 'autocolorscale', autoColorscaleDftl);\n    var sclOut = coerce(prefix + 'colorscale');\n\n    // reversescale is handled at the containerOut level\n    var reverseScale = coerce(prefix + 'reversescale');\n    if(reverseScale) containerOut.colorscale = flipScale(sclOut);\n\n    // ... until Scatter.colorbar can handle marker line colorbars\n    if(prefix === 'marker.line.') return;\n\n    // handle both the trace case where the dflt is listed in attributes and\n    // the marker case where the dflt is determined by hasColorbar\n    var showScaleDftl;\n    if(prefix) showScaleDftl = hasColorbar(containerIn);\n    var showScale = coerce(prefix + 'showscale', showScaleDftl);\n\n    if(showScale) colorbarDefaults(containerIn, containerOut, layout);\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/colorbar/has_colorbar.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Lib = require('../../lib');\n\n\nmodule.exports = function hasColorbar(container) {\n    return Lib.isPlainObject(container.colorbar);\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/colorbar/defaults.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar handleTickValueDefaults = require('../../plots/cartesian/tick_value_defaults');\nvar handleTickMarkDefaults = require('../../plots/cartesian/tick_mark_defaults');\nvar handleTickLabelDefaults = require('../../plots/cartesian/tick_label_defaults');\n\nvar attributes = require('./attributes');\n\n\nmodule.exports = function colorbarDefaults(containerIn, containerOut, layout) {\n    var colorbarOut = containerOut.colorbar = {},\n        colorbarIn = containerIn.colorbar || {};\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(colorbarIn, colorbarOut, attributes, attr, dflt);\n    }\n\n    var thicknessmode = coerce('thicknessmode');\n    coerce('thickness', (thicknessmode === 'fraction') ?\n        30 / (layout.width - layout.margin.l - layout.margin.r) :\n        30\n    );\n\n    var lenmode = coerce('lenmode');\n    coerce('len', (lenmode === 'fraction') ?\n        1 :\n        layout.height - layout.margin.t - layout.margin.b\n    );\n\n    coerce('x');\n    coerce('xanchor');\n    coerce('xpad');\n    coerce('y');\n    coerce('yanchor');\n    coerce('ypad');\n    Lib.noneOrAll(colorbarIn, colorbarOut, ['x', 'y']);\n\n    coerce('outlinecolor');\n    coerce('outlinewidth');\n    coerce('bordercolor');\n    coerce('borderwidth');\n    coerce('bgcolor');\n\n    handleTickValueDefaults(colorbarIn, colorbarOut, coerce, 'linear');\n\n    handleTickLabelDefaults(colorbarIn, colorbarOut, coerce, 'linear',\n        {outerTicks: false, font: layout.font, noHover: true});\n\n    handleTickMarkDefaults(colorbarIn, colorbarOut, coerce, 'linear',\n        {outerTicks: false, font: layout.font, noHover: true});\n\n    coerce('title');\n    Lib.coerceFont(coerce, 'titlefont', layout.font);\n    coerce('titleside');\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/cartesian/tick_value_defaults.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar Lib = require('../../lib');\nvar ONEDAY = require('../../constants/numerical').ONEDAY;\n\n\nmodule.exports = function handleTickValueDefaults(containerIn, containerOut, coerce, axType) {\n    var tickmodeDefault = 'auto';\n\n    if(containerIn.tickmode === 'array' &&\n            (axType === 'log' || axType === 'date')) {\n        containerIn.tickmode = 'auto';\n    }\n\n    if(Array.isArray(containerIn.tickvals)) tickmodeDefault = 'array';\n    else if(containerIn.dtick) {\n        tickmodeDefault = 'linear';\n    }\n    var tickmode = coerce('tickmode', tickmodeDefault);\n\n    if(tickmode === 'auto') coerce('nticks');\n    else if(tickmode === 'linear') {\n        // dtick is usually a positive number, but there are some\n        // special strings available for log or date axes\n        // default is 1 day for dates, otherwise 1\n        var dtickDflt = (axType === 'date') ? ONEDAY : 1;\n        var dtick = coerce('dtick', dtickDflt);\n        if(isNumeric(dtick)) {\n            containerOut.dtick = (dtick > 0) ? Number(dtick) : dtickDflt;\n        }\n        else if(typeof dtick !== 'string') {\n            containerOut.dtick = dtickDflt;\n        }\n        else {\n            // date and log special cases are all one character plus a number\n            var prefix = dtick.charAt(0),\n                dtickNum = dtick.substr(1);\n\n            dtickNum = isNumeric(dtickNum) ? Number(dtickNum) : 0;\n            if((dtickNum <= 0) || !(\n                    // \"M<n>\" gives ticks every (integer) n months\n                    (axType === 'date' && prefix === 'M' && dtickNum === Math.round(dtickNum)) ||\n                    // \"L<f>\" gives ticks linearly spaced in data (not in position) every (float) f\n                    (axType === 'log' && prefix === 'L') ||\n                    // \"D1\" gives powers of 10 with all small digits between, \"D2\" gives only 2 and 5\n                    (axType === 'log' && prefix === 'D' && (dtickNum === 1 || dtickNum === 2))\n                )) {\n                containerOut.dtick = dtickDflt;\n            }\n        }\n\n        // tick0 can have different valType for different axis types, so\n        // validate that now. Also for dates, change milliseconds to date strings\n        var tick0Dflt = (axType === 'date') ? Lib.dateTick0(containerOut.calendar) : 0;\n        var tick0 = coerce('tick0', tick0Dflt);\n        if(axType === 'date') {\n            containerOut.tick0 = Lib.cleanDate(tick0, tick0Dflt);\n        }\n        // Aside from date axes, dtick must be numeric; D1 and D2 modes ignore tick0 entirely\n        else if(isNumeric(tick0) && dtick !== 'D1' && dtick !== 'D2') {\n            containerOut.tick0 = Number(tick0);\n        }\n        else {\n            containerOut.tick0 = tick0Dflt;\n        }\n    }\n    else {\n        var tickvals = coerce('tickvals');\n        if(tickvals === undefined) containerOut.tickmode = 'auto';\n        else coerce('ticktext');\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/cartesian/tick_mark_defaults.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Lib = require('../../lib');\n\nvar layoutAttributes = require('./layout_attributes');\n\n\n/**\n * options: inherits outerTicks from axes.handleAxisDefaults\n */\nmodule.exports = function handleTickDefaults(containerIn, containerOut, coerce, options) {\n    var tickLen = Lib.coerce2(containerIn, containerOut, layoutAttributes, 'ticklen'),\n        tickWidth = Lib.coerce2(containerIn, containerOut, layoutAttributes, 'tickwidth'),\n        tickColor = Lib.coerce2(containerIn, containerOut, layoutAttributes, 'tickcolor', containerOut.color),\n        showTicks = coerce('ticks', (options.outerTicks || tickLen || tickWidth || tickColor) ? 'outside' : '');\n\n    if(!showTicks) {\n        delete containerOut.ticklen;\n        delete containerOut.tickwidth;\n        delete containerOut.tickcolor;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/cartesian/layout_attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar fontAttrs = require('../font_attributes');\nvar colorAttrs = require('../../components/color/attributes');\nvar dash = require('../../components/drawing/attributes').dash;\nvar extendFlat = require('../../lib/extend').extendFlat;\n\nvar constants = require('./constants');\n\n\nmodule.exports = {\n    visible: {\n        valType: 'boolean',\n        role: 'info',\n        description: [\n            'A single toggle to hide the axis while preserving interaction like dragging.',\n            'Default is true when a cheater plot is present on the axis, otherwise',\n            'false'\n        ].join(' ')\n    },\n    color: {\n        valType: 'color',\n        dflt: colorAttrs.defaultLine,\n        role: 'style',\n        description: [\n            'Sets default for all colors associated with this axis',\n            'all at once: line, font, tick, and grid colors.',\n            'Grid color is lightened by blending this with the plot background',\n            'Individual pieces can override this.'\n        ].join(' ')\n    },\n    title: {\n        valType: 'string',\n        role: 'info',\n        description: 'Sets the title of this axis.'\n    },\n    titlefont: extendFlat({}, fontAttrs, {\n        description: [\n            'Sets this axis\\' title font.'\n        ].join(' ')\n    }),\n    type: {\n        valType: 'enumerated',\n        // '-' means we haven't yet run autotype or couldn't find any data\n        // it gets turned into linear in gd._fullLayout but not copied back\n        // to gd.data like the others are.\n        values: ['-', 'linear', 'log', 'date', 'category'],\n        dflt: '-',\n        role: 'info',\n        description: [\n            'Sets the axis type.',\n            'By default, plotly attempts to determined the axis type',\n            'by looking into the data of the traces that referenced',\n            'the axis in question.'\n        ].join(' ')\n    },\n    autorange: {\n        valType: 'enumerated',\n        values: [true, false, 'reversed'],\n        dflt: true,\n        role: 'style',\n        description: [\n            'Determines whether or not the range of this axis is',\n            'computed in relation to the input data.',\n            'See `rangemode` for more info.',\n            'If `range` is provided, then `autorange` is set to *false*.'\n        ].join(' ')\n    },\n    rangemode: {\n        valType: 'enumerated',\n        values: ['normal', 'tozero', 'nonnegative'],\n        dflt: 'normal',\n        role: 'style',\n        description: [\n            'If *normal*, the range is computed in relation to the extrema',\n            'of the input data.',\n            'If *tozero*`, the range extends to 0,',\n            'regardless of the input data',\n            'If *nonnegative*, the range is non-negative,',\n            'regardless of the input data.'\n        ].join(' ')\n    },\n    range: {\n        valType: 'info_array',\n        role: 'info',\n        items: [\n            {valType: 'any'},\n            {valType: 'any'}\n        ],\n        description: [\n            'Sets the range of this axis.',\n            'If the axis `type` is *log*, then you must take the log of your',\n            'desired range (e.g. to set the range from 1 to 100,',\n            'set the range from 0 to 2).',\n            'If the axis `type` is *date*, it should be date strings,',\n            'like date data, though Date objects and unix milliseconds',\n            'will be accepted and converted to strings.',\n            'If the axis `type` is *category*, it should be numbers,',\n            'using the scale where each category is assigned a serial',\n            'number from zero in the order it appears.'\n        ].join(' ')\n    },\n    fixedrange: {\n        valType: 'boolean',\n        dflt: false,\n        role: 'info',\n        description: [\n            'Determines whether or not this axis is zoom-able.',\n            'If true, then zoom is disabled.'\n        ].join(' ')\n    },\n    // scaleanchor: not used directly, just put here for reference\n    // values are any opposite-letter axis id\n    scaleanchor: {\n        valType: 'enumerated',\n        values: [\n            constants.idRegex.x.toString(),\n            constants.idRegex.y.toString()\n        ],\n        role: 'info',\n        description: [\n            'If set to an opposite-letter axis id (e.g. `x2`, `y`), the range of this axis',\n            'changes together with the range of the corresponding opposite-letter axis.',\n            'such that the scale of pixels per unit is in a constant ratio.',\n            'Both axes are still zoomable, but when you zoom one, the other will',\n            'zoom the same amount, keeping a fixed midpoint.',\n            'Autorange will also expand about the midpoints to satisfy the constraint.',\n            'You can chain these, ie `yaxis: {scaleanchor: *x*}, xaxis2: {scaleanchor: *y*}`',\n            'but you can only link axes of the same `type`.',\n            'Loops (`yaxis: {scaleanchor: *x*}, xaxis: {scaleanchor: *y*}` or longer) are redundant',\n            'and the last constraint encountered will be ignored to avoid possible',\n            'inconsistent constraints via `scaleratio`.'\n        ].join(' ')\n    },\n    scaleratio: {\n        valType: 'number',\n        min: 0,\n        dflt: 1,\n        role: 'info',\n        description: [\n            'If this axis is linked to another by `scaleanchor`, this determines the pixel',\n            'to unit scale ratio. For example, if this value is 10, then every unit on',\n            'this axis spans 10 times the number of pixels as a unit on the linked axis.',\n            'Use this for example to create an elevation profile where the vertical scale',\n            'is exaggerated a fixed amount with respect to the horizontal.'\n        ].join(' ')\n    },\n    // ticks\n    tickmode: {\n        valType: 'enumerated',\n        values: ['auto', 'linear', 'array'],\n        role: 'info',\n        description: [\n            'Sets the tick mode for this axis.',\n            'If *auto*, the number of ticks is set via `nticks`.',\n            'If *linear*, the placement of the ticks is determined by',\n            'a starting position `tick0` and a tick step `dtick`',\n            '(*linear* is the default value if `tick0` and `dtick` are provided).',\n            'If *array*, the placement of the ticks is set via `tickvals`',\n            'and the tick text is `ticktext`.',\n            '(*array* is the default value if `tickvals` is provided).'\n        ].join(' ')\n    },\n    nticks: {\n        valType: 'integer',\n        min: 0,\n        dflt: 0,\n        role: 'style',\n        description: [\n            'Specifies the maximum number of ticks for the particular axis.',\n            'The actual number of ticks will be chosen automatically to be',\n            'less than or equal to `nticks`.',\n            'Has an effect only if `tickmode` is set to *auto*.'\n        ].join(' ')\n    },\n    tick0: {\n        valType: 'any',\n        role: 'style',\n        description: [\n            'Sets the placement of the first tick on this axis.',\n            'Use with `dtick`.',\n            'If the axis `type` is *log*, then you must take the log of your starting tick',\n            '(e.g. to set the starting tick to 100, set the `tick0` to 2)',\n            'except when `dtick`=*L<f>* (see `dtick` for more info).',\n            'If the axis `type` is *date*, it should be a date string, like date data.',\n            'If the axis `type` is *category*, it should be a number, using the scale where',\n            'each category is assigned a serial number from zero in the order it appears.'\n        ].join(' ')\n    },\n    dtick: {\n        valType: 'any',\n        role: 'style',\n        description: [\n            'Sets the step in-between ticks on this axis. Use with `tick0`.',\n            'Must be a positive number, or special strings available to *log* and *date* axes.',\n            'If the axis `type` is *log*, then ticks are set every 10^(n*dtick) where n',\n            'is the tick number. For example,',\n            'to set a tick mark at 1, 10, 100, 1000, ... set dtick to 1.',\n            'To set tick marks at 1, 100, 10000, ... set dtick to 2.',\n            'To set tick marks at 1, 5, 25, 125, 625, 3125, ... set dtick to log_10(5), or 0.69897000433.',\n            '*log* has several special values; *L<f>*, where `f` is a positive number,',\n            'gives ticks linearly spaced in value (but not position).',\n            'For example `tick0` = 0.1, `dtick` = *L0.5* will put ticks at 0.1, 0.6, 1.1, 1.6 etc.',\n            'To show powers of 10 plus small digits between, use *D1* (all digits) or *D2* (only 2 and 5).',\n            '`tick0` is ignored for *D1* and *D2*.',\n            'If the axis `type` is *date*, then you must convert the time to milliseconds.',\n            'For example, to set the interval between ticks to one day,',\n            'set `dtick` to 86400000.0.',\n            '*date* also has special values *M<n>* gives ticks spaced by a number of months.',\n            '`n` must be a positive integer.',\n            'To set ticks on the 15th of every third month, set `tick0` to *2000-01-15* and `dtick` to *M3*.',\n            'To set ticks every 4 years, set `dtick` to *M48*'\n        ].join(' ')\n    },\n    tickvals: {\n        valType: 'data_array',\n        description: [\n            'Sets the values at which ticks on this axis appear.',\n            'Only has an effect if `tickmode` is set to *array*.',\n            'Used with `ticktext`.'\n        ].join(' ')\n    },\n    ticktext: {\n        valType: 'data_array',\n        description: [\n            'Sets the text displayed at the ticks position via `tickvals`.',\n            'Only has an effect if `tickmode` is set to *array*.',\n            'Used with `tickvals`.'\n        ].join(' ')\n    },\n    ticks: {\n        valType: 'enumerated',\n        values: ['outside', 'inside', ''],\n        role: 'style',\n        description: [\n            'Determines whether ticks are drawn or not.',\n            'If **, this axis\\' ticks are not drawn.',\n            'If *outside* (*inside*), this axis\\' are drawn outside (inside)',\n            'the axis lines.'\n        ].join(' ')\n    },\n    mirror: {\n        valType: 'enumerated',\n        values: [true, 'ticks', false, 'all', 'allticks'],\n        dflt: false,\n        role: 'style',\n        description: [\n            'Determines if the axis lines or/and ticks are mirrored to',\n            'the opposite side of the plotting area.',\n            'If *true*, the axis lines are mirrored.',\n            'If *ticks*, the axis lines and ticks are mirrored.',\n            'If *false*, mirroring is disable.',\n            'If *all*, axis lines are mirrored on all shared-axes subplots.',\n            'If *allticks*, axis lines and ticks are mirrored',\n            'on all shared-axes subplots.'\n        ].join(' ')\n    },\n    ticklen: {\n        valType: 'number',\n        min: 0,\n        dflt: 5,\n        role: 'style',\n        description: 'Sets the tick length (in px).'\n    },\n    tickwidth: {\n        valType: 'number',\n        min: 0,\n        dflt: 1,\n        role: 'style',\n        description: 'Sets the tick width (in px).'\n    },\n    tickcolor: {\n        valType: 'color',\n        dflt: colorAttrs.defaultLine,\n        role: 'style',\n        description: 'Sets the tick color.'\n    },\n    showticklabels: {\n        valType: 'boolean',\n        dflt: true,\n        role: 'style',\n        description: 'Determines whether or not the tick labels are drawn.'\n    },\n    showspikes: {\n        valType: 'boolean',\n        dflt: false,\n        role: 'style',\n        description: [\n            'Determines whether or not spikes (aka droplines) are drawn for this axis.',\n            'Note: This only takes affect when hovermode = closest'\n        ].join(' ')\n    },\n    spikecolor: {\n        valType: 'color',\n        dflt: null,\n        role: 'style',\n        description: 'Sets the spike color. If undefined, will use the series color'\n    },\n    spikethickness: {\n        valType: 'number',\n        dflt: 3,\n        role: 'style',\n        description: 'Sets the width (in px) of the zero line.'\n    },\n    spikedash: extendFlat({}, dash, {dflt: 'dash'}),\n    spikemode: {\n        valType: 'flaglist',\n        flags: ['toaxis', 'across', 'marker'],\n        role: 'style',\n        dflt: 'toaxis',\n        description: [\n            'Determines the drawing mode for the spike line',\n            'If *toaxis*, the line is drawn from the data point to the axis the ',\n            'series is plotted on.',\n\n            'If *across*, the line is drawn across the entire plot area, and',\n            'supercedes *toaxis*.',\n\n            'If *marker*, then a marker dot is drawn on the axis the series is',\n            'plotted on'\n        ].join(' ')\n    },\n    tickfont: extendFlat({}, fontAttrs, {\n        description: 'Sets the tick font.'\n    }),\n    tickangle: {\n        valType: 'angle',\n        dflt: 'auto',\n        role: 'style',\n        description: [\n            'Sets the angle of the tick labels with respect to the horizontal.',\n            'For example, a `tickangle` of -90 draws the tick labels',\n            'vertically.'\n        ].join(' ')\n    },\n    tickprefix: {\n        valType: 'string',\n        dflt: '',\n        role: 'style',\n        description: 'Sets a tick label prefix.'\n    },\n    showtickprefix: {\n        valType: 'enumerated',\n        values: ['all', 'first', 'last', 'none'],\n        dflt: 'all',\n        role: 'style',\n        description: [\n            'If *all*, all tick labels are displayed with a prefix.',\n            'If *first*, only the first tick is displayed with a prefix.',\n            'If *last*, only the last tick is displayed with a suffix.',\n            'If *none*, tick prefixes are hidden.'\n        ].join(' ')\n    },\n    ticksuffix: {\n        valType: 'string',\n        dflt: '',\n        role: 'style',\n        description: 'Sets a tick label suffix.'\n    },\n    showticksuffix: {\n        valType: 'enumerated',\n        values: ['all', 'first', 'last', 'none'],\n        dflt: 'all',\n        role: 'style',\n        description: 'Same as `showtickprefix` but for tick suffixes.'\n    },\n    showexponent: {\n        valType: 'enumerated',\n        values: ['all', 'first', 'last', 'none'],\n        dflt: 'all',\n        role: 'style',\n        description: [\n            'If *all*, all exponents are shown besides their significands.',\n            'If *first*, only the exponent of the first tick is shown.',\n            'If *last*, only the exponent of the last tick is shown.',\n            'If *none*, no exponents appear.'\n        ].join(' ')\n    },\n    exponentformat: {\n        valType: 'enumerated',\n        values: ['none', 'e', 'E', 'power', 'SI', 'B'],\n        dflt: 'B',\n        role: 'style',\n        description: [\n            'Determines a formatting rule for the tick exponents.',\n            'For example, consider the number 1,000,000,000.',\n            'If *none*, it appears as 1,000,000,000.',\n            'If *e*, 1e+9.',\n            'If *E*, 1E+9.',\n            'If *power*, 1x10^9 (with 9 in a super script).',\n            'If *SI*, 1G.',\n            'If *B*, 1B.'\n        ].join(' ')\n    },\n    separatethousands: {\n        valType: 'boolean',\n        dflt: false,\n        role: 'style',\n        description: [\n            'If \"true\", even 4-digit integers are separated'\n        ].join(' ')\n    },\n    tickformat: {\n        valType: 'string',\n        dflt: '',\n        role: 'style',\n        description: [\n            'Sets the tick label formatting rule using d3 formatting mini-languages',\n            'which are very similar to those in Python. For numbers, see:',\n            'https://github.com/d3/d3-format/blob/master/README.md#locale_format',\n            'And for dates see:',\n            'https://github.com/d3/d3-time-format/blob/master/README.md#locale_format',\n            'We add one item to d3\\'s date formatter: *%{n}f* for fractional seconds',\n            'with n digits. For example, *2016-10-13 09:15:23.456* with tickformat',\n            '*%H~%M~%S.%2f* would display *09~15~23.46*'\n        ].join(' ')\n    },\n    hoverformat: {\n        valType: 'string',\n        dflt: '',\n        role: 'style',\n        description: [\n            'Sets the hover text formatting rule using d3 formatting mini-languages',\n            'which are very similar to those in Python. For numbers, see:',\n            'https://github.com/d3/d3-format/blob/master/README.md#locale_format',\n            'And for dates see:',\n            'https://github.com/d3/d3-time-format/blob/master/README.md#locale_format',\n            'We add one item to d3\\'s date formatter: *%{n}f* for fractional seconds',\n            'with n digits. For example, *2016-10-13 09:15:23.456* with tickformat',\n            '*%H~%M~%S.%2f* would display *09~15~23.46*'\n        ].join(' ')\n    },\n    // lines and grids\n    showline: {\n        valType: 'boolean',\n        dflt: false,\n        role: 'style',\n        description: [\n            'Determines whether or not a line bounding this axis is drawn.'\n        ].join(' ')\n    },\n    linecolor: {\n        valType: 'color',\n        dflt: colorAttrs.defaultLine,\n        role: 'style',\n        description: 'Sets the axis line color.'\n    },\n    linewidth: {\n        valType: 'number',\n        min: 0,\n        dflt: 1,\n        role: 'style',\n        description: 'Sets the width (in px) of the axis line.'\n    },\n    showgrid: {\n        valType: 'boolean',\n        role: 'style',\n        description: [\n            'Determines whether or not grid lines are drawn.',\n            'If *true*, the grid lines are drawn at every tick mark.'\n        ].join(' ')\n    },\n    gridcolor: {\n        valType: 'color',\n        dflt: colorAttrs.lightLine,\n        role: 'style',\n        description: 'Sets the color of the grid lines.'\n    },\n    gridwidth: {\n        valType: 'number',\n        min: 0,\n        dflt: 1,\n        role: 'style',\n        description: 'Sets the width (in px) of the grid lines.'\n    },\n    zeroline: {\n        valType: 'boolean',\n        role: 'style',\n        description: [\n            'Determines whether or not a line is drawn at along the 0 value',\n            'of this axis.',\n            'If *true*, the zero line is drawn on top of the grid lines.'\n        ].join(' ')\n    },\n    zerolinecolor: {\n        valType: 'color',\n        dflt: colorAttrs.defaultLine,\n        role: 'style',\n        description: 'Sets the line color of the zero line.'\n    },\n    zerolinewidth: {\n        valType: 'number',\n        dflt: 1,\n        role: 'style',\n        description: 'Sets the width (in px) of the zero line.'\n    },\n    // positioning attributes\n    // anchor: not used directly, just put here for reference\n    // values are any opposite-letter axis id\n    anchor: {\n        valType: 'enumerated',\n        values: [\n            'free',\n            constants.idRegex.x.toString(),\n            constants.idRegex.y.toString()\n        ],\n        role: 'info',\n        description: [\n            'If set to an opposite-letter axis id (e.g. `x2`, `y`), this axis is bound to',\n            'the corresponding opposite-letter axis.',\n            'If set to *free*, this axis\\' position is determined by `position`.'\n        ].join(' ')\n    },\n    // side: not used directly, as values depend on direction\n    // values are top, bottom for x axes, and left, right for y\n    side: {\n        valType: 'enumerated',\n        values: ['top', 'bottom', 'left', 'right'],\n        role: 'info',\n        description: [\n            'Determines whether a x (y) axis is positioned',\n            'at the *bottom* (*left*) or *top* (*right*)',\n            'of the plotting area.'\n        ].join(' ')\n    },\n    // overlaying: not used directly, just put here for reference\n    // values are false and any other same-letter axis id that's not\n    // itself overlaying anything\n    overlaying: {\n        valType: 'enumerated',\n        values: [\n            'free',\n            constants.idRegex.x.toString(),\n            constants.idRegex.y.toString()\n        ],\n        role: 'info',\n        description: [\n            'If set a same-letter axis id, this axis is overlaid on top of',\n            'the corresponding same-letter axis.',\n            'If *false*, this axis does not overlay any same-letter axes.'\n        ].join(' ')\n    },\n    domain: {\n        valType: 'info_array',\n        role: 'info',\n        items: [\n            {valType: 'number', min: 0, max: 1},\n            {valType: 'number', min: 0, max: 1}\n        ],\n        dflt: [0, 1],\n        description: [\n            'Sets the domain of this axis (in plot fraction).'\n        ].join(' ')\n    },\n    position: {\n        valType: 'number',\n        min: 0,\n        max: 1,\n        dflt: 0,\n        role: 'style',\n        description: [\n            'Sets the position of this axis in the plotting space',\n            '(in normalized coordinates).',\n            'Only has an effect if `anchor` is set to *free*.'\n        ].join(' ')\n    },\n    categoryorder: {\n        valType: 'enumerated',\n        values: [\n            'trace', 'category ascending', 'category descending', 'array'\n            /* , 'value ascending', 'value descending'*/ // value ascending / descending to be implemented later\n        ],\n        dflt: 'trace',\n        role: 'info',\n        description: [\n            'Specifies the ordering logic for the case of categorical variables.',\n            'By default, plotly uses *trace*, which specifies the order that is present in the data supplied.',\n            'Set `categoryorder` to *category ascending* or *category descending* if order should be determined by',\n            'the alphanumerical order of the category names.',\n            /* 'Set `categoryorder` to *value ascending* or *value descending* if order should be determined by the',\n            'numerical order of the values.',*/ // // value ascending / descending to be implemented later\n            'Set `categoryorder` to *array* to derive the ordering from the attribute `categoryarray`. If a category',\n            'is not found in the `categoryarray` array, the sorting behavior for that attribute will be identical to',\n            'the *trace* mode. The unspecified categories will follow the categories in `categoryarray`.'\n        ].join(' ')\n    },\n    categoryarray: {\n        valType: 'data_array',\n        role: 'info',\n        description: [\n            'Sets the order in which categories on this axis appear.',\n            'Only has an effect if `categoryorder` is set to *array*.',\n            'Used with `categoryorder`.'\n        ].join(' ')\n    },\n\n    _deprecated: {\n        autotick: {\n            valType: 'boolean',\n            role: 'info',\n            description: [\n                'Obsolete.',\n                'Set `tickmode` to *auto* for old `autotick` *true* behavior.',\n                'Set `tickmode` to *linear* for `autotick` *false*.'\n            ].join(' ')\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/drawing/attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nexports.dash = {\n    valType: 'string',\n    // string type usually doesn't take values... this one should really be\n    // a special type or at least a special coercion function, from the GUI\n    // you only get these values but elsewhere the user can supply a list of\n    // dash lengths in px, and it will be honored\n    values: ['solid', 'dot', 'dash', 'longdash', 'dashdot', 'longdashdot'],\n    dflt: 'solid',\n    role: 'style',\n    description: [\n        'Sets the dash style of lines. Set to a dash type string',\n        '(*solid*, *dot*, *dash*, *longdash*, *dashdot*, or *longdashdot*)',\n        'or a dash length list in px (eg *5px,10px,2px,2px*).'\n    ].join(' ')\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/cartesian/constants.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n\nmodule.exports = {\n\n    idRegex: {\n        x: /^x([2-9]|[1-9][0-9]+)?$/,\n        y: /^y([2-9]|[1-9][0-9]+)?$/\n    },\n\n    attrRegex: {\n        x: /^xaxis([2-9]|[1-9][0-9]+)?$/,\n        y: /^yaxis([2-9]|[1-9][0-9]+)?$/\n    },\n\n    // axis match regular expression\n    xAxisMatch: /^xaxis[0-9]*$/,\n    yAxisMatch: /^yaxis[0-9]*$/,\n\n    // pattern matching axis ids and names\n    AX_ID_PATTERN: /^[xyz][0-9]*$/,\n    AX_NAME_PATTERN: /^[xyz]axis[0-9]*$/,\n\n    // pixels to move mouse before you stop clamping to starting point\n    MINDRAG: 8,\n\n    // smallest dimension allowed for a select box\n    MINSELECT: 12,\n\n    // smallest dimension allowed for a zoombox\n    MINZOOM: 20,\n\n    // width of axis drag regions\n    DRAGGERSIZE: 20,\n\n    // max pixels away from mouse to allow a point to highlight\n    MAXDIST: 20,\n\n    // hover labels for multiple horizontal bars get tilted by this angle\n    YANGLE: 60,\n\n    // size and display constants for hover text\n    HOVERARROWSIZE: 6, // pixel size of hover arrows\n    HOVERTEXTPAD: 3, // pixels padding around text\n    HOVERFONTSIZE: 13,\n    HOVERFONT: 'Arial, sans-serif',\n\n    // minimum time (msec) between hover calls\n    HOVERMINTIME: 50,\n\n    // max pixels off straight before a lasso select line counts as bent\n    BENDPX: 1.5,\n\n    // delay before a redraw (relayout) after smooth panning and zooming\n    REDRAWDELAY: 50,\n\n    // last resort axis ranges for x and y axes if we have no data\n    DFLTRANGEX: [-1, 6],\n    DFLTRANGEY: [-1, 4]\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/cartesian/tick_label_defaults.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Lib = require('../../lib');\n\n\n/**\n * options: inherits font, outerTicks, noHover from axes.handleAxisDefaults\n */\nmodule.exports = function handleTickLabelDefaults(containerIn, containerOut, coerce, axType, options) {\n    var showAttrDflt = getShowAttrDflt(containerIn);\n\n    var tickPrefix = coerce('tickprefix');\n    if(tickPrefix) coerce('showtickprefix', showAttrDflt);\n\n    var tickSuffix = coerce('ticksuffix');\n    if(tickSuffix) coerce('showticksuffix', showAttrDflt);\n\n    var showTickLabels = coerce('showticklabels');\n    if(showTickLabels) {\n        var font = options.font || {};\n        // as with titlefont.color, inherit axis.color only if one was\n        // explicitly provided\n        var dfltFontColor = (containerOut.color === containerIn.color) ?\n            containerOut.color : font.color;\n        Lib.coerceFont(coerce, 'tickfont', {\n            family: font.family,\n            size: font.size,\n            color: dfltFontColor\n        });\n        coerce('tickangle');\n\n        if(axType !== 'category') {\n            var tickFormat = coerce('tickformat');\n            if(!tickFormat && axType !== 'date') {\n                coerce('showexponent', showAttrDflt);\n                coerce('exponentformat');\n                coerce('separatethousands');\n            }\n        }\n    }\n\n    if(axType !== 'category' && !options.noHover) coerce('hoverformat');\n};\n\n/*\n * Attributes 'showexponent', 'showtickprefix' and 'showticksuffix'\n * share values.\n *\n * If only 1 attribute is set,\n * the remaining attributes inherit that value.\n *\n * If 2 attributes are set to the same value,\n * the remaining attribute inherits that value.\n *\n * If 2 attributes are set to different values,\n * the remaining is set to its dflt value.\n *\n */\nfunction getShowAttrDflt(containerIn) {\n    var showAttrsAll = ['showexponent',\n            'showtickprefix',\n            'showticksuffix'],\n        showAttrs = showAttrsAll.filter(function(a) {\n            return containerIn[a] !== undefined;\n        }),\n        sameVal = function(a) {\n            return containerIn[a] === containerIn[showAttrs[0]];\n        };\n\n    if(showAttrs.every(sameVal) || showAttrs.length === 1) {\n        return containerIn[showAttrs[0]];\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/colorbar/attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar axesAttrs = require('../../plots/cartesian/layout_attributes');\nvar fontAttrs = require('../../plots/font_attributes');\nvar extendFlat = require('../../lib/extend').extendFlat;\n\n\nmodule.exports = {\n// TODO: only right is supported currently\n//     orient: {\n//         valType: 'enumerated',\n//         role: 'info',\n//         values: ['left', 'right', 'top', 'bottom'],\n//         dflt: 'right',\n//         description: [\n//             'Determines which side are the labels on',\n//             '(so left and right make vertical bars, etc.)'\n//         ].join(' ')\n//     },\n    thicknessmode: {\n        valType: 'enumerated',\n        values: ['fraction', 'pixels'],\n        role: 'style',\n        dflt: 'pixels',\n        description: [\n            'Determines whether this color bar\\'s thickness',\n            '(i.e. the measure in the constant color direction)',\n            'is set in units of plot *fraction* or in *pixels*.',\n            'Use `thickness` to set the value.'\n        ].join(' ')\n    },\n    thickness: {\n        valType: 'number',\n        role: 'style',\n        min: 0,\n        dflt: 30,\n        description: [\n            'Sets the thickness of the color bar',\n            'This measure excludes the size of the padding, ticks and labels.'\n        ].join(' ')\n    },\n    lenmode: {\n        valType: 'enumerated',\n        values: ['fraction', 'pixels'],\n        role: 'info',\n        dflt: 'fraction',\n        description: [\n            'Determines whether this color bar\\'s length',\n            '(i.e. the measure in the color variation direction)',\n            'is set in units of plot *fraction* or in *pixels.',\n            'Use `len` to set the value.'\n        ].join(' ')\n    },\n    len: {\n        valType: 'number',\n        min: 0,\n        dflt: 1,\n        role: 'style',\n        description: [\n            'Sets the length of the color bar',\n            'This measure excludes the padding of both ends.',\n            'That is, the color bar length is this length minus the',\n            'padding on both ends.'\n        ].join(' ')\n    },\n    x: {\n        valType: 'number',\n        dflt: 1.02,\n        min: -2,\n        max: 3,\n        role: 'style',\n        description: [\n            'Sets the x position of the color bar (in plot fraction).'\n        ].join(' ')\n    },\n    xanchor: {\n        valType: 'enumerated',\n        values: ['left', 'center', 'right'],\n        dflt: 'left',\n        role: 'style',\n        description: [\n            'Sets this color bar\\'s horizontal position anchor.',\n            'This anchor binds the `x` position to the *left*, *center*',\n            'or *right* of the color bar.'\n        ].join(' ')\n    },\n    xpad: {\n        valType: 'number',\n        role: 'style',\n        min: 0,\n        dflt: 10,\n        description: 'Sets the amount of padding (in px) along the x direction.'\n    },\n    y: {\n        valType: 'number',\n        role: 'style',\n        dflt: 0.5,\n        min: -2,\n        max: 3,\n        description: [\n            'Sets the y position of the color bar (in plot fraction).'\n        ].join(' ')\n    },\n    yanchor: {\n        valType: 'enumerated',\n        values: ['top', 'middle', 'bottom'],\n        role: 'style',\n        dflt: 'middle',\n        description: [\n            'Sets this color bar\\'s vertical position anchor',\n            'This anchor binds the `y` position to the *top*, *middle*',\n            'or *bottom* of the color bar.'\n        ].join(' ')\n    },\n    ypad: {\n        valType: 'number',\n        role: 'style',\n        min: 0,\n        dflt: 10,\n        description: 'Sets the amount of padding (in px) along the y direction.'\n    },\n    // a possible line around the bar itself\n    outlinecolor: axesAttrs.linecolor,\n    outlinewidth: axesAttrs.linewidth,\n    // Should outlinewidth have {dflt: 0} ?\n    // another possible line outside the padding and tick labels\n    bordercolor: axesAttrs.linecolor,\n    borderwidth: {\n        valType: 'number',\n        role: 'style',\n        min: 0,\n        dflt: 0,\n        description: [\n            'Sets the width (in px) or the border enclosing this color bar.'\n        ].join(' ')\n    },\n    bgcolor: {\n        valType: 'color',\n        role: 'style',\n        dflt: 'rgba(0,0,0,0)',\n        description: 'Sets the color of padded area.'\n    },\n    // tick and title properties named and function exactly as in axes\n    tickmode: axesAttrs.tickmode,\n    nticks: axesAttrs.nticks,\n    tick0: axesAttrs.tick0,\n    dtick: axesAttrs.dtick,\n    tickvals: axesAttrs.tickvals,\n    ticktext: axesAttrs.ticktext,\n    ticks: extendFlat({}, axesAttrs.ticks, {dflt: ''}),\n    ticklen: axesAttrs.ticklen,\n    tickwidth: axesAttrs.tickwidth,\n    tickcolor: axesAttrs.tickcolor,\n    showticklabels: axesAttrs.showticklabels,\n    tickfont: axesAttrs.tickfont,\n    tickangle: axesAttrs.tickangle,\n    tickformat: axesAttrs.tickformat,\n    tickprefix: axesAttrs.tickprefix,\n    showtickprefix: axesAttrs.showtickprefix,\n    ticksuffix: axesAttrs.ticksuffix,\n    showticksuffix: axesAttrs.showticksuffix,\n    separatethousands: axesAttrs.separatethousands,\n    exponentformat: axesAttrs.exponentformat,\n    showexponent: axesAttrs.showexponent,\n    title: {\n        valType: 'string',\n        role: 'info',\n        dflt: 'Click to enter colorscale title',\n        description: 'Sets the title of the color bar.'\n    },\n    titlefont: extendFlat({}, fontAttrs, {\n        description: [\n            'Sets this color bar\\'s title font.'\n        ].join(' ')\n    }),\n    titleside: {\n        valType: 'enumerated',\n        values: ['right', 'top', 'bottom'],\n        role: 'style',\n        dflt: 'top',\n        description: [\n            'Determines the location of the colorbar title',\n            'with respect to the color bar.'\n        ].join(' ')\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/colorscale/is_valid_scale.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar scales = require('./scales');\nvar isValidScaleArray = require('./is_valid_scale_array');\n\n\nmodule.exports = function isValidScale(scl) {\n    if(scales[scl] !== undefined) return true;\n    else return isValidScaleArray(scl);\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/colorscale/flip_scale.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nmodule.exports = function flipScale(scl) {\n    var N = scl.length,\n        sclNew = new Array(N),\n        si;\n\n    for(var i = N - 1, j = 0; i >= 0; i--, j++) {\n        si = scl[i];\n        sclNew[j] = [1 - si[0], si[1]];\n    }\n\n    return sclNew;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/colorscale/calc.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Lib = require('../../lib');\n\nvar scales = require('./scales');\nvar flipScale = require('./flip_scale');\n\n\nmodule.exports = function calc(trace, vals, containerStr, cLetter) {\n    var container, inputContainer;\n\n    if(containerStr) {\n        container = Lib.nestedProperty(trace, containerStr).get();\n        inputContainer = Lib.nestedProperty(trace._input, containerStr).get();\n    }\n    else {\n        container = trace;\n        inputContainer = trace._input;\n    }\n\n    var autoAttr = cLetter + 'auto',\n        minAttr = cLetter + 'min',\n        maxAttr = cLetter + 'max',\n        auto = container[autoAttr],\n        min = container[minAttr],\n        max = container[maxAttr],\n        scl = container.colorscale;\n\n    if(auto !== false || min === undefined) {\n        min = Lib.aggNums(Math.min, null, vals);\n    }\n\n    if(auto !== false || max === undefined) {\n        max = Lib.aggNums(Math.max, null, vals);\n    }\n\n    if(min === max) {\n        min -= 0.5;\n        max += 0.5;\n    }\n\n    container[minAttr] = min;\n    container[maxAttr] = max;\n\n    inputContainer[minAttr] = min;\n    inputContainer[maxAttr] = max;\n\n    /*\n     * If auto was explicitly false but min or max was missing,\n     * we filled in the missing piece here but later the trace does\n     * not look auto.\n     * Otherwise make sure the trace still looks auto as far as later\n     * changes are concerned.\n     */\n    inputContainer[autoAttr] = (auto !== false ||\n        (min === undefined && max === undefined));\n\n    if(container.autocolorscale) {\n        if(min * max < 0) scl = scales.RdBu;\n        else if(min >= 0) scl = scales.Reds;\n        else scl = scales.Blues;\n\n        // reversescale is handled at the containerOut level\n        inputContainer.colorscale = scl;\n        if(container.reversescale) scl = flipScale(scl);\n        container.colorscale = scl;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/colorscale/has_colorscale.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\n\nvar isValidScale = require('./is_valid_scale');\n\n\nmodule.exports = function hasColorscale(trace, containerStr) {\n    var container = containerStr ?\n            Lib.nestedProperty(trace, containerStr).get() || {} :\n            trace,\n        color = container.color,\n        isArrayWithOneNumber = false;\n\n    if(Array.isArray(color)) {\n        for(var i = 0; i < color.length; i++) {\n            if(isNumeric(color[i])) {\n                isArrayWithOneNumber = true;\n                break;\n            }\n        }\n    }\n\n    return (\n        Lib.isPlainObject(container) && (\n            isArrayWithOneNumber ||\n            container.showscale === true ||\n            (isNumeric(container.cmin) && isNumeric(container.cmax)) ||\n            isValidScale(container.colorscale) ||\n            Lib.isPlainObject(container.colorbar)\n        )\n    );\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/colorscale/extract_scale.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\n/**\n * Extract colorscale into numeric domain and color range.\n *\n * @param {array} scl colorscale array of arrays\n * @param {number} cmin minimum color value (used to clamp scale)\n * @param {number} cmax maximum color value (used to clamp scale)\n */\nmodule.exports = function extractScale(scl, cmin, cmax) {\n    var N = scl.length,\n        domain = new Array(N),\n        range = new Array(N);\n\n    for(var i = 0; i < N; i++) {\n        var si = scl[i];\n\n        domain[i] = cmin + si[0] * (cmax - cmin);\n        range[i] = si[1];\n    }\n\n    return {\n        domain: domain,\n        range: range\n    };\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/colorscale/make_color_scale_func.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\nvar tinycolor = require('tinycolor2');\nvar isNumeric = require('fast-isnumeric');\n\nvar Color = require('../color');\n\n/**\n * General colorscale function generator.\n *\n * @param {object} specs output of Colorscale.extractScale or precomputed domain, range.\n *  - domain {array}\n *  - range {array}\n *\n * @param {object} opts\n *  - noNumericCheck {boolean} if true, scale func bypasses numeric checks\n *  - returnArray {boolean} if true, scale func return 4-item array instead of color strings\n *\n * @return {function}\n */\nmodule.exports = function makeColorScaleFunc(specs, opts) {\n    opts = opts || {};\n\n    var domain = specs.domain,\n        range = specs.range,\n        N = range.length,\n        _range = new Array(N);\n\n    for(var i = 0; i < N; i++) {\n        var rgba = tinycolor(range[i]).toRgb();\n        _range[i] = [rgba.r, rgba.g, rgba.b, rgba.a];\n    }\n\n    var _sclFunc = d3.scale.linear()\n        .domain(domain)\n        .range(_range)\n        .clamp(true);\n\n    var noNumericCheck = opts.noNumericCheck,\n        returnArray = opts.returnArray,\n        sclFunc;\n\n    if(noNumericCheck && returnArray) {\n        sclFunc = _sclFunc;\n    }\n    else if(noNumericCheck) {\n        sclFunc = function(v) {\n            return colorArray2rbga(_sclFunc(v));\n        };\n    }\n    else if(returnArray) {\n        sclFunc = function(v) {\n            if(isNumeric(v)) return _sclFunc(v);\n            else if(tinycolor(v).isValid()) return v;\n            else return Color.defaultLine;\n        };\n    }\n    else {\n        sclFunc = function(v) {\n            if(isNumeric(v)) return colorArray2rbga(_sclFunc(v));\n            else if(tinycolor(v).isValid()) return v;\n            else return Color.defaultLine;\n        };\n    }\n\n    // colorbar draw looks into the d3 scale closure for domain and range\n\n    sclFunc.domain = _sclFunc.domain;\n\n    sclFunc.range = function() { return range; };\n\n    return sclFunc;\n};\n\nfunction colorArray2rbga(colorArray) {\n    var colorObj = {\n        r: colorArray[0],\n        g: colorArray[1],\n        b: colorArray[2],\n        a: colorArray[3]\n    };\n\n    return tinycolor(colorObj).toRgbString();\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/scatter/subtypes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Lib = require('../../lib');\n\nmodule.exports = {\n    hasLines: function(trace) {\n        return trace.visible && trace.mode &&\n            trace.mode.indexOf('lines') !== -1;\n    },\n\n    hasMarkers: function(trace) {\n        return trace.visible && trace.mode &&\n            trace.mode.indexOf('markers') !== -1;\n    },\n\n    hasText: function(trace) {\n        return trace.visible && trace.mode &&\n            trace.mode.indexOf('text') !== -1;\n    },\n\n    isBubble: function(trace) {\n        return Lib.isPlainObject(trace.marker) &&\n            Array.isArray(trace.marker.size);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/scatter/make_bubble_size_func.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\n\n// used in the drawing step for 'scatter' and 'scattegeo' and\n// in the convert step for 'scatter3d'\nmodule.exports = function makeBubbleSizeFn(trace) {\n    var marker = trace.marker,\n        sizeRef = marker.sizeref || 1,\n        sizeMin = marker.sizemin || 0;\n\n    // for bubble charts, allow scaling the provided value linearly\n    // and by area or diameter.\n    // Note this only applies to the array-value sizes\n\n    var baseFn = (marker.sizemode === 'area') ?\n            function(v) { return Math.sqrt(v / sizeRef); } :\n            function(v) { return v / sizeRef; };\n\n    // TODO add support for position/negative bubbles?\n    // TODO add 'sizeoffset' attribute?\n    return function(v) {\n        var baseSize = baseFn(v / 2);\n\n        // don't show non-numeric and negative sizes\n        return (isNumeric(baseSize) && (baseSize > 0)) ?\n            Math.max(baseSize, sizeMin) :\n            0;\n    };\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/drawing/symbol_defs.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\n\n/** Marker symbol definitions\n * users can specify markers either by number or name\n * add 100 (or '-open') and you get an open marker\n *  open markers have no fill and use line color as the stroke color\n * add 200 (or '-dot') and you get a dot in the middle\n * add both and you get both\n */\n\nmodule.exports = {\n    circle: {\n        n: 0,\n        f: function(r) {\n            var rs = d3.round(r, 2);\n            return 'M' + rs + ',0A' + rs + ',' + rs + ' 0 1,1 0,-' + rs +\n                'A' + rs + ',' + rs + ' 0 0,1 ' + rs + ',0Z';\n        }\n    },\n    square: {\n        n: 1,\n        f: function(r) {\n            var rs = d3.round(r, 2);\n            return 'M' + rs + ',' + rs + 'H-' + rs + 'V-' + rs + 'H' + rs + 'Z';\n        }\n    },\n    diamond: {\n        n: 2,\n        f: function(r) {\n            var rd = d3.round(r * 1.3, 2);\n            return 'M' + rd + ',0L0,' + rd + 'L-' + rd + ',0L0,-' + rd + 'Z';\n        }\n    },\n    cross: {\n        n: 3,\n        f: function(r) {\n            var rc = d3.round(r * 0.4, 2),\n                rc2 = d3.round(r * 1.2, 2);\n            return 'M' + rc2 + ',' + rc + 'H' + rc + 'V' + rc2 + 'H-' + rc +\n                'V' + rc + 'H-' + rc2 + 'V-' + rc + 'H-' + rc + 'V-' + rc2 +\n                'H' + rc + 'V-' + rc + 'H' + rc2 + 'Z';\n        }\n    },\n    x: {\n        n: 4,\n        f: function(r) {\n            var rx = d3.round(r * 0.8 / Math.sqrt(2), 2),\n                ne = 'l' + rx + ',' + rx,\n                se = 'l' + rx + ',-' + rx,\n                sw = 'l-' + rx + ',-' + rx,\n                nw = 'l-' + rx + ',' + rx;\n            return 'M0,' + rx + ne + se + sw + se + sw + nw + sw + nw + ne + nw + ne + 'Z';\n        }\n    },\n    'triangle-up': {\n        n: 5,\n        f: function(r) {\n            var rt = d3.round(r * 2 / Math.sqrt(3), 2),\n                r2 = d3.round(r / 2, 2),\n                rs = d3.round(r, 2);\n            return 'M-' + rt + ',' + r2 + 'H' + rt + 'L0,-' + rs + 'Z';\n        }\n    },\n    'triangle-down': {\n        n: 6,\n        f: function(r) {\n            var rt = d3.round(r * 2 / Math.sqrt(3), 2),\n                r2 = d3.round(r / 2, 2),\n                rs = d3.round(r, 2);\n            return 'M-' + rt + ',-' + r2 + 'H' + rt + 'L0,' + rs + 'Z';\n        }\n    },\n    'triangle-left': {\n        n: 7,\n        f: function(r) {\n            var rt = d3.round(r * 2 / Math.sqrt(3), 2),\n                r2 = d3.round(r / 2, 2),\n                rs = d3.round(r, 2);\n            return 'M' + r2 + ',-' + rt + 'V' + rt + 'L-' + rs + ',0Z';\n        }\n    },\n    'triangle-right': {\n        n: 8,\n        f: function(r) {\n            var rt = d3.round(r * 2 / Math.sqrt(3), 2),\n                r2 = d3.round(r / 2, 2),\n                rs = d3.round(r, 2);\n            return 'M-' + r2 + ',-' + rt + 'V' + rt + 'L' + rs + ',0Z';\n        }\n    },\n    'triangle-ne': {\n        n: 9,\n        f: function(r) {\n            var r1 = d3.round(r * 0.6, 2),\n                r2 = d3.round(r * 1.2, 2);\n            return 'M-' + r2 + ',-' + r1 + 'H' + r1 + 'V' + r2 + 'Z';\n        }\n    },\n    'triangle-se': {\n        n: 10,\n        f: function(r) {\n            var r1 = d3.round(r * 0.6, 2),\n                r2 = d3.round(r * 1.2, 2);\n            return 'M' + r1 + ',-' + r2 + 'V' + r1 + 'H-' + r2 + 'Z';\n        }\n    },\n    'triangle-sw': {\n        n: 11,\n        f: function(r) {\n            var r1 = d3.round(r * 0.6, 2),\n                r2 = d3.round(r * 1.2, 2);\n            return 'M' + r2 + ',' + r1 + 'H-' + r1 + 'V-' + r2 + 'Z';\n        }\n    },\n    'triangle-nw': {\n        n: 12,\n        f: function(r) {\n            var r1 = d3.round(r * 0.6, 2),\n                r2 = d3.round(r * 1.2, 2);\n            return 'M-' + r1 + ',' + r2 + 'V-' + r1 + 'H' + r2 + 'Z';\n        }\n    },\n    pentagon: {\n        n: 13,\n        f: function(r) {\n            var x1 = d3.round(r * 0.951, 2),\n                x2 = d3.round(r * 0.588, 2),\n                y0 = d3.round(-r, 2),\n                y1 = d3.round(r * -0.309, 2),\n                y2 = d3.round(r * 0.809, 2);\n            return 'M' + x1 + ',' + y1 + 'L' + x2 + ',' + y2 + 'H-' + x2 +\n                'L-' + x1 + ',' + y1 + 'L0,' + y0 + 'Z';\n        }\n    },\n    hexagon: {\n        n: 14,\n        f: function(r) {\n            var y0 = d3.round(r, 2),\n                y1 = d3.round(r / 2, 2),\n                x = d3.round(r * Math.sqrt(3) / 2, 2);\n            return 'M' + x + ',-' + y1 + 'V' + y1 + 'L0,' + y0 +\n                'L-' + x + ',' + y1 + 'V-' + y1 + 'L0,-' + y0 + 'Z';\n        }\n    },\n    hexagon2: {\n        n: 15,\n        f: function(r) {\n            var x0 = d3.round(r, 2),\n                x1 = d3.round(r / 2, 2),\n                y = d3.round(r * Math.sqrt(3) / 2, 2);\n            return 'M-' + x1 + ',' + y + 'H' + x1 + 'L' + x0 +\n                ',0L' + x1 + ',-' + y + 'H-' + x1 + 'L-' + x0 + ',0Z';\n        }\n    },\n    octagon: {\n        n: 16,\n        f: function(r) {\n            var a = d3.round(r * 0.924, 2),\n                b = d3.round(r * 0.383, 2);\n            return 'M-' + b + ',-' + a + 'H' + b + 'L' + a + ',-' + b + 'V' + b +\n                'L' + b + ',' + a + 'H-' + b + 'L-' + a + ',' + b + 'V-' + b + 'Z';\n        }\n    },\n    star: {\n        n: 17,\n        f: function(r) {\n            var rs = r * 1.4,\n                x1 = d3.round(rs * 0.225, 2),\n                x2 = d3.round(rs * 0.951, 2),\n                x3 = d3.round(rs * 0.363, 2),\n                x4 = d3.round(rs * 0.588, 2),\n                y0 = d3.round(-rs, 2),\n                y1 = d3.round(rs * -0.309, 2),\n                y3 = d3.round(rs * 0.118, 2),\n                y4 = d3.round(rs * 0.809, 2),\n                y5 = d3.round(rs * 0.382, 2);\n            return 'M' + x1 + ',' + y1 + 'H' + x2 + 'L' + x3 + ',' + y3 +\n                'L' + x4 + ',' + y4 + 'L0,' + y5 + 'L-' + x4 + ',' + y4 +\n                'L-' + x3 + ',' + y3 + 'L-' + x2 + ',' + y1 + 'H-' + x1 +\n                'L0,' + y0 + 'Z';\n        }\n    },\n    hexagram: {\n        n: 18,\n        f: function(r) {\n            var y = d3.round(r * 0.66, 2),\n                x1 = d3.round(r * 0.38, 2),\n                x2 = d3.round(r * 0.76, 2);\n            return 'M-' + x2 + ',0l-' + x1 + ',-' + y + 'h' + x2 +\n                'l' + x1 + ',-' + y + 'l' + x1 + ',' + y + 'h' + x2 +\n                'l-' + x1 + ',' + y + 'l' + x1 + ',' + y + 'h-' + x2 +\n                'l-' + x1 + ',' + y + 'l-' + x1 + ',-' + y + 'h-' + x2 + 'Z';\n        }\n    },\n    'star-triangle-up': {\n        n: 19,\n        f: function(r) {\n            var x = d3.round(r * Math.sqrt(3) * 0.8, 2),\n                y1 = d3.round(r * 0.8, 2),\n                y2 = d3.round(r * 1.6, 2),\n                rc = d3.round(r * 4, 2),\n                aPart = 'A ' + rc + ',' + rc + ' 0 0 1 ';\n            return 'M-' + x + ',' + y1 + aPart + x + ',' + y1 +\n                aPart + '0,-' + y2 + aPart + '-' + x + ',' + y1 + 'Z';\n        }\n    },\n    'star-triangle-down': {\n        n: 20,\n        f: function(r) {\n            var x = d3.round(r * Math.sqrt(3) * 0.8, 2),\n                y1 = d3.round(r * 0.8, 2),\n                y2 = d3.round(r * 1.6, 2),\n                rc = d3.round(r * 4, 2),\n                aPart = 'A ' + rc + ',' + rc + ' 0 0 1 ';\n            return 'M' + x + ',-' + y1 + aPart + '-' + x + ',-' + y1 +\n                aPart + '0,' + y2 + aPart + x + ',-' + y1 + 'Z';\n        }\n    },\n    'star-square': {\n        n: 21,\n        f: function(r) {\n            var rp = d3.round(r * 1.1, 2),\n                rc = d3.round(r * 2, 2),\n                aPart = 'A ' + rc + ',' + rc + ' 0 0 1 ';\n            return 'M-' + rp + ',-' + rp + aPart + '-' + rp + ',' + rp +\n                aPart + rp + ',' + rp + aPart + rp + ',-' + rp +\n                aPart + '-' + rp + ',-' + rp + 'Z';\n        }\n    },\n    'star-diamond': {\n        n: 22,\n        f: function(r) {\n            var rp = d3.round(r * 1.4, 2),\n                rc = d3.round(r * 1.9, 2),\n                aPart = 'A ' + rc + ',' + rc + ' 0 0 1 ';\n            return 'M-' + rp + ',0' + aPart + '0,' + rp +\n                aPart + rp + ',0' + aPart + '0,-' + rp +\n                aPart + '-' + rp + ',0' + 'Z';\n        }\n    },\n    'diamond-tall': {\n        n: 23,\n        f: function(r) {\n            var x = d3.round(r * 0.7, 2),\n                y = d3.round(r * 1.4, 2);\n            return 'M0,' + y + 'L' + x + ',0L0,-' + y + 'L-' + x + ',0Z';\n        }\n    },\n    'diamond-wide': {\n        n: 24,\n        f: function(r) {\n            var x = d3.round(r * 1.4, 2),\n                y = d3.round(r * 0.7, 2);\n            return 'M0,' + y + 'L' + x + ',0L0,-' + y + 'L-' + x + ',0Z';\n        }\n    },\n    hourglass: {\n        n: 25,\n        f: function(r) {\n            var rs = d3.round(r, 2);\n            return 'M' + rs + ',' + rs + 'H-' + rs + 'L' + rs + ',-' + rs + 'H-' + rs + 'Z';\n        },\n        noDot: true\n    },\n    bowtie: {\n        n: 26,\n        f: function(r) {\n            var rs = d3.round(r, 2);\n            return 'M' + rs + ',' + rs + 'V-' + rs + 'L-' + rs + ',' + rs + 'V-' + rs + 'Z';\n        },\n        noDot: true\n    },\n    'circle-cross': {\n        n: 27,\n        f: function(r) {\n            var rs = d3.round(r, 2);\n            return 'M0,' + rs + 'V-' + rs + 'M' + rs + ',0H-' + rs +\n                'M' + rs + ',0A' + rs + ',' + rs + ' 0 1,1 0,-' + rs +\n                'A' + rs + ',' + rs + ' 0 0,1 ' + rs + ',0Z';\n        },\n        needLine: true,\n        noDot: true\n    },\n    'circle-x': {\n        n: 28,\n        f: function(r) {\n            var rs = d3.round(r, 2),\n                rc = d3.round(r / Math.sqrt(2), 2);\n            return 'M' + rc + ',' + rc + 'L-' + rc + ',-' + rc +\n                'M' + rc + ',-' + rc + 'L-' + rc + ',' + rc +\n                'M' + rs + ',0A' + rs + ',' + rs + ' 0 1,1 0,-' + rs +\n                'A' + rs + ',' + rs + ' 0 0,1 ' + rs + ',0Z';\n        },\n        needLine: true,\n        noDot: true\n    },\n    'square-cross': {\n        n: 29,\n        f: function(r) {\n            var rs = d3.round(r, 2);\n            return 'M0,' + rs + 'V-' + rs + 'M' + rs + ',0H-' + rs +\n                'M' + rs + ',' + rs + 'H-' + rs + 'V-' + rs + 'H' + rs + 'Z';\n        },\n        needLine: true,\n        noDot: true\n    },\n    'square-x': {\n        n: 30,\n        f: function(r) {\n            var rs = d3.round(r, 2);\n            return 'M' + rs + ',' + rs + 'L-' + rs + ',-' + rs +\n                'M' + rs + ',-' + rs + 'L-' + rs + ',' + rs +\n                'M' + rs + ',' + rs + 'H-' + rs + 'V-' + rs + 'H' + rs + 'Z';\n        },\n        needLine: true,\n        noDot: true\n    },\n    'diamond-cross': {\n        n: 31,\n        f: function(r) {\n            var rd = d3.round(r * 1.3, 2);\n            return 'M' + rd + ',0L0,' + rd + 'L-' + rd + ',0L0,-' + rd + 'Z' +\n                'M0,-' + rd + 'V' + rd + 'M-' + rd + ',0H' + rd;\n        },\n        needLine: true,\n        noDot: true\n    },\n    'diamond-x': {\n        n: 32,\n        f: function(r) {\n            var rd = d3.round(r * 1.3, 2),\n                r2 = d3.round(r * 0.65, 2);\n            return 'M' + rd + ',0L0,' + rd + 'L-' + rd + ',0L0,-' + rd + 'Z' +\n                'M-' + r2 + ',-' + r2 + 'L' + r2 + ',' + r2 +\n                'M-' + r2 + ',' + r2 + 'L' + r2 + ',-' + r2;\n        },\n        needLine: true,\n        noDot: true\n    },\n    'cross-thin': {\n        n: 33,\n        f: function(r) {\n            var rc = d3.round(r * 1.4, 2);\n            return 'M0,' + rc + 'V-' + rc + 'M' + rc + ',0H-' + rc;\n        },\n        needLine: true,\n        noDot: true\n    },\n    'x-thin': {\n        n: 34,\n        f: function(r) {\n            var rx = d3.round(r, 2);\n            return 'M' + rx + ',' + rx + 'L-' + rx + ',-' + rx +\n                'M' + rx + ',-' + rx + 'L-' + rx + ',' + rx;\n        },\n        needLine: true,\n        noDot: true\n    },\n    asterisk: {\n        n: 35,\n        f: function(r) {\n            var rc = d3.round(r * 1.2, 2);\n            var rs = d3.round(r * 0.85, 2);\n            return 'M0,' + rc + 'V-' + rc + 'M' + rc + ',0H-' + rc +\n                'M' + rs + ',' + rs + 'L-' + rs + ',-' + rs +\n                'M' + rs + ',-' + rs + 'L-' + rs + ',' + rs;\n        },\n        needLine: true,\n        noDot: true\n    },\n    hash: {\n        n: 36,\n        f: function(r) {\n            var r1 = d3.round(r / 2, 2),\n                r2 = d3.round(r, 2);\n            return 'M' + r1 + ',' + r2 + 'V-' + r2 +\n                'm-' + r2 + ',0V' + r2 +\n                'M' + r2 + ',' + r1 + 'H-' + r2 +\n                'm0,-' + r2 + 'H' + r2;\n        },\n        needLine: true\n    },\n    'y-up': {\n        n: 37,\n        f: function(r) {\n            var x = d3.round(r * 1.2, 2),\n                y0 = d3.round(r * 1.6, 2),\n                y1 = d3.round(r * 0.8, 2);\n            return 'M-' + x + ',' + y1 + 'L0,0M' + x + ',' + y1 + 'L0,0M0,-' + y0 + 'L0,0';\n        },\n        needLine: true,\n        noDot: true\n    },\n    'y-down': {\n        n: 38,\n        f: function(r) {\n            var x = d3.round(r * 1.2, 2),\n                y0 = d3.round(r * 1.6, 2),\n                y1 = d3.round(r * 0.8, 2);\n            return 'M-' + x + ',-' + y1 + 'L0,0M' + x + ',-' + y1 + 'L0,0M0,' + y0 + 'L0,0';\n        },\n        needLine: true,\n        noDot: true\n    },\n    'y-left': {\n        n: 39,\n        f: function(r) {\n            var y = d3.round(r * 1.2, 2),\n                x0 = d3.round(r * 1.6, 2),\n                x1 = d3.round(r * 0.8, 2);\n            return 'M' + x1 + ',' + y + 'L0,0M' + x1 + ',-' + y + 'L0,0M-' + x0 + ',0L0,0';\n        },\n        needLine: true,\n        noDot: true\n    },\n    'y-right': {\n        n: 40,\n        f: function(r) {\n            var y = d3.round(r * 1.2, 2),\n                x0 = d3.round(r * 1.6, 2),\n                x1 = d3.round(r * 0.8, 2);\n            return 'M-' + x1 + ',' + y + 'L0,0M-' + x1 + ',-' + y + 'L0,0M' + x0 + ',0L0,0';\n        },\n        needLine: true,\n        noDot: true\n    },\n    'line-ew': {\n        n: 41,\n        f: function(r) {\n            var rc = d3.round(r * 1.4, 2);\n            return 'M' + rc + ',0H-' + rc;\n        },\n        needLine: true,\n        noDot: true\n    },\n    'line-ns': {\n        n: 42,\n        f: function(r) {\n            var rc = d3.round(r * 1.4, 2);\n            return 'M0,' + rc + 'V-' + rc;\n        },\n        needLine: true,\n        noDot: true\n    },\n    'line-ne': {\n        n: 43,\n        f: function(r) {\n            var rx = d3.round(r, 2);\n            return 'M' + rx + ',-' + rx + 'L-' + rx + ',' + rx;\n        },\n        needLine: true,\n        noDot: true\n    },\n    'line-nw': {\n        n: 44,\n        f: function(r) {\n            var rx = d3.round(r, 2);\n            return 'M' + rx + ',' + rx + 'L-' + rx + ',-' + rx;\n        },\n        needLine: true,\n        noDot: true\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/constants/interactions.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n\nmodule.exports = {\n    /**\n     * Timing information for interactive elements\n     */\n    SHOW_PLACEHOLDER: 100,\n    HIDE_PLACEHOLDER: 1000,\n\n    // ms between first mousedown and 2nd mouseup to constitute dblclick...\n    // we don't seem to have access to the system setting\n    DBLCLICKDELAY: 300\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/cartesian/layout_defaults.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar Color = require('../../components/color');\nvar basePlotLayoutAttributes = require('../layout_attributes');\n\nvar constants = require('./constants');\nvar layoutAttributes = require('./layout_attributes');\nvar handleTypeDefaults = require('./type_defaults');\nvar handleAxisDefaults = require('./axis_defaults');\nvar handleConstraintDefaults = require('./constraint_defaults');\nvar handlePositionDefaults = require('./position_defaults');\nvar axisIds = require('./axis_ids');\n\n\nmodule.exports = function supplyLayoutDefaults(layoutIn, layoutOut, fullData) {\n    var layoutKeys = Object.keys(layoutIn),\n        xaListCartesian = [],\n        yaListCartesian = [],\n        xaListGl2d = [],\n        yaListGl2d = [],\n        xaListCheater = [],\n        xaListNonCheater = [],\n        outerTicks = {},\n        noGrids = {},\n        i;\n\n    // look for axes in the data\n    for(i = 0; i < fullData.length; i++) {\n        var trace = fullData[i];\n        var listX, listY;\n\n        if(Registry.traceIs(trace, 'cartesian')) {\n            listX = xaListCartesian;\n            listY = yaListCartesian;\n        }\n        else if(Registry.traceIs(trace, 'gl2d')) {\n            listX = xaListGl2d;\n            listY = yaListGl2d;\n        }\n        else continue;\n\n        var xaName = axisIds.id2name(trace.xaxis),\n            yaName = axisIds.id2name(trace.yaxis);\n\n        // Two things trigger axis visibility:\n        // 1. is not carpet\n        // 2. carpet that's not cheater\n        if(!Registry.traceIs(trace, 'carpet') || (trace.type === 'carpet' && !trace._cheater)) {\n            if(xaName) Lib.pushUnique(xaListNonCheater, xaName);\n        }\n\n        // The above check for definitely-not-cheater is not adequate. This\n        // second list tracks which axes *could* be a cheater so that the\n        // full condition triggering hiding is:\n        //   *could* be a cheater and *is not definitely visible*\n        if(trace.type === 'carpet' && trace._cheater) {\n            if(xaName) Lib.pushUnique(xaListCheater, xaName);\n        }\n\n        // add axes implied by traces\n        if(xaName && listX.indexOf(xaName) === -1) listX.push(xaName);\n        if(yaName && listY.indexOf(yaName) === -1) listY.push(yaName);\n\n        // check for default formatting tweaks\n        if(Registry.traceIs(trace, '2dMap')) {\n            outerTicks[xaName] = true;\n            outerTicks[yaName] = true;\n        }\n\n        if(Registry.traceIs(trace, 'oriented')) {\n            var positionAxis = trace.orientation === 'h' ? yaName : xaName;\n            noGrids[positionAxis] = true;\n        }\n    }\n\n    // N.B. Ignore orphan axes (i.e. axes that have no data attached to them)\n    // if gl3d or geo is present on graph. This is retain backward compatible.\n    //\n    // TODO drop this in version 2.0\n    var ignoreOrphan = (layoutOut._has('gl3d') || layoutOut._has('geo'));\n\n    if(!ignoreOrphan) {\n        for(i = 0; i < layoutKeys.length; i++) {\n            var key = layoutKeys[i];\n\n            // orphan layout axes are considered cartesian subplots\n\n            if(xaListGl2d.indexOf(key) === -1 &&\n                xaListCartesian.indexOf(key) === -1 &&\n                    constants.xAxisMatch.test(key)) {\n                xaListCartesian.push(key);\n            }\n            else if(yaListGl2d.indexOf(key) === -1 &&\n                yaListCartesian.indexOf(key) === -1 &&\n                    constants.yAxisMatch.test(key)) {\n                yaListCartesian.push(key);\n            }\n        }\n    }\n\n    // make sure that plots with orphan cartesian axes\n    // are considered 'cartesian'\n    if(xaListCartesian.length && yaListCartesian.length) {\n        Lib.pushUnique(layoutOut._basePlotModules, Registry.subplotsRegistry.cartesian);\n    }\n\n    function axSort(a, b) {\n        var aNum = Number(a.substr(5) || 1),\n            bNum = Number(b.substr(5) || 1);\n        return aNum - bNum;\n    }\n\n    var xaList = xaListCartesian.concat(xaListGl2d).sort(axSort),\n        yaList = yaListCartesian.concat(yaListGl2d).sort(axSort),\n        axesList = xaList.concat(yaList);\n\n    // plot_bgcolor only makes sense if there's a (2D) plot!\n    // TODO: bgcolor for each subplot, to inherit from the main one\n    var plot_bgcolor = Color.background;\n    if(xaList.length && yaList.length) {\n        plot_bgcolor = Lib.coerce(layoutIn, layoutOut, basePlotLayoutAttributes, 'plot_bgcolor');\n    }\n\n    var bgColor = Color.combine(plot_bgcolor, layoutOut.paper_bgcolor);\n\n    var axName, axLetter, axLayoutIn, axLayoutOut;\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(axLayoutIn, axLayoutOut, layoutAttributes, attr, dflt);\n    }\n\n    function getCounterAxes(axLetter) {\n        var list = {x: yaList, y: xaList}[axLetter];\n        return Lib.simpleMap(list, axisIds.name2id);\n    }\n\n    var counterAxes = {x: getCounterAxes('x'), y: getCounterAxes('y')};\n\n    function getOverlayableAxes(axLetter, axName) {\n        var list = {x: xaList, y: yaList}[axLetter];\n        var out = [];\n\n        for(var j = 0; j < list.length; j++) {\n            var axName2 = list[j];\n\n            if(axName2 !== axName && !(layoutIn[axName2] || {}).overlaying) {\n                out.push(axisIds.name2id(axName2));\n            }\n        }\n\n        return out;\n    }\n\n    // first pass creates the containers, determines types, and handles most of the settings\n    for(i = 0; i < axesList.length; i++) {\n        axName = axesList[i];\n\n        if(!Lib.isPlainObject(layoutIn[axName])) {\n            layoutIn[axName] = {};\n        }\n\n        axLayoutIn = layoutIn[axName];\n        axLayoutOut = layoutOut[axName] = {};\n\n        handleTypeDefaults(axLayoutIn, axLayoutOut, coerce, fullData, axName);\n\n        axLetter = axName.charAt(0);\n        var overlayableAxes = getOverlayableAxes(axLetter, axName);\n\n        var defaultOptions = {\n            letter: axLetter,\n            font: layoutOut.font,\n            outerTicks: outerTicks[axName],\n            showGrid: !noGrids[axName],\n            data: fullData,\n            bgColor: bgColor,\n            calendar: layoutOut.calendar,\n            cheateronly: axLetter === 'x' && (xaListCheater.indexOf(axName) !== -1 && xaListNonCheater.indexOf(axName) === -1)\n        };\n\n        handleAxisDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions, layoutOut);\n\n        var showSpikes = coerce('showspikes');\n        if(showSpikes) {\n            coerce('spikecolor');\n            coerce('spikethickness');\n            coerce('spikedash');\n            coerce('spikemode');\n        }\n\n        var positioningOptions = {\n            letter: axLetter,\n            counterAxes: counterAxes[axLetter],\n            overlayableAxes: overlayableAxes\n        };\n\n        handlePositionDefaults(axLayoutIn, axLayoutOut, coerce, positioningOptions);\n\n        axLayoutOut._input = axLayoutIn;\n    }\n\n    // quick second pass for range slider and selector defaults\n    var rangeSliderDefaults = Registry.getComponentMethod('rangeslider', 'handleDefaults'),\n        rangeSelectorDefaults = Registry.getComponentMethod('rangeselector', 'handleDefaults');\n\n    for(i = 0; i < xaList.length; i++) {\n        axName = xaList[i];\n        axLayoutIn = layoutIn[axName];\n        axLayoutOut = layoutOut[axName];\n\n        rangeSliderDefaults(layoutIn, layoutOut, axName);\n\n        if(axLayoutOut.type === 'date') {\n            rangeSelectorDefaults(\n                axLayoutIn,\n                axLayoutOut,\n                layoutOut,\n                yaList,\n                axLayoutOut.calendar\n            );\n        }\n\n        coerce('fixedrange');\n    }\n\n    for(i = 0; i < yaList.length; i++) {\n        axName = yaList[i];\n        axLayoutIn = layoutIn[axName];\n        axLayoutOut = layoutOut[axName];\n\n        var anchoredAxis = layoutOut[axisIds.id2name(axLayoutOut.anchor)];\n\n        var fixedRangeDflt = (\n            anchoredAxis &&\n            anchoredAxis.rangeslider &&\n            anchoredAxis.rangeslider.visible\n        );\n\n        coerce('fixedrange', fixedRangeDflt);\n    }\n\n    // Finally, handle scale constraints. We need to do this after all axes have\n    // coerced both `type` (so we link only axes of the same type) and\n    // `fixedrange` (so we can avoid linking from OR TO a fixed axis).\n\n    // sets of axes linked by `scaleanchor` along with the scaleratios compounded\n    // together, populated in handleConstraintDefaults\n    layoutOut._axisConstraintGroups = [];\n    var allAxisIds = counterAxes.x.concat(counterAxes.y);\n\n    for(i = 0; i < axesList.length; i++) {\n        axName = axesList[i];\n        axLetter = axName.charAt(0);\n\n        axLayoutIn = layoutIn[axName];\n        axLayoutOut = layoutOut[axName];\n\n        handleConstraintDefaults(axLayoutIn, axLayoutOut, coerce, allAxisIds, layoutOut);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/cartesian/type_defaults.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Registry = require('../../registry');\nvar autoType = require('./axis_autotype');\nvar name2id = require('./axis_ids').name2id;\n\n/*\n *  data: the plot data to use in choosing auto type\n *  name: axis object name (ie 'xaxis') if one should be stored\n */\nmodule.exports = function handleTypeDefaults(containerIn, containerOut, coerce, data, name) {\n    // set up some private properties\n    if(name) {\n        containerOut._name = name;\n        containerOut._id = name2id(name);\n    }\n\n    var axType = coerce('type');\n    if(axType === '-') {\n        setAutoType(containerOut, data);\n\n        if(containerOut.type === '-') {\n            containerOut.type = 'linear';\n        }\n        else {\n            // copy autoType back to input axis\n            // note that if this object didn't exist\n            // in the input layout, we have to put it in\n            // this happens in the main supplyDefaults function\n            containerIn.type = containerOut.type;\n        }\n    }\n};\n\nfunction setAutoType(ax, data) {\n    // new logic: let people specify any type they want,\n    // only autotype if type is '-'\n    if(ax.type !== '-') return;\n\n    var id = ax._id,\n        axLetter = id.charAt(0);\n\n    // support 3d\n    if(id.indexOf('scene') !== -1) id = axLetter;\n\n    var d0 = getFirstNonEmptyTrace(data, id, axLetter);\n    if(!d0) return;\n\n    // first check for histograms, as the count direction\n    // should always default to a linear axis\n    if(d0.type === 'histogram' &&\n            axLetter === {v: 'y', h: 'x'}[d0.orientation || 'v']) {\n        ax.type = 'linear';\n        return;\n    }\n\n    var calAttr = axLetter + 'calendar',\n        calendar = d0[calAttr];\n\n    // check all boxes on this x axis to see\n    // if they're dates, numbers, or categories\n    if(isBoxWithoutPositionCoords(d0, axLetter)) {\n        var posLetter = getBoxPosLetter(d0),\n            boxPositions = [],\n            trace;\n\n        for(var i = 0; i < data.length; i++) {\n            trace = data[i];\n            if(!Registry.traceIs(trace, 'box') ||\n               (trace[axLetter + 'axis'] || axLetter) !== id) continue;\n\n            if(trace[posLetter] !== undefined) boxPositions.push(trace[posLetter][0]);\n            else if(trace.name !== undefined) boxPositions.push(trace.name);\n            else boxPositions.push('text');\n\n            if(trace[calAttr] !== calendar) calendar = undefined;\n        }\n\n        ax.type = autoType(boxPositions, calendar);\n    }\n    else {\n        ax.type = autoType(d0[axLetter] || [d0[axLetter + '0']], calendar);\n    }\n}\n\nfunction getFirstNonEmptyTrace(data, id, axLetter) {\n    for(var i = 0; i < data.length; i++) {\n        var trace = data[i];\n\n        if((trace[axLetter + 'axis'] || axLetter) === id) {\n            if(isBoxWithoutPositionCoords(trace, axLetter)) {\n                return trace;\n            }\n            else if((trace[axLetter] || []).length || trace[axLetter + '0']) {\n                return trace;\n            }\n        }\n    }\n}\n\nfunction getBoxPosLetter(trace) {\n    return {v: 'x', h: 'y'}[trace.orientation || 'v'];\n}\n\nfunction isBoxWithoutPositionCoords(trace, axLetter) {\n    var posLetter = getBoxPosLetter(trace),\n        isBox = Registry.traceIs(trace, 'box'),\n        isCandlestick = Registry.traceIs(trace._fullInput || {}, 'candlestick');\n\n    return (\n        isBox &&\n        !isCandlestick &&\n        axLetter === posLetter &&\n        trace[posLetter] === undefined &&\n        trace[posLetter + '0'] === undefined\n    );\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/cartesian/axis_autotype.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nmodule.exports = function autoType(array, calendar) {\n    if(moreDates(array, calendar)) return 'date';\n    if(category(array)) return 'category';\n    if(linearOK(array)) return 'linear';\n    else return '-';\n};\n\n// is there at least one number in array? If not, we should leave\n// ax.type empty so it can be autoset later\nfunction linearOK(array) {\n    if(!array) return false;\n\n    for(var i = 0; i < array.length; i++) {\n        if(isNumeric(array[i])) return true;\n    }\n\n    return false;\n}\n\n// does the array a have mostly dates rather than numbers?\n// note: some values can be neither (such as blanks, text)\n// 2- or 4-digit integers can be both, so require twice as many\n// dates as non-dates, to exclude cases with mostly 2 & 4 digit\n// numbers and a few dates\nfunction moreDates(a, calendar) {\n    var dcnt = 0,\n        ncnt = 0,\n        // test at most 1000 points, evenly spaced\n        inc = Math.max(1, (a.length - 1) / 1000),\n        ai;\n\n    for(var i = 0; i < a.length; i += inc) {\n        ai = a[Math.round(i)];\n        if(Lib.isDateTime(ai, calendar)) dcnt += 1;\n        if(isNumeric(ai)) ncnt += 1;\n    }\n\n    return (dcnt > ncnt * 2);\n}\n\n// are the (x,y)-values in gd.data mostly text?\n// require twice as many categories as numbers\nfunction category(a) {\n    // test at most 1000 points\n    var inc = Math.max(1, (a.length - 1) / 1000),\n        curvenums = 0,\n        curvecats = 0,\n        ai;\n\n    for(var i = 0; i < a.length; i += inc) {\n        ai = a[Math.round(i)];\n        if(Lib.cleanNumber(ai) !== BADNUM) curvenums++;\n        else if(typeof ai === 'string' && ai !== '' && ai !== 'None') curvecats++;\n    }\n\n    return curvecats > curvenums * 2;\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/cartesian/axis_ids.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Registry = require('../../registry');\nvar Plots = require('../plots');\nvar Lib = require('../../lib');\n\nvar constants = require('./constants');\n\n\n// convert between axis names (xaxis, xaxis2, etc, elements of gd.layout)\n// and axis id's (x, x2, etc). Would probably have ditched 'xaxis'\n// completely in favor of just 'x' if it weren't ingrained in the API etc.\nexports.id2name = function id2name(id) {\n    if(typeof id !== 'string' || !id.match(constants.AX_ID_PATTERN)) return;\n    var axNum = id.substr(1);\n    if(axNum === '1') axNum = '';\n    return id.charAt(0) + 'axis' + axNum;\n};\n\nexports.name2id = function name2id(name) {\n    if(!name.match(constants.AX_NAME_PATTERN)) return;\n    var axNum = name.substr(5);\n    if(axNum === '1') axNum = '';\n    return name.charAt(0) + axNum;\n};\n\nexports.cleanId = function cleanId(id, axLetter) {\n    if(!id.match(constants.AX_ID_PATTERN)) return;\n    if(axLetter && id.charAt(0) !== axLetter) return;\n\n    var axNum = id.substr(1).replace(/^0+/, '');\n    if(axNum === '1') axNum = '';\n    return id.charAt(0) + axNum;\n};\n\n// get all axis object names\n// optionally restricted to only x or y or z by string axLetter\n// and optionally 2D axes only, not those inside 3D scenes\nfunction listNames(gd, axLetter, only2d) {\n    var fullLayout = gd._fullLayout;\n    if(!fullLayout) return [];\n\n    function filterAxis(obj, extra) {\n        var keys = Object.keys(obj),\n            axMatch = /^[xyz]axis[0-9]*/,\n            out = [];\n\n        for(var i = 0; i < keys.length; i++) {\n            var k = keys[i];\n            if(axLetter && k.charAt(0) !== axLetter) continue;\n            if(axMatch.test(k)) out.push(extra + k);\n        }\n\n        return out.sort();\n    }\n\n    var names = filterAxis(fullLayout, '');\n    if(only2d) return names;\n\n    var sceneIds3D = Plots.getSubplotIds(fullLayout, 'gl3d') || [];\n    for(var i = 0; i < sceneIds3D.length; i++) {\n        var sceneId = sceneIds3D[i];\n        names = names.concat(\n            filterAxis(fullLayout[sceneId], sceneId + '.')\n        );\n    }\n\n    return names;\n}\n\n// get all axis objects, as restricted in listNames\nexports.list = function(gd, axletter, only2d) {\n    return listNames(gd, axletter, only2d)\n        .map(function(axName) {\n            return Lib.nestedProperty(gd._fullLayout, axName).get();\n        });\n};\n\n// get all axis ids, optionally restricted by letter\n// this only makes sense for 2d axes\nexports.listIds = function(gd, axletter) {\n    return listNames(gd, axletter, true).map(exports.name2id);\n};\n\n// get an axis object from its id 'x','x2' etc\n// optionally, id can be a subplot (ie 'x2y3') and type gets x or y from it\nexports.getFromId = function(gd, id, type) {\n    var fullLayout = gd._fullLayout;\n\n    if(type === 'x') id = id.replace(/y[0-9]*/, '');\n    else if(type === 'y') id = id.replace(/x[0-9]*/, '');\n\n    return fullLayout[exports.id2name(id)];\n};\n\n// get an axis object of specified type from the containing trace\nexports.getFromTrace = function(gd, fullTrace, type) {\n    var fullLayout = gd._fullLayout;\n    var ax = null;\n\n    if(Registry.traceIs(fullTrace, 'gl3d')) {\n        var scene = fullTrace.scene;\n        if(scene.substr(0, 5) === 'scene') {\n            ax = fullLayout[scene][type + 'axis'];\n        }\n    }\n    else {\n        ax = exports.getFromId(gd, fullTrace[type + 'axis'] || type);\n    }\n\n    return ax;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/cartesian/axis_defaults.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar colorMix = require('tinycolor2').mix;\n\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar lightFraction = require('../../components/color/attributes').lightFraction;\n\nvar layoutAttributes = require('./layout_attributes');\nvar handleTickValueDefaults = require('./tick_value_defaults');\nvar handleTickMarkDefaults = require('./tick_mark_defaults');\nvar handleTickLabelDefaults = require('./tick_label_defaults');\nvar handleCategoryOrderDefaults = require('./category_order_defaults');\nvar setConvert = require('./set_convert');\nvar orderedCategories = require('./ordered_categories');\n\n\n/**\n * options: object containing:\n *\n *  letter: 'x' or 'y'\n *  title: name of the axis (ie 'Colorbar') to go in default title\n *  font: the default font to inherit\n *  outerTicks: boolean, should ticks default to outside?\n *  showGrid: boolean, should gridlines be shown by default?\n *  noHover: boolean, this axis doesn't support hover effects?\n *  data: the plot data, used to manage categories\n *  bgColor: the plot background color, to calculate default gridline colors\n */\nmodule.exports = function handleAxisDefaults(containerIn, containerOut, coerce, options, layoutOut) {\n    var letter = options.letter,\n        font = options.font || {},\n        defaultTitle = 'Click to enter ' +\n            (options.title || (letter.toUpperCase() + ' axis')) +\n            ' title';\n\n    function coerce2(attr, dflt) {\n        return Lib.coerce2(containerIn, containerOut, layoutAttributes, attr, dflt);\n    }\n\n    var visible = coerce('visible', !options.cheateronly);\n\n    var axType = containerOut.type;\n\n    if(axType === 'date') {\n        var handleCalendarDefaults = Registry.getComponentMethod('calendars', 'handleDefaults');\n        handleCalendarDefaults(containerIn, containerOut, 'calendar', options.calendar);\n    }\n\n    setConvert(containerOut, layoutOut);\n\n    var autoRange = coerce('autorange', !containerOut.isValidRange(containerIn.range));\n\n    if(autoRange) coerce('rangemode');\n\n    coerce('range');\n    containerOut.cleanRange();\n\n    handleCategoryOrderDefaults(containerIn, containerOut, coerce);\n    containerOut._initialCategories = axType === 'category' ?\n        orderedCategories(letter, containerOut.categoryorder, containerOut.categoryarray, options.data) :\n        [];\n\n    if(!visible) return containerOut;\n\n    var dfltColor = coerce('color');\n    // if axis.color was provided, use it for fonts too; otherwise,\n    // inherit from global font color in case that was provided.\n    var dfltFontColor = (dfltColor === containerIn.color) ? dfltColor : font.color;\n\n    coerce('title', defaultTitle);\n    Lib.coerceFont(coerce, 'titlefont', {\n        family: font.family,\n        size: Math.round(font.size * 1.2),\n        color: dfltFontColor\n    });\n\n    handleTickValueDefaults(containerIn, containerOut, coerce, axType);\n    handleTickLabelDefaults(containerIn, containerOut, coerce, axType, options);\n    handleTickMarkDefaults(containerIn, containerOut, coerce, options);\n\n    var lineColor = coerce2('linecolor', dfltColor),\n        lineWidth = coerce2('linewidth'),\n        showLine = coerce('showline', !!lineColor || !!lineWidth);\n\n    if(!showLine) {\n        delete containerOut.linecolor;\n        delete containerOut.linewidth;\n    }\n\n    if(showLine || containerOut.ticks) coerce('mirror');\n\n    var gridColor = coerce2('gridcolor', colorMix(dfltColor, options.bgColor, lightFraction).toRgbString()),\n        gridWidth = coerce2('gridwidth'),\n        showGridLines = coerce('showgrid', options.showGrid || !!gridColor || !!gridWidth);\n\n    if(!showGridLines) {\n        delete containerOut.gridcolor;\n        delete containerOut.gridwidth;\n    }\n\n    var zeroLineColor = coerce2('zerolinecolor', dfltColor),\n        zeroLineWidth = coerce2('zerolinewidth'),\n        showZeroLine = coerce('zeroline', options.showGrid || !!zeroLineColor || !!zeroLineWidth);\n\n    if(!showZeroLine) {\n        delete containerOut.zerolinecolor;\n        delete containerOut.zerolinewidth;\n    }\n\n    return containerOut;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/cartesian/category_order_defaults.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n\nmodule.exports = function handleCategoryOrderDefaults(containerIn, containerOut, coerce) {\n    if(containerOut.type !== 'category') return;\n\n    var arrayIn = containerIn.categoryarray,\n        orderDefault;\n\n    var isValidArray = (Array.isArray(arrayIn) && arrayIn.length > 0);\n\n    // override default 'categoryorder' value when non-empty array is supplied\n    if(isValidArray) orderDefault = 'array';\n\n    var order = coerce('categoryorder', orderDefault);\n\n    // coerce 'categoryarray' only in array order case\n    if(order === 'array') coerce('categoryarray');\n\n    // cannot set 'categoryorder' to 'array' with an invalid 'categoryarray'\n    if(!isValidArray && order === 'array') {\n        containerOut.categoryorder = 'trace';\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/cartesian/set_convert.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\nvar cleanNumber = Lib.cleanNumber;\nvar ms2DateTime = Lib.ms2DateTime;\nvar dateTime2ms = Lib.dateTime2ms;\n\nvar numConstants = require('../../constants/numerical');\nvar FP_SAFE = numConstants.FP_SAFE;\nvar BADNUM = numConstants.BADNUM;\n\nvar constants = require('./constants');\nvar axisIds = require('./axis_ids');\n\nfunction fromLog(v) {\n    return Math.pow(10, v);\n}\n\nfunction num(v) {\n    if(!isNumeric(v)) return BADNUM;\n    v = Number(v);\n    if(v < -FP_SAFE || v > FP_SAFE) return BADNUM;\n    return isNumeric(v) ? Number(v) : BADNUM;\n}\n\n/**\n * Define the conversion functions for an axis data is used in 5 ways:\n *\n *  d: data, in whatever form it's provided\n *  c: calcdata: turned into numbers, but not linearized\n *  l: linearized - same as c except for log axes (and other nonlinear\n *      mappings later?) this is used when we need to know if it's\n *      *possible* to show some data on this axis, without caring about\n *      the current range\n *  p: pixel value - mapped to the screen with current size and zoom\n *  r: ranges, tick0, and annotation positions match one of the above\n *     but are handled differently for different types:\n *     - linear and date: data format (d)\n *     - category: calcdata format (c), and will stay that way because\n *       the data format has no continuous mapping\n *     - log: linearized (l) format\n *       TODO: in v2.0 we plan to change it to data format. At that point\n *       shapes will work the same way as ranges, tick0, and annotations\n *       so they can use this conversion too.\n *\n * Creates/updates these conversion functions, and a few more utilities\n * like cleanRange, and makeCalcdata\n *\n * also clears the autorange bounds ._min and ._max\n * and the autotick constraints ._minDtick, ._forceTick0\n */\nmodule.exports = function setConvert(ax, fullLayout) {\n    fullLayout = fullLayout || {};\n\n    // clipMult: how many axis lengths past the edge do we render?\n    // for panning, 1-2 would suffice, but for zooming more is nice.\n    // also, clipping can affect the direction of lines off the edge...\n    var clipMult = 10;\n\n    function toLog(v, clip) {\n        if(v > 0) return Math.log(v) / Math.LN10;\n\n        else if(v <= 0 && clip && ax.range && ax.range.length === 2) {\n            // clip NaN (ie past negative infinity) to clipMult axis\n            // length past the negative edge\n            var r0 = ax.range[0],\n                r1 = ax.range[1];\n            return 0.5 * (r0 + r1 - 3 * clipMult * Math.abs(r0 - r1));\n        }\n\n        else return BADNUM;\n    }\n\n    /*\n     * wrapped dateTime2ms that:\n     * - accepts ms numbers for backward compatibility\n     * - inserts a dummy arg so calendar is the 3rd arg (see notes below).\n     * - defaults to ax.calendar\n     */\n    function dt2ms(v, _, calendar) {\n        // NOTE: Changed this behavior: previously we took any numeric value\n        // to be a ms, even if it was a string that could be a bare year.\n        // Now we convert it as a date if at all possible, and only try\n        // as (local) ms if that fails.\n        var ms = dateTime2ms(v, calendar || ax.calendar);\n        if(ms === BADNUM) {\n            if(isNumeric(v)) ms = dateTime2ms(new Date(+v));\n            else return BADNUM;\n        }\n        return ms;\n    }\n\n    // wrapped ms2DateTime to insert default ax.calendar\n    function ms2dt(v, r, calendar) {\n        return ms2DateTime(v, r, calendar || ax.calendar);\n    }\n\n    function getCategoryName(v) {\n        return ax._categories[Math.round(v)];\n    }\n\n    /*\n     * setCategoryIndex: return the index of category v,\n     * inserting it in the list if it's not already there\n     *\n     * this will enter the categories in the order it\n     * encounters them, ie all the categories from the\n     * first data set, then all the ones from the second\n     * that aren't in the first etc.\n     *\n     * it is assumed that this function is being invoked in the\n     * already sorted category order; otherwise there would be\n     * a disconnect between the array and the index returned\n     */\n    function setCategoryIndex(v) {\n        if(v !== null && v !== undefined) {\n            if(ax._categoriesMap === undefined) {\n                ax._categoriesMap = {};\n            }\n\n            if(ax._categoriesMap[v] !== undefined) {\n                return ax._categoriesMap[v];\n            } else {\n                ax._categories.push(v);\n\n                var curLength = ax._categories.length - 1;\n                ax._categoriesMap[v] = curLength;\n\n                return curLength;\n            }\n        }\n        return BADNUM;\n    }\n\n    function getCategoryIndex(v) {\n        // d2l/d2c variant that that won't add categories but will also\n        // allow numbers to be mapped to the linearized axis positions\n        if(ax._categoriesMap) {\n            var index = ax._categoriesMap[v];\n            if(index !== undefined) return index;\n        }\n\n        if(typeof v === 'number') { return v; }\n    }\n\n    function l2p(v) {\n        if(!isNumeric(v)) return BADNUM;\n\n        // include 2 fractional digits on pixel, for PDF zooming etc\n        return d3.round(ax._b + ax._m * v, 2);\n    }\n\n    function p2l(px) { return (px - ax._b) / ax._m; }\n\n    // conversions among c/l/p are fairly simple - do them together for all axis types\n    ax.c2l = (ax.type === 'log') ? toLog : num;\n    ax.l2c = (ax.type === 'log') ? fromLog : num;\n\n    ax.l2p = l2p;\n    ax.p2l = p2l;\n\n    ax.c2p = (ax.type === 'log') ? function(v, clip) { return l2p(toLog(v, clip)); } : l2p;\n    ax.p2c = (ax.type === 'log') ? function(px) { return fromLog(p2l(px)); } : p2l;\n\n    /*\n     * now type-specific conversions for **ALL** other combinations\n     * they're all written out, instead of being combinations of each other, for\n     * both clarity and speed.\n     */\n    if(['linear', '-'].indexOf(ax.type) !== -1) {\n        // all are data vals, but d and r need cleaning\n        ax.d2r = ax.r2d = ax.d2c = ax.r2c = ax.d2l = ax.r2l = cleanNumber;\n        ax.c2d = ax.c2r = ax.l2d = ax.l2r = num;\n\n        ax.d2p = ax.r2p = function(v) { return l2p(cleanNumber(v)); };\n        ax.p2d = ax.p2r = p2l;\n    }\n    else if(ax.type === 'log') {\n        // d and c are data vals, r and l are logged (but d and r need cleaning)\n        ax.d2r = ax.d2l = function(v, clip) { return toLog(cleanNumber(v), clip); };\n        ax.r2d = ax.r2c = function(v) { return fromLog(cleanNumber(v)); };\n\n        ax.d2c = ax.r2l = cleanNumber;\n        ax.c2d = ax.l2r = num;\n\n        ax.c2r = toLog;\n        ax.l2d = fromLog;\n\n        ax.d2p = function(v, clip) { return l2p(ax.d2r(v, clip)); };\n        ax.p2d = function(px) { return fromLog(p2l(px)); };\n\n        ax.r2p = function(v) { return l2p(cleanNumber(v)); };\n        ax.p2r = p2l;\n    }\n    else if(ax.type === 'date') {\n        // r and d are date strings, l and c are ms\n\n        /*\n         * Any of these functions with r and d on either side, calendar is the\n         * **3rd** argument. log has reserved the second argument.\n         *\n         * Unless you need the special behavior of the second arg (ms2DateTime\n         * uses this to limit precision, toLog uses true to clip negatives\n         * to offscreen low rather than undefined), it's safe to pass 0.\n         */\n        ax.d2r = ax.r2d = Lib.identity;\n\n        ax.d2c = ax.r2c = ax.d2l = ax.r2l = dt2ms;\n        ax.c2d = ax.c2r = ax.l2d = ax.l2r = ms2dt;\n\n        ax.d2p = ax.r2p = function(v, _, calendar) { return l2p(dt2ms(v, 0, calendar)); };\n        ax.p2d = ax.p2r = function(px, r, calendar) { return ms2dt(p2l(px), r, calendar); };\n    }\n    else if(ax.type === 'category') {\n        // d is categories; r, c, and l are indices\n        // TODO: should r accept category names too?\n        // ie r2c and r2l would be getCategoryIndex (and r2p would change)\n\n        ax.d2r = ax.d2c = ax.d2l = setCategoryIndex;\n        ax.r2d = ax.c2d = ax.l2d = getCategoryName;\n\n        // special d2l variant that won't add categories\n        ax.d2l_noadd = getCategoryIndex;\n\n        ax.r2l = ax.l2r = ax.r2c = ax.c2r = num;\n\n        ax.d2p = function(v) { return l2p(getCategoryIndex(v)); };\n        ax.p2d = function(px) { return getCategoryName(p2l(px)); };\n        ax.r2p = l2p;\n        ax.p2r = p2l;\n    }\n\n    // find the range value at the specified (linear) fraction of the axis\n    ax.fraction2r = function(v) {\n        var rl0 = ax.r2l(ax.range[0]),\n            rl1 = ax.r2l(ax.range[1]);\n        return ax.l2r(rl0 + v * (rl1 - rl0));\n    };\n\n    // find the fraction of the range at the specified range value\n    ax.r2fraction = function(v) {\n        var rl0 = ax.r2l(ax.range[0]),\n            rl1 = ax.r2l(ax.range[1]);\n        return (ax.r2l(v) - rl0) / (rl1 - rl0);\n    };\n\n    /*\n     * cleanRange: make sure range is a couplet of valid & distinct values\n     * keep numbers away from the limits of floating point numbers,\n     * and dates away from the ends of our date system (+/- 9999 years)\n     *\n     * optional param rangeAttr: operate on a different attribute, like\n     * ax._r, rather than ax.range\n     */\n    ax.cleanRange = function(rangeAttr) {\n        if(!rangeAttr) rangeAttr = 'range';\n        var range = Lib.nestedProperty(ax, rangeAttr).get(),\n            axLetter = (ax._id || 'x').charAt(0),\n            i, dflt;\n\n        if(ax.type === 'date') dflt = Lib.dfltRange(ax.calendar);\n        else if(axLetter === 'y') dflt = constants.DFLTRANGEY;\n        else dflt = constants.DFLTRANGEX;\n\n        // make sure we don't later mutate the defaults\n        dflt = dflt.slice();\n\n        if(!range || range.length !== 2) {\n            Lib.nestedProperty(ax, rangeAttr).set(dflt);\n            return;\n        }\n\n        if(ax.type === 'date') {\n            // check if milliseconds or js date objects are provided for range\n            // and convert to date strings\n            range[0] = Lib.cleanDate(range[0], BADNUM, ax.calendar);\n            range[1] = Lib.cleanDate(range[1], BADNUM, ax.calendar);\n        }\n\n        for(i = 0; i < 2; i++) {\n            if(ax.type === 'date') {\n                if(!Lib.isDateTime(range[i], ax.calendar)) {\n                    ax[rangeAttr] = dflt;\n                    break;\n                }\n\n                if(ax.r2l(range[0]) === ax.r2l(range[1])) {\n                    // split by +/- 1 second\n                    var linCenter = Lib.constrain(ax.r2l(range[0]),\n                        Lib.MIN_MS + 1000, Lib.MAX_MS - 1000);\n                    range[0] = ax.l2r(linCenter - 1000);\n                    range[1] = ax.l2r(linCenter + 1000);\n                    break;\n                }\n            }\n            else {\n                if(!isNumeric(range[i])) {\n                    if(isNumeric(range[1 - i])) {\n                        range[i] = range[1 - i] * (i ? 10 : 0.1);\n                    }\n                    else {\n                        ax[rangeAttr] = dflt;\n                        break;\n                    }\n                }\n\n                if(range[i] < -FP_SAFE) range[i] = -FP_SAFE;\n                else if(range[i] > FP_SAFE) range[i] = FP_SAFE;\n\n                if(range[0] === range[1]) {\n                    // somewhat arbitrary: split by 1 or 1ppm, whichever is bigger\n                    var inc = Math.max(1, Math.abs(range[0] * 1e-6));\n                    range[0] -= inc;\n                    range[1] += inc;\n                }\n            }\n        }\n    };\n\n    // set scaling to pixels\n    ax.setScale = function(usePrivateRange) {\n        var gs = fullLayout._size,\n            axLetter = ax._id.charAt(0);\n\n        // TODO cleaner way to handle this case\n        if(!ax._categories) ax._categories = [];\n        // Add a map to optimize the performance of category collection\n        if(!ax._categoriesMap) ax._categoriesMap = {};\n\n        // make sure we have a domain (pull it in from the axis\n        // this one is overlaying if necessary)\n        if(ax.overlaying) {\n            var ax2 = axisIds.getFromId({ _fullLayout: fullLayout }, ax.overlaying);\n            ax.domain = ax2.domain;\n        }\n\n        // While transitions are occuring, occurring, we get a double-transform\n        // issue if we transform the drawn layer *and* use the new axis range to\n        // draw the data. This allows us to construct setConvert using the pre-\n        // interaction values of the range:\n        var rangeAttr = (usePrivateRange && ax._r) ? '_r' : 'range',\n            calendar = ax.calendar;\n        ax.cleanRange(rangeAttr);\n\n        var rl0 = ax.r2l(ax[rangeAttr][0], calendar),\n            rl1 = ax.r2l(ax[rangeAttr][1], calendar);\n\n        if(axLetter === 'y') {\n            ax._offset = gs.t + (1 - ax.domain[1]) * gs.h;\n            ax._length = gs.h * (ax.domain[1] - ax.domain[0]);\n            ax._m = ax._length / (rl0 - rl1);\n            ax._b = -ax._m * rl1;\n        }\n        else {\n            ax._offset = gs.l + ax.domain[0] * gs.w;\n            ax._length = gs.w * (ax.domain[1] - ax.domain[0]);\n            ax._m = ax._length / (rl1 - rl0);\n            ax._b = -ax._m * rl0;\n        }\n\n        if(!isFinite(ax._m) || !isFinite(ax._b)) {\n            Lib.notifier(\n                'Something went wrong with axis scaling',\n                'long');\n            fullLayout._replotting = false;\n            throw new Error('axis scaling');\n        }\n    };\n\n    // makeCalcdata: takes an x or y array and converts it\n    // to a position on the axis object \"ax\"\n    // inputs:\n    //      trace - a data object from gd.data\n    //      axLetter - a string, either 'x' or 'y', for which item\n    //          to convert (TODO: is this now always the same as\n    //          the first letter of ax._id?)\n    // in case the expected data isn't there, make a list of\n    // integers based on the opposite data\n    ax.makeCalcdata = function(trace, axLetter) {\n        var arrayIn, arrayOut, i;\n\n        var cal = ax.type === 'date' && trace[axLetter + 'calendar'];\n\n        if(axLetter in trace) {\n            arrayIn = trace[axLetter];\n            arrayOut = new Array(arrayIn.length);\n\n            for(i = 0; i < arrayIn.length; i++) {\n                arrayOut[i] = ax.d2c(arrayIn[i], 0, cal);\n            }\n        }\n        else {\n            var v0 = ((axLetter + '0') in trace) ?\n                    ax.d2c(trace[axLetter + '0'], 0, cal) : 0,\n                dv = (trace['d' + axLetter]) ?\n                    Number(trace['d' + axLetter]) : 1;\n\n            // the opposing data, for size if we have x and dx etc\n            arrayIn = trace[{x: 'y', y: 'x'}[axLetter]];\n            arrayOut = new Array(arrayIn.length);\n\n            for(i = 0; i < arrayIn.length; i++) arrayOut[i] = v0 + i * dv;\n        }\n        return arrayOut;\n    };\n\n    ax.isValidRange = function(range) {\n        return (\n            Array.isArray(range) &&\n            range.length === 2 &&\n            isNumeric(ax.r2l(range[0])) &&\n            isNumeric(ax.r2l(range[1]))\n        );\n    };\n\n    // for autoranging: arrays of objects:\n    //      {val: axis value, pad: pixel padding}\n    // on the low and high sides\n    ax._min = [];\n    ax._max = [];\n\n    // copy ref to fullLayout.separators so that\n    // methods in Axes can use it w/o having to pass fullLayout\n    ax._separators = fullLayout.separators;\n\n    // and for bar charts and box plots: reset forced minimum tick spacing\n    delete ax._minDtick;\n    delete ax._forceTick0;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/cartesian/ordered_categories.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\n\n// flattenUniqueSort :: String -> Function -> [[String]] -> [String]\nfunction flattenUniqueSort(axisLetter, sortFunction, data) {\n\n    // Bisection based insertion sort of distinct values for logarithmic time complexity.\n    // Can't use a hashmap, which is O(1), because ES5 maps coerce keys to strings. If it ever becomes a bottleneck,\n    // code can be separated: a hashmap (JS object) based version if all values encountered are strings; and\n    // downgrading to this O(log(n)) array on the first encounter of a non-string value.\n\n    var categoryArray = [];\n\n    var traceLines = data.map(function(d) {return d[axisLetter];});\n\n    var i, j, tracePoints, category, insertionIndex;\n\n    var bisector = d3.bisector(sortFunction).left;\n\n    for(i = 0; i < traceLines.length; i++) {\n\n        tracePoints = traceLines[i];\n\n        for(j = 0; j < tracePoints.length; j++) {\n\n            category = tracePoints[j];\n\n            // skip loop: ignore null and undefined categories\n            if(category === null || category === undefined) continue;\n\n            insertionIndex = bisector(categoryArray, category);\n\n            // skip loop on already encountered values\n            if(insertionIndex < categoryArray.length && categoryArray[insertionIndex] === category) continue;\n\n            // insert value\n            categoryArray.splice(insertionIndex, 0, category);\n        }\n    }\n\n    return categoryArray;\n}\n\n\n/**\n * This pure function returns the ordered categories for specified axisLetter, categoryorder, categoryarray and data.\n *\n * If categoryorder is 'array', the result is a fresh copy of categoryarray, or if unspecified, an empty array.\n *\n * If categoryorder is 'category ascending' or 'category descending', the result is an array of ascending or descending\n * order of the unique categories encountered in the data for specified axisLetter.\n *\n * See cartesian/layout_attributes.js for the definition of categoryorder and categoryarray\n *\n */\n\n// orderedCategories :: String -> String -> [String] -> [[String]] -> [String]\nmodule.exports = function orderedCategories(axisLetter, categoryorder, categoryarray, data) {\n\n    switch(categoryorder) {\n        case 'array': return Array.isArray(categoryarray) ? categoryarray.slice() : [];\n        case 'category ascending': return flattenUniqueSort(axisLetter, d3.ascending, data);\n        case 'category descending': return flattenUniqueSort(axisLetter, d3.descending, data);\n        case 'trace': return [];\n        default: return [];\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/cartesian/constraint_defaults.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar id2name = require('./axis_ids').id2name;\n\n\nmodule.exports = function handleConstraintDefaults(containerIn, containerOut, coerce, allAxisIds, layoutOut) {\n    var constraintGroups = layoutOut._axisConstraintGroups;\n\n    if(containerOut.fixedrange || !containerIn.scaleanchor) return;\n\n    var constraintOpts = getConstraintOpts(constraintGroups, containerOut._id, allAxisIds, layoutOut);\n\n    var scaleanchor = Lib.coerce(containerIn, containerOut, {\n        scaleanchor: {\n            valType: 'enumerated',\n            values: constraintOpts.linkableAxes\n        }\n    }, 'scaleanchor');\n\n    if(scaleanchor) {\n        var scaleratio = coerce('scaleratio');\n        // TODO: I suppose I could do attribute.min: Number.MIN_VALUE to avoid zero,\n        // but that seems hacky. Better way to say \"must be a positive number\"?\n        // Of course if you use several super-tiny values you could eventually\n        // force a product of these to zero and all hell would break loose...\n        // Likewise with super-huge values.\n        if(!scaleratio) scaleratio = containerOut.scaleratio = 1;\n\n        updateConstraintGroups(constraintGroups, constraintOpts.thisGroup,\n            containerOut._id, scaleanchor, scaleratio);\n    }\n    else if(allAxisIds.indexOf(containerIn.scaleanchor) !== -1) {\n        Lib.warn('ignored ' + containerOut._name + '.scaleanchor: \"' +\n            containerIn.scaleanchor + '\" to avoid either an infinite loop ' +\n            'and possibly inconsistent scaleratios, or because the target' +\n            'axis has fixed range.');\n    }\n};\n\nfunction getConstraintOpts(constraintGroups, thisID, allAxisIds, layoutOut) {\n    // If this axis is already part of a constraint group, we can't\n    // scaleanchor any other axis in that group, or we'd make a loop.\n    // Filter allAxisIds to enforce this, also matching axis types.\n\n    var thisType = layoutOut[id2name(thisID)].type;\n\n    var i, j, idj, axj;\n\n    var linkableAxes = [];\n    for(j = 0; j < allAxisIds.length; j++) {\n        idj = allAxisIds[j];\n        if(idj === thisID) continue;\n\n        axj = layoutOut[id2name(idj)];\n        if(axj.type === thisType && !axj.fixedrange) linkableAxes.push(idj);\n    }\n\n    for(i = 0; i < constraintGroups.length; i++) {\n        if(constraintGroups[i][thisID]) {\n            var thisGroup = constraintGroups[i];\n\n            var linkableAxesNoLoops = [];\n            for(j = 0; j < linkableAxes.length; j++) {\n                idj = linkableAxes[j];\n                if(!thisGroup[idj]) linkableAxesNoLoops.push(idj);\n            }\n            return {linkableAxes: linkableAxesNoLoops, thisGroup: thisGroup};\n        }\n    }\n\n    return {linkableAxes: linkableAxes, thisGroup: null};\n}\n\n\n/*\n * Add this axis to the axis constraint groups, which is the collection\n * of axes that are all constrained together on scale.\n *\n * constraintGroups: a list of objects. each object is\n * {axis_id: scale_within_group}, where scale_within_group is\n * only important relative to the rest of the group, and defines\n * the relative scales between all axes in the group\n *\n * thisGroup: the group the current axis is already in\n * thisID: the id if the current axis\n * scaleanchor: the id of the axis to scale it with\n * scaleratio: the ratio of this axis to the scaleanchor axis\n */\nfunction updateConstraintGroups(constraintGroups, thisGroup, thisID, scaleanchor, scaleratio) {\n    var i, j, groupi, keyj, thisGroupIndex;\n\n    if(thisGroup === null) {\n        thisGroup = {};\n        thisGroup[thisID] = 1;\n        thisGroupIndex = constraintGroups.length;\n        constraintGroups.push(thisGroup);\n    }\n    else {\n        thisGroupIndex = constraintGroups.indexOf(thisGroup);\n    }\n\n    var thisGroupKeys = Object.keys(thisGroup);\n\n    // we know that this axis isn't in any other groups, but we don't know\n    // about the scaleanchor axis. If it is, we need to merge the groups.\n    for(i = 0; i < constraintGroups.length; i++) {\n        groupi = constraintGroups[i];\n        if(i !== thisGroupIndex && groupi[scaleanchor]) {\n            var baseScale = groupi[scaleanchor];\n            for(j = 0; j < thisGroupKeys.length; j++) {\n                keyj = thisGroupKeys[j];\n                groupi[keyj] = baseScale * scaleratio * thisGroup[keyj];\n            }\n            constraintGroups.splice(thisGroupIndex, 1);\n            return;\n        }\n    }\n\n    // otherwise, we insert the new scaleanchor axis as the base scale (1)\n    // in its group, and scale the rest of the group to it\n    if(scaleratio !== 1) {\n        for(j = 0; j < thisGroupKeys.length; j++) {\n            thisGroup[thisGroupKeys[j]] *= scaleratio;\n        }\n    }\n    thisGroup[scaleanchor] = 1;\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/cartesian/position_defaults.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\n\n\nmodule.exports = function handlePositionDefaults(containerIn, containerOut, coerce, options) {\n    var counterAxes = options.counterAxes || [],\n        overlayableAxes = options.overlayableAxes || [],\n        letter = options.letter;\n\n    var anchor = Lib.coerce(containerIn, containerOut, {\n        anchor: {\n            valType: 'enumerated',\n            values: ['free'].concat(counterAxes),\n            dflt: isNumeric(containerIn.position) ? 'free' :\n                (counterAxes[0] || 'free')\n        }\n    }, 'anchor');\n\n    if(anchor === 'free') coerce('position');\n\n    Lib.coerce(containerIn, containerOut, {\n        side: {\n            valType: 'enumerated',\n            values: letter === 'x' ? ['bottom', 'top'] : ['left', 'right'],\n            dflt: letter === 'x' ? 'bottom' : 'left'\n        }\n    }, 'side');\n\n    var overlaying = false;\n    if(overlayableAxes.length) {\n        overlaying = Lib.coerce(containerIn, containerOut, {\n            overlaying: {\n                valType: 'enumerated',\n                values: [false].concat(overlayableAxes),\n                dflt: false\n            }\n        }, 'overlaying');\n    }\n\n    if(!overlaying) {\n        // TODO: right now I'm copying this domain over to overlaying axes\n        // in ax.setscale()... but this means we still need (imperfect) logic\n        // in the axes popover to hide domain for the overlaying axis.\n        // perhaps I should make a private version _domain that all axes get???\n        var domain = coerce('domain');\n        if(domain[0] > domain[1] - 0.01) containerOut.domain = [0, 1];\n        Lib.noneOrAll(containerIn.domain, containerOut.domain, [0, 1]);\n    }\n\n    return containerOut;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/errorbars/compute_error.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\n\n/**\n * Error bar computing function generator\n *\n * N.B. The generated function does not clean the dataPt entries. Non-numeric\n * entries result in undefined error magnitudes.\n *\n * @param {object} opts error bar attributes\n *\n * @return {function} :\n *      @param {numeric} dataPt data point from where to compute the error magnitude\n *      @param {number} index index of dataPt in its corresponding data array\n *      @return {array}\n *        - error[0] : error magnitude in the negative direction\n *        - error[1] : \" \" \" \" positive \"\n */\nmodule.exports = function makeComputeError(opts) {\n    var type = opts.type,\n        symmetric = opts.symmetric;\n\n    if(type === 'data') {\n        var array = opts.array,\n            arrayminus = opts.arrayminus;\n\n        if(symmetric || arrayminus === undefined) {\n            return function computeError(dataPt, index) {\n                var val = +(array[index]);\n                return [val, val];\n            };\n        }\n        else {\n            return function computeError(dataPt, index) {\n                return [+arrayminus[index], +array[index]];\n            };\n        }\n    }\n    else {\n        var computeErrorValue = makeComputeErrorValue(type, opts.value),\n            computeErrorValueMinus = makeComputeErrorValue(type, opts.valueminus);\n\n        if(symmetric || opts.valueminus === undefined) {\n            return function computeError(dataPt) {\n                var val = computeErrorValue(dataPt);\n                return [val, val];\n            };\n        }\n        else {\n            return function computeError(dataPt) {\n                return [\n                    computeErrorValueMinus(dataPt),\n                    computeErrorValue(dataPt)\n                ];\n            };\n        }\n    }\n};\n\n/**\n * Compute error bar magnitude (for all types except data)\n *\n * @param {string} type error bar type\n * @param {numeric} value error bar value\n *\n * @return {function} :\n *      @param {numeric} dataPt\n */\nfunction makeComputeErrorValue(type, value) {\n    if(type === 'percent') {\n        return function(dataPt) {\n            return Math.abs(dataPt * value / 100);\n        };\n    }\n    if(type === 'constant') {\n        return function() {\n            return Math.abs(value);\n        };\n    }\n    if(type === 'sqrt') {\n        return function(dataPt) {\n            return Math.sqrt(Math.abs(dataPt));\n        };\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/errorbars/plot.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\nvar isNumeric = require('fast-isnumeric');\n\nvar subTypes = require('../../traces/scatter/subtypes');\n\nmodule.exports = function plot(traces, plotinfo, transitionOpts) {\n    var isNew;\n\n    var xa = plotinfo.xaxis,\n        ya = plotinfo.yaxis;\n\n    var hasAnimation = transitionOpts && transitionOpts.duration > 0;\n\n    traces.each(function(d) {\n        var trace = d[0].trace,\n            // || {} is in case the trace (specifically scatterternary)\n            // doesn't support error bars at all, but does go through\n            // the scatter.plot mechanics, which calls ErrorBars.plot\n            // internally\n            xObj = trace.error_x || {},\n            yObj = trace.error_y || {};\n\n        var keyFunc;\n\n        if(trace.ids) {\n            keyFunc = function(d) {return d.id;};\n        }\n\n        var sparse = (\n            subTypes.hasMarkers(trace) &&\n            trace.marker.maxdisplayed > 0\n        );\n\n        if(!yObj.visible && !xObj.visible) return;\n\n        var errorbars = d3.select(this).selectAll('g.errorbar')\n            .data(d, keyFunc);\n\n        errorbars.exit().remove();\n\n        errorbars.style('opacity', 1);\n\n        var enter = errorbars.enter().append('g')\n            .classed('errorbar', true);\n\n        if(hasAnimation) {\n            enter.style('opacity', 0).transition()\n                .duration(transitionOpts.duration)\n                .style('opacity', 1);\n        }\n\n        errorbars.each(function(d) {\n            var errorbar = d3.select(this);\n            var coords = errorCoords(d, xa, ya);\n\n            if(sparse && !d.vis) return;\n\n            var path;\n\n            if(yObj.visible && isNumeric(coords.x) &&\n                    isNumeric(coords.yh) &&\n                    isNumeric(coords.ys)) {\n                var yw = yObj.width;\n\n                path = 'M' + (coords.x - yw) + ',' +\n                    coords.yh + 'h' + (2 * yw) + // hat\n                    'm-' + yw + ',0V' + coords.ys; // bar\n\n\n                if(!coords.noYS) path += 'm-' + yw + ',0h' + (2 * yw); // shoe\n\n                var yerror = errorbar.select('path.yerror');\n\n                isNew = !yerror.size();\n\n                if(isNew) {\n                    yerror = errorbar.append('path')\n                        .classed('yerror', true);\n                } else if(hasAnimation) {\n                    yerror = yerror\n                        .transition()\n                            .duration(transitionOpts.duration)\n                            .ease(transitionOpts.easing);\n                }\n\n                yerror.attr('d', path);\n            }\n\n            if(xObj.visible && isNumeric(coords.y) &&\n                    isNumeric(coords.xh) &&\n                    isNumeric(coords.xs)) {\n                var xw = (xObj.copy_ystyle ? yObj : xObj).width;\n\n                path = 'M' + coords.xh + ',' +\n                    (coords.y - xw) + 'v' + (2 * xw) + // hat\n                    'm0,-' + xw + 'H' + coords.xs; // bar\n\n                if(!coords.noXS) path += 'm0,-' + xw + 'v' + (2 * xw); // shoe\n\n                var xerror = errorbar.select('path.xerror');\n\n                isNew = !xerror.size();\n\n                if(isNew) {\n                    xerror = errorbar.append('path')\n                        .classed('xerror', true);\n                } else if(hasAnimation) {\n                    xerror = xerror\n                        .transition()\n                            .duration(transitionOpts.duration)\n                            .ease(transitionOpts.easing);\n                }\n\n                xerror.attr('d', path);\n            }\n        });\n    });\n};\n\n// compute the coordinates of the error-bar objects\nfunction errorCoords(d, xa, ya) {\n    var out = {\n        x: xa.c2p(d.x),\n        y: ya.c2p(d.y)\n    };\n\n    // calculate the error bar size and hat and shoe locations\n    if(d.yh !== undefined) {\n        out.yh = ya.c2p(d.yh);\n        out.ys = ya.c2p(d.ys);\n\n        // if the shoes go off-scale (ie log scale, error bars past zero)\n        // clip the bar and hide the shoes\n        if(!isNumeric(out.ys)) {\n            out.noYS = true;\n            out.ys = ya.c2p(d.ys, true);\n        }\n    }\n\n    if(d.xh !== undefined) {\n        out.xh = xa.c2p(d.xh);\n        out.xs = xa.c2p(d.xs);\n\n        if(!isNumeric(out.xs)) {\n            out.noXS = true;\n            out.xs = xa.c2p(d.xs, true);\n        }\n    }\n\n    return out;\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/errorbars/style.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\n\nvar Color = require('../color');\n\n\nmodule.exports = function style(traces) {\n    traces.each(function(d) {\n        var trace = d[0].trace,\n            yObj = trace.error_y || {},\n            xObj = trace.error_x || {};\n\n        var s = d3.select(this);\n\n        s.selectAll('path.yerror')\n            .style('stroke-width', yObj.thickness + 'px')\n            .call(Color.stroke, yObj.color);\n\n        if(xObj.copy_ystyle) xObj = yObj;\n\n        s.selectAll('path.xerror')\n            .style('stroke-width', xObj.thickness + 'px')\n            .call(Color.stroke, xObj.color);\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/command.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Plotly = require('../plotly');\nvar Lib = require('../lib');\n\n/*\n * Create or update an observer. This function is designed to be\n * idempotent so that it can be called over and over as the component\n * updates, and will attach and detach listeners as needed.\n *\n * @param {optional object} container\n *      An object on which the observer is stored. This is the mechanism\n *      by which it is idempotent. If it already exists, another won't be\n *      added. Each time it's called, the value lookup table is updated.\n * @param {array} commandList\n *      An array of commands, following either `buttons` of `updatemenus`\n *      or `steps` of `sliders`.\n * @param {function} onchange\n *      A listener called when the value is changed. Receives data object\n *      with information about the new state.\n */\nexports.manageCommandObserver = function(gd, container, commandList, onchange) {\n    var ret = {};\n    var enabled = true;\n\n    if(container && container._commandObserver) {\n        ret = container._commandObserver;\n    }\n\n    if(!ret.cache) {\n        ret.cache = {};\n    }\n\n    // Either create or just recompute this:\n    ret.lookupTable = {};\n\n    var binding = exports.hasSimpleAPICommandBindings(gd, commandList, ret.lookupTable);\n\n    if(container && container._commandObserver) {\n        if(!binding) {\n            // If container exists and there are no longer any bindings,\n            // remove existing:\n            if(container._commandObserver.remove) {\n                container._commandObserver.remove();\n                container._commandObserver = null;\n                return ret;\n            }\n        } else {\n            // If container exists and there *are* bindings, then the lookup\n            // table should have been updated and check is already attached,\n            // so there's nothing to be done:\n            return ret;\n\n\n        }\n    }\n\n    // Determine whether there's anything to do for this binding:\n\n    if(binding) {\n        // Build the cache:\n        bindingValueHasChanged(gd, binding, ret.cache);\n\n        ret.check = function check() {\n            if(!enabled) return;\n\n            var update = bindingValueHasChanged(gd, binding, ret.cache);\n\n            if(update.changed && onchange) {\n                // Disable checks for the duration of this command in order to avoid\n                // infinite loops:\n                if(ret.lookupTable[update.value] !== undefined) {\n                    ret.disable();\n                    Promise.resolve(onchange({\n                        value: update.value,\n                        type: binding.type,\n                        prop: binding.prop,\n                        traces: binding.traces,\n                        index: ret.lookupTable[update.value]\n                    })).then(ret.enable, ret.enable);\n                }\n            }\n\n            return update.changed;\n        };\n\n        var checkEvents = [\n            'plotly_relayout',\n            'plotly_redraw',\n            'plotly_restyle',\n            'plotly_update',\n            'plotly_animatingframe',\n            'plotly_afterplot'\n        ];\n\n        for(var i = 0; i < checkEvents.length; i++) {\n            gd._internalOn(checkEvents[i], ret.check);\n        }\n\n        ret.remove = function() {\n            for(var i = 0; i < checkEvents.length; i++) {\n                gd._removeInternalListener(checkEvents[i], ret.check);\n            }\n        };\n    } else {\n        // TODO: It'd be really neat to actually give a *reason* for this, but at least a warning\n        // is a start\n        Lib.warn('Unable to automatically bind plot updates to API command');\n\n        ret.lookupTable = {};\n        ret.remove = function() {};\n    }\n\n    ret.disable = function disable() {\n        enabled = false;\n    };\n\n    ret.enable = function enable() {\n        enabled = true;\n    };\n\n    if(container) {\n        container._commandObserver = ret;\n    }\n\n    return ret;\n};\n\n/*\n * This function checks to see if an array of objects containing\n * method and args properties is compatible with automatic two-way\n * binding. The criteria right now are that\n *\n *   1. multiple traces may be affected\n *   2. only one property may be affected\n *   3. the same property must be affected by all commands\n */\nexports.hasSimpleAPICommandBindings = function(gd, commandList, bindingsByValue) {\n    var i;\n    var n = commandList.length;\n\n    var refBinding;\n\n    for(i = 0; i < n; i++) {\n        var binding;\n        var command = commandList[i];\n        var method = command.method;\n        var args = command.args;\n\n        if(!Array.isArray(args)) args = [];\n\n        // If any command has no method, refuse to bind:\n        if(!method) {\n            return false;\n        }\n        var bindings = exports.computeAPICommandBindings(gd, method, args);\n\n        // Right now, handle one and *only* one property being set:\n        if(bindings.length !== 1) {\n            return false;\n        }\n\n        if(!refBinding) {\n            refBinding = bindings[0];\n            if(Array.isArray(refBinding.traces)) {\n                refBinding.traces.sort();\n            }\n        } else {\n            binding = bindings[0];\n            if(binding.type !== refBinding.type) {\n                return false;\n            }\n            if(binding.prop !== refBinding.prop) {\n                return false;\n            }\n            if(Array.isArray(refBinding.traces)) {\n                if(Array.isArray(binding.traces)) {\n                    binding.traces.sort();\n                    for(var j = 0; j < refBinding.traces.length; j++) {\n                        if(refBinding.traces[j] !== binding.traces[j]) {\n                            return false;\n                        }\n                    }\n                } else {\n                    return false;\n                }\n            } else {\n                if(binding.prop !== refBinding.prop) {\n                    return false;\n                }\n            }\n        }\n\n        binding = bindings[0];\n        var value = binding.value;\n        if(Array.isArray(value)) {\n            if(value.length === 1) {\n                value = value[0];\n            } else {\n                return false;\n            }\n        }\n        if(bindingsByValue) {\n            bindingsByValue[value] = i;\n        }\n    }\n\n    return refBinding;\n};\n\nfunction bindingValueHasChanged(gd, binding, cache) {\n    var container, value, obj;\n    var changed = false;\n\n    if(binding.type === 'data') {\n        // If it's data, we need to get a trace. Based on the limited scope\n        // of what we cover, we can just take the first trace from the list,\n        // or otherwise just the first trace:\n        container = gd._fullData[binding.traces !== null ? binding.traces[0] : 0];\n    } else if(binding.type === 'layout') {\n        container = gd._fullLayout;\n    } else {\n        return false;\n    }\n\n    value = Lib.nestedProperty(container, binding.prop).get();\n\n    obj = cache[binding.type] = cache[binding.type] || {};\n\n    if(obj.hasOwnProperty(binding.prop)) {\n        if(obj[binding.prop] !== value) {\n            changed = true;\n        }\n    }\n\n    obj[binding.prop] = value;\n\n    return {\n        changed: changed,\n        value: value\n    };\n}\n\n/*\n * Execute an API command. There's really not much to this; it just provides\n * a common hook so that implementations don't need to be synchronized across\n * multiple components with the ability to invoke API commands.\n *\n * @param {string} method\n *      The name of the plotly command to execute. Must be one of 'animate',\n *      'restyle', 'relayout', 'update'.\n * @param {array} args\n *      A list of arguments passed to the API command\n */\nexports.executeAPICommand = function(gd, method, args) {\n    var apiMethod = Plotly[method];\n\n    var allArgs = [gd];\n\n    if(!Array.isArray(args)) args = [];\n\n    for(var i = 0; i < args.length; i++) {\n        allArgs.push(args[i]);\n    }\n\n    return apiMethod.apply(null, allArgs).catch(function(err) {\n        Lib.warn('API call to Plotly.' + method + ' rejected.', err);\n        return Promise.reject(err);\n    });\n};\n\nexports.computeAPICommandBindings = function(gd, method, args) {\n    var bindings;\n\n    if(!Array.isArray(args)) args = [];\n\n    switch(method) {\n        case 'restyle':\n            bindings = computeDataBindings(gd, args);\n            break;\n        case 'relayout':\n            bindings = computeLayoutBindings(gd, args);\n            break;\n        case 'update':\n            bindings = computeDataBindings(gd, [args[0], args[2]])\n                .concat(computeLayoutBindings(gd, [args[1]]));\n            break;\n        case 'animate':\n            bindings = computeAnimateBindings(gd, args);\n            break;\n        default:\n            // This is the case where intelligent logic about what affects\n            // this command is not implemented. It causes no ill effects.\n            // For example, addFrames simply won't bind to a control component.\n            bindings = [];\n    }\n    return bindings;\n};\n\nfunction computeAnimateBindings(gd, args) {\n    // We'll assume that the only relevant modification an animation\n    // makes that's meaningfully tracked is the frame:\n    if(Array.isArray(args[0]) && args[0].length === 1 && ['string', 'number'].indexOf(typeof args[0][0]) !== -1) {\n        return [{type: 'layout', prop: '_currentFrame', value: args[0][0].toString()}];\n    } else {\n        return [];\n    }\n}\n\nfunction computeLayoutBindings(gd, args) {\n    var bindings = [];\n\n    var astr = args[0];\n    var aobj = {};\n    if(typeof astr === 'string') {\n        aobj[astr] = args[1];\n    } else if(Lib.isPlainObject(astr)) {\n        aobj = astr;\n    } else {\n        return bindings;\n    }\n\n    crawl(aobj, function(path, attrName, attr) {\n        bindings.push({type: 'layout', prop: path, value: attr});\n    }, '', 0);\n\n    return bindings;\n}\n\nfunction computeDataBindings(gd, args) {\n    var traces, astr, val, aobj;\n    var bindings = [];\n\n    // Logic copied from Plotly.restyle:\n    astr = args[0];\n    val = args[1];\n    traces = args[2];\n    aobj = {};\n    if(typeof astr === 'string') {\n        aobj[astr] = val;\n    } else if(Lib.isPlainObject(astr)) {\n        // the 3-arg form\n        aobj = astr;\n\n        if(traces === undefined) {\n            traces = val;\n        }\n    } else {\n        return bindings;\n    }\n\n    if(traces === undefined) {\n        // Explicitly assign this to null instead of undefined:\n        traces = null;\n    }\n\n    crawl(aobj, function(path, attrName, attr) {\n        var thisTraces;\n        if(Array.isArray(attr)) {\n            var nAttr = Math.min(attr.length, gd.data.length);\n            if(traces) {\n                nAttr = Math.min(nAttr, traces.length);\n            }\n            thisTraces = [];\n            for(var j = 0; j < nAttr; j++) {\n                thisTraces[j] = traces ? traces[j] : j;\n            }\n        } else {\n            thisTraces = traces ? traces.slice(0) : null;\n        }\n\n        // Convert [7] to just 7 when traces is null:\n        if(thisTraces === null) {\n            if(Array.isArray(attr)) {\n                attr = attr[0];\n            }\n        } else if(Array.isArray(thisTraces)) {\n            if(!Array.isArray(attr)) {\n                var tmp = attr;\n                attr = [];\n                for(var i = 0; i < thisTraces.length; i++) {\n                    attr[i] = tmp;\n                }\n            }\n            attr.length = Math.min(thisTraces.length, attr.length);\n        }\n\n        bindings.push({\n            type: 'data',\n            prop: path,\n            traces: thisTraces,\n            value: attr\n        });\n    }, '', 0);\n\n    return bindings;\n}\n\nfunction crawl(attrs, callback, path, depth) {\n    Object.keys(attrs).forEach(function(attrName) {\n        var attr = attrs[attrName];\n\n        if(attrName[0] === '_') return;\n\n        var thisPath = path + (depth > 0 ? '.' : '') + attrName;\n\n        if(Lib.isPlainObject(attr)) {\n            crawl(attr, callback, thisPath, depth + 1);\n        } else {\n            // Only execute the callback on leaf nodes:\n            callback(thisPath, attrName, attr);\n        }\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/cartesian/graph_interact.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\nvar isNumeric = require('fast-isnumeric');\nvar tinycolor = require('tinycolor2');\n\nvar Lib = require('../../lib');\nvar Events = require('../../lib/events');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar Color = require('../../components/color');\nvar Drawing = require('../../components/drawing');\nvar dragElement = require('../../components/dragelement');\nvar overrideCursor = require('../../lib/override_cursor');\nvar Registry = require('../../registry');\n\nvar Axes = require('./axes');\nvar constants = require('./constants');\nvar dragBox = require('./dragbox');\nvar layoutAttributes = require('../layout_attributes');\n\n\nvar fx = module.exports = {};\n\n// TODO remove this in version 2.0\n// copy on Fx for backward compatible\nfx.unhover = dragElement.unhover;\n\nfx.supplyLayoutDefaults = function(layoutIn, layoutOut, fullData) {\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(layoutIn, layoutOut, layoutAttributes, attr, dflt);\n    }\n\n    coerce('dragmode');\n\n    var hovermodeDflt;\n    if(layoutOut._has('cartesian')) {\n        // flag for 'horizontal' plots:\n        // determines the state of the mode bar 'compare' hovermode button\n        var isHoriz = layoutOut._isHoriz = fx.isHoriz(fullData);\n        hovermodeDflt = isHoriz ? 'y' : 'x';\n    }\n    else hovermodeDflt = 'closest';\n\n    coerce('hovermode', hovermodeDflt);\n};\n\nfx.isHoriz = function(fullData) {\n    var isHoriz = true;\n\n    for(var i = 0; i < fullData.length; i++) {\n        var trace = fullData[i];\n\n        if(trace.orientation !== 'h') {\n            isHoriz = false;\n            break;\n        }\n    }\n\n    return isHoriz;\n};\n\nfx.init = function(gd) {\n    var fullLayout = gd._fullLayout;\n\n    if(!fullLayout._has('cartesian') || gd._context.staticPlot) return;\n\n    var subplots = Object.keys(fullLayout._plots || {}).sort(function(a, b) {\n        // sort overlays last, then by x axis number, then y axis number\n        if((fullLayout._plots[a].mainplot && true) ===\n            (fullLayout._plots[b].mainplot && true)) {\n            var aParts = a.split('y'),\n                bParts = b.split('y');\n            return (aParts[0] === bParts[0]) ?\n                (Number(aParts[1] || 1) - Number(bParts[1] || 1)) :\n                (Number(aParts[0] || 1) - Number(bParts[0] || 1));\n        }\n        return fullLayout._plots[a].mainplot ? 1 : -1;\n    });\n\n    subplots.forEach(function(subplot) {\n        var plotinfo = fullLayout._plots[subplot];\n\n        if(!fullLayout._has('cartesian')) return;\n\n        var xa = plotinfo.xaxis,\n            ya = plotinfo.yaxis,\n\n            // the y position of the main x axis line\n            y0 = (xa._linepositions[subplot] || [])[3],\n\n            // the x position of the main y axis line\n            x0 = (ya._linepositions[subplot] || [])[3];\n\n        var DRAGGERSIZE = constants.DRAGGERSIZE;\n        if(isNumeric(y0) && xa.side === 'top') y0 -= DRAGGERSIZE;\n        if(isNumeric(x0) && ya.side !== 'right') x0 -= DRAGGERSIZE;\n\n        // main and corner draggers need not be repeated for\n        // overlaid subplots - these draggers drag them all\n        if(!plotinfo.mainplot) {\n            // main dragger goes over the grids and data, so we use its\n            // mousemove events for all data hover effects\n            var maindrag = dragBox(gd, plotinfo, 0, 0,\n                xa._length, ya._length, 'ns', 'ew');\n\n            maindrag.onmousemove = function(evt) {\n                // This is on `gd._fullLayout`, *not* fullLayout because the reference\n                // changes by the time this is called again.\n                gd._fullLayout._rehover = function() {\n                    if(gd._fullLayout._hoversubplot === subplot) {\n                        fx.hover(gd, evt, subplot);\n                    }\n                };\n\n                fx.hover(gd, evt, subplot);\n\n                // Note that we have *not* used the cached fullLayout variable here\n                // since that may be outdated when this is called as a callback later on\n                gd._fullLayout._lasthover = maindrag;\n                gd._fullLayout._hoversubplot = subplot;\n            };\n\n            /*\n             * IMPORTANT:\n             * We must check for the presence of the drag cover here.\n             * If we don't, a 'mouseout' event is triggered on the\n             * maindrag before each 'click' event, which has the effect\n             * of clearing the hoverdata; thus, cancelling the click event.\n             */\n            maindrag.onmouseout = function(evt) {\n                if(gd._dragging) return;\n\n                // When the mouse leaves this maindrag, unset the hovered subplot.\n                // This may cause problems if it leaves the subplot directly *onto*\n                // another subplot, but that's a tiny corner case at the moment.\n                gd._fullLayout._hoversubplot = null;\n\n                dragElement.unhover(gd, evt);\n            };\n\n            maindrag.onclick = function(evt) {\n                fx.click(gd, evt);\n            };\n\n            // corner draggers\n            if(gd._context.showAxisDragHandles) {\n                dragBox(gd, plotinfo, -DRAGGERSIZE, -DRAGGERSIZE,\n                    DRAGGERSIZE, DRAGGERSIZE, 'n', 'w');\n                dragBox(gd, plotinfo, xa._length, -DRAGGERSIZE,\n                    DRAGGERSIZE, DRAGGERSIZE, 'n', 'e');\n                dragBox(gd, plotinfo, -DRAGGERSIZE, ya._length,\n                    DRAGGERSIZE, DRAGGERSIZE, 's', 'w');\n                dragBox(gd, plotinfo, xa._length, ya._length,\n                    DRAGGERSIZE, DRAGGERSIZE, 's', 'e');\n            }\n        }\n        if(gd._context.showAxisDragHandles) {\n            // x axis draggers - if you have overlaid plots,\n            // these drag each axis separately\n            if(isNumeric(y0)) {\n                if(xa.anchor === 'free') y0 -= fullLayout._size.h * (1 - ya.domain[1]);\n                dragBox(gd, plotinfo, xa._length * 0.1, y0,\n                    xa._length * 0.8, DRAGGERSIZE, '', 'ew');\n                dragBox(gd, plotinfo, 0, y0,\n                    xa._length * 0.1, DRAGGERSIZE, '', 'w');\n                dragBox(gd, plotinfo, xa._length * 0.9, y0,\n                    xa._length * 0.1, DRAGGERSIZE, '', 'e');\n            }\n            // y axis draggers\n            if(isNumeric(x0)) {\n                if(ya.anchor === 'free') x0 -= fullLayout._size.w * xa.domain[0];\n                dragBox(gd, plotinfo, x0, ya._length * 0.1,\n                    DRAGGERSIZE, ya._length * 0.8, 'ns', '');\n                dragBox(gd, plotinfo, x0, ya._length * 0.9,\n                    DRAGGERSIZE, ya._length * 0.1, 's', '');\n                dragBox(gd, plotinfo, x0, 0,\n                    DRAGGERSIZE, ya._length * 0.1, 'n', '');\n            }\n        }\n    });\n\n    // In case you mousemove over some hovertext, send it to fx.hover too\n    // we do this so that we can put the hover text in front of everything,\n    // but still be able to interact with everything as if it isn't there\n    var hoverLayer = fullLayout._hoverlayer.node();\n\n    hoverLayer.onmousemove = function(evt) {\n        evt.target = fullLayout._lasthover;\n        fx.hover(gd, evt, fullLayout._hoversubplot);\n    };\n\n    hoverLayer.onclick = function(evt) {\n        evt.target = fullLayout._lasthover;\n        fx.click(gd, evt);\n    };\n\n    // also delegate mousedowns... TODO: does this actually work?\n    hoverLayer.onmousedown = function(evt) {\n        fullLayout._lasthover.onmousedown(evt);\n    };\n};\n\n// hover labels for multiple horizontal bars get tilted by some angle,\n// then need to be offset differently if they overlap\nvar YANGLE = constants.YANGLE,\n    YA_RADIANS = Math.PI * YANGLE / 180,\n\n    // expansion of projected height\n    YFACTOR = 1 / Math.sin(YA_RADIANS),\n\n    // to make the appropriate post-rotation x offset,\n    // you need both x and y offsets\n    YSHIFTX = Math.cos(YA_RADIANS),\n    YSHIFTY = Math.sin(YA_RADIANS);\n\n// convenience functions for mapping all relevant axes\nfunction flat(subplots, v) {\n    var out = [];\n    for(var i = subplots.length; i > 0; i--) out.push(v);\n    return out;\n}\n\nfunction p2c(axArray, v) {\n    var out = [];\n    for(var i = 0; i < axArray.length; i++) out.push(axArray[i].p2c(v));\n    return out;\n}\n\nfunction quadrature(dx, dy) {\n    return function(di) {\n        var x = dx(di),\n            y = dy(di);\n        return Math.sqrt(x * x + y * y);\n    };\n}\n\n// size and display constants for hover text\nvar HOVERARROWSIZE = constants.HOVERARROWSIZE,\n    HOVERTEXTPAD = constants.HOVERTEXTPAD;\n\n// fx.hover: highlight data on hover\n// evt can be a mousemove event, or an object with data about what points\n//   to hover on\n//      {xpx,ypx[,hovermode]} - pixel locations from top left\n//          (with optional overriding hovermode)\n//      {xval,yval[,hovermode]} - data values\n//      [{curveNumber,(pointNumber|xval and/or yval)}] -\n//              array of specific points to highlight\n//          pointNumber is a single integer if gd.data[curveNumber] is 1D,\n//              or a two-element array if it's 2D\n//          xval and yval are data values,\n//              1D data may specify either or both,\n//              2D data must specify both\n// subplot is an id string (default \"xy\")\n// makes use of gl.hovermode, which can be:\n//      x (find the points with the closest x values, ie a column),\n//      closest (find the single closest point)\n//    internally there are two more that occasionally get used:\n//      y (pick out a row - only used for multiple horizontal bar charts)\n//      array (used when the user specifies an explicit\n//          array of points to hover on)\n//\n// We wrap the hovers in a timer, to limit their frequency.\n// The actual rendering is done by private functions\n// hover() and unhover().\n\nfx.hover = function(gd, evt, subplot) {\n    if(typeof gd === 'string') gd = document.getElementById(gd);\n    if(gd._lastHoverTime === undefined) gd._lastHoverTime = 0;\n\n    // If we have an update queued, discard it now\n    if(gd._hoverTimer !== undefined) {\n        clearTimeout(gd._hoverTimer);\n        gd._hoverTimer = undefined;\n    }\n    // Is it more than 100ms since the last update?  If so, force\n    // an update now (synchronously) and exit\n    if(Date.now() > gd._lastHoverTime + constants.HOVERMINTIME) {\n        hover(gd, evt, subplot);\n        gd._lastHoverTime = Date.now();\n        return;\n    }\n    // Queue up the next hover for 100ms from now (if no further events)\n    gd._hoverTimer = setTimeout(function() {\n        hover(gd, evt, subplot);\n        gd._lastHoverTime = Date.now();\n        gd._hoverTimer = undefined;\n    }, constants.HOVERMINTIME);\n};\n\n// The actual implementation is here:\n\nfunction hover(gd, evt, subplot) {\n    if(subplot === 'pie') {\n        gd.emit('plotly_hover', {\n            event: evt.originalEvent,\n            points: [evt]\n        });\n        return;\n    }\n\n    if(!subplot) subplot = 'xy';\n\n    // if the user passed in an array of subplots,\n    // use those instead of finding overlayed plots\n    var subplots = Array.isArray(subplot) ? subplot : [subplot];\n\n    var fullLayout = gd._fullLayout,\n        plots = fullLayout._plots || [],\n        plotinfo = plots[subplot];\n\n    // list of all overlaid subplots to look at\n    if(plotinfo) {\n        var overlayedSubplots = plotinfo.overlays.map(function(pi) {\n            return pi.id;\n        });\n\n        subplots = subplots.concat(overlayedSubplots);\n    }\n\n    var len = subplots.length,\n        xaArray = new Array(len),\n        yaArray = new Array(len);\n\n    for(var i = 0; i < len; i++) {\n        var spId = subplots[i];\n\n        // 'cartesian' case\n        var plotObj = plots[spId];\n        if(plotObj) {\n\n            // TODO make sure that fullLayout_plots axis refs\n            // get updated properly so that we don't have\n            // to use Axes.getFromId in general.\n\n            xaArray[i] = Axes.getFromId(gd, plotObj.xaxis._id);\n            yaArray[i] = Axes.getFromId(gd, plotObj.yaxis._id);\n            continue;\n        }\n\n        // other subplot types\n        var _subplot = fullLayout[spId]._subplot;\n        xaArray[i] = _subplot.xaxis;\n        yaArray[i] = _subplot.yaxis;\n    }\n\n    var hovermode = evt.hovermode || fullLayout.hovermode;\n\n    if(['x', 'y', 'closest'].indexOf(hovermode) === -1 || !gd.calcdata ||\n            gd.querySelector('.zoombox') || gd._dragging) {\n        return dragElement.unhoverRaw(gd, evt);\n    }\n\n        // hoverData: the set of candidate points we've found to highlight\n    var hoverData = [],\n\n        // searchData: the data to search in. Mostly this is just a copy of\n        // gd.calcdata, filtered to the subplot and overlays we're on\n        // but if a point array is supplied it will be a mapping\n        // of indicated curves\n        searchData = [],\n\n        // [x|y]valArray: the axis values of the hover event\n        // mapped onto each of the currently selected overlaid subplots\n        xvalArray,\n        yvalArray,\n\n        // used in loops\n        itemnum,\n        curvenum,\n        cd,\n        trace,\n        subplotId,\n        subploti,\n        mode,\n        xval,\n        yval,\n        pointData,\n        closedataPreviousLength;\n\n    // Figure out what we're hovering on:\n    // mouse location or user-supplied data\n\n    if(Array.isArray(evt)) {\n        // user specified an array of points to highlight\n        hovermode = 'array';\n        for(itemnum = 0; itemnum < evt.length; itemnum++) {\n            cd = gd.calcdata[evt[itemnum].curveNumber||0];\n            if(cd[0].trace.hoverinfo !== 'skip') {\n                searchData.push(cd);\n            }\n        }\n    }\n    else {\n        for(curvenum = 0; curvenum < gd.calcdata.length; curvenum++) {\n            cd = gd.calcdata[curvenum];\n            trace = cd[0].trace;\n            if(trace.hoverinfo !== 'skip' && subplots.indexOf(getSubplot(trace)) !== -1) {\n                searchData.push(cd);\n            }\n        }\n\n        // [x|y]px: the pixels (from top left) of the mouse location\n        // on the currently selected plot area\n        var hasUserCalledHover = !evt.target,\n            xpx, ypx;\n\n        if(hasUserCalledHover) {\n            if('xpx' in evt) xpx = evt.xpx;\n            else xpx = xaArray[0]._length / 2;\n\n            if('ypx' in evt) ypx = evt.ypx;\n            else ypx = yaArray[0]._length / 2;\n        }\n        else {\n            // fire the beforehover event and quit if it returns false\n            // note that we're only calling this on real mouse events, so\n            // manual calls to fx.hover will always run.\n            if(Events.triggerHandler(gd, 'plotly_beforehover', evt) === false) {\n                return;\n            }\n\n            var dbb = evt.target.getBoundingClientRect();\n\n            xpx = evt.clientX - dbb.left;\n            ypx = evt.clientY - dbb.top;\n\n            // in case hover was called from mouseout into hovertext,\n            // it's possible you're not actually over the plot anymore\n            if(xpx < 0 || xpx > dbb.width || ypx < 0 || ypx > dbb.height) {\n                return dragElement.unhoverRaw(gd, evt);\n            }\n        }\n\n        if('xval' in evt) xvalArray = flat(subplots, evt.xval);\n        else xvalArray = p2c(xaArray, xpx);\n\n        if('yval' in evt) yvalArray = flat(subplots, evt.yval);\n        else yvalArray = p2c(yaArray, ypx);\n\n        if(!isNumeric(xvalArray[0]) || !isNumeric(yvalArray[0])) {\n            Lib.warn('Fx.hover failed', evt, gd);\n            return dragElement.unhoverRaw(gd, evt);\n        }\n    }\n\n    // the pixel distance to beat as a matching point\n    // in 'x' or 'y' mode this resets for each trace\n    var distance = Infinity;\n\n    // find the closest point in each trace\n    // this is minimum dx and/or dy, depending on mode\n    // and the pixel position for the label (labelXpx, labelYpx)\n    for(curvenum = 0; curvenum < searchData.length; curvenum++) {\n        cd = searchData[curvenum];\n\n        // filter out invisible or broken data\n        if(!cd || !cd[0] || !cd[0].trace || cd[0].trace.visible !== true) continue;\n\n        trace = cd[0].trace;\n\n        // Explicitly bail out for these two. I don't know how to otherwise prevent\n        // the rest of this function from running and failing\n        if(['carpet', 'contourcarpet'].indexOf(trace._module.name) !== -1) continue;\n\n        subplotId = getSubplot(trace);\n        subploti = subplots.indexOf(subplotId);\n\n        // within one trace mode can sometimes be overridden\n        mode = hovermode;\n\n        // container for new point, also used to pass info into module.hoverPoints\n        pointData = {\n            // trace properties\n            cd: cd,\n            trace: trace,\n            xa: xaArray[subploti],\n            ya: yaArray[subploti],\n            name: (gd.data.length > 1 || trace.hoverinfo.indexOf('name') !== -1) ? trace.name : undefined,\n            // point properties - override all of these\n            index: false, // point index in trace - only used by plotly.js hoverdata consumers\n            distance: Math.min(distance, constants.MAXDIST), // pixel distance or pseudo-distance\n            color: Color.defaultLine, // trace color\n            x0: undefined,\n            x1: undefined,\n            y0: undefined,\n            y1: undefined,\n            xLabelVal: undefined,\n            yLabelVal: undefined,\n            zLabelVal: undefined,\n            text: undefined\n        };\n\n        // add ref to subplot object (non-cartesian case)\n        if(fullLayout[subplotId]) {\n            pointData.subplot = fullLayout[subplotId]._subplot;\n        }\n\n        closedataPreviousLength = hoverData.length;\n\n        // for a highlighting array, figure out what\n        // we're searching for with this element\n        if(mode === 'array') {\n            var selection = evt[curvenum];\n            if('pointNumber' in selection) {\n                pointData.index = selection.pointNumber;\n                mode = 'closest';\n            }\n            else {\n                mode = '';\n                if('xval' in selection) {\n                    xval = selection.xval;\n                    mode = 'x';\n                }\n                if('yval' in selection) {\n                    yval = selection.yval;\n                    mode = mode ? 'closest' : 'y';\n                }\n            }\n        }\n        else {\n            xval = xvalArray[subploti];\n            yval = yvalArray[subploti];\n        }\n\n        // Now find the points.\n        if(trace._module && trace._module.hoverPoints) {\n            var newPoints = trace._module.hoverPoints(pointData, xval, yval, mode);\n            if(newPoints) {\n                var newPoint;\n                for(var newPointNum = 0; newPointNum < newPoints.length; newPointNum++) {\n                    newPoint = newPoints[newPointNum];\n                    if(isNumeric(newPoint.x0) && isNumeric(newPoint.y0)) {\n                        hoverData.push(cleanPoint(newPoint, hovermode));\n                    }\n                }\n            }\n        }\n        else {\n            Lib.log('Unrecognized trace type in hover:', trace);\n        }\n\n        // in closest mode, remove any existing (farther) points\n        // and don't look any farther than this latest point (or points, if boxes)\n        if(hovermode === 'closest' && hoverData.length > closedataPreviousLength) {\n            hoverData.splice(0, closedataPreviousLength);\n            distance = hoverData[0].distance;\n        }\n    }\n\n    // nothing left: remove all labels and quit\n    if(hoverData.length === 0) return dragElement.unhoverRaw(gd, evt);\n\n    hoverData.sort(function(d1, d2) { return d1.distance - d2.distance; });\n\n    // lastly, emit custom hover/unhover events\n    var oldhoverdata = gd._hoverdata,\n        newhoverdata = [];\n\n    // pull out just the data that's useful to\n    // other people and send it to the event\n    for(itemnum = 0; itemnum < hoverData.length; itemnum++) {\n        var pt = hoverData[itemnum];\n\n        var out = {\n            data: pt.trace._input,\n            fullData: pt.trace,\n            curveNumber: pt.trace.index,\n            pointNumber: pt.index\n        };\n\n        if(pt.trace._module.eventData) out = pt.trace._module.eventData(out, pt);\n        else {\n            out.x = pt.xVal;\n            out.y = pt.yVal;\n            out.xaxis = pt.xa;\n            out.yaxis = pt.ya;\n\n            if(pt.zLabelVal !== undefined) out.z = pt.zLabelVal;\n        }\n\n        newhoverdata.push(out);\n    }\n\n    gd._hoverdata = newhoverdata;\n\n    if(hoverChanged(gd, evt, oldhoverdata) && fullLayout._hasCartesian) {\n        var spikelineOpts = {\n            hovermode: hovermode,\n            fullLayout: fullLayout,\n            container: fullLayout._hoverlayer,\n            outerContainer: fullLayout._paperdiv\n        };\n        createSpikelines(hoverData, spikelineOpts);\n    }\n\n    // if there's more than one horz bar trace,\n    // rotate the labels so they don't overlap\n    var rotateLabels = hovermode === 'y' && searchData.length > 1;\n\n    var bgColor = Color.combine(\n        fullLayout.plot_bgcolor || Color.background,\n        fullLayout.paper_bgcolor\n    );\n\n    var labelOpts = {\n        hovermode: hovermode,\n        rotateLabels: rotateLabels,\n        bgColor: bgColor,\n        container: fullLayout._hoverlayer,\n        outerContainer: fullLayout._paperdiv\n    };\n\n    var hoverLabels = createHoverText(hoverData, labelOpts);\n\n    hoverAvoidOverlaps(hoverData, rotateLabels ? 'xa' : 'ya');\n\n    alignHoverText(hoverLabels, rotateLabels);\n\n    // TODO: tagName hack is needed to appease geo.js's hack of using evt.target=true\n    // we should improve the \"fx\" API so other plots can use it without these hack.\n    if(evt.target && evt.target.tagName) {\n        var hasClickToShow = Registry.getComponentMethod('annotations', 'hasClickToShow')(gd, newhoverdata);\n        overrideCursor(d3.select(evt.target), hasClickToShow ? 'pointer' : '');\n    }\n\n    // don't emit events if called manually\n    if(!evt.target || !hoverChanged(gd, evt, oldhoverdata)) return;\n\n    if(oldhoverdata) {\n        gd.emit('plotly_unhover', {\n            event: evt,\n            points: oldhoverdata\n        });\n    }\n\n    gd.emit('plotly_hover', {\n        event: evt,\n        points: gd._hoverdata,\n        xaxes: xaArray,\n        yaxes: yaArray,\n        xvals: xvalArray,\n        yvals: yvalArray\n    });\n}\n\n// look for either .subplot (currently just ternary)\n// or xaxis and yaxis attributes\nfunction getSubplot(trace) {\n    return trace.subplot || (trace.xaxis + trace.yaxis) || trace.geo;\n}\n\nfx.getDistanceFunction = function(mode, dx, dy, dxy) {\n    if(mode === 'closest') return dxy || quadrature(dx, dy);\n    return mode === 'x' ? dx : dy;\n};\n\nfx.getClosest = function(cd, distfn, pointData) {\n    // do we already have a point number? (array mode only)\n    if(pointData.index !== false) {\n        if(pointData.index >= 0 && pointData.index < cd.length) {\n            pointData.distance = 0;\n        }\n        else pointData.index = false;\n    }\n    else {\n        // apply the distance function to each data point\n        // this is the longest loop... if this bogs down, we may need\n        // to create pre-sorted data (by x or y), not sure how to\n        // do this for 'closest'\n        for(var i = 0; i < cd.length; i++) {\n            var newDistance = distfn(cd[i]);\n            if(newDistance <= pointData.distance) {\n                pointData.index = i;\n                pointData.distance = newDistance;\n            }\n        }\n    }\n    return pointData;\n};\n\nfunction cleanPoint(d, hovermode) {\n    d.posref = hovermode === 'y' ? (d.x0 + d.x1) / 2 : (d.y0 + d.y1) / 2;\n\n    // then constrain all the positions to be on the plot\n    d.x0 = Lib.constrain(d.x0, 0, d.xa._length);\n    d.x1 = Lib.constrain(d.x1, 0, d.xa._length);\n    d.y0 = Lib.constrain(d.y0, 0, d.ya._length);\n    d.y1 = Lib.constrain(d.y1, 0, d.ya._length);\n\n    // and convert the x and y label values into objects\n    // formatted as text, with font info\n    var logOffScale;\n    if(d.xLabelVal !== undefined) {\n        logOffScale = (d.xa.type === 'log' && d.xLabelVal <= 0);\n        var xLabelObj = Axes.tickText(d.xa,\n                d.xa.c2l(logOffScale ? -d.xLabelVal : d.xLabelVal), 'hover');\n        if(logOffScale) {\n            if(d.xLabelVal === 0) d.xLabel = '0';\n            else d.xLabel = '-' + xLabelObj.text;\n        }\n        // TODO: should we do something special if the axis calendar and\n        // the data calendar are different? Somehow display both dates with\n        // their system names? Right now it will just display in the axis calendar\n        // but users could add the other one as text.\n        else d.xLabel = xLabelObj.text;\n        d.xVal = d.xa.c2d(d.xLabelVal);\n    }\n\n    if(d.yLabelVal !== undefined) {\n        logOffScale = (d.ya.type === 'log' && d.yLabelVal <= 0);\n        var yLabelObj = Axes.tickText(d.ya,\n                d.ya.c2l(logOffScale ? -d.yLabelVal : d.yLabelVal), 'hover');\n        if(logOffScale) {\n            if(d.yLabelVal === 0) d.yLabel = '0';\n            else d.yLabel = '-' + yLabelObj.text;\n        }\n        // TODO: see above TODO\n        else d.yLabel = yLabelObj.text;\n        d.yVal = d.ya.c2d(d.yLabelVal);\n    }\n\n    if(d.zLabelVal !== undefined) d.zLabel = String(d.zLabelVal);\n\n    // for box means and error bars, add the range to the label\n    if(!isNaN(d.xerr) && !(d.xa.type === 'log' && d.xerr <= 0)) {\n        var xeText = Axes.tickText(d.xa, d.xa.c2l(d.xerr), 'hover').text;\n        if(d.xerrneg !== undefined) {\n            d.xLabel += ' +' + xeText + ' / -' +\n                Axes.tickText(d.xa, d.xa.c2l(d.xerrneg), 'hover').text;\n        }\n        else d.xLabel += '  ' + xeText;\n\n        // small distance penalty for error bars, so that if there are\n        // traces with errors and some without, the error bar label will\n        // hoist up to the point\n        if(hovermode === 'x') d.distance += 1;\n    }\n    if(!isNaN(d.yerr) && !(d.ya.type === 'log' && d.yerr <= 0)) {\n        var yeText = Axes.tickText(d.ya, d.ya.c2l(d.yerr), 'hover').text;\n        if(d.yerrneg !== undefined) {\n            d.yLabel += ' +' + yeText + ' / -' +\n                Axes.tickText(d.ya, d.ya.c2l(d.yerrneg), 'hover').text;\n        }\n        else d.yLabel += '  ' + yeText;\n\n        if(hovermode === 'y') d.distance += 1;\n    }\n\n    var infomode = d.trace.hoverinfo;\n    if(infomode !== 'all') {\n        infomode = infomode.split('+');\n        if(infomode.indexOf('x') === -1) d.xLabel = undefined;\n        if(infomode.indexOf('y') === -1) d.yLabel = undefined;\n        if(infomode.indexOf('z') === -1) d.zLabel = undefined;\n        if(infomode.indexOf('text') === -1) d.text = undefined;\n        if(infomode.indexOf('name') === -1) d.name = undefined;\n    }\n\n    return d;\n}\n\n/*\n * Draw a single hover item in a pre-existing svg container somewhere\n * hoverItem should have keys:\n *    - x and y (or x0, x1, y0, and y1):\n *      the pixel position to mark, relative to opts.container\n *    - xLabel, yLabel, zLabel, text, and name:\n *      info to go in the label\n *    - color:\n *      the background color for the label.\n *    - idealAlign (optional):\n *      'left' or 'right' for which side of the x/y box to try to put this on first\n *    - borderColor (optional):\n *      color for the border, defaults to strongest contrast with color\n *    - fontFamily (optional):\n *      string, the font for this label, defaults to constants.HOVERFONT\n *    - fontSize (optional):\n *      the label font size, defaults to constants.HOVERFONTSIZE\n *    - fontColor (optional):\n *      defaults to borderColor\n * opts should have keys:\n *    - bgColor:\n *      the background color this is against, used if the trace is\n *      non-opaque, and for the name, which goes outside the box\n *    - container:\n *      a <svg> or <g> element to add the hover label to\n *    - outerContainer:\n *      normally a parent of `container`, sets the bounding box to use to\n *      constrain the hover label and determine whether to show it on the left or right\n */\nfx.loneHover = function(hoverItem, opts) {\n    var pointData = {\n        color: hoverItem.color || Color.defaultLine,\n        x0: hoverItem.x0 || hoverItem.x || 0,\n        x1: hoverItem.x1 || hoverItem.x || 0,\n        y0: hoverItem.y0 || hoverItem.y || 0,\n        y1: hoverItem.y1 || hoverItem.y || 0,\n        xLabel: hoverItem.xLabel,\n        yLabel: hoverItem.yLabel,\n        zLabel: hoverItem.zLabel,\n        text: hoverItem.text,\n        name: hoverItem.name,\n        idealAlign: hoverItem.idealAlign,\n\n        // optional extra bits of styling\n        borderColor: hoverItem.borderColor,\n        fontFamily: hoverItem.fontFamily,\n        fontSize: hoverItem.fontSize,\n        fontColor: hoverItem.fontColor,\n\n        // filler to make createHoverText happy\n        trace: {\n            index: 0,\n            hoverinfo: ''\n        },\n        xa: {_offset: 0},\n        ya: {_offset: 0},\n        index: 0\n    };\n\n    var container3 = d3.select(opts.container),\n        outerContainer3 = opts.outerContainer ?\n            d3.select(opts.outerContainer) : container3;\n\n    var fullOpts = {\n        hovermode: 'closest',\n        rotateLabels: false,\n        bgColor: opts.bgColor || Color.background,\n        container: container3,\n        outerContainer: outerContainer3\n    };\n\n    var hoverLabel = createHoverText([pointData], fullOpts);\n    alignHoverText(hoverLabel, fullOpts.rotateLabels);\n\n    return hoverLabel.node();\n};\n\nfx.loneUnhover = function(containerOrSelection) {\n    // duck type whether the arg is a d3 selection because ie9 doesn't\n    // handle instanceof like modern browsers do.\n    var selection = Lib.isD3Selection(containerOrSelection) ?\n            containerOrSelection :\n            d3.select(containerOrSelection);\n\n    selection.selectAll('g.hovertext').remove();\n    selection.selectAll('.spikeline').remove();\n};\n\nfunction createSpikelines(hoverData, opts) {\n    var hovermode = opts.hovermode;\n    var container = opts.container;\n    var c0 = hoverData[0];\n    var xa = c0.xa;\n    var ya = c0.ya;\n    var showX = xa.showspikes;\n    var showY = ya.showspikes;\n\n    // Remove old spikeline items\n    container.selectAll('.spikeline').remove();\n\n    if(hovermode !== 'closest' || !(showX || showY)) return;\n\n    var fullLayout = opts.fullLayout;\n    var xPoint = xa._offset + (c0.x0 + c0.x1) / 2;\n    var yPoint = ya._offset + (c0.y0 + c0.y1) / 2;\n    var contrastColor = Color.combine(fullLayout.plot_bgcolor, fullLayout.paper_bgcolor);\n    var dfltDashColor = tinycolor.readability(c0.color, contrastColor) < 1.5 ?\n            Color.contrast(contrastColor) : c0.color;\n\n    if(showY) {\n        var yMode = ya.spikemode;\n        var yThickness = ya.spikethickness;\n        var yColor = ya.spikecolor || dfltDashColor;\n        var yBB = ya._boundingBox;\n        var xEdge = ((yBB.left + yBB.right) / 2) < xPoint ? yBB.right : yBB.left;\n\n        if(yMode.indexOf('toaxis') !== -1 || yMode.indexOf('across') !== -1) {\n            var xBase = xEdge;\n            var xEndSpike = xPoint;\n            if(yMode.indexOf('across') !== -1) {\n                xBase = ya._counterSpan[0];\n                xEndSpike = ya._counterSpan[1];\n            }\n\n            // Background horizontal Line (to y-axis)\n            container.append('line')\n                .attr({\n                    'x1': xBase,\n                    'x2': xEndSpike,\n                    'y1': yPoint,\n                    'y2': yPoint,\n                    'stroke-width': yThickness + 2,\n                    'stroke': contrastColor\n                })\n                .classed('spikeline', true)\n                .classed('crisp', true);\n\n            // Foreground horizontal line (to y-axis)\n            container.append('line')\n                .attr({\n                    'x1': xBase,\n                    'x2': xEndSpike,\n                    'y1': yPoint,\n                    'y2': yPoint,\n                    'stroke-width': yThickness,\n                    'stroke': yColor,\n                    'stroke-dasharray': Drawing.dashStyle(ya.spikedash, yThickness)\n                })\n                .classed('spikeline', true)\n                .classed('crisp', true);\n        }\n        // Y axis marker\n        if(yMode.indexOf('marker') !== -1) {\n            container.append('circle')\n                .attr({\n                    'cx': xEdge + (ya.side !== 'right' ? yThickness : -yThickness),\n                    'cy': yPoint,\n                    'r': yThickness,\n                    'fill': yColor\n                })\n                .classed('spikeline', true);\n        }\n    }\n\n    if(showX) {\n        var xMode = xa.spikemode;\n        var xThickness = xa.spikethickness;\n        var xColor = xa.spikecolor || dfltDashColor;\n        var xBB = xa._boundingBox;\n        var yEdge = ((xBB.top + xBB.bottom) / 2) < yPoint ? xBB.bottom : xBB.top;\n\n        if(xMode.indexOf('toaxis') !== -1 || xMode.indexOf('across') !== -1) {\n            var yBase = yEdge;\n            var yEndSpike = yPoint;\n            if(xMode.indexOf('across') !== -1) {\n                yBase = xa._counterSpan[0];\n                yEndSpike = xa._counterSpan[1];\n            }\n\n            // Background vertical line (to x-axis)\n            container.append('line')\n                .attr({\n                    'x1': xPoint,\n                    'x2': xPoint,\n                    'y1': yBase,\n                    'y2': yEndSpike,\n                    'stroke-width': xThickness + 2,\n                    'stroke': contrastColor\n                })\n                .classed('spikeline', true)\n                .classed('crisp', true);\n\n            // Foreground vertical line (to x-axis)\n            container.append('line')\n                .attr({\n                    'x1': xPoint,\n                    'x2': xPoint,\n                    'y1': yBase,\n                    'y2': yEndSpike,\n                    'stroke-width': xThickness,\n                    'stroke': xColor,\n                    'stroke-dasharray': Drawing.dashStyle(xa.spikedash, xThickness)\n                })\n                .classed('spikeline', true)\n                .classed('crisp', true);\n        }\n\n        // X axis marker\n        if(xMode.indexOf('marker') !== -1) {\n            container.append('circle')\n                .attr({\n                    'cx': xPoint,\n                    'cy': yEdge - (xa.side !== 'top' ? xThickness : -xThickness),\n                    'r': xThickness,\n                    'fill': xColor\n                })\n                .classed('spikeline', true);\n        }\n    }\n}\n\nfunction createHoverText(hoverData, opts) {\n    var hovermode = opts.hovermode,\n        rotateLabels = opts.rotateLabels,\n        bgColor = opts.bgColor,\n        container = opts.container,\n        outerContainer = opts.outerContainer,\n\n        // opts.fontFamily/Size are used for the common label\n        // and as defaults for each hover label, though the individual labels\n        // can override this.\n        fontFamily = opts.fontFamily || constants.HOVERFONT,\n        fontSize = opts.fontSize || constants.HOVERFONTSIZE,\n\n        c0 = hoverData[0],\n        xa = c0.xa,\n        ya = c0.ya,\n        commonAttr = hovermode === 'y' ? 'yLabel' : 'xLabel',\n        t0 = c0[commonAttr],\n        t00 = (String(t0) || '').split(' ')[0],\n        outerContainerBB = outerContainer.node().getBoundingClientRect(),\n        outerTop = outerContainerBB.top,\n        outerWidth = outerContainerBB.width,\n        outerHeight = outerContainerBB.height;\n\n    // show the common label, if any, on the axis\n    // never show a common label in array mode,\n    // even if sometimes there could be one\n    var showCommonLabel = c0.distance <= constants.MAXDIST &&\n                          (hovermode === 'x' || hovermode === 'y');\n\n    // all hover traces hoverinfo must contain the hovermode\n    // to have common labels\n    var i, traceHoverinfo;\n    for(i = 0; i < hoverData.length; i++) {\n        traceHoverinfo = hoverData[i].trace.hoverinfo;\n        var parts = traceHoverinfo.split('+');\n        if(parts.indexOf('all') === -1 &&\n            parts.indexOf(hovermode) === -1) {\n            showCommonLabel = false;\n            break;\n        }\n    }\n\n    var commonLabel = container.selectAll('g.axistext')\n        .data(showCommonLabel ? [0] : []);\n    commonLabel.enter().append('g')\n        .classed('axistext', true);\n    commonLabel.exit().remove();\n\n    commonLabel.each(function() {\n        var label = d3.select(this),\n            lpath = label.selectAll('path').data([0]),\n            ltext = label.selectAll('text').data([0]);\n\n        lpath.enter().append('path')\n            .style({fill: Color.defaultLine, 'stroke-width': '1px', stroke: Color.background});\n        ltext.enter().append('text')\n            .call(Drawing.font, fontFamily, fontSize, Color.background)\n            // prohibit tex interpretation until we can handle\n            // tex and regular text together\n            .attr('data-notex', 1);\n\n        ltext.text(t0)\n            .call(svgTextUtils.convertToTspans)\n            .call(Drawing.setPosition, 0, 0)\n          .selectAll('tspan.line')\n            .call(Drawing.setPosition, 0, 0);\n        label.attr('transform', '');\n\n        var tbb = ltext.node().getBoundingClientRect();\n        if(hovermode === 'x') {\n            ltext.attr('text-anchor', 'middle')\n                .call(Drawing.setPosition, 0, (xa.side === 'top' ?\n                    (outerTop - tbb.bottom - HOVERARROWSIZE - HOVERTEXTPAD) :\n                    (outerTop - tbb.top + HOVERARROWSIZE + HOVERTEXTPAD)))\n                .selectAll('tspan.line')\n                    .attr({\n                        x: ltext.attr('x'),\n                        y: ltext.attr('y')\n                    });\n\n            var topsign = xa.side === 'top' ? '-' : '';\n            lpath.attr('d', 'M0,0' +\n                'L' + HOVERARROWSIZE + ',' + topsign + HOVERARROWSIZE +\n                'H' + (HOVERTEXTPAD + tbb.width / 2) +\n                'v' + topsign + (HOVERTEXTPAD * 2 + tbb.height) +\n                'H-' + (HOVERTEXTPAD + tbb.width / 2) +\n                'V' + topsign + HOVERARROWSIZE + 'H-' + HOVERARROWSIZE + 'Z');\n\n            label.attr('transform', 'translate(' +\n                (xa._offset + (c0.x0 + c0.x1) / 2) + ',' +\n                (ya._offset + (xa.side === 'top' ? 0 : ya._length)) + ')');\n        }\n        else {\n            ltext.attr('text-anchor', ya.side === 'right' ? 'start' : 'end')\n                .call(Drawing.setPosition,\n                    (ya.side === 'right' ? 1 : -1) * (HOVERTEXTPAD + HOVERARROWSIZE),\n                    outerTop - tbb.top - tbb.height / 2)\n                .selectAll('tspan.line')\n                    .attr({\n                        x: ltext.attr('x'),\n                        y: ltext.attr('y')\n                    });\n\n            var leftsign = ya.side === 'right' ? '' : '-';\n            lpath.attr('d', 'M0,0' +\n                'L' + leftsign + HOVERARROWSIZE + ',' + HOVERARROWSIZE +\n                'V' + (HOVERTEXTPAD + tbb.height / 2) +\n                'h' + leftsign + (HOVERTEXTPAD * 2 + tbb.width) +\n                'V-' + (HOVERTEXTPAD + tbb.height / 2) +\n                'H' + leftsign + HOVERARROWSIZE + 'V-' + HOVERARROWSIZE + 'Z');\n\n            label.attr('transform', 'translate(' +\n                (xa._offset + (ya.side === 'right' ? xa._length : 0)) + ',' +\n                (ya._offset + (c0.y0 + c0.y1) / 2) + ')');\n        }\n        // remove the \"close but not quite\" points\n        // because of error bars, only take up to a space\n        hoverData = hoverData.filter(function(d) {\n            return (d.zLabelVal !== undefined) ||\n                (d[commonAttr] || '').split(' ')[0] === t00;\n        });\n    });\n\n    // show all the individual labels\n\n    // first create the objects\n    var hoverLabels = container.selectAll('g.hovertext')\n        .data(hoverData, function(d) {\n            return [d.trace.index, d.index, d.x0, d.y0, d.name, d.attr, d.xa, d.ya || ''].join(',');\n        });\n    hoverLabels.enter().append('g')\n        .classed('hovertext', true)\n        .each(function() {\n            var g = d3.select(this);\n            // trace name label (rect and text.name)\n            g.append('rect')\n                .call(Color.fill, Color.addOpacity(bgColor, 0.8));\n            g.append('text').classed('name', true);\n            // trace data label (path and text.nums)\n            g.append('path')\n                .style('stroke-width', '1px');\n            g.append('text').classed('nums', true)\n                .call(Drawing.font, fontFamily, fontSize);\n        });\n    hoverLabels.exit().remove();\n\n    // then put the text in, position the pointer to the data,\n    // and figure out sizes\n    hoverLabels.each(function(d) {\n        var g = d3.select(this).attr('transform', ''),\n            name = '',\n            text = '',\n            // combine possible non-opaque trace color with bgColor\n            baseColor = Color.opacity(d.color) ?\n                d.color : Color.defaultLine,\n            traceColor = Color.combine(baseColor, bgColor),\n\n            // find a contrasting color for border and text\n            contrastColor = d.borderColor || Color.contrast(traceColor);\n\n        // to get custom 'name' labels pass cleanPoint\n        if(d.nameOverride !== undefined) d.name = d.nameOverride;\n\n        if(d.name && d.zLabelVal === undefined) {\n            // strip out our pseudo-html elements from d.name (if it exists at all)\n            name = svgTextUtils.plainText(d.name || '');\n\n            if(name.length > 15) name = name.substr(0, 12) + '...';\n        }\n\n        // used by other modules (initially just ternary) that\n        // manage their own hoverinfo independent of cleanPoint\n        // the rest of this will still apply, so such modules\n        // can still put things in (x|y|z)Label, text, and name\n        // and hoverinfo will still determine their visibility\n        if(d.extraText !== undefined) text += d.extraText;\n\n        if(d.zLabel !== undefined) {\n            if(d.xLabel !== undefined) text += 'x: ' + d.xLabel + '<br>';\n            if(d.yLabel !== undefined) text += 'y: ' + d.yLabel + '<br>';\n            text += (text ? 'z: ' : '') + d.zLabel;\n        }\n        else if(showCommonLabel && d[hovermode + 'Label'] === t0) {\n            text = d[(hovermode === 'x' ? 'y' : 'x') + 'Label'] || '';\n        }\n        else if(d.xLabel === undefined) {\n            if(d.yLabel !== undefined) text = d.yLabel;\n        }\n        else if(d.yLabel === undefined) text = d.xLabel;\n        else text = '(' + d.xLabel + ', ' + d.yLabel + ')';\n\n        if(d.text && !Array.isArray(d.text)) text += (text ? '<br>' : '') + d.text;\n\n        // if 'text' is empty at this point,\n        // put 'name' in main label and don't show secondary label\n        if(text === '') {\n            // if 'name' is also empty, remove entire label\n            if(name === '') g.remove();\n            text = name;\n        }\n\n        // main label\n        var tx = g.select('text.nums')\n            .call(Drawing.font,\n                d.fontFamily || fontFamily,\n                d.fontSize || fontSize,\n                d.fontColor || contrastColor)\n            .call(Drawing.setPosition, 0, 0)\n            .text(text)\n            .attr('data-notex', 1)\n            .call(svgTextUtils.convertToTspans);\n        tx.selectAll('tspan.line')\n            .call(Drawing.setPosition, 0, 0);\n\n        var tx2 = g.select('text.name'),\n            tx2width = 0;\n\n        // secondary label for non-empty 'name'\n        if(name && name !== text) {\n            tx2.call(Drawing.font,\n                    d.fontFamily || fontFamily,\n                    d.fontSize || fontSize,\n                    traceColor)\n                .text(name)\n                .call(Drawing.setPosition, 0, 0)\n                .attr('data-notex', 1)\n                .call(svgTextUtils.convertToTspans);\n            tx2.selectAll('tspan.line')\n                .call(Drawing.setPosition, 0, 0);\n            tx2width = tx2.node().getBoundingClientRect().width + 2 * HOVERTEXTPAD;\n        }\n        else {\n            tx2.remove();\n            g.select('rect').remove();\n        }\n\n        g.select('path')\n            .style({\n                fill: traceColor,\n                stroke: contrastColor\n            });\n        var tbb = tx.node().getBoundingClientRect(),\n            htx = d.xa._offset + (d.x0 + d.x1) / 2,\n            hty = d.ya._offset + (d.y0 + d.y1) / 2,\n            dx = Math.abs(d.x1 - d.x0),\n            dy = Math.abs(d.y1 - d.y0),\n            txTotalWidth = tbb.width + HOVERARROWSIZE + HOVERTEXTPAD + tx2width,\n            anchorStartOK,\n            anchorEndOK;\n\n        d.ty0 = outerTop - tbb.top;\n        d.bx = tbb.width + 2 * HOVERTEXTPAD;\n        d.by = tbb.height + 2 * HOVERTEXTPAD;\n        d.anchor = 'start';\n        d.txwidth = tbb.width;\n        d.tx2width = tx2width;\n        d.offset = 0;\n\n        if(rotateLabels) {\n            d.pos = htx;\n            anchorStartOK = hty + dy / 2 + txTotalWidth <= outerHeight;\n            anchorEndOK = hty - dy / 2 - txTotalWidth >= 0;\n            if((d.idealAlign === 'top' || !anchorStartOK) && anchorEndOK) {\n                hty -= dy / 2;\n                d.anchor = 'end';\n            } else if(anchorStartOK) {\n                hty += dy / 2;\n                d.anchor = 'start';\n            } else d.anchor = 'middle';\n        }\n        else {\n            d.pos = hty;\n            anchorStartOK = htx + dx / 2 + txTotalWidth <= outerWidth;\n            anchorEndOK = htx - dx / 2 - txTotalWidth >= 0;\n            if((d.idealAlign === 'left' || !anchorStartOK) && anchorEndOK) {\n                htx -= dx / 2;\n                d.anchor = 'end';\n            } else if(anchorStartOK) {\n                htx += dx / 2;\n                d.anchor = 'start';\n            } else d.anchor = 'middle';\n        }\n\n        tx.attr('text-anchor', d.anchor);\n        if(tx2width) tx2.attr('text-anchor', d.anchor);\n        g.attr('transform', 'translate(' + htx + ',' + hty + ')' +\n            (rotateLabels ? 'rotate(' + YANGLE + ')' : ''));\n    });\n\n    return hoverLabels;\n}\n\n// Make groups of touching points, and within each group\n// move each point so that no labels overlap, but the average\n// label position is the same as it was before moving. Indicentally,\n// this is equivalent to saying all the labels are on equal linear\n// springs about their initial position. Initially, each point is\n// its own group, but as we find overlaps we will clump the points.\n//\n// Also, there are hard constraints at the edges of the graphs,\n// that push all groups to the middle so they are visible. I don't\n// know what happens if the group spans all the way from one edge to\n// the other, though it hardly matters - there's just too much\n// information then.\nfunction hoverAvoidOverlaps(hoverData, ax) {\n    var nummoves = 0,\n\n        // make groups of touching points\n        pointgroups = hoverData\n            .map(function(d, i) {\n                var axis = d[ax];\n                return [{\n                    i: i,\n                    dp: 0,\n                    pos: d.pos,\n                    posref: d.posref,\n                    size: d.by * (axis._id.charAt(0) === 'x' ? YFACTOR : 1) / 2,\n                    pmin: axis._offset,\n                    pmax: axis._offset + axis._length\n                }];\n            })\n            .sort(function(a, b) { return a[0].posref - b[0].posref; }),\n        donepositioning,\n        topOverlap,\n        bottomOverlap,\n        i, j,\n        pti,\n        sumdp;\n\n    function constrainGroup(grp) {\n        var minPt = grp[0],\n            maxPt = grp[grp.length - 1];\n\n        // overlap with the top - positive vals are overlaps\n        topOverlap = minPt.pmin - minPt.pos - minPt.dp + minPt.size;\n\n        // overlap with the bottom - positive vals are overlaps\n        bottomOverlap = maxPt.pos + maxPt.dp + maxPt.size - minPt.pmax;\n\n        // check for min overlap first, so that we always\n        // see the largest labels\n        // allow for .01px overlap, so we don't get an\n        // infinite loop from rounding errors\n        if(topOverlap > 0.01) {\n            for(j = grp.length - 1; j >= 0; j--) grp[j].dp += topOverlap;\n            donepositioning = false;\n        }\n        if(bottomOverlap < 0.01) return;\n        if(topOverlap < -0.01) {\n            // make sure we're not pushing back and forth\n            for(j = grp.length - 1; j >= 0; j--) grp[j].dp -= bottomOverlap;\n            donepositioning = false;\n        }\n        if(!donepositioning) return;\n\n        // no room to fix positioning, delete off-screen points\n\n        // first see how many points we need to delete\n        var deleteCount = 0;\n        for(i = 0; i < grp.length; i++) {\n            pti = grp[i];\n            if(pti.pos + pti.dp + pti.size > minPt.pmax) deleteCount++;\n        }\n\n        // start by deleting points whose data is off screen\n        for(i = grp.length - 1; i >= 0; i--) {\n            if(deleteCount <= 0) break;\n            pti = grp[i];\n\n            // pos has already been constrained to [pmin,pmax]\n            // so look for points close to that to delete\n            if(pti.pos > minPt.pmax - 1) {\n                pti.del = true;\n                deleteCount--;\n            }\n        }\n        for(i = 0; i < grp.length; i++) {\n            if(deleteCount <= 0) break;\n            pti = grp[i];\n\n            // pos has already been constrained to [pmin,pmax]\n            // so look for points close to that to delete\n            if(pti.pos < minPt.pmin + 1) {\n                pti.del = true;\n                deleteCount--;\n\n                // shift the whole group minus into this new space\n                bottomOverlap = pti.size * 2;\n                for(j = grp.length - 1; j >= 0; j--) grp[j].dp -= bottomOverlap;\n            }\n        }\n        // then delete points that go off the bottom\n        for(i = grp.length - 1; i >= 0; i--) {\n            if(deleteCount <= 0) break;\n            pti = grp[i];\n            if(pti.pos + pti.dp + pti.size > minPt.pmax) {\n                pti.del = true;\n                deleteCount--;\n            }\n        }\n    }\n\n    // loop through groups, combining them if they overlap,\n    // until nothing moves\n    while(!donepositioning && nummoves <= hoverData.length) {\n        // to avoid infinite loops, don't move more times\n        // than there are traces\n        nummoves++;\n\n        // assume nothing will move in this iteration,\n        // reverse this if it does\n        donepositioning = true;\n        i = 0;\n        while(i < pointgroups.length - 1) {\n                // the higher (g0) and lower (g1) point group\n            var g0 = pointgroups[i],\n                g1 = pointgroups[i + 1],\n\n                // the lowest point in the higher group (p0)\n                // the highest point in the lower group (p1)\n                p0 = g0[g0.length - 1],\n                p1 = g1[0];\n            topOverlap = p0.pos + p0.dp + p0.size - p1.pos - p1.dp + p1.size;\n\n            // Only group points that lie on the same axes\n            if(topOverlap > 0.01 && (p0.pmin === p1.pmin) && (p0.pmax === p1.pmax)) {\n                // push the new point(s) added to this group out of the way\n                for(j = g1.length - 1; j >= 0; j--) g1[j].dp += topOverlap;\n\n                // add them to the group\n                g0.push.apply(g0, g1);\n                pointgroups.splice(i + 1, 1);\n\n                // adjust for minimum average movement\n                sumdp = 0;\n                for(j = g0.length - 1; j >= 0; j--) sumdp += g0[j].dp;\n                bottomOverlap = sumdp / g0.length;\n                for(j = g0.length - 1; j >= 0; j--) g0[j].dp -= bottomOverlap;\n                donepositioning = false;\n            }\n            else i++;\n        }\n\n        // check if we're going off the plot on either side and fix\n        pointgroups.forEach(constrainGroup);\n    }\n\n    // now put these offsets into hoverData\n    for(i = pointgroups.length - 1; i >= 0; i--) {\n        var grp = pointgroups[i];\n        for(j = grp.length - 1; j >= 0; j--) {\n            var pt = grp[j],\n                hoverPt = hoverData[pt.i];\n            hoverPt.offset = pt.dp;\n            hoverPt.del = pt.del;\n        }\n    }\n}\n\nfunction alignHoverText(hoverLabels, rotateLabels) {\n    // finally set the text positioning relative to the data and draw the\n    // box around it\n    hoverLabels.each(function(d) {\n        var g = d3.select(this);\n        if(d.del) {\n            g.remove();\n            return;\n        }\n        var horzSign = d.anchor === 'end' ? -1 : 1,\n            tx = g.select('text.nums'),\n            alignShift = {start: 1, end: -1, middle: 0}[d.anchor],\n            txx = alignShift * (HOVERARROWSIZE + HOVERTEXTPAD),\n            tx2x = txx + alignShift * (d.txwidth + HOVERTEXTPAD),\n            offsetX = 0,\n            offsetY = d.offset;\n        if(d.anchor === 'middle') {\n            txx -= d.tx2width / 2;\n            tx2x -= d.tx2width / 2;\n        }\n        if(rotateLabels) {\n            offsetY *= -YSHIFTY;\n            offsetX = d.offset * YSHIFTX;\n        }\n\n        g.select('path').attr('d', d.anchor === 'middle' ?\n            // middle aligned: rect centered on data\n            ('M-' + (d.bx / 2) + ',-' + (d.by / 2) + 'h' + d.bx + 'v' + d.by + 'h-' + d.bx + 'Z') :\n            // left or right aligned: side rect with arrow to data\n            ('M0,0L' + (horzSign * HOVERARROWSIZE + offsetX) + ',' + (HOVERARROWSIZE + offsetY) +\n                'v' + (d.by / 2 - HOVERARROWSIZE) +\n                'h' + (horzSign * d.bx) +\n                'v-' + d.by +\n                'H' + (horzSign * HOVERARROWSIZE + offsetX) +\n                'V' + (offsetY - HOVERARROWSIZE) +\n                'Z'));\n\n        tx.call(Drawing.setPosition,\n                txx + offsetX, offsetY + d.ty0 - d.by / 2 + HOVERTEXTPAD)\n            .selectAll('tspan.line')\n                .attr({\n                    x: tx.attr('x'),\n                    y: tx.attr('y')\n                });\n\n        if(d.tx2width) {\n            g.select('text.name, text.name tspan.line')\n                .call(Drawing.setPosition,\n                    tx2x + alignShift * HOVERTEXTPAD + offsetX,\n                    offsetY + d.ty0 - d.by / 2 + HOVERTEXTPAD);\n            g.select('rect')\n                .call(Drawing.setRect,\n                    tx2x + (alignShift - 1) * d.tx2width / 2 + offsetX,\n                    offsetY - d.by / 2 - 1,\n                    d.tx2width, d.by + 2);\n        }\n    });\n}\n\nfunction hoverChanged(gd, evt, oldhoverdata) {\n    // don't emit any events if nothing changed\n    if(!oldhoverdata || oldhoverdata.length !== gd._hoverdata.length) return true;\n\n    for(var i = oldhoverdata.length - 1; i >= 0; i--) {\n        var oldPt = oldhoverdata[i],\n            newPt = gd._hoverdata[i];\n        if(oldPt.curveNumber !== newPt.curveNumber ||\n                String(oldPt.pointNumber) !== String(newPt.pointNumber)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n// on click\nfx.click = function(gd, evt) {\n    var annotationsDone = Registry.getComponentMethod('annotations', 'onClick')(gd, gd._hoverdata);\n\n    function emitClick() { gd.emit('plotly_click', {points: gd._hoverdata, event: evt}); }\n\n    if(gd._hoverdata && evt && evt.target) {\n        if(annotationsDone && annotationsDone.then) {\n            annotationsDone.then(emitClick);\n        }\n        else emitClick();\n\n        // why do we get a double event without this???\n        if(evt.stopImmediatePropagation) evt.stopImmediatePropagation();\n    }\n};\n\n\n// for bar charts and others with finite-size objects: you must be inside\n// it to see its hover info, so distance is infinite outside.\n// But make distance inside be at least 1/4 MAXDIST, and a little bigger\n// for bigger bars, to prioritize scatter and smaller bars over big bars\n\n// note that for closest mode, two inbox's will get added in quadrature\n// args are (signed) difference from the two opposite edges\n// count one edge as in, so that over continuous ranges you never get a gap\nfx.inbox = function(v0, v1) {\n    if(v0 * v1 < 0 || v0 === 0) {\n        return constants.MAXDIST * (0.6 - 0.3 / Math.max(3, Math.abs(v0 - v1)));\n    }\n    return Infinity;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/lib/events.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\n/* global jQuery:false */\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar Events = {\n\n    init: function(plotObj) {\n\n        /*\n         * If we have already instantiated an emitter for this plot\n         * return early.\n         */\n        if(plotObj._ev instanceof EventEmitter) return plotObj;\n\n        var ev = new EventEmitter();\n        var internalEv = new EventEmitter();\n\n        /*\n         * Assign to plot._ev while we still live in a land\n         * where plot is a DOM element with stuff attached to it.\n         * In the future we can make plot the event emitter itself.\n         */\n        plotObj._ev = ev;\n\n        /*\n         * Create a second event handler that will manage events *internally*.\n         * This allows parts of plotly to respond to thing like relayout without\n         * having to use the user-facing event handler. They cannot peacefully\n         * coexist on the same handler because a user invoking\n         * plotObj.removeAllListeners() would detach internal events, breaking\n         * plotly.\n         */\n        plotObj._internalEv = internalEv;\n\n        /*\n         * Assign bound methods from the ev to the plot object. These methods\n         * will reference the 'this' of plot._ev even though they are methods\n         * of plot. This will keep the event machinery away from the plot object\n         * which currently is often a DOM element but presents an API that will\n         * continue to function when plot becomes an emitter. Not all EventEmitter\n         * methods have been bound to `plot` as some do not currently add value to\n         * the Plotly event API.\n         */\n        plotObj.on = ev.on.bind(ev);\n        plotObj.once = ev.once.bind(ev);\n        plotObj.removeListener = ev.removeListener.bind(ev);\n        plotObj.removeAllListeners = ev.removeAllListeners.bind(ev);\n\n        /*\n         * Create funtions for managing internal events. These are *only* triggered\n         * by the mirroring of external events via the emit function.\n         */\n        plotObj._internalOn = internalEv.on.bind(internalEv);\n        plotObj._internalOnce = internalEv.once.bind(internalEv);\n        plotObj._removeInternalListener = internalEv.removeListener.bind(internalEv);\n        plotObj._removeAllInternalListeners = internalEv.removeAllListeners.bind(internalEv);\n\n        /*\n         * We must wrap emit to continue to support JQuery events. The idea\n         * is to check to see if the user is using JQuery events, if they are\n         * we emit JQuery events to trigger user handlers as well as the EventEmitter\n         * events.\n         */\n        plotObj.emit = function(event, data) {\n            if(typeof jQuery !== 'undefined') {\n                jQuery(plotObj).trigger(event, data);\n            }\n\n            ev.emit(event, data);\n            internalEv.emit(event, data);\n        };\n\n        return plotObj;\n    },\n\n    /*\n     * This function behaves like jQueries triggerHandler. It calls\n     * all handlers for a particular event and returns the return value\n     * of the LAST handler. This function also triggers jQuery's\n     * triggerHandler for backwards compatibility.\n     *\n     * Note: triggerHandler has been recommended for deprecation in v2.0.0,\n     * so the additional behavior of triggerHandler triggering internal events\n     * is deliberate excluded in order to avoid reinforcing more usage.\n     */\n    triggerHandler: function(plotObj, event, data) {\n        var jQueryHandlerValue;\n        var nodeEventHandlerValue;\n        /*\n         * If Jquery exists run all its handlers for this event and\n         * collect the return value of the LAST handler function\n         */\n        if(typeof jQuery !== 'undefined') {\n            jQueryHandlerValue = jQuery(plotObj).triggerHandler(event, data);\n        }\n\n        /*\n         * Now run all the node style event handlers\n         */\n        var ev = plotObj._ev;\n        if(!ev) return jQueryHandlerValue;\n\n        var handlers = ev._events[event];\n        if(!handlers) return jQueryHandlerValue;\n\n        /*\n         * handlers can be function or an array of functions\n         */\n        if(typeof handlers === 'function') handlers = [handlers];\n        var lastHandler = handlers.pop();\n\n        /*\n         * Call all the handlers except the last one.\n         */\n        for(var i = 0; i < handlers.length; i++) {\n            handlers[i](data);\n        }\n\n        /*\n         * Now call the final handler and collect its value\n         */\n        nodeEventHandlerValue = lastHandler(data);\n\n        /*\n         * Return either the jquery handler value if it exists or the\n         * nodeEventHandler value. Jquery event value superceeds nodejs\n         * events for backwards compatability reasons.\n         */\n        return jQueryHandlerValue !== undefined ? jQueryHandlerValue :\n            nodeEventHandlerValue;\n    },\n\n    purge: function(plotObj) {\n        delete plotObj._ev;\n        delete plotObj.on;\n        delete plotObj.once;\n        delete plotObj.removeListener;\n        delete plotObj.removeAllListeners;\n        delete plotObj.emit;\n\n        delete plotObj._ev;\n        delete plotObj._internalEv;\n        delete plotObj._internalOn;\n        delete plotObj._internalOnce;\n        delete plotObj._removeInternalListener;\n        delete plotObj._removeAllInternalListeners;\n\n        return plotObj;\n    }\n\n};\n\nmodule.exports = Events;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/dragelement/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Plotly = require('../../plotly');\nvar Lib = require('../../lib');\n\nvar constants = require('../../plots/cartesian/constants');\nvar interactConstants = require('../../constants/interactions');\n\nvar dragElement = module.exports = {};\n\ndragElement.align = require('./align');\ndragElement.getCursor = require('./cursor');\n\nvar unhover = require('./unhover');\ndragElement.unhover = unhover.wrapped;\ndragElement.unhoverRaw = unhover.raw;\n\n/**\n * Abstracts click & drag interactions\n * @param {object} options with keys:\n *      element (required) the DOM element to drag\n *      prepFn (optional) function(event, startX, startY)\n *          executed on mousedown\n *          startX and startY are the clientX and clientY pixel position\n *          of the mousedown event\n *      moveFn (optional) function(dx, dy, dragged)\n *          executed on move\n *          dx and dy are the net pixel offset of the drag,\n *          dragged is true/false, has the mouse moved enough to\n *          constitute a drag\n *      doneFn (optional) function(dragged, numClicks, e)\n *          executed on mouseup, or mouseout of window since\n *          we don't get events after that\n *          dragged is as in moveFn\n *          numClicks is how many clicks we've registered within\n *          a doubleclick time\n *          e is the original event\n *      setCursor (optional) function(event)\n *          executed on mousemove before mousedown\n *          the purpose of this callback is to update the mouse cursor before\n *          the click & drag interaction has been initiated\n */\ndragElement.init = function init(options) {\n    var gd = Lib.getPlotDiv(options.element) || {},\n        numClicks = 1,\n        DBLCLICKDELAY = interactConstants.DBLCLICKDELAY,\n        startX,\n        startY,\n        newMouseDownTime,\n        dragCover,\n        initialTarget,\n        initialOnMouseMove;\n\n    if(!gd._mouseDownTime) gd._mouseDownTime = 0;\n\n    function onStart(e) {\n        // disable call to options.setCursor(evt)\n        options.element.onmousemove = initialOnMouseMove;\n\n        // make dragging and dragged into properties of gd\n        // so that others can look at and modify them\n        gd._dragged = false;\n        gd._dragging = true;\n        startX = e.clientX;\n        startY = e.clientY;\n        initialTarget = e.target;\n\n        newMouseDownTime = (new Date()).getTime();\n        if(newMouseDownTime - gd._mouseDownTime < DBLCLICKDELAY) {\n            // in a click train\n            numClicks += 1;\n        }\n        else {\n            // new click train\n            numClicks = 1;\n            gd._mouseDownTime = newMouseDownTime;\n        }\n\n        if(options.prepFn) options.prepFn(e, startX, startY);\n\n        dragCover = coverSlip();\n\n        dragCover.onmousemove = onMove;\n        dragCover.onmouseup = onDone;\n        dragCover.onmouseout = onDone;\n\n        dragCover.style.cursor = window.getComputedStyle(options.element).cursor;\n\n        return Lib.pauseEvent(e);\n    }\n\n    function onMove(e) {\n        var dx = e.clientX - startX,\n            dy = e.clientY - startY,\n            minDrag = options.minDrag || constants.MINDRAG;\n\n        if(Math.abs(dx) < minDrag) dx = 0;\n        if(Math.abs(dy) < minDrag) dy = 0;\n        if(dx || dy) {\n            gd._dragged = true;\n            dragElement.unhover(gd);\n        }\n\n        if(options.moveFn) options.moveFn(dx, dy, gd._dragged);\n\n        return Lib.pauseEvent(e);\n    }\n\n    function onDone(e) {\n        // re-enable call to options.setCursor(evt)\n        initialOnMouseMove = options.element.onmousemove;\n        if(options.setCursor) options.element.onmousemove = options.setCursor;\n\n        dragCover.onmousemove = null;\n        dragCover.onmouseup = null;\n        dragCover.onmouseout = null;\n        Lib.removeElement(dragCover);\n\n        if(!gd._dragging) {\n            gd._dragged = false;\n            return;\n        }\n        gd._dragging = false;\n\n        // don't count as a dblClick unless the mouseUp is also within\n        // the dblclick delay\n        if((new Date()).getTime() - gd._mouseDownTime > DBLCLICKDELAY) {\n            numClicks = Math.max(numClicks - 1, 1);\n        }\n\n        if(options.doneFn) options.doneFn(gd._dragged, numClicks, e);\n\n        if(!gd._dragged) {\n            var e2;\n\n            try {\n                e2 = new MouseEvent('click', e);\n            }\n            catch(err) {\n                e2 = document.createEvent('MouseEvents');\n                e2.initMouseEvent('click',\n                    e.bubbles, e.cancelable,\n                    e.view, e.detail,\n                    e.screenX, e.screenY,\n                    e.clientX, e.clientY,\n                    e.ctrlKey, e.altKey, e.shiftKey, e.metaKey,\n                    e.button, e.relatedTarget);\n            }\n\n            initialTarget.dispatchEvent(e2);\n        }\n\n        finishDrag(gd);\n\n        gd._dragged = false;\n\n        return Lib.pauseEvent(e);\n    }\n\n    // enable call to options.setCursor(evt)\n    initialOnMouseMove = options.element.onmousemove;\n    if(options.setCursor) options.element.onmousemove = options.setCursor;\n\n    options.element.onmousedown = onStart;\n    options.element.style.pointerEvents = 'all';\n};\n\nfunction coverSlip() {\n    var cover = document.createElement('div');\n\n    cover.className = 'dragcover';\n    var cStyle = cover.style;\n    cStyle.position = 'fixed';\n    cStyle.left = 0;\n    cStyle.right = 0;\n    cStyle.top = 0;\n    cStyle.bottom = 0;\n    cStyle.zIndex = 999999999;\n    cStyle.background = 'none';\n\n    document.body.appendChild(cover);\n\n    return cover;\n}\n\ndragElement.coverSlip = coverSlip;\n\nfunction finishDrag(gd) {\n    gd._dragging = false;\n    if(gd._replotPending) Plotly.plot(gd);\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/dragelement/align.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\n\n// for automatic alignment on dragging, <1/3 means left align,\n// >2/3 means right, and between is center. Pick the right fraction\n// based on where you are, and return the fraction corresponding to\n// that position on the object\nmodule.exports = function align(v, dv, v0, v1, anchor) {\n    var vmin = (v - v0) / (v1 - v0),\n        vmax = vmin + dv / (v1 - v0),\n        vc = (vmin + vmax) / 2;\n\n    // explicitly specified anchor\n    if(anchor === 'left' || anchor === 'bottom') return vmin;\n    if(anchor === 'center' || anchor === 'middle') return vc;\n    if(anchor === 'right' || anchor === 'top') return vmax;\n\n    // automatic based on position\n    if(vmin < (2 / 3) - vc) return vmin;\n    if(vmax > (4 / 3) - vc) return vmax;\n    return vc;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/dragelement/cursor.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Lib = require('../../lib');\n\n\n// set cursors pointing toward the closest corner/side,\n// to indicate alignment\n// x and y are 0-1, fractions of the plot area\nvar cursorset = [\n    ['sw-resize', 's-resize', 'se-resize'],\n    ['w-resize', 'move', 'e-resize'],\n    ['nw-resize', 'n-resize', 'ne-resize']\n];\n\nmodule.exports = function getCursor(x, y, xanchor, yanchor) {\n    if(xanchor === 'left') x = 0;\n    else if(xanchor === 'center') x = 1;\n    else if(xanchor === 'right') x = 2;\n    else x = Lib.constrain(Math.floor(x * 3), 0, 2);\n\n    if(yanchor === 'bottom') y = 0;\n    else if(yanchor === 'middle') y = 1;\n    else if(yanchor === 'top') y = 2;\n    else y = Lib.constrain(Math.floor(y * 3), 0, 2);\n\n    return cursorset[y][x];\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/dragelement/unhover.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\n\nvar Events = require('../../lib/events');\n\n\nvar unhover = module.exports = {};\n\n\nunhover.wrapped = function(gd, evt, subplot) {\n    if(typeof gd === 'string') gd = document.getElementById(gd);\n\n    // Important, clear any queued hovers\n    if(gd._hoverTimer) {\n        clearTimeout(gd._hoverTimer);\n        gd._hoverTimer = undefined;\n    }\n\n    unhover.raw(gd, evt, subplot);\n};\n\n\n// remove hover effects on mouse out, and emit unhover event\nunhover.raw = function unhoverRaw(gd, evt) {\n    var fullLayout = gd._fullLayout;\n    var oldhoverdata = gd._hoverdata;\n\n    if(!evt) evt = {};\n    if(evt.target &&\n       Events.triggerHandler(gd, 'plotly_beforehover', evt) === false) {\n        return;\n    }\n\n    fullLayout._hoverlayer.selectAll('g').remove();\n    fullLayout._hoverlayer.selectAll('line').remove();\n    fullLayout._hoverlayer.selectAll('circle').remove();\n    gd._hoverdata = undefined;\n\n    if(evt.target && oldhoverdata) {\n        gd.emit('plotly_unhover', {\n            event: evt,\n            points: oldhoverdata\n        });\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/lib/override_cursor.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar setCursor = require('./setcursor');\n\nvar STASHATTR = 'data-savedcursor';\nvar NO_CURSOR = '!!';\n\n/*\n * works with our CSS cursor classes (see css/_cursor.scss)\n * to override a previous cursor set on d3 single-element selections,\n * by moving the name of the original cursor to the data-savedcursor attr.\n * omit cursor to revert to the previously set value.\n */\nmodule.exports = function overrideCursor(el3, csr) {\n    var savedCursor = el3.attr(STASHATTR);\n    if(csr) {\n        if(!savedCursor) {\n            var classes = (el3.attr('class') || '').split(' ');\n            for(var i = 0; i < classes.length; i++) {\n                var cls = classes[i];\n                if(cls.indexOf('cursor-') === 0) {\n                    el3.attr(STASHATTR, cls.substr(7))\n                        .classed(cls, false);\n                }\n            }\n            if(!el3.attr(STASHATTR)) {\n                el3.attr(STASHATTR, NO_CURSOR);\n            }\n        }\n        setCursor(el3, csr);\n    }\n    else if(savedCursor) {\n        el3.attr(STASHATTR, null);\n\n        if(savedCursor === NO_CURSOR) setCursor(el3);\n        else setCursor(el3, savedCursor);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/lib/setcursor.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\n// works with our CSS cursor classes (see css/_cursor.scss)\n// to apply cursors to d3 single-element selections.\n// omit cursor to revert to the default.\nmodule.exports = function setCursor(el3, csr) {\n    (el3.attr('class') || '').split(' ').forEach(function(cls) {\n        if(cls.indexOf('cursor-') === 0) el3.classed(cls, false);\n    });\n\n    if(csr) el3.classed('cursor-' + csr, true);\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/cartesian/dragbox.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\nvar tinycolor = require('tinycolor2');\n\nvar Plotly = require('../../plotly');\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar Color = require('../../components/color');\nvar Drawing = require('../../components/drawing');\nvar setCursor = require('../../lib/setcursor');\nvar dragElement = require('../../components/dragelement');\n\nvar doTicks = require('./axes').doTicks;\nvar getFromId = require('./axis_ids').getFromId;\nvar prepSelect = require('./select');\nvar scaleZoom = require('./scale_zoom');\n\nvar constants = require('./constants');\nvar MINDRAG = constants.MINDRAG;\nvar MINZOOM = constants.MINZOOM;\n\n\n// flag for showing \"doubleclick to zoom out\" only at the beginning\nvar SHOWZOOMOUTTIP = true;\n\n// dragBox: create an element to drag one or more axis ends\n// inputs:\n//      plotinfo - which subplot are we making dragboxes on?\n//      x,y,w,h - left, top, width, height of the box\n//      ns - how does this drag the vertical axis?\n//          'n' - top only\n//          's' - bottom only\n//          'ns' - top and bottom together, difference unchanged\n//      ew - same for horizontal axis\nmodule.exports = function dragBox(gd, plotinfo, x, y, w, h, ns, ew) {\n    // mouseDown stores ms of first mousedown event in the last\n    // DBLCLICKDELAY ms on the drag bars\n    // numClicks stores how many mousedowns have been seen\n    // within DBLCLICKDELAY so we can check for click or doubleclick events\n    // dragged stores whether a drag has occurred, so we don't have to\n    // redraw unnecessarily, ie if no move bigger than MINDRAG or MINZOOM px\n    var fullLayout = gd._fullLayout,\n        zoomlayer = gd._fullLayout._zoomlayer,\n        isMainDrag = (ns + ew === 'nsew'),\n        subplots,\n        xa,\n        ya,\n        xs,\n        ys,\n        pw,\n        ph,\n        xActive,\n        yActive,\n        cursor,\n        isSubplotConstrained,\n        xaLinked,\n        yaLinked;\n\n    function recomputeAxisLists() {\n        xa = [plotinfo.xaxis];\n        ya = [plotinfo.yaxis];\n        var xa0 = xa[0];\n        var ya0 = ya[0];\n        pw = xa0._length;\n        ph = ya0._length;\n\n        var constraintGroups = fullLayout._axisConstraintGroups;\n        var xIDs = [xa0._id];\n        var yIDs = [ya0._id];\n\n        // if we're dragging two axes at once, also drag overlays\n        subplots = [plotinfo].concat((ns && ew) ? plotinfo.overlays : []);\n\n        for(var i = 1; i < subplots.length; i++) {\n            var subplotXa = subplots[i].xaxis,\n                subplotYa = subplots[i].yaxis;\n\n            if(xa.indexOf(subplotXa) === -1) {\n                xa.push(subplotXa);\n                xIDs.push(subplotXa._id);\n            }\n\n            if(ya.indexOf(subplotYa) === -1) {\n                ya.push(subplotYa);\n                yIDs.push(subplotYa._id);\n            }\n        }\n\n        xActive = isDirectionActive(xa, ew);\n        yActive = isDirectionActive(ya, ns);\n        cursor = getDragCursor(yActive + xActive, fullLayout.dragmode);\n        xs = xa0._offset;\n        ys = ya0._offset;\n\n        var links = calcLinks(constraintGroups, xIDs, yIDs);\n        isSubplotConstrained = links.xy;\n\n        // finally make the list of axis objects to link\n        xaLinked = [];\n        for(var xLinkID in links.x) { xaLinked.push(getFromId(gd, xLinkID)); }\n        yaLinked = [];\n        for(var yLinkID in links.y) { yaLinked.push(getFromId(gd, yLinkID)); }\n    }\n\n    recomputeAxisLists();\n\n    var dragger = makeDragger(plotinfo, ns + ew + 'drag', cursor, x, y, w, h);\n\n    // still need to make the element if the axes are disabled\n    // but nuke its events (except for maindrag which needs them for hover)\n    // and stop there\n    if(!yActive && !xActive && !isSelectOrLasso(fullLayout.dragmode)) {\n        dragger.onmousedown = null;\n        dragger.style.pointerEvents = isMainDrag ? 'all' : 'none';\n        return dragger;\n    }\n\n    var dragOptions = {\n        element: dragger,\n        gd: gd,\n        plotinfo: plotinfo,\n        doubleclick: doubleClick,\n        prepFn: function(e, startX, startY) {\n            var dragModeNow = gd._fullLayout.dragmode;\n\n            if(isMainDrag) {\n                // main dragger handles all drag modes, and changes\n                // to pan (or to zoom if it already is pan) on shift\n                if(e.shiftKey) {\n                    if(dragModeNow === 'pan') dragModeNow = 'zoom';\n                    else dragModeNow = 'pan';\n                }\n            }\n            // all other draggers just pan\n            else dragModeNow = 'pan';\n\n            if(dragModeNow === 'lasso') dragOptions.minDrag = 1;\n            else dragOptions.minDrag = undefined;\n\n            if(dragModeNow === 'zoom') {\n                dragOptions.moveFn = zoomMove;\n                dragOptions.doneFn = zoomDone;\n\n                // zoomMove takes care of the threshold, but we need to\n                // minimize this so that constrained zoom boxes will flip\n                // orientation at the right place\n                dragOptions.minDrag = 1;\n\n                zoomPrep(e, startX, startY);\n            }\n            else if(dragModeNow === 'pan') {\n                dragOptions.moveFn = plotDrag;\n                dragOptions.doneFn = dragDone;\n                clearSelect(zoomlayer);\n            }\n            else if(isSelectOrLasso(dragModeNow)) {\n                dragOptions.xaxes = xa;\n                dragOptions.yaxes = ya;\n                prepSelect(e, startX, startY, dragOptions, dragModeNow);\n            }\n        }\n    };\n\n    dragElement.init(dragOptions);\n\n    var x0,\n        y0,\n        box,\n        lum,\n        path0,\n        dimmed,\n        zoomMode,\n        zb,\n        corners;\n\n    function zoomPrep(e, startX, startY) {\n        var dragBBox = dragger.getBoundingClientRect();\n        x0 = startX - dragBBox.left;\n        y0 = startY - dragBBox.top;\n        box = {l: x0, r: x0, w: 0, t: y0, b: y0, h: 0};\n        lum = gd._hmpixcount ?\n            (gd._hmlumcount / gd._hmpixcount) :\n            tinycolor(gd._fullLayout.plot_bgcolor).getLuminance();\n        path0 = 'M0,0H' + pw + 'V' + ph + 'H0V0';\n        dimmed = false;\n        zoomMode = 'xy';\n\n        zb = makeZoombox(zoomlayer, lum, xs, ys, path0);\n\n        corners = makeCorners(zoomlayer, xs, ys);\n\n        clearSelect(zoomlayer);\n    }\n\n    function zoomMove(dx0, dy0) {\n        if(gd._transitioningWithDuration) {\n            return false;\n        }\n\n        var x1 = Math.max(0, Math.min(pw, dx0 + x0)),\n            y1 = Math.max(0, Math.min(ph, dy0 + y0)),\n            dx = Math.abs(x1 - x0),\n            dy = Math.abs(y1 - y0);\n\n        box.l = Math.min(x0, x1);\n        box.r = Math.max(x0, x1);\n        box.t = Math.min(y0, y1);\n        box.b = Math.max(y0, y1);\n\n        function noZoom() {\n            zoomMode = '';\n            box.r = box.l;\n            box.t = box.b;\n            corners.attr('d', 'M0,0Z');\n        }\n\n        if(isSubplotConstrained) {\n            if(dx > MINZOOM || dy > MINZOOM) {\n                zoomMode = 'xy';\n                if(dx / pw > dy / ph) {\n                    dy = dx * ph / pw;\n                    if(y0 > y1) box.t = y0 - dy;\n                    else box.b = y0 + dy;\n                }\n                else {\n                    dx = dy * pw / ph;\n                    if(x0 > x1) box.l = x0 - dx;\n                    else box.r = x0 + dx;\n                }\n                corners.attr('d', xyCorners(box));\n            }\n            else {\n                noZoom();\n            }\n        }\n        // look for small drags in one direction or the other,\n        // and only drag the other axis\n        else if(!yActive || dy < Math.min(Math.max(dx * 0.6, MINDRAG), MINZOOM)) {\n            if(dx < MINDRAG) {\n                noZoom();\n            }\n            else {\n                box.t = 0;\n                box.b = ph;\n                zoomMode = 'x';\n                corners.attr('d', xCorners(box, y0));\n            }\n        }\n        else if(!xActive || dx < Math.min(dy * 0.6, MINZOOM)) {\n            box.l = 0;\n            box.r = pw;\n            zoomMode = 'y';\n            corners.attr('d', yCorners(box, x0));\n        }\n        else {\n            zoomMode = 'xy';\n            corners.attr('d', xyCorners(box));\n        }\n        box.w = box.r - box.l;\n        box.h = box.b - box.t;\n\n        updateZoombox(zb, corners, box, path0, dimmed, lum);\n        dimmed = true;\n    }\n\n    function zoomDone(dragged, numClicks) {\n        if(Math.min(box.h, box.w) < MINDRAG * 2) {\n            if(numClicks === 2) doubleClick();\n\n            return removeZoombox(gd);\n        }\n\n        // TODO: edit linked axes in zoomAxRanges and in dragTail\n        if(zoomMode === 'xy' || zoomMode === 'x') zoomAxRanges(xa, box.l / pw, box.r / pw, xaLinked);\n        if(zoomMode === 'xy' || zoomMode === 'y') zoomAxRanges(ya, (ph - box.b) / ph, (ph - box.t) / ph, yaLinked);\n\n        removeZoombox(gd);\n        dragTail(zoomMode);\n\n        if(SHOWZOOMOUTTIP && gd.data && gd._context.showTips) {\n            Lib.notifier('Double-click to<br>zoom back out', 'long');\n            SHOWZOOMOUTTIP = false;\n        }\n    }\n\n    function dragDone(dragged, numClicks) {\n        var singleEnd = (ns + ew).length === 1;\n        if(dragged) dragTail();\n        else if(numClicks === 2 && !singleEnd) doubleClick();\n        else if(numClicks === 1 && singleEnd) {\n            var ax = ns ? ya[0] : xa[0],\n                end = (ns === 's' || ew === 'w') ? 0 : 1,\n                attrStr = ax._name + '.range[' + end + ']',\n                initialText = getEndText(ax, end),\n                hAlign = 'left',\n                vAlign = 'middle';\n\n            if(ax.fixedrange) return;\n\n            if(ns) {\n                vAlign = (ns === 'n') ? 'top' : 'bottom';\n                if(ax.side === 'right') hAlign = 'right';\n            }\n            else if(ew === 'e') hAlign = 'right';\n\n            if(gd._context.showAxisRangeEntryBoxes) {\n                d3.select(dragger)\n                    .call(svgTextUtils.makeEditable, null, {\n                        immediate: true,\n                        background: fullLayout.paper_bgcolor,\n                        text: String(initialText),\n                        fill: ax.tickfont ? ax.tickfont.color : '#444',\n                        horizontalAlign: hAlign,\n                        verticalAlign: vAlign\n                    })\n                    .on('edit', function(text) {\n                        var v = ax.d2r(text);\n                        if(v !== undefined) {\n                            Plotly.relayout(gd, attrStr, v);\n                        }\n                    });\n            }\n        }\n    }\n\n    // scroll zoom, on all draggers except corners\n    var scrollViewBox = [0, 0, pw, ph],\n        // wait a little after scrolling before redrawing\n        redrawTimer = null,\n        REDRAWDELAY = constants.REDRAWDELAY,\n        mainplot = plotinfo.mainplot ?\n            fullLayout._plots[plotinfo.mainplot] : plotinfo;\n\n    function zoomWheel(e) {\n        // deactivate mousewheel scrolling on embedded graphs\n        // devs can override this with layout._enablescrollzoom,\n        // but _ ensures this setting won't leave their page\n        if(!gd._context.scrollZoom && !fullLayout._enablescrollzoom) {\n            return;\n        }\n\n        // If a transition is in progress, then disable any behavior:\n        if(gd._transitioningWithDuration) {\n            return Lib.pauseEvent(e);\n        }\n\n        var pc = gd.querySelector('.plotly');\n\n        recomputeAxisLists();\n\n        // if the plot has scrollbars (more than a tiny excess)\n        // disable scrollzoom too.\n        if(pc.scrollHeight - pc.clientHeight > 10 ||\n                pc.scrollWidth - pc.clientWidth > 10) {\n            return;\n        }\n\n        clearTimeout(redrawTimer);\n\n        var wheelDelta = -e.deltaY;\n        if(!isFinite(wheelDelta)) wheelDelta = e.wheelDelta / 10;\n        if(!isFinite(wheelDelta)) {\n            Lib.log('Did not find wheel motion attributes: ', e);\n            return;\n        }\n\n        var zoom = Math.exp(-Math.min(Math.max(wheelDelta, -20), 20) / 100),\n            gbb = mainplot.draglayer.select('.nsewdrag')\n                .node().getBoundingClientRect(),\n            xfrac = (e.clientX - gbb.left) / gbb.width,\n            yfrac = (gbb.bottom - e.clientY) / gbb.height,\n            i;\n\n        function zoomWheelOneAxis(ax, centerFraction, zoom) {\n            if(ax.fixedrange) return;\n\n            var axRange = Lib.simpleMap(ax.range, ax.r2l),\n                v0 = axRange[0] + (axRange[1] - axRange[0]) * centerFraction;\n            function doZoom(v) { return ax.l2r(v0 + (v - v0) * zoom); }\n            ax.range = axRange.map(doZoom);\n        }\n\n        if(ew || isSubplotConstrained) {\n            // if we're only zooming this axis because of constraints,\n            // zoom it about the center\n            if(!ew) xfrac = 0.5;\n\n            for(i = 0; i < xa.length; i++) zoomWheelOneAxis(xa[i], xfrac, zoom);\n\n            scrollViewBox[2] *= zoom;\n            scrollViewBox[0] += scrollViewBox[2] * xfrac * (1 / zoom - 1);\n        }\n        if(ns || isSubplotConstrained) {\n            if(!ns) yfrac = 0.5;\n\n            for(i = 0; i < ya.length; i++) zoomWheelOneAxis(ya[i], yfrac, zoom);\n\n            scrollViewBox[3] *= zoom;\n            scrollViewBox[1] += scrollViewBox[3] * (1 - yfrac) * (1 / zoom - 1);\n        }\n\n        // viewbox redraw at first\n        updateSubplots(scrollViewBox);\n        ticksAndAnnotations(ns, ew);\n\n        // then replot after a delay to make sure\n        // no more scrolling is coming\n        redrawTimer = setTimeout(function() {\n            scrollViewBox = [0, 0, pw, ph];\n\n            var zoomMode;\n            if(isSubplotConstrained) zoomMode = 'xy';\n            else zoomMode = (ew ? 'x' : '') + (ns ? 'y' : '');\n\n            dragTail(zoomMode);\n        }, REDRAWDELAY);\n\n        return Lib.pauseEvent(e);\n    }\n\n    // everything but the corners gets wheel zoom\n    if(ns.length * ew.length !== 1) {\n        // still seems to be some confusion about onwheel vs onmousewheel...\n        if(dragger.onwheel !== undefined) dragger.onwheel = zoomWheel;\n        else if(dragger.onmousewheel !== undefined) dragger.onmousewheel = zoomWheel;\n    }\n\n    // plotDrag: move the plot in response to a drag\n    function plotDrag(dx, dy) {\n        // If a transition is in progress, then disable any behavior:\n        if(gd._transitioningWithDuration) {\n            return;\n        }\n\n        recomputeAxisLists();\n\n        if(xActive === 'ew' || yActive === 'ns') {\n            if(xActive) dragAxList(xa, dx);\n            if(yActive) dragAxList(ya, dy);\n            updateSubplots([xActive ? -dx : 0, yActive ? -dy : 0, pw, ph]);\n            ticksAndAnnotations(yActive, xActive);\n            return;\n        }\n\n        // dz: set a new value for one end (0 or 1) of an axis array axArray,\n        // and return a pixel shift for that end for the viewbox\n        // based on pixel drag distance d\n        // TODO: this makes (generally non-fatal) errors when you get\n        // near floating point limits\n        function dz(axArray, end, d) {\n            var otherEnd = 1 - end,\n                movedAx,\n                newLinearizedEnd;\n            for(var i = 0; i < axArray.length; i++) {\n                var axi = axArray[i];\n                if(axi.fixedrange) continue;\n                movedAx = axi;\n                newLinearizedEnd = axi._rl[otherEnd] +\n                    (axi._rl[end] - axi._rl[otherEnd]) / dZoom(d / axi._length);\n                var newEnd = axi.l2r(newLinearizedEnd);\n\n                // if l2r comes back false or undefined, it means we've dragged off\n                // the end of valid ranges - so stop.\n                if(newEnd !== false && newEnd !== undefined) axi.range[end] = newEnd;\n            }\n            return movedAx._length * (movedAx._rl[end] - newLinearizedEnd) /\n                (movedAx._rl[end] - movedAx._rl[otherEnd]);\n        }\n\n        if(isSubplotConstrained && xActive && yActive) {\n            // dragging a corner of a constrained subplot:\n            // respect the fixed corner, but harmonize dx and dy\n            var dxySign = ((xActive === 'w') === (yActive === 'n')) ? 1 : -1;\n            var dxyFraction = (dx / pw + dxySign * dy / ph) / 2;\n            dx = dxyFraction * pw;\n            dy = dxySign * dxyFraction * ph;\n        }\n\n        if(xActive === 'w') dx = dz(xa, 0, dx);\n        else if(xActive === 'e') dx = dz(xa, 1, -dx);\n        else if(!xActive) dx = 0;\n\n        if(yActive === 'n') dy = dz(ya, 1, dy);\n        else if(yActive === 's') dy = dz(ya, 0, -dy);\n        else if(!yActive) dy = 0;\n\n        var x0 = (xActive === 'w') ? dx : 0;\n        var y0 = (yActive === 'n') ? dy : 0;\n\n        if(isSubplotConstrained) {\n            var i;\n            if(!xActive && yActive.length === 1) {\n                // dragging one end of the y axis of a constrained subplot\n                // scale the other axis the same about its middle\n                for(i = 0; i < xa.length; i++) {\n                    xa[i].range = xa[i]._r.slice();\n                    scaleZoom(xa[i], 1 - dy / ph);\n                }\n                dx = dy * pw / ph;\n                x0 = dx / 2;\n            }\n            if(!yActive && xActive.length === 1) {\n                for(i = 0; i < ya.length; i++) {\n                    ya[i].range = ya[i]._r.slice();\n                    scaleZoom(ya[i], 1 - dx / pw);\n                }\n                dy = dx * ph / pw;\n                y0 = dy / 2;\n            }\n        }\n\n        updateSubplots([x0, y0, pw - dx, ph - dy]);\n        ticksAndAnnotations(yActive, xActive);\n    }\n\n    function ticksAndAnnotations(ns, ew) {\n        var activeAxIds = [],\n            i;\n\n        function pushActiveAxIds(axList) {\n            for(i = 0; i < axList.length; i++) {\n                if(!axList[i].fixedrange) activeAxIds.push(axList[i]._id);\n            }\n        }\n\n        if(ew || isSubplotConstrained) {\n            pushActiveAxIds(xa);\n            pushActiveAxIds(xaLinked);\n        }\n        if(ns || isSubplotConstrained) {\n            pushActiveAxIds(ya);\n            pushActiveAxIds(yaLinked);\n        }\n\n        for(i = 0; i < activeAxIds.length; i++) {\n            doTicks(gd, activeAxIds[i], true);\n        }\n\n        function redrawObjs(objArray, method, shortCircuit) {\n            for(i = 0; i < objArray.length; i++) {\n                var obji = objArray[i];\n\n                if((ew && activeAxIds.indexOf(obji.xref) !== -1) ||\n                    (ns && activeAxIds.indexOf(obji.yref) !== -1)) {\n                    method(gd, i);\n                    // once is enough for images (which doesn't use the `i` arg anyway)\n                    if(shortCircuit) return;\n                }\n            }\n        }\n\n        // annotations and shapes 'draw' method is slow,\n        // use the finer-grained 'drawOne' method instead\n\n        redrawObjs(fullLayout.annotations || [], Registry.getComponentMethod('annotations', 'drawOne'));\n        redrawObjs(fullLayout.shapes || [], Registry.getComponentMethod('shapes', 'drawOne'));\n        redrawObjs(fullLayout.images || [], Registry.getComponentMethod('images', 'draw'), true);\n    }\n\n    function doubleClick() {\n        if(gd._transitioningWithDuration) return;\n\n        var doubleClickConfig = gd._context.doubleClick,\n            axList = (xActive ? xa : []).concat(yActive ? ya : []),\n            attrs = {};\n\n        var ax, i, rangeInitial;\n\n        // For reset+autosize mode:\n        // If *any* of the main axes is not at its initial range\n        // (or autoranged, if we have no initial range, to match the logic in\n        // doubleClickConfig === 'reset' below), we reset.\n        // If they are *all* at their initial ranges, then we autosize.\n        if(doubleClickConfig === 'reset+autosize') {\n\n            doubleClickConfig = 'autosize';\n\n            for(i = 0; i < axList.length; i++) {\n                ax = axList[i];\n                if((ax._rangeInitial && (\n                        ax.range[0] !== ax._rangeInitial[0] ||\n                        ax.range[1] !== ax._rangeInitial[1]\n                    )) ||\n                    (!ax._rangeInitial && !ax.autorange)\n                ) {\n                    doubleClickConfig = 'reset';\n                    break;\n                }\n            }\n        }\n\n        if(doubleClickConfig === 'autosize') {\n            // don't set the linked axes here, so relayout marks them as shrinkable\n            // and we autosize just to the requested axis/axes\n            for(i = 0; i < axList.length; i++) {\n                ax = axList[i];\n                if(!ax.fixedrange) attrs[ax._name + '.autorange'] = true;\n            }\n        }\n        else if(doubleClickConfig === 'reset') {\n            // when we're resetting, reset all linked axes too, so we get back\n            // to the fully-auto-with-constraints situation\n            if(xActive || isSubplotConstrained) axList = axList.concat(xaLinked);\n            if(yActive && !isSubplotConstrained) axList = axList.concat(yaLinked);\n\n            if(isSubplotConstrained) {\n                if(!xActive) axList = axList.concat(xa);\n                else if(!yActive) axList = axList.concat(ya);\n            }\n\n            for(i = 0; i < axList.length; i++) {\n                ax = axList[i];\n\n                if(!ax._rangeInitial) {\n                    attrs[ax._name + '.autorange'] = true;\n                }\n                else {\n                    rangeInitial = ax._rangeInitial;\n                    attrs[ax._name + '.range[0]'] = rangeInitial[0];\n                    attrs[ax._name + '.range[1]'] = rangeInitial[1];\n                }\n            }\n        }\n\n        gd.emit('plotly_doubleclick', null);\n        Plotly.relayout(gd, attrs);\n    }\n\n    // dragTail - finish a drag event with a redraw\n    function dragTail(zoommode) {\n        if(zoommode === undefined) zoommode = (ew ? 'x' : '') + (ns ? 'y' : '');\n\n        var attrs = {};\n        // revert to the previous axis settings, then apply the new ones\n        // through relayout - this lets relayout manage undo/redo\n        var axesToModify;\n        if(zoommode === 'xy') axesToModify = xa.concat(ya);\n        else if(zoommode === 'x') axesToModify = xa;\n        else if(zoommode === 'y') axesToModify = ya;\n\n        for(var i = 0; i < axesToModify.length; i++) {\n            var axi = axesToModify[i];\n            if(axi._r[0] !== axi.range[0]) attrs[axi._name + '.range[0]'] = axi.range[0];\n            if(axi._r[1] !== axi.range[1]) attrs[axi._name + '.range[1]'] = axi.range[1];\n\n            axi.range = axi._input.range = axi._r.slice();\n        }\n\n        updateSubplots([0, 0, pw, ph]);\n        Plotly.relayout(gd, attrs);\n    }\n\n    // updateSubplots - find all plot viewboxes that should be\n    // affected by this drag, and update them. look for all plots\n    // sharing an affected axis (including the one being dragged)\n    function updateSubplots(viewBox) {\n        var plotinfos = fullLayout._plots;\n        var subplots = Object.keys(plotinfos);\n        var xScaleFactor = viewBox[2] / xa[0]._length;\n        var yScaleFactor = viewBox[3] / ya[0]._length;\n        var editX = ew || isSubplotConstrained;\n        var editY = ns || isSubplotConstrained;\n\n        var i, xScaleFactor2, yScaleFactor2, clipDx, clipDy;\n\n        // Find the appropriate scaling for this axis, if it's linked to the\n        // dragged axes by constraints. 0 is special, it means this axis shouldn't\n        // ever be scaled (will be converted to 1 if the other axis is scaled)\n        function getLinkedScaleFactor(ax) {\n            if(ax.fixedrange) return 0;\n\n            if(editX && xaLinked.indexOf(ax) !== -1) {\n                return xScaleFactor;\n            }\n            if(editY && (isSubplotConstrained ? xaLinked : yaLinked).indexOf(ax) !== -1) {\n                return yScaleFactor;\n            }\n            return 0;\n        }\n\n        function scaleAndGetShift(ax, scaleFactor) {\n            if(scaleFactor) {\n                ax.range = ax._r.slice();\n                scaleZoom(ax, scaleFactor);\n                return ax._length * (1 - scaleFactor) / 2;\n            }\n            return 0;\n        }\n\n        for(i = 0; i < subplots.length; i++) {\n\n            var subplot = plotinfos[subplots[i]],\n                xa2 = subplot.xaxis,\n                ya2 = subplot.yaxis,\n                editX2 = editX && !xa2.fixedrange && (xa.indexOf(xa2) !== -1),\n                editY2 = editY && !ya2.fixedrange && (ya.indexOf(ya2) !== -1);\n\n            if(editX2) {\n                xScaleFactor2 = xScaleFactor;\n                clipDx = viewBox[0];\n            }\n            else {\n                xScaleFactor2 = getLinkedScaleFactor(xa2);\n                clipDx = scaleAndGetShift(xa2, xScaleFactor2);\n            }\n\n            if(editY2) {\n                yScaleFactor2 = yScaleFactor;\n                clipDy = viewBox[1];\n            }\n            else {\n                yScaleFactor2 = getLinkedScaleFactor(ya2);\n                clipDy = scaleAndGetShift(ya2, yScaleFactor2);\n            }\n\n            // don't scale at all if neither axis is scalable here\n            if(!xScaleFactor2 && !yScaleFactor2) continue;\n\n            // but if only one is, reset the other axis scaling\n            if(!xScaleFactor2) xScaleFactor2 = 1;\n            if(!yScaleFactor2) yScaleFactor2 = 1;\n\n            var plotDx = xa2._offset - clipDx / xScaleFactor2,\n                plotDy = ya2._offset - clipDy / yScaleFactor2;\n\n            fullLayout._defs.selectAll('#' + subplot.clipId)\n                .call(Drawing.setTranslate, clipDx, clipDy)\n                .call(Drawing.setScale, xScaleFactor2, yScaleFactor2);\n\n            subplot.plot\n                .call(Drawing.setTranslate, plotDx, plotDy)\n                .call(Drawing.setScale, 1 / xScaleFactor2, 1 / yScaleFactor2)\n\n                // This is specifically directed at scatter traces, applying an inverse\n                // scale to individual points to counteract the scale of the trace\n                // as a whole:\n                .select('.scatterlayer').selectAll('.points').selectAll('.point')\n                    .call(Drawing.setPointGroupScale, xScaleFactor2, yScaleFactor2);\n        }\n    }\n\n    return dragger;\n};\n\nfunction makeDragger(plotinfo, dragClass, cursor, x, y, w, h) {\n    var dragger3 = plotinfo.draglayer.selectAll('.' + dragClass).data([0]);\n\n    dragger3.enter().append('rect')\n        .classed('drag', true)\n        .classed(dragClass, true)\n        .style({fill: 'transparent', 'stroke-width': 0})\n        .attr('data-subplot', plotinfo.id);\n\n    dragger3.call(Drawing.setRect, x, y, w, h)\n        .call(setCursor, cursor);\n\n    return dragger3.node();\n}\n\nfunction isDirectionActive(axList, activeVal) {\n    for(var i = 0; i < axList.length; i++) {\n        if(!axList[i].fixedrange) return activeVal;\n    }\n    return '';\n}\n\nfunction getEndText(ax, end) {\n    var initialVal = ax.range[end],\n        diff = Math.abs(initialVal - ax.range[1 - end]),\n        dig;\n\n    // TODO: this should basically be ax.r2d but we're doing extra\n    // rounding here... can we clean up at all?\n    if(ax.type === 'date') {\n        return initialVal;\n    }\n    else if(ax.type === 'log') {\n        dig = Math.ceil(Math.max(0, -Math.log(diff) / Math.LN10)) + 3;\n        return d3.format('.' + dig + 'g')(Math.pow(10, initialVal));\n    }\n    else { // linear numeric (or category... but just show numbers here)\n        dig = Math.floor(Math.log(Math.abs(initialVal)) / Math.LN10) -\n            Math.floor(Math.log(diff) / Math.LN10) + 4;\n        return d3.format('.' + String(dig) + 'g')(initialVal);\n    }\n}\n\nfunction zoomAxRanges(axList, r0Fraction, r1Fraction, linkedAxes) {\n    var i,\n        axi,\n        axRangeLinear0,\n        axRangeLinearSpan;\n\n    for(i = 0; i < axList.length; i++) {\n        axi = axList[i];\n        if(axi.fixedrange) continue;\n\n        axRangeLinear0 = axi._rl[0];\n        axRangeLinearSpan = axi._rl[1] - axRangeLinear0;\n        axi.range = [\n            axi.l2r(axRangeLinear0 + axRangeLinearSpan * r0Fraction),\n            axi.l2r(axRangeLinear0 + axRangeLinearSpan * r1Fraction)\n        ];\n    }\n\n    // zoom linked axes about their centers\n    if(linkedAxes && linkedAxes.length) {\n        var linkedR0Fraction = (r0Fraction + (1 - r1Fraction)) / 2;\n\n        zoomAxRanges(linkedAxes, linkedR0Fraction, 1 - linkedR0Fraction);\n    }\n}\n\nfunction dragAxList(axList, pix) {\n    for(var i = 0; i < axList.length; i++) {\n        var axi = axList[i];\n        if(!axi.fixedrange) {\n            axi.range = [\n                axi.l2r(axi._rl[0] - pix / axi._m),\n                axi.l2r(axi._rl[1] - pix / axi._m)\n            ];\n        }\n    }\n}\n\n// common transform for dragging one end of an axis\n// d>0 is compressing scale (cursor is over the plot,\n//  the axis end should move with the cursor)\n// d<0 is expanding (cursor is off the plot, axis end moves\n//  nonlinearly so you can expand far)\nfunction dZoom(d) {\n    return 1 - ((d >= 0) ? Math.min(d, 0.9) :\n        1 / (1 / Math.max(d, -0.3) + 3.222));\n}\n\nfunction getDragCursor(nsew, dragmode) {\n    if(!nsew) return 'pointer';\n    if(nsew === 'nsew') {\n        if(dragmode === 'pan') return 'move';\n        return 'crosshair';\n    }\n    return nsew.toLowerCase() + '-resize';\n}\n\nfunction makeZoombox(zoomlayer, lum, xs, ys, path0) {\n    return zoomlayer.append('path')\n        .attr('class', 'zoombox')\n        .style({\n            'fill': lum > 0.2 ? 'rgba(0,0,0,0)' : 'rgba(255,255,255,0)',\n            'stroke-width': 0\n        })\n        .attr('transform', 'translate(' + xs + ', ' + ys + ')')\n        .attr('d', path0 + 'Z');\n}\n\nfunction makeCorners(zoomlayer, xs, ys) {\n    return zoomlayer.append('path')\n        .attr('class', 'zoombox-corners')\n        .style({\n            fill: Color.background,\n            stroke: Color.defaultLine,\n            'stroke-width': 1,\n            opacity: 0\n        })\n        .attr('transform', 'translate(' + xs + ', ' + ys + ')')\n        .attr('d', 'M0,0Z');\n}\n\nfunction clearSelect(zoomlayer) {\n    // until we get around to persistent selections, remove the outline\n    // here. The selection itself will be removed when the plot redraws\n    // at the end.\n    zoomlayer.selectAll('.select-outline').remove();\n}\n\nfunction updateZoombox(zb, corners, box, path0, dimmed, lum) {\n    zb.attr('d',\n        path0 + 'M' + (box.l) + ',' + (box.t) + 'v' + (box.h) +\n        'h' + (box.w) + 'v-' + (box.h) + 'h-' + (box.w) + 'Z');\n    if(!dimmed) {\n        zb.transition()\n            .style('fill', lum > 0.2 ? 'rgba(0,0,0,0.4)' :\n                'rgba(255,255,255,0.3)')\n            .duration(200);\n        corners.transition()\n            .style('opacity', 1)\n            .duration(200);\n    }\n}\n\nfunction removeZoombox(gd) {\n    d3.select(gd)\n        .selectAll('.zoombox,.js-zoombox-backdrop,.js-zoombox-menu,.zoombox-corners')\n        .remove();\n}\n\nfunction isSelectOrLasso(dragmode) {\n    var modes = ['lasso', 'select'];\n\n    return modes.indexOf(dragmode) !== -1;\n}\n\nfunction xCorners(box, y0) {\n    return 'M' +\n        (box.l - 0.5) + ',' + (y0 - MINZOOM - 0.5) +\n        'h-3v' + (2 * MINZOOM + 1) + 'h3ZM' +\n        (box.r + 0.5) + ',' + (y0 - MINZOOM - 0.5) +\n        'h3v' + (2 * MINZOOM + 1) + 'h-3Z';\n}\n\nfunction yCorners(box, x0) {\n    return 'M' +\n        (x0 - MINZOOM - 0.5) + ',' + (box.t - 0.5) +\n        'v-3h' + (2 * MINZOOM + 1) + 'v3ZM' +\n        (x0 - MINZOOM - 0.5) + ',' + (box.b + 0.5) +\n        'v3h' + (2 * MINZOOM + 1) + 'v-3Z';\n}\n\nfunction xyCorners(box) {\n    var clen = Math.floor(Math.min(box.b - box.t, box.r - box.l, MINZOOM) / 2);\n    return 'M' +\n        (box.l - 3.5) + ',' + (box.t - 0.5 + clen) + 'h3v' + (-clen) +\n            'h' + clen + 'v-3h-' + (clen + 3) + 'ZM' +\n        (box.r + 3.5) + ',' + (box.t - 0.5 + clen) + 'h-3v' + (-clen) +\n            'h' + (-clen) + 'v-3h' + (clen + 3) + 'ZM' +\n        (box.r + 3.5) + ',' + (box.b + 0.5 - clen) + 'h-3v' + clen +\n            'h' + (-clen) + 'v3h' + (clen + 3) + 'ZM' +\n        (box.l - 3.5) + ',' + (box.b + 0.5 - clen) + 'h3v' + clen +\n            'h' + clen + 'v3h-' + (clen + 3) + 'Z';\n}\n\nfunction calcLinks(constraintGroups, xIDs, yIDs) {\n    var isSubplotConstrained = false;\n    var xLinks = {};\n    var yLinks = {};\n    var i, j, k;\n\n    var group, xLinkID, yLinkID;\n    for(i = 0; i < constraintGroups.length; i++) {\n        group = constraintGroups[i];\n        // check if any of the x axes we're dragging is in this constraint group\n        for(j = 0; j < xIDs.length; j++) {\n            if(group[xIDs[j]]) {\n                // put the rest of these axes into xLinks, if we're not already\n                // dragging them, so we know to scale these axes automatically too\n                // to match the changes in the dragged x axes\n                for(xLinkID in group) {\n                    if((xLinkID.charAt(0) === 'x' ? xIDs : yIDs).indexOf(xLinkID) === -1) {\n                        xLinks[xLinkID] = 1;\n                    }\n                }\n\n                // check if the x and y axes of THIS drag are linked\n                for(k = 0; k < yIDs.length; k++) {\n                    if(group[yIDs[k]]) isSubplotConstrained = true;\n                }\n            }\n        }\n\n        // now check if any of the y axes we're dragging is in this constraint group\n        // only look for outside links, as we've already checked for links within the dragger\n        for(j = 0; j < yIDs.length; j++) {\n            if(group[yIDs[j]]) {\n                for(yLinkID in group) {\n                    if((yLinkID.charAt(0) === 'x' ? xIDs : yIDs).indexOf(yLinkID) === -1) {\n                        yLinks[yLinkID] = 1;\n                    }\n                }\n            }\n        }\n    }\n\n    if(isSubplotConstrained) {\n        // merge xLinks and yLinks if the subplot is constrained,\n        // since we'll always apply both anyway and the two will contain\n        // duplicates\n        Lib.extendFlat(xLinks, yLinks);\n        yLinks = {};\n    }\n    return {\n        x: xLinks,\n        y: yLinks,\n        xy: isSubplotConstrained\n    };\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/cartesian/select.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar polygon = require('../../lib/polygon');\nvar color = require('../../components/color');\n\nvar axes = require('./axes');\nvar constants = require('./constants');\n\nvar filteredPolygon = polygon.filter;\nvar polygonTester = polygon.tester;\nvar MINSELECT = constants.MINSELECT;\n\nfunction getAxId(ax) { return ax._id; }\n\nmodule.exports = function prepSelect(e, startX, startY, dragOptions, mode) {\n    var plot = dragOptions.gd._fullLayout._zoomlayer,\n        dragBBox = dragOptions.element.getBoundingClientRect(),\n        xs = dragOptions.plotinfo.xaxis._offset,\n        ys = dragOptions.plotinfo.yaxis._offset,\n        x0 = startX - dragBBox.left,\n        y0 = startY - dragBBox.top,\n        x1 = x0,\n        y1 = y0,\n        path0 = 'M' + x0 + ',' + y0,\n        pw = dragOptions.xaxes[0]._length,\n        ph = dragOptions.yaxes[0]._length,\n        xAxisIds = dragOptions.xaxes.map(getAxId),\n        yAxisIds = dragOptions.yaxes.map(getAxId),\n        allAxes = dragOptions.xaxes.concat(dragOptions.yaxes),\n        pts;\n\n    if(mode === 'lasso') {\n        pts = filteredPolygon([[x0, y0]], constants.BENDPX);\n    }\n\n    var outlines = plot.selectAll('path.select-outline').data([1, 2]);\n\n    outlines.enter()\n        .append('path')\n        .attr('class', function(d) { return 'select-outline select-outline-' + d; })\n        .attr('transform', 'translate(' + xs + ', ' + ys + ')')\n        .attr('d', path0 + 'Z');\n\n    var corners = plot.append('path')\n        .attr('class', 'zoombox-corners')\n        .style({\n            fill: color.background,\n            stroke: color.defaultLine,\n            'stroke-width': 1\n        })\n        .attr('transform', 'translate(' + xs + ', ' + ys + ')')\n        .attr('d', 'M0,0Z');\n\n\n    // find the traces to search for selection points\n    var searchTraces = [],\n        gd = dragOptions.gd,\n        i,\n        cd,\n        trace,\n        searchInfo,\n        selection = [],\n        eventData;\n    for(i = 0; i < gd.calcdata.length; i++) {\n        cd = gd.calcdata[i];\n        trace = cd[0].trace;\n        if(!trace._module || !trace._module.selectPoints) continue;\n\n        if(dragOptions.subplot) {\n            if(trace.subplot !== dragOptions.subplot) continue;\n\n            searchTraces.push({\n                selectPoints: trace._module.selectPoints,\n                cd: cd,\n                xaxis: dragOptions.xaxes[0],\n                yaxis: dragOptions.yaxes[0]\n            });\n        }\n        else {\n            if(xAxisIds.indexOf(trace.xaxis) === -1) continue;\n            if(yAxisIds.indexOf(trace.yaxis) === -1) continue;\n\n            searchTraces.push({\n                selectPoints: trace._module.selectPoints,\n                cd: cd,\n                xaxis: axes.getFromId(gd, trace.xaxis),\n                yaxis: axes.getFromId(gd, trace.yaxis)\n            });\n        }\n    }\n\n    function axValue(ax) {\n        var index = (ax._id.charAt(0) === 'y') ? 1 : 0;\n        return function(v) { return ax.p2d(v[index]); };\n    }\n\n    function ascending(a, b) { return a - b; }\n\n    dragOptions.moveFn = function(dx0, dy0) {\n        var poly,\n            ax;\n        x1 = Math.max(0, Math.min(pw, dx0 + x0));\n        y1 = Math.max(0, Math.min(ph, dy0 + y0));\n\n        var dx = Math.abs(x1 - x0),\n            dy = Math.abs(y1 - y0);\n\n        if(mode === 'select') {\n            if(dy < Math.min(dx * 0.6, MINSELECT)) {\n                // horizontal motion: make a vertical box\n                poly = polygonTester([[x0, 0], [x0, ph], [x1, ph], [x1, 0]]);\n                // extras to guide users in keeping a straight selection\n                corners.attr('d', 'M' + poly.xmin + ',' + (y0 - MINSELECT) +\n                    'h-4v' + (2 * MINSELECT) + 'h4Z' +\n                    'M' + (poly.xmax - 1) + ',' + (y0 - MINSELECT) +\n                    'h4v' + (2 * MINSELECT) + 'h-4Z');\n\n            }\n            else if(dx < Math.min(dy * 0.6, MINSELECT)) {\n                // vertical motion: make a horizontal box\n                poly = polygonTester([[0, y0], [0, y1], [pw, y1], [pw, y0]]);\n                corners.attr('d', 'M' + (x0 - MINSELECT) + ',' + poly.ymin +\n                    'v-4h' + (2 * MINSELECT) + 'v4Z' +\n                    'M' + (x0 - MINSELECT) + ',' + (poly.ymax - 1) +\n                    'v4h' + (2 * MINSELECT) + 'v-4Z');\n            }\n            else {\n                // diagonal motion\n                poly = polygonTester([[x0, y0], [x0, y1], [x1, y1], [x1, y0]]);\n                corners.attr('d', 'M0,0Z');\n            }\n            outlines.attr('d', 'M' + poly.xmin + ',' + poly.ymin +\n                'H' + (poly.xmax - 1) + 'V' + (poly.ymax - 1) +\n                'H' + poly.xmin + 'Z');\n        }\n        else if(mode === 'lasso') {\n            pts.addPt([x1, y1]);\n            poly = polygonTester(pts.filtered);\n            outlines.attr('d', 'M' + pts.filtered.join('L') + 'Z');\n        }\n\n        selection = [];\n        for(i = 0; i < searchTraces.length; i++) {\n            searchInfo = searchTraces[i];\n            [].push.apply(selection, searchInfo.selectPoints(searchInfo, poly));\n        }\n\n        eventData = {points: selection};\n\n        if(mode === 'select') {\n            var ranges = eventData.range = {},\n                axLetter;\n\n            for(i = 0; i < allAxes.length; i++) {\n                ax = allAxes[i];\n                axLetter = ax._id.charAt(0);\n                ranges[ax._id] = [\n                    ax.p2d(poly[axLetter + 'min']),\n                    ax.p2d(poly[axLetter + 'max'])].sort(ascending);\n            }\n        }\n        else {\n            var dataPts = eventData.lassoPoints = {};\n\n            for(i = 0; i < allAxes.length; i++) {\n                ax = allAxes[i];\n                dataPts[ax._id] = pts.filtered.map(axValue(ax));\n            }\n        }\n        dragOptions.gd.emit('plotly_selecting', eventData);\n    };\n\n    dragOptions.doneFn = function(dragged, numclicks) {\n        corners.remove();\n        if(!dragged && numclicks === 2) {\n            // clear selection on doubleclick\n            outlines.remove();\n            for(i = 0; i < searchTraces.length; i++) {\n                searchInfo = searchTraces[i];\n                searchInfo.selectPoints(searchInfo, false);\n            }\n\n            gd.emit('plotly_deselect', null);\n        }\n        else {\n            dragOptions.gd.emit('plotly_selected', eventData);\n        }\n    };\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/lib/polygon.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar dot = require('./matrix').dot;\n\nvar polygon = module.exports = {};\n\n/**\n * Turn an array of [x, y] pairs into a polygon object\n * that can test if points are inside it\n *\n * @param ptsIn Array of [x, y] pairs\n *\n * @returns polygon Object {xmin, xmax, ymin, ymax, pts, contains}\n *      (x|y)(min|max) are the bounding rect of the polygon\n *      pts is the original array, with the first pair repeated at the end\n *      contains is a function: (pt, omitFirstEdge)\n *          pt is the [x, y] pair to test\n *          omitFirstEdge truthy means points exactly on the first edge don't\n *              count. This is for use adding one polygon to another so we\n *              don't double-count the edge where they meet.\n *          returns boolean: is pt inside the polygon (including on its edges)\n */\npolygon.tester = function tester(ptsIn) {\n    var pts = ptsIn.slice(),\n        xmin = pts[0][0],\n        xmax = xmin,\n        ymin = pts[0][1],\n        ymax = ymin;\n\n    pts.push(pts[0]);\n    for(var i = 1; i < pts.length; i++) {\n        xmin = Math.min(xmin, pts[i][0]);\n        xmax = Math.max(xmax, pts[i][0]);\n        ymin = Math.min(ymin, pts[i][1]);\n        ymax = Math.max(ymax, pts[i][1]);\n    }\n\n    // do we have a rectangle? Handle this here, so we can use the same\n    // tester for the rectangular case without sacrificing speed\n\n    var isRect = false,\n        rectFirstEdgeTest;\n\n    if(pts.length === 5) {\n        if(pts[0][0] === pts[1][0]) { // vert, horz, vert, horz\n            if(pts[2][0] === pts[3][0] &&\n                    pts[0][1] === pts[3][1] &&\n                    pts[1][1] === pts[2][1]) {\n                isRect = true;\n                rectFirstEdgeTest = function(pt) { return pt[0] === pts[0][0]; };\n            }\n        }\n        else if(pts[0][1] === pts[1][1]) { // horz, vert, horz, vert\n            if(pts[2][1] === pts[3][1] &&\n                    pts[0][0] === pts[3][0] &&\n                    pts[1][0] === pts[2][0]) {\n                isRect = true;\n                rectFirstEdgeTest = function(pt) { return pt[1] === pts[0][1]; };\n            }\n        }\n    }\n\n    function rectContains(pt, omitFirstEdge) {\n        var x = pt[0],\n            y = pt[1];\n\n        if(x < xmin || x > xmax || y < ymin || y > ymax) {\n            // pt is outside the bounding box of polygon\n            return false;\n        }\n        if(omitFirstEdge && rectFirstEdgeTest(pt)) return false;\n\n        return true;\n    }\n\n    function contains(pt, omitFirstEdge) {\n        var x = pt[0],\n            y = pt[1];\n\n        if(x < xmin || x > xmax || y < ymin || y > ymax) {\n            // pt is outside the bounding box of polygon\n            return false;\n        }\n\n        var imax = pts.length,\n            x1 = pts[0][0],\n            y1 = pts[0][1],\n            crossings = 0,\n            i,\n            x0,\n            y0,\n            xmini,\n            ycross;\n\n        for(i = 1; i < imax; i++) {\n            // find all crossings of a vertical line upward from pt with\n            // polygon segments\n            // crossings exactly at xmax don't count, unless the point is\n            // exactly on the segment, then it counts as inside.\n            x0 = x1;\n            y0 = y1;\n            x1 = pts[i][0];\n            y1 = pts[i][1];\n            xmini = Math.min(x0, x1);\n\n            // outside the bounding box of this segment, it's only a crossing\n            // if it's below the box.\n            if(x < xmini || x > Math.max(x0, x1) || y > Math.max(y0, y1)) {\n                continue;\n            }\n            else if(y < Math.min(y0, y1)) {\n                // don't count the left-most point of the segment as a crossing\n                // because we don't want to double-count adjacent crossings\n                // UNLESS the polygon turns past vertical at exactly this x\n                // Note that this is repeated below, but we can't factor it out\n                // because\n                if(x !== xmini) crossings++;\n            }\n            // inside the bounding box, check the actual line intercept\n            else {\n                // vertical segment - we know already that the point is exactly\n                // on the segment, so mark the crossing as exactly at the point.\n                if(x1 === x0) ycross = y;\n                // any other angle\n                else ycross = y0 + (x - x0) * (y1 - y0) / (x1 - x0);\n\n                // exactly on the edge: counts as inside the polygon, unless it's the\n                // first edge and we're omitting it.\n                if(y === ycross) {\n                    if(i === 1 && omitFirstEdge) return false;\n                    return true;\n                }\n\n                if(y <= ycross && x !== xmini) crossings++;\n            }\n        }\n\n        // if we've gotten this far, odd crossings means inside, even is outside\n        return crossings % 2 === 1;\n    }\n\n    return {\n        xmin: xmin,\n        xmax: xmax,\n        ymin: ymin,\n        ymax: ymax,\n        pts: pts,\n        contains: isRect ? rectContains : contains,\n        isRect: isRect\n    };\n};\n\n/**\n * Test if a segment of a points array is bent or straight\n *\n * @param pts Array of [x, y] pairs\n * @param start the index of the proposed start of the straight section\n * @param end the index of the proposed end point\n * @param tolerance the max distance off the line connecting start and end\n *      before the line counts as bent\n * @returns boolean: true means this segment is bent, false means straight\n */\nvar isBent = polygon.isSegmentBent = function isBent(pts, start, end, tolerance) {\n    var startPt = pts[start],\n        segment = [pts[end][0] - startPt[0], pts[end][1] - startPt[1]],\n        segmentSquared = dot(segment, segment),\n        segmentLen = Math.sqrt(segmentSquared),\n        unitPerp = [-segment[1] / segmentLen, segment[0] / segmentLen],\n        i,\n        part,\n        partParallel;\n\n    for(i = start + 1; i < end; i++) {\n        part = [pts[i][0] - startPt[0], pts[i][1] - startPt[1]];\n        partParallel = dot(part, segment);\n\n        if(partParallel < 0 || partParallel > segmentSquared ||\n            Math.abs(dot(part, unitPerp)) > tolerance) return true;\n    }\n    return false;\n};\n\n/**\n * Make a filtering polygon, to minimize the number of segments\n *\n * @param pts Array of [x, y] pairs (must start with at least 1 pair)\n * @param tolerance the maximum deviation from straight allowed for\n *      removing points to simplify the polygon\n *\n * @returns Object {addPt, raw, filtered}\n *      addPt is a function(pt: [x, y] pair) to add a raw point and\n *          continue filtering\n *      raw is all the input points\n *      filtered is the resulting filtered Array of [x, y] pairs\n */\npolygon.filter = function filter(pts, tolerance) {\n    var ptsFiltered = [pts[0]],\n        doneRawIndex = 0,\n        doneFilteredIndex = 0;\n\n    function addPt(pt) {\n        pts.push(pt);\n        var prevFilterLen = ptsFiltered.length,\n            iLast = doneRawIndex;\n        ptsFiltered.splice(doneFilteredIndex + 1);\n\n        for(var i = iLast + 1; i < pts.length; i++) {\n            if(i === pts.length - 1 || isBent(pts, iLast, i + 1, tolerance)) {\n                ptsFiltered.push(pts[i]);\n                if(ptsFiltered.length < prevFilterLen - 2) {\n                    doneRawIndex = i;\n                    doneFilteredIndex = ptsFiltered.length - 1;\n                }\n                iLast = i;\n            }\n        }\n    }\n\n    if(pts.length > 1) {\n        var lastPt = pts.pop();\n        addPt(lastPt);\n    }\n\n    return {\n        addPt: addPt,\n        raw: pts,\n        filtered: ptsFiltered\n    };\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/cartesian/scale_zoom.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nmodule.exports = function scaleZoom(ax, factor, centerFraction) {\n    if(centerFraction === undefined) centerFraction = 0.5;\n\n    var rangeLinear = [ax.r2l(ax.range[0]), ax.r2l(ax.range[1])];\n    var center = rangeLinear[0] + (rangeLinear[1] - rangeLinear[0]) * centerFraction;\n    var newHalfSpan = (center - rangeLinear[0]) * factor;\n\n    ax.range = ax._input.range = [\n        ax.l2r(center - newHalfSpan),\n        ax.l2r(center + newHalfSpan)\n    ];\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/modebar/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nexports.manage = require('./manage');\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/modebar/manage.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Axes = require('../../plots/cartesian/axes');\nvar scatterSubTypes = require('../../traces/scatter/subtypes');\n\nvar createModeBar = require('./modebar');\nvar modeBarButtons = require('./buttons');\n\n/**\n * ModeBar wrapper around 'create' and 'update',\n * chooses buttons to pass to ModeBar constructor based on\n * plot type and plot config.\n *\n * @param {object} gd main plot object\n *\n */\nmodule.exports = function manageModeBar(gd) {\n    var fullLayout = gd._fullLayout,\n        context = gd._context,\n        modeBar = fullLayout._modeBar;\n\n    if(!context.displayModeBar) {\n        if(modeBar) {\n            modeBar.destroy();\n            delete fullLayout._modeBar;\n        }\n        return;\n    }\n\n    if(!Array.isArray(context.modeBarButtonsToRemove)) {\n        throw new Error([\n            '*modeBarButtonsToRemove* configuration options',\n            'must be an array.'\n        ].join(' '));\n    }\n\n    if(!Array.isArray(context.modeBarButtonsToAdd)) {\n        throw new Error([\n            '*modeBarButtonsToAdd* configuration options',\n            'must be an array.'\n        ].join(' '));\n    }\n\n    var customButtons = context.modeBarButtons;\n    var buttonGroups;\n\n    if(Array.isArray(customButtons) && customButtons.length) {\n        buttonGroups = fillCustomButton(customButtons);\n    }\n    else {\n        buttonGroups = getButtonGroups(\n            gd,\n            context.modeBarButtonsToRemove,\n            context.modeBarButtonsToAdd\n        );\n    }\n\n    if(modeBar) modeBar.update(gd, buttonGroups);\n    else fullLayout._modeBar = createModeBar(gd, buttonGroups);\n};\n\n// logic behind which buttons are displayed by default\nfunction getButtonGroups(gd, buttonsToRemove, buttonsToAdd) {\n    var fullLayout = gd._fullLayout,\n        fullData = gd._fullData;\n\n    var hasCartesian = fullLayout._has('cartesian'),\n        hasGL3D = fullLayout._has('gl3d'),\n        hasGeo = fullLayout._has('geo'),\n        hasPie = fullLayout._has('pie'),\n        hasGL2D = fullLayout._has('gl2d'),\n        hasTernary = fullLayout._has('ternary');\n\n    var groups = [];\n\n    function addGroup(newGroup) {\n        var out = [];\n\n        for(var i = 0; i < newGroup.length; i++) {\n            var button = newGroup[i];\n            if(buttonsToRemove.indexOf(button) !== -1) continue;\n            out.push(modeBarButtons[button]);\n        }\n\n        groups.push(out);\n    }\n\n    // buttons common to all plot types\n    addGroup(['toImage', 'sendDataToCloud']);\n\n    // graphs with more than one plot types get 'union buttons'\n    // which reset the view or toggle hover labels across all subplots.\n    if((hasCartesian || hasGL2D || hasPie || hasTernary) + hasGeo + hasGL3D > 1) {\n        addGroup(['resetViews', 'toggleHover']);\n        return appendButtonsToGroups(groups, buttonsToAdd);\n    }\n\n    if(hasGL3D) {\n        addGroup(['zoom3d', 'pan3d', 'orbitRotation', 'tableRotation']);\n        addGroup(['resetCameraDefault3d', 'resetCameraLastSave3d']);\n        addGroup(['hoverClosest3d']);\n    }\n\n    if(hasGeo) {\n        addGroup(['zoomInGeo', 'zoomOutGeo', 'resetGeo']);\n        addGroup(['hoverClosestGeo']);\n    }\n\n    var allAxesFixed = areAllAxesFixed(fullLayout),\n        dragModeGroup = [];\n\n    if(((hasCartesian || hasGL2D) && !allAxesFixed) || hasTernary) {\n        dragModeGroup = ['zoom2d', 'pan2d'];\n    }\n    if((hasCartesian || hasTernary) && isSelectable(fullData)) {\n        dragModeGroup.push('select2d');\n        dragModeGroup.push('lasso2d');\n    }\n    if(dragModeGroup.length) addGroup(dragModeGroup);\n\n    if((hasCartesian || hasGL2D) && !allAxesFixed && !hasTernary) {\n        addGroup(['zoomIn2d', 'zoomOut2d', 'autoScale2d', 'resetScale2d']);\n    }\n\n    if(hasCartesian && hasPie) {\n        addGroup(['toggleHover']);\n    }\n    else if(hasGL2D) {\n        addGroup(['hoverClosestGl2d']);\n    }\n    else if(hasCartesian) {\n        addGroup(['toggleSpikelines', 'hoverClosestCartesian', 'hoverCompareCartesian']);\n    }\n    else if(hasPie) {\n        addGroup(['hoverClosestPie']);\n    }\n\n    return appendButtonsToGroups(groups, buttonsToAdd);\n}\n\nfunction areAllAxesFixed(fullLayout) {\n    var axList = Axes.list({_fullLayout: fullLayout}, null, true);\n    var allFixed = true;\n\n    for(var i = 0; i < axList.length; i++) {\n        if(!axList[i].fixedrange) {\n            allFixed = false;\n            break;\n        }\n    }\n\n    return allFixed;\n}\n\n// look for traces that support selection\n// to be updated as we add more selectPoints handlers\nfunction isSelectable(fullData) {\n    var selectable = false;\n\n    for(var i = 0; i < fullData.length; i++) {\n        if(selectable) break;\n\n        var trace = fullData[i];\n\n        if(!trace._module || !trace._module.selectPoints) continue;\n\n        if(trace.type === 'scatter' || trace.type === 'scatterternary') {\n            if(scatterSubTypes.hasMarkers(trace) || scatterSubTypes.hasText(trace)) {\n                selectable = true;\n            }\n        }\n        // assume that in general if the trace module has selectPoints,\n        // then it's selectable. Scatter is an exception to this because it must\n        // have markers or text, not just be a scatter type.\n        else selectable = true;\n    }\n\n    return selectable;\n}\n\nfunction appendButtonsToGroups(groups, buttons) {\n    if(buttons.length) {\n        if(Array.isArray(buttons[0])) {\n            for(var i = 0; i < buttons.length; i++) {\n                groups.push(buttons[i]);\n            }\n        }\n        else groups.push(buttons);\n    }\n\n    return groups;\n}\n\n// fill in custom buttons referring to default mode bar buttons\nfunction fillCustomButton(customButtons) {\n    for(var i = 0; i < customButtons.length; i++) {\n        var buttonGroup = customButtons[i];\n\n        for(var j = 0; j < buttonGroup.length; j++) {\n            var button = buttonGroup[j];\n\n            if(typeof button === 'string') {\n                if(modeBarButtons[button] !== undefined) {\n                    customButtons[i][j] = modeBarButtons[button];\n                }\n                else {\n                    throw new Error([\n                        '*modeBarButtons* configuration options',\n                        'invalid button name'\n                    ].join(' '));\n                }\n            }\n        }\n    }\n\n    return customButtons;\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/modebar/modebar.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\n\nvar Lib = require('../../lib');\nvar Icons = require('../../../build/ploticon');\n\n\n/**\n * UI controller for interactive plots\n * @Class\n * @Param {object} opts\n * @Param {object} opts.buttons    nested arrays of grouped buttons config objects\n * @Param {object} opts.container  container div to append modeBar\n * @Param {object} opts.graphInfo  primary plot object containing data and layout\n */\nfunction ModeBar(opts) {\n    this.container = opts.container;\n    this.element = document.createElement('div');\n\n    this.update(opts.graphInfo, opts.buttons);\n\n    this.container.appendChild(this.element);\n}\n\nvar proto = ModeBar.prototype;\n\n/**\n * Update modeBar (buttons and logo)\n *\n * @param {object} graphInfo  primary plot object containing data and layout\n * @param {array of arrays} buttons nested arrays of grouped buttons to initialize\n *\n */\nproto.update = function(graphInfo, buttons) {\n    this.graphInfo = graphInfo;\n\n    var context = this.graphInfo._context;\n\n    if(context.displayModeBar === 'hover') {\n        this.element.className = 'modebar modebar--hover';\n    }\n    else this.element.className = 'modebar';\n\n    // if buttons or logo have changed, redraw modebar interior\n    var needsNewButtons = !this.hasButtons(buttons),\n        needsNewLogo = (this.hasLogo !== context.displaylogo);\n\n    if(needsNewButtons || needsNewLogo) {\n        this.removeAllButtons();\n\n        this.updateButtons(buttons);\n\n        if(context.displaylogo) {\n            this.element.appendChild(this.getLogo());\n            this.hasLogo = true;\n        }\n    }\n\n    this.updateActiveButton();\n};\n\nproto.updateButtons = function(buttons) {\n    var _this = this;\n\n    this.buttons = buttons;\n    this.buttonElements = [];\n    this.buttonsNames = [];\n\n    this.buttons.forEach(function(buttonGroup) {\n        var group = _this.createGroup();\n\n        buttonGroup.forEach(function(buttonConfig) {\n            var buttonName = buttonConfig.name;\n            if(!buttonName) {\n                throw new Error('must provide button \\'name\\' in button config');\n            }\n            if(_this.buttonsNames.indexOf(buttonName) !== -1) {\n                throw new Error('button name \\'' + buttonName + '\\' is taken');\n            }\n            _this.buttonsNames.push(buttonName);\n\n            var button = _this.createButton(buttonConfig);\n            _this.buttonElements.push(button);\n            group.appendChild(button);\n        });\n\n        _this.element.appendChild(group);\n    });\n};\n\n/**\n * Empty div for containing a group of buttons\n * @Return {HTMLelement}\n */\nproto.createGroup = function() {\n    var group = document.createElement('div');\n    group.className = 'modebar-group';\n\n    return group;\n};\n\n/**\n * Create a new button div and set constant and configurable attributes\n * @Param {object} config (see ./buttons.js for more info)\n * @Return {HTMLelement}\n */\nproto.createButton = function(config) {\n    var _this = this,\n        button = document.createElement('a');\n\n    button.setAttribute('rel', 'tooltip');\n    button.className = 'modebar-btn';\n\n    var title = config.title;\n    if(title === undefined) title = config.name;\n    if(title || title === 0) button.setAttribute('data-title', title);\n\n    if(config.attr !== undefined) button.setAttribute('data-attr', config.attr);\n\n    var val = config.val;\n    if(val !== undefined) {\n        if(typeof val === 'function') val = val(this.graphInfo);\n        button.setAttribute('data-val', val);\n    }\n\n    var click = config.click;\n    if(typeof click !== 'function') {\n        throw new Error('must provide button \\'click\\' function in button config');\n    }\n    else {\n        button.addEventListener('click', function(ev) {\n            config.click(_this.graphInfo, ev);\n\n            // only needed for 'hoverClosestGeo' which does not call relayout\n            _this.updateActiveButton(ev.currentTarget);\n        });\n    }\n\n    button.setAttribute('data-toggle', config.toggle || false);\n    if(config.toggle) d3.select(button).classed('active', true);\n\n    button.appendChild(this.createIcon(config.icon || Icons.question, config.name));\n    button.setAttribute('data-gravity', config.gravity || 'n');\n\n    return button;\n};\n\n/**\n * Add an icon to a button\n * @Param {object} thisIcon\n * @Param {number} thisIcon.width\n * @Param {string} thisIcon.path\n * @Return {HTMLelement}\n */\nproto.createIcon = function(thisIcon, name) {\n    var iconHeight = thisIcon.ascent - thisIcon.descent,\n        svgNS = 'http://www.w3.org/2000/svg',\n        icon = document.createElementNS(svgNS, 'svg'),\n        path = document.createElementNS(svgNS, 'path');\n\n    icon.setAttribute('height', '1em');\n    icon.setAttribute('width', (thisIcon.width / iconHeight) + 'em');\n    icon.setAttribute('viewBox', [0, 0, thisIcon.width, iconHeight].join(' '));\n\n    var transform = name === 'toggleSpikelines' ?\n        'matrix(1.5 0 0 -1.5 0 ' + thisIcon.ascent + ')' :\n        'matrix(1 0 0 -1 0 ' + thisIcon.ascent + ')';\n\n    path.setAttribute('d', thisIcon.path);\n    path.setAttribute('transform', transform);\n    icon.appendChild(path);\n\n    return icon;\n};\n\n/**\n * Updates active button with attribute specified in layout\n * @Param {object} graphInfo plot object containing data and layout\n * @Return {HTMLelement}\n */\nproto.updateActiveButton = function(buttonClicked) {\n    var fullLayout = this.graphInfo._fullLayout,\n        dataAttrClicked = (buttonClicked !== undefined) ?\n            buttonClicked.getAttribute('data-attr') :\n            null;\n\n    this.buttonElements.forEach(function(button) {\n        var thisval = button.getAttribute('data-val') || true,\n            dataAttr = button.getAttribute('data-attr'),\n            isToggleButton = (button.getAttribute('data-toggle') === 'true'),\n            button3 = d3.select(button);\n\n        // Use 'data-toggle' and 'buttonClicked' to toggle buttons\n        // that have no one-to-one equivalent in fullLayout\n        if(isToggleButton) {\n            if(dataAttr === dataAttrClicked) {\n                button3.classed('active', !button3.classed('active'));\n            }\n        }\n        else {\n            var val = (dataAttr === null) ?\n                dataAttr :\n                Lib.nestedProperty(fullLayout, dataAttr).get();\n\n            button3.classed('active', val === thisval);\n        }\n\n    });\n};\n\n/**\n * Check if modeBar is configured as button configuration argument\n *\n * @Param {object} buttons 2d array of grouped button config objects\n * @Return {boolean}\n */\nproto.hasButtons = function(buttons) {\n    var currentButtons = this.buttons;\n\n    if(!currentButtons) return false;\n\n    if(buttons.length !== currentButtons.length) return false;\n\n    for(var i = 0; i < buttons.length; ++i) {\n        if(buttons[i].length !== currentButtons[i].length) return false;\n        for(var j = 0; j < buttons[i].length; j++) {\n            if(buttons[i][j].name !== currentButtons[i][j].name) return false;\n        }\n    }\n\n    return true;\n};\n\n/**\n * @return {HTMLDivElement} The logo image wrapped in a group\n */\nproto.getLogo = function() {\n    var group = this.createGroup(),\n        a = document.createElement('a');\n\n    a.href = 'https://plot.ly/';\n    a.target = '_blank';\n    a.setAttribute('data-title', 'Produced with Plotly');\n    a.className = 'modebar-btn plotlyjsicon modebar-btn--logo';\n\n    a.appendChild(this.createIcon(Icons.plotlylogo));\n\n    group.appendChild(a);\n    return group;\n};\n\nproto.removeAllButtons = function() {\n    while(this.element.firstChild) {\n        this.element.removeChild(this.element.firstChild);\n    }\n\n    this.hasLogo = false;\n};\n\nproto.destroy = function() {\n    Lib.removeElement(this.container.querySelector('.modebar'));\n};\n\nfunction createModeBar(gd, buttons) {\n    var fullLayout = gd._fullLayout;\n\n    var modeBar = new ModeBar({\n        graphInfo: gd,\n        container: fullLayout._paperdiv.node(),\n        buttons: buttons\n    });\n\n    if(fullLayout._privateplot) {\n        d3.select(modeBar.element).append('span')\n            .classed('badge-private float--left', true)\n            .text('PRIVATE');\n    }\n\n    return modeBar;\n}\n\nmodule.exports = createModeBar;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/build/ploticon.js":"'use strict';\n\nmodule.exports = {\n    'undo': {\n        'width': 857.1,\n        'path': 'm857 350q0-87-34-166t-91-137-137-92-166-34q-96 0-183 41t-147 114q-4 6-4 13t5 11l76 77q6 5 14 5 9-1 13-7 41-53 100-82t126-29q58 0 110 23t92 61 61 91 22 111-22 111-61 91-92 61-110 23q-55 0-105-20t-90-57l77-77q17-16 8-38-10-23-33-23h-250q-15 0-25 11t-11 25v250q0 24 22 33 22 10 39-8l72-72q60 57 137 88t159 31q87 0 166-34t137-92 91-137 34-166z',\n        'ascent': 850,\n        'descent': -150\n    },\n    'home': {\n        'width': 928.6,\n        'path': 'm786 296v-267q0-15-11-26t-25-10h-214v214h-143v-214h-214q-15 0-25 10t-11 26v267q0 1 0 2t0 2l321 264 321-264q1-1 1-4z m124 39l-34-41q-5-5-12-6h-2q-7 0-12 3l-386 322-386-322q-7-4-13-4-7 2-12 7l-35 41q-4 5-3 13t6 12l401 334q18 15 42 15t43-15l136-114v109q0 8 5 13t13 5h107q8 0 13-5t5-13v-227l122-102q5-5 6-12t-4-13z',\n        'ascent': 850,\n        'descent': -150\n    },\n    'camera-retro': {\n        'width': 1000,\n        'path': 'm518 386q0 8-5 13t-13 5q-37 0-63-27t-26-63q0-8 5-13t13-5 12 5 5 13q0 23 16 38t38 16q8 0 13 5t5 13z m125-73q0-59-42-101t-101-42-101 42-42 101 42 101 101 42 101-42 42-101z m-572-320h858v71h-858v-71z m643 320q0 89-62 152t-152 62-151-62-63-152 63-151 151-63 152 63 62 151z m-571 358h214v72h-214v-72z m-72-107h858v143h-462l-36-71h-360v-72z m929 143v-714q0-30-21-51t-50-21h-858q-29 0-50 21t-21 51v714q0 30 21 51t50 21h858q29 0 50-21t21-51z',\n        'ascent': 850,\n        'descent': -150\n    },\n    'zoombox': {\n        'width': 1000,\n        'path': 'm1000-25l-250 251c40 63 63 138 63 218 0 224-182 406-407 406-224 0-406-182-406-406s183-406 407-406c80 0 155 22 218 62l250-250 125 125z m-812 250l0 438 437 0 0-438-437 0z m62 375l313 0 0-312-313 0 0 312z',\n        'ascent': 850,\n        'descent': -150\n    },\n    'pan': {\n        'width': 1000,\n        'path': 'm1000 350l-187 188 0-125-250 0 0 250 125 0-188 187-187-187 125 0 0-250-250 0 0 125-188-188 186-187 0 125 252 0 0-250-125 0 187-188 188 188-125 0 0 250 250 0 0-126 187 188z',\n        'ascent': 850,\n        'descent': -150\n    },\n    'zoom_plus': {\n        'width': 1000,\n        'path': 'm1 787l0-875 875 0 0 875-875 0z m687-500l-187 0 0-187-125 0 0 187-188 0 0 125 188 0 0 187 125 0 0-187 187 0 0-125z',\n        'ascent': 850,\n        'descent': -150\n    },\n    'zoom_minus': {\n        'width': 1000,\n        'path': 'm0 788l0-876 875 0 0 876-875 0z m688-500l-500 0 0 125 500 0 0-125z',\n        'ascent': 850,\n        'descent': -150\n    },\n    'autoscale': {\n        'width': 1000,\n        'path': 'm250 850l-187 0-63 0 0-62 0-188 63 0 0 188 187 0 0 62z m688 0l-188 0 0-62 188 0 0-188 62 0 0 188 0 62-62 0z m-875-938l0 188-63 0 0-188 0-62 63 0 187 0 0 62-187 0z m875 188l0-188-188 0 0-62 188 0 62 0 0 62 0 188-62 0z m-125 188l-1 0-93-94-156 156 156 156 92-93 2 0 0 250-250 0 0-2 93-92-156-156-156 156 94 92 0 2-250 0 0-250 0 0 93 93 157-156-157-156-93 94 0 0 0-250 250 0 0 0-94 93 156 157 156-157-93-93 0 0 250 0 0 250z',\n        'ascent': 850,\n        'descent': -150\n    },\n    'tooltip_basic': {\n        'width': 1500,\n        'path': 'm375 725l0 0-375-375 375-374 0-1 1125 0 0 750-1125 0z',\n        'ascent': 850,\n        'descent': -150\n    },\n    'tooltip_compare': {\n        'width': 1125,\n        'path': 'm187 786l0 2-187-188 188-187 0 0 937 0 0 373-938 0z m0-499l0 1-187-188 188-188 0 0 937 0 0 376-938-1z',\n        'ascent': 850,\n        'descent': -150\n    },\n    'plotlylogo': {\n        'width': 1542,\n        'path': 'm0-10h182v-140h-182v140z m228 146h183v-286h-183v286z m225 714h182v-1000h-182v1000z m225-285h182v-715h-182v715z m225 142h183v-857h-183v857z m231-428h182v-429h-182v429z m225-291h183v-138h-183v138z',\n        'ascent': 850,\n        'descent': -150\n    },\n    'z-axis': {\n        'width': 1000,\n        'path': 'm833 5l-17 108v41l-130-65 130-66c0 0 0 38 0 39 0-1 36-14 39-25 4-15-6-22-16-30-15-12-39-16-56-20-90-22-187-23-279-23-261 0-341 34-353 59 3 60 228 110 228 110-140-8-351-35-351-116 0-120 293-142 474-142 155 0 477 22 477 142 0 50-74 79-163 96z m-374 94c-58-5-99-21-99-40 0-24 65-43 144-43 79 0 143 19 143 43 0 19-42 34-98 40v216h87l-132 135-133-135h88v-216z m167 515h-136v1c16 16 31 34 46 52l84 109v54h-230v-71h124v-1c-16-17-28-32-44-51l-89-114v-51h245v72z',\n        'ascent': 850,\n        'descent': -150\n    },\n    '3d_rotate': {\n        'width': 1000,\n        'path': 'm922 660c-5 4-9 7-14 11-359 263-580-31-580-31l-102 28 58-400c0 1 1 1 2 2 118 108 351 249 351 249s-62 27-100 42c88 83 222 183 347 122 16-8 30-17 44-27-2 1-4 2-6 4z m36-329c0 0 64 229-88 296-62 27-124 14-175-11 157-78 225-208 249-266 8-19 11-31 11-31 2 5 6 15 11 32-5-13-8-20-8-20z m-775-239c70-31 117-50 198-32-121 80-199 346-199 346l-96-15-58-12c0 0 55-226 155-287z m603 133l-317-139c0 0 4-4 19-14 7-5 24-15 24-15s-177-147-389 4c235-287 536-112 536-112l31-22 100 299-4-1z m-298-153c6-4 14-9 24-15 0 0-17 10-24 15z',\n        'ascent': 850,\n        'descent': -150\n    },\n    'camera': {\n        'width': 1000,\n        'path': 'm500 450c-83 0-150-67-150-150 0-83 67-150 150-150 83 0 150 67 150 150 0 83-67 150-150 150z m400 150h-120c-16 0-34 13-39 29l-31 93c-6 15-23 28-40 28h-340c-16 0-34-13-39-28l-31-94c-6-15-23-28-40-28h-120c-55 0-100-45-100-100v-450c0-55 45-100 100-100h800c55 0 100 45 100 100v450c0 55-45 100-100 100z m-400-550c-138 0-250 112-250 250 0 138 112 250 250 250 138 0 250-112 250-250 0-138-112-250-250-250z m365 380c-19 0-35 16-35 35 0 19 16 35 35 35 19 0 35-16 35-35 0-19-16-35-35-35z',\n        'ascent': 850,\n        'descent': -150\n    },\n    'movie': {\n        'width': 1000,\n        'path': 'm938 413l-188-125c0 37-17 71-44 94 64 38 107 107 107 187 0 121-98 219-219 219-121 0-219-98-219-219 0-61 25-117 66-156h-115c30 33 49 76 49 125 0 103-84 187-187 187s-188-84-188-187c0-57 26-107 65-141-38-22-65-62-65-109v-250c0-70 56-126 125-126h500c69 0 125 56 125 126l188-126c34 0 62 28 62 63v375c0 35-28 63-62 63z m-750 0c-69 0-125 56-125 125s56 125 125 125 125-56 125-125-56-125-125-125z m406-1c-87 0-157 70-157 157 0 86 70 156 157 156s156-70 156-156-70-157-156-157z',\n        'ascent': 850,\n        'descent': -150\n    },\n    'question': {\n        'width': 857.1,\n        'path': 'm500 82v107q0 8-5 13t-13 5h-107q-8 0-13-5t-5-13v-107q0-8 5-13t13-5h107q8 0 13 5t5 13z m143 375q0 49-31 91t-77 65-95 23q-136 0-207-119-9-14 4-24l74-55q4-4 10-4 9 0 14 7 30 38 48 51 19 14 48 14 27 0 48-15t21-33q0-21-11-34t-38-25q-35-16-65-48t-29-70v-20q0-8 5-13t13-5h107q8 0 13 5t5 13q0 10 12 27t30 28q18 10 28 16t25 19 25 27 16 34 7 45z m214-107q0-117-57-215t-156-156-215-58-216 58-155 156-58 215 58 215 155 156 216 58 215-58 156-156 57-215z',\n        'ascent': 850,\n        'descent': -150\n    },\n    'disk': {\n        'width': 857.1,\n        'path': 'm214-7h429v214h-429v-214z m500 0h72v500q0 8-6 21t-11 20l-157 156q-5 6-19 12t-22 5v-232q0-22-15-38t-38-16h-322q-22 0-37 16t-16 38v232h-72v-714h72v232q0 22 16 38t37 16h465q22 0 38-16t15-38v-232z m-214 518v178q0 8-5 13t-13 5h-107q-7 0-13-5t-5-13v-178q0-8 5-13t13-5h107q7 0 13 5t5 13z m357-18v-518q0-22-15-38t-38-16h-750q-23 0-38 16t-16 38v750q0 22 16 38t38 16h517q23 0 50-12t42-26l156-157q16-15 27-42t11-49z',\n        'ascent': 850,\n        'descent': -150\n    },\n    'lasso': {\n        'width': 1031,\n        'path': 'm1018 538c-36 207-290 336-568 286-277-48-473-256-436-463 10-57 36-108 76-151-13-66 11-137 68-183 34-28 75-41 114-42l-55-70 0 0c-2-1-3-2-4-3-10-14-8-34 5-45 14-11 34-8 45 4 1 1 2 3 2 5l0 0 113 140c16 11 31 24 45 40 4 3 6 7 8 11 48-3 100 0 151 9 278 48 473 255 436 462z m-624-379c-80 14-149 48-197 96 42 42 109 47 156 9 33-26 47-66 41-105z m-187-74c-19 16-33 37-39 60 50-32 109-55 174-68-42-25-95-24-135 8z m360 75c-34-7-69-9-102-8 8 62-16 128-68 170-73 59-175 54-244-5-9 20-16 40-20 61-28 159 121 317 333 354s407-60 434-217c28-159-121-318-333-355z',\n        'ascent': 850,\n        'descent': -150\n    },\n    'selectbox': {\n        'width': 1000,\n        'path': 'm0 850l0-143 143 0 0 143-143 0z m286 0l0-143 143 0 0 143-143 0z m285 0l0-143 143 0 0 143-143 0z m286 0l0-143 143 0 0 143-143 0z m-857-286l0-143 143 0 0 143-143 0z m857 0l0-143 143 0 0 143-143 0z m-857-285l0-143 143 0 0 143-143 0z m857 0l0-143 143 0 0 143-143 0z m-857-286l0-143 143 0 0 143-143 0z m286 0l0-143 143 0 0 143-143 0z m285 0l0-143 143 0 0 143-143 0z m286 0l0-143 143 0 0 143-143 0z',\n        'ascent': 850,\n        'descent': -150\n    },\n    'spikeline': {\n        'width': 1000,\n        'path': 'M512 409c0-57-46-104-103-104-57 0-104 47-104 104 0 57 47 103 104 103 57 0 103-46 103-103z m-327-39l92 0 0 92-92 0z m-185 0l92 0 0 92-92 0z m370-186l92 0 0 93-92 0z m0-184l92 0 0 92-92 0z',\n        'ascent': 850,\n        'descent': -150\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/modebar/buttons.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Plotly = require('../../plotly');\nvar Plots = require('../../plots/plots');\nvar Axes = require('../../plots/cartesian/axes');\nvar Lib = require('../../lib');\nvar downloadImage = require('../../snapshot/download');\nvar Icons = require('../../../build/ploticon');\n\n\nvar modeBarButtons = module.exports = {};\n\n/**\n * ModeBar buttons configuration\n *\n * @param {string} name\n *      name / id of the buttons (for tracking)\n * @param {string} title\n *      text that appears while hovering over the button,\n *      enter null, false or '' for no hover text\n * @param {string} icon\n *      svg icon object associated with the button\n *      can be linked to Plotly.Icons to use the default plotly icons\n * @param {string} [gravity]\n *      icon positioning\n * @param {function} click\n *      click handler associated with the button, a function of\n *      'gd' (the main graph object) and\n *      'ev' (the event object)\n * @param {string} [attr]\n *      attribute associated with button,\n *      use this with 'val' to keep track of the state\n * @param {*} [val]\n *      initial 'attr' value, can be a function of gd\n * @param {boolean} [toggle]\n *      is the button a toggle button?\n */\n\nmodeBarButtons.toImage = {\n    name: 'toImage',\n    title: 'Download plot as a png',\n    icon: Icons.camera,\n    click: function(gd) {\n        var format = 'png';\n\n        Lib.notifier('Taking snapshot - this may take a few seconds', 'long');\n\n        if(Lib.isIE()) {\n            Lib.notifier('IE only supports svg.  Changing format to svg.', 'long');\n            format = 'svg';\n        }\n\n        downloadImage(gd, {'format': format})\n          .then(function(filename) {\n              Lib.notifier('Snapshot succeeded - ' + filename, 'long');\n          })\n          .catch(function() {\n              Lib.notifier('Sorry there was a problem downloading your snapshot!', 'long');\n          });\n    }\n};\n\nmodeBarButtons.sendDataToCloud = {\n    name: 'sendDataToCloud',\n    title: 'Save and edit plot in cloud',\n    icon: Icons.disk,\n    click: function(gd) {\n        Plots.sendDataToCloud(gd);\n    }\n};\n\nmodeBarButtons.zoom2d = {\n    name: 'zoom2d',\n    title: 'Zoom',\n    attr: 'dragmode',\n    val: 'zoom',\n    icon: Icons.zoombox,\n    click: handleCartesian\n};\n\nmodeBarButtons.pan2d = {\n    name: 'pan2d',\n    title: 'Pan',\n    attr: 'dragmode',\n    val: 'pan',\n    icon: Icons.pan,\n    click: handleCartesian\n};\n\nmodeBarButtons.select2d = {\n    name: 'select2d',\n    title: 'Box Select',\n    attr: 'dragmode',\n    val: 'select',\n    icon: Icons.selectbox,\n    click: handleCartesian\n};\n\nmodeBarButtons.lasso2d = {\n    name: 'lasso2d',\n    title: 'Lasso Select',\n    attr: 'dragmode',\n    val: 'lasso',\n    icon: Icons.lasso,\n    click: handleCartesian\n};\n\nmodeBarButtons.zoomIn2d = {\n    name: 'zoomIn2d',\n    title: 'Zoom in',\n    attr: 'zoom',\n    val: 'in',\n    icon: Icons.zoom_plus,\n    click: handleCartesian\n};\n\nmodeBarButtons.zoomOut2d = {\n    name: 'zoomOut2d',\n    title: 'Zoom out',\n    attr: 'zoom',\n    val: 'out',\n    icon: Icons.zoom_minus,\n    click: handleCartesian\n};\n\nmodeBarButtons.autoScale2d = {\n    name: 'autoScale2d',\n    title: 'Autoscale',\n    attr: 'zoom',\n    val: 'auto',\n    icon: Icons.autoscale,\n    click: handleCartesian\n};\n\nmodeBarButtons.resetScale2d = {\n    name: 'resetScale2d',\n    title: 'Reset axes',\n    attr: 'zoom',\n    val: 'reset',\n    icon: Icons.home,\n    click: handleCartesian\n};\n\nmodeBarButtons.hoverClosestCartesian = {\n    name: 'hoverClosestCartesian',\n    title: 'Show closest data on hover',\n    attr: 'hovermode',\n    val: 'closest',\n    icon: Icons.tooltip_basic,\n    gravity: 'ne',\n    click: handleCartesian\n};\n\nmodeBarButtons.hoverCompareCartesian = {\n    name: 'hoverCompareCartesian',\n    title: 'Compare data on hover',\n    attr: 'hovermode',\n    val: function(gd) {\n        return gd._fullLayout._isHoriz ? 'y' : 'x';\n    },\n    icon: Icons.tooltip_compare,\n    gravity: 'ne',\n    click: handleCartesian\n};\n\nfunction handleCartesian(gd, ev) {\n    var button = ev.currentTarget,\n        astr = button.getAttribute('data-attr'),\n        val = button.getAttribute('data-val') || true,\n        fullLayout = gd._fullLayout,\n        aobj = {},\n        axList = Axes.list(gd, null, true),\n        ax,\n        allEnabled = 'on',\n        i;\n\n    if(astr === 'zoom') {\n        var mag = (val === 'in') ? 0.5 : 2,\n            r0 = (1 + mag) / 2,\n            r1 = (1 - mag) / 2;\n\n        var axName;\n\n        for(i = 0; i < axList.length; i++) {\n            ax = axList[i];\n\n            if(!ax.fixedrange) {\n                axName = ax._name;\n                if(val === 'auto') aobj[axName + '.autorange'] = true;\n                else if(val === 'reset') {\n                    if(ax._rangeInitial === undefined) {\n                        aobj[axName + '.autorange'] = true;\n                    }\n                    else {\n                        var rangeInitial = ax._rangeInitial.slice();\n                        aobj[axName + '.range[0]'] = rangeInitial[0];\n                        aobj[axName + '.range[1]'] = rangeInitial[1];\n                    }\n                    if(ax._showSpikeInitial !== undefined) {\n                        aobj[axName + '.showspikes'] = ax._showSpikeInitial;\n                        if(allEnabled === 'on' && !ax._showSpikeInitial) {\n                            allEnabled = 'off';\n                        }\n                    }\n                }\n                else {\n                    var rangeNow = [\n                        ax.r2l(ax.range[0]),\n                        ax.r2l(ax.range[1]),\n                    ];\n\n                    var rangeNew = [\n                        r0 * rangeNow[0] + r1 * rangeNow[1],\n                        r0 * rangeNow[1] + r1 * rangeNow[0]\n                    ];\n\n                    aobj[axName + '.range[0]'] = ax.l2r(rangeNew[0]);\n                    aobj[axName + '.range[1]'] = ax.l2r(rangeNew[1]);\n                }\n            }\n        }\n        fullLayout._cartesianSpikesEnabled = allEnabled;\n    }\n    else {\n        // if ALL traces have orientation 'h', 'hovermode': 'x' otherwise: 'y'\n        if(astr === 'hovermode' && (val === 'x' || val === 'y')) {\n            val = fullLayout._isHoriz ? 'y' : 'x';\n            button.setAttribute('data-val', val);\n            if(val !== 'closest') {\n                fullLayout._cartesianSpikesEnabled = 'off';\n            }\n        } else if(astr === 'hovermode' && val === 'closest') {\n            for(i = 0; i < axList.length; i++) {\n                ax = axList[i];\n                if(allEnabled === 'on' && !ax.showspikes) {\n                    allEnabled = 'off';\n                }\n            }\n            fullLayout._cartesianSpikesEnabled = allEnabled;\n        }\n\n        aobj[astr] = val;\n    }\n\n    Plotly.relayout(gd, aobj);\n}\n\nmodeBarButtons.zoom3d = {\n    name: 'zoom3d',\n    title: 'Zoom',\n    attr: 'scene.dragmode',\n    val: 'zoom',\n    icon: Icons.zoombox,\n    click: handleDrag3d\n};\n\nmodeBarButtons.pan3d = {\n    name: 'pan3d',\n    title: 'Pan',\n    attr: 'scene.dragmode',\n    val: 'pan',\n    icon: Icons.pan,\n    click: handleDrag3d\n};\n\nmodeBarButtons.orbitRotation = {\n    name: 'orbitRotation',\n    title: 'orbital rotation',\n    attr: 'scene.dragmode',\n    val: 'orbit',\n    icon: Icons['3d_rotate'],\n    click: handleDrag3d\n};\n\nmodeBarButtons.tableRotation = {\n    name: 'tableRotation',\n    title: 'turntable rotation',\n    attr: 'scene.dragmode',\n    val: 'turntable',\n    icon: Icons['z-axis'],\n    click: handleDrag3d\n};\n\nfunction handleDrag3d(gd, ev) {\n    var button = ev.currentTarget,\n        attr = button.getAttribute('data-attr'),\n        val = button.getAttribute('data-val') || true,\n        fullLayout = gd._fullLayout,\n        sceneIds = Plots.getSubplotIds(fullLayout, 'gl3d'),\n        layoutUpdate = {};\n\n    var parts = attr.split('.');\n\n    for(var i = 0; i < sceneIds.length; i++) {\n        layoutUpdate[sceneIds[i] + '.' + parts[1]] = val;\n    }\n\n    Plotly.relayout(gd, layoutUpdate);\n}\n\nmodeBarButtons.resetCameraDefault3d = {\n    name: 'resetCameraDefault3d',\n    title: 'Reset camera to default',\n    attr: 'resetDefault',\n    icon: Icons.home,\n    click: handleCamera3d\n};\n\nmodeBarButtons.resetCameraLastSave3d = {\n    name: 'resetCameraLastSave3d',\n    title: 'Reset camera to last save',\n    attr: 'resetLastSave',\n    icon: Icons.movie,\n    click: handleCamera3d\n};\n\nfunction handleCamera3d(gd, ev) {\n    var button = ev.currentTarget,\n        attr = button.getAttribute('data-attr'),\n        fullLayout = gd._fullLayout,\n        sceneIds = Plots.getSubplotIds(fullLayout, 'gl3d'),\n        aobj = {};\n\n    for(var i = 0; i < sceneIds.length; i++) {\n        var sceneId = sceneIds[i],\n            key = sceneId + '.camera',\n            scene = fullLayout[sceneId]._scene;\n\n        if(attr === 'resetDefault') {\n            aobj[key] = null;\n        }\n        else if(attr === 'resetLastSave') {\n            aobj[key] = Lib.extendDeep({}, scene.cameraInitial);\n        }\n    }\n\n    Plotly.relayout(gd, aobj);\n}\n\nmodeBarButtons.hoverClosest3d = {\n    name: 'hoverClosest3d',\n    title: 'Toggle show closest data on hover',\n    attr: 'hovermode',\n    val: null,\n    toggle: true,\n    icon: Icons.tooltip_basic,\n    gravity: 'ne',\n    click: handleHover3d\n};\n\nfunction handleHover3d(gd, ev) {\n    var button = ev.currentTarget,\n        val = button._previousVal || false,\n        layout = gd.layout,\n        fullLayout = gd._fullLayout,\n        sceneIds = Plots.getSubplotIds(fullLayout, 'gl3d');\n\n    var axes = ['xaxis', 'yaxis', 'zaxis'],\n        spikeAttrs = ['showspikes', 'spikesides', 'spikethickness', 'spikecolor'];\n\n    // initialize 'current spike' object to be stored in the DOM\n    var currentSpikes = {},\n        axisSpikes = {},\n        layoutUpdate = {};\n\n    if(val) {\n        layoutUpdate = Lib.extendDeep(layout, val);\n        button._previousVal = null;\n    }\n    else {\n        layoutUpdate = {\n            'allaxes.showspikes': false\n        };\n\n        for(var i = 0; i < sceneIds.length; i++) {\n            var sceneId = sceneIds[i],\n                sceneLayout = fullLayout[sceneId],\n                sceneSpikes = currentSpikes[sceneId] = {};\n\n            sceneSpikes.hovermode = sceneLayout.hovermode;\n            layoutUpdate[sceneId + '.hovermode'] = false;\n\n            // copy all the current spike attrs\n            for(var j = 0; j < 3; j++) {\n                var axis = axes[j];\n                axisSpikes = sceneSpikes[axis] = {};\n\n                for(var k = 0; k < spikeAttrs.length; k++) {\n                    var spikeAttr = spikeAttrs[k];\n                    axisSpikes[spikeAttr] = sceneLayout[axis][spikeAttr];\n                }\n            }\n        }\n\n        button._previousVal = Lib.extendDeep({}, currentSpikes);\n    }\n\n    Plotly.relayout(gd, layoutUpdate);\n}\n\nmodeBarButtons.zoomInGeo = {\n    name: 'zoomInGeo',\n    title: 'Zoom in',\n    attr: 'zoom',\n    val: 'in',\n    icon: Icons.zoom_plus,\n    click: handleGeo\n};\n\nmodeBarButtons.zoomOutGeo = {\n    name: 'zoomOutGeo',\n    title: 'Zoom out',\n    attr: 'zoom',\n    val: 'out',\n    icon: Icons.zoom_minus,\n    click: handleGeo\n};\n\nmodeBarButtons.resetGeo = {\n    name: 'resetGeo',\n    title: 'Reset',\n    attr: 'reset',\n    val: null,\n    icon: Icons.autoscale,\n    click: handleGeo\n};\n\nmodeBarButtons.hoverClosestGeo = {\n    name: 'hoverClosestGeo',\n    title: 'Toggle show closest data on hover',\n    attr: 'hovermode',\n    val: null,\n    toggle: true,\n    icon: Icons.tooltip_basic,\n    gravity: 'ne',\n    click: toggleHover\n};\n\nfunction handleGeo(gd, ev) {\n    var button = ev.currentTarget,\n        attr = button.getAttribute('data-attr'),\n        val = button.getAttribute('data-val') || true,\n        fullLayout = gd._fullLayout,\n        geoIds = Plots.getSubplotIds(fullLayout, 'geo');\n\n    for(var i = 0; i < geoIds.length; i++) {\n        var geo = fullLayout[geoIds[i]]._subplot;\n\n        if(attr === 'zoom') {\n            var scale = geo.projection.scale();\n            var newScale = (val === 'in') ? 2 * scale : 0.5 * scale;\n            geo.projection.scale(newScale);\n            geo.zoom.scale(newScale);\n            geo.render();\n        }\n        else if(attr === 'reset') geo.zoomReset();\n    }\n}\n\nmodeBarButtons.hoverClosestGl2d = {\n    name: 'hoverClosestGl2d',\n    title: 'Toggle show closest data on hover',\n    attr: 'hovermode',\n    val: null,\n    toggle: true,\n    icon: Icons.tooltip_basic,\n    gravity: 'ne',\n    click: toggleHover\n};\n\nmodeBarButtons.hoverClosestPie = {\n    name: 'hoverClosestPie',\n    title: 'Toggle show closest data on hover',\n    attr: 'hovermode',\n    val: 'closest',\n    icon: Icons.tooltip_basic,\n    gravity: 'ne',\n    click: toggleHover\n};\n\nfunction toggleHover(gd) {\n    var fullLayout = gd._fullLayout;\n\n    var onHoverVal;\n    if(fullLayout._has('cartesian')) {\n        onHoverVal = fullLayout._isHoriz ? 'y' : 'x';\n    }\n    else onHoverVal = 'closest';\n\n    var newHover = gd._fullLayout.hovermode ? false : onHoverVal;\n\n    Plotly.relayout(gd, 'hovermode', newHover);\n}\n\n// buttons when more then one plot types are present\n\nmodeBarButtons.toggleHover = {\n    name: 'toggleHover',\n    title: 'Toggle show closest data on hover',\n    attr: 'hovermode',\n    val: null,\n    toggle: true,\n    icon: Icons.tooltip_basic,\n    gravity: 'ne',\n    click: function(gd, ev) {\n        toggleHover(gd);\n\n        // the 3d hovermode update must come\n        // last so that layout.hovermode update does not\n        // override scene?.hovermode?.layout.\n        handleHover3d(gd, ev);\n    }\n};\n\nmodeBarButtons.resetViews = {\n    name: 'resetViews',\n    title: 'Reset views',\n    icon: Icons.home,\n    click: function(gd, ev) {\n        var button = ev.currentTarget;\n\n        button.setAttribute('data-attr', 'zoom');\n        button.setAttribute('data-val', 'reset');\n        handleCartesian(gd, ev);\n\n        button.setAttribute('data-attr', 'resetLastSave');\n        handleCamera3d(gd, ev);\n\n        // N.B handleCamera3d also triggers a replot for\n        // geo subplots.\n    }\n};\n\nmodeBarButtons.toggleSpikelines = {\n    name: 'toggleSpikelines',\n    title: 'Toggle Spike Lines',\n    icon: Icons.spikeline,\n    attr: '_cartesianSpikesEnabled',\n    val: 'on',\n    click: function(gd) {\n        var fullLayout = gd._fullLayout;\n\n        fullLayout._cartesianSpikesEnabled = fullLayout.hovermode === 'closest' ?\n            (fullLayout._cartesianSpikesEnabled === 'on' ? 'off' : 'on') : 'on';\n\n        var aobj = setSpikelineVisibility(gd);\n\n        aobj.hovermode = 'closest';\n        Plotly.relayout(gd, aobj);\n    }\n};\n\nfunction setSpikelineVisibility(gd) {\n    var fullLayout = gd._fullLayout,\n        axList = Axes.list(gd, null, true),\n        ax,\n        axName,\n        aobj = {};\n\n    for(var i = 0; i < axList.length; i++) {\n        ax = axList[i];\n        axName = ax._name;\n        aobj[axName + '.showspikes'] = fullLayout._cartesianSpikesEnabled === 'on' ? true : false;\n    }\n\n    return aobj;\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/snapshot/download.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar toImage = require('../plot_api/to_image');\nvar Lib = require('../lib'); // for isIE\nvar fileSaver = require('./filesaver');\n\n/**\n * @param {object} gd figure Object\n * @param {object} opts option object\n * @param opts.format 'jpeg' | 'png' | 'webp' | 'svg'\n * @param opts.width width of snapshot in px\n * @param opts.height height of snapshot in px\n * @param opts.filename name of file excluding extension\n */\nfunction downloadImage(gd, opts) {\n\n    // check for undefined opts\n    opts = opts || {};\n\n    // default to png\n    opts.format = opts.format || 'png';\n\n    return new Promise(function(resolve, reject) {\n        if(gd._snapshotInProgress) {\n            reject(new Error('Snapshotting already in progress.'));\n        }\n\n        // see comments within svgtoimg for additional\n        //   discussion of problems with IE\n        //   can now draw to canvas, but CORS tainted canvas\n        //   does not allow toDataURL\n        //   svg format will work though\n        if(Lib.isIE() && opts.format !== 'svg') {\n            reject(new Error('Sorry IE does not support downloading from canvas. Try {format:\\'svg\\'} instead.'));\n        }\n\n        gd._snapshotInProgress = true;\n        var promise = toImage(gd, opts);\n\n        var filename = opts.filename || gd.fn || 'newplot';\n        filename += '.' + opts.format;\n\n        promise.then(function(result) {\n            gd._snapshotInProgress = false;\n            return fileSaver(result, filename);\n        }).then(function(name) {\n            resolve(name);\n        }).catch(function(err) {\n            gd._snapshotInProgress = false;\n            reject(err);\n        });\n    });\n}\n\nmodule.exports = downloadImage;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plot_api/to_image.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Plotly = require('../plotly');\nvar Lib = require('../lib');\n\nvar helpers = require('../snapshot/helpers');\nvar clonePlot = require('../snapshot/cloneplot');\nvar toSVG = require('../snapshot/tosvg');\nvar svgToImg = require('../snapshot/svgtoimg');\n\n/**\n * @param {object} gd figure Object\n * @param {object} opts option object\n * @param opts.format 'jpeg' | 'png' | 'webp' | 'svg'\n * @param opts.width width of snapshot in px\n * @param opts.height height of snapshot in px\n */\nfunction toImage(gd, opts) {\n\n    var promise = new Promise(function(resolve, reject) {\n        // check for undefined opts\n        opts = opts || {};\n        // default to png\n        opts.format = opts.format || 'png';\n\n        var isSizeGood = function(size) {\n            // undefined and null are valid options\n            if(size === undefined || size === null) {\n                return true;\n            }\n\n            if(isNumeric(size) && size > 1) {\n                return true;\n            }\n\n            return false;\n        };\n\n        if(!isSizeGood(opts.width) || !isSizeGood(opts.height)) {\n            reject(new Error('Height and width should be pixel values.'));\n        }\n\n        // first clone the GD so we can operate in a clean environment\n        var clone = clonePlot(gd, {format: 'png', height: opts.height, width: opts.width});\n        var clonedGd = clone.gd;\n\n        // put the cloned div somewhere off screen before attaching to DOM\n        clonedGd.style.position = 'absolute';\n        clonedGd.style.left = '-5000px';\n        document.body.appendChild(clonedGd);\n\n        function wait() {\n            var delay = helpers.getDelay(clonedGd._fullLayout);\n\n            return new Promise(function(resolve, reject) {\n                setTimeout(function() {\n                    var svg = toSVG(clonedGd);\n\n                    var canvas = document.createElement('canvas');\n                    canvas.id = Lib.randstr();\n\n                    svgToImg({\n                        format: opts.format,\n                        width: clonedGd._fullLayout.width,\n                        height: clonedGd._fullLayout.height,\n                        canvas: canvas,\n                        svg: svg,\n                        // ask svgToImg to return a Promise\n                        //  rather than EventEmitter\n                        //  leave EventEmitter for backward\n                        //  compatibility\n                        promise: true\n                    }).then(function(url) {\n                        if(clonedGd) document.body.removeChild(clonedGd);\n                        resolve(url);\n                    }).catch(function(err) {\n                        reject(err);\n                    });\n\n                }, delay);\n            });\n        }\n\n        var redrawFunc = helpers.getRedrawFunc(clonedGd);\n\n        Plotly.plot(clonedGd, clone.data, clone.layout, clone.config)\n            .then(redrawFunc)\n            .then(wait)\n            .then(function(url) { resolve(url); })\n            .catch(function(err) {\n                reject(err);\n            });\n    });\n\n    return promise;\n}\n\nmodule.exports = toImage;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/snapshot/helpers.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nexports.getDelay = function(fullLayout) {\n\n    // polar clears fullLayout._has for some reason\n    if(!fullLayout._has) return 0;\n\n    // maybe we should add a 'gl' (and 'svg') layoutCategory ??\n    return (fullLayout._has('gl3d') || fullLayout._has('gl2d')) ? 500 : 0;\n};\n\nexports.getRedrawFunc = function(gd) {\n\n    // do not work if polar is present\n    if((gd.data && gd.data[0] && gd.data[0].r)) return;\n\n    return function() {\n        (gd.calcdata || []).forEach(function(d) {\n            if(d[0] && d[0].t && d[0].t.cb) d[0].t.cb();\n        });\n    };\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/snapshot/cloneplot.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Lib = require('../lib');\nvar Plots = require('../plots/plots');\n\nvar extendFlat = Lib.extendFlat;\nvar extendDeep = Lib.extendDeep;\n\n// Put default plotTile layouts here\nfunction cloneLayoutOverride(tileClass) {\n    var override;\n\n    switch(tileClass) {\n        case 'themes__thumb':\n            override = {\n                autosize: true,\n                width: 150,\n                height: 150,\n                title: '',\n                showlegend: false,\n                margin: {l: 5, r: 5, t: 5, b: 5, pad: 0},\n                annotations: []\n            };\n            break;\n\n        case 'thumbnail':\n            override = {\n                title: '',\n                hidesources: true,\n                showlegend: false,\n                borderwidth: 0,\n                bordercolor: '',\n                margin: {l: 1, r: 1, t: 1, b: 1, pad: 0},\n                annotations: []\n            };\n            break;\n\n        default:\n            override = {};\n    }\n\n\n    return override;\n}\n\nfunction keyIsAxis(keyName) {\n    var types = ['xaxis', 'yaxis', 'zaxis'];\n    return (types.indexOf(keyName.slice(0, 5)) > -1);\n}\n\n\nmodule.exports = function clonePlot(graphObj, options) {\n\n    // Polar plot compatibility\n    if(graphObj.framework && graphObj.framework.isPolar) {\n        graphObj = graphObj.framework.getConfig();\n    }\n\n    var i;\n    var oldData = graphObj.data;\n    var oldLayout = graphObj.layout;\n    var newData = extendDeep([], oldData);\n    var newLayout = extendDeep({}, oldLayout, cloneLayoutOverride(options.tileClass));\n    var context = graphObj._context || {};\n\n    if(options.width) newLayout.width = options.width;\n    if(options.height) newLayout.height = options.height;\n\n    if(options.tileClass === 'thumbnail' || options.tileClass === 'themes__thumb') {\n        // kill annotations\n        newLayout.annotations = [];\n        var keys = Object.keys(newLayout);\n\n        for(i = 0; i < keys.length; i++) {\n            if(keyIsAxis(keys[i])) {\n                newLayout[keys[i]].title = '';\n            }\n        }\n\n        // kill colorbar and pie labels\n        for(i = 0; i < newData.length; i++) {\n            var trace = newData[i];\n            trace.showscale = false;\n            if(trace.marker) trace.marker.showscale = false;\n            if(trace.type === 'pie') trace.textposition = 'none';\n        }\n    }\n\n    if(Array.isArray(options.annotations)) {\n        for(i = 0; i < options.annotations.length; i++) {\n            newLayout.annotations.push(options.annotations[i]);\n        }\n    }\n\n    var sceneIds = Plots.getSubplotIds(newLayout, 'gl3d');\n\n    if(sceneIds.length) {\n        var axesImageOverride = {};\n        if(options.tileClass === 'thumbnail') {\n            axesImageOverride = {\n                title: '',\n                showaxeslabels: false,\n                showticklabels: false,\n                linetickenable: false\n            };\n        }\n        for(i = 0; i < sceneIds.length; i++) {\n            var scene = newLayout[sceneIds[i]];\n\n            if(!scene.xaxis) {\n                scene.xaxis = {};\n            }\n\n            if(!scene.yaxis) {\n                scene.yaxis = {};\n            }\n\n            if(!scene.zaxis) {\n                scene.zaxis = {};\n            }\n\n            extendFlat(scene.xaxis, axesImageOverride);\n            extendFlat(scene.yaxis, axesImageOverride);\n            extendFlat(scene.zaxis, axesImageOverride);\n\n            // TODO what does this do?\n            scene._scene = null;\n        }\n    }\n\n    var gd = document.createElement('div');\n    if(options.tileClass) gd.className = options.tileClass;\n\n    var plotTile = {\n        gd: gd,\n        td: gd, // for external (image server) compatibility\n        layout: newLayout,\n        data: newData,\n        config: {\n            staticPlot: (options.staticPlot === undefined) ?\n                true :\n                options.staticPlot,\n            plotGlPixelRatio: (options.plotGlPixelRatio === undefined) ?\n                2 :\n                options.plotGlPixelRatio,\n            displaylogo: options.displaylogo || false,\n            showLink: options.showLink || false,\n            showTips: options.showTips || false,\n            mapboxAccessToken: context.mapboxAccessToken\n        }\n    };\n\n    if(options.setBackground !== 'transparent') {\n        plotTile.config.setBackground = options.setBackground || 'opaque';\n    }\n\n    // attaching the default Layout the gd, so you can grab it later\n    plotTile.gd.defaultLayout = cloneLayoutOverride(options.tileClass);\n\n    return plotTile;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/snapshot/tosvg.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\n\nvar svgTextUtils = require('../lib/svg_text_utils');\nvar Drawing = require('../components/drawing');\nvar Color = require('../components/color');\n\nvar xmlnsNamespaces = require('../constants/xmlns_namespaces');\n\n\nmodule.exports = function toSVG(gd, format) {\n    var fullLayout = gd._fullLayout,\n        svg = fullLayout._paper,\n        toppaper = fullLayout._toppaper,\n        i;\n\n    // make background color a rect in the svg, then revert after scraping\n    // all other alterations have been dealt with by properly preparing the svg\n    // in the first place... like setting cursors with css classes so we don't\n    // have to remove them, and providing the right namespaces in the svg to\n    // begin with\n    svg.insert('rect', ':first-child')\n        .call(Drawing.setRect, 0, 0, fullLayout.width, fullLayout.height)\n        .call(Color.fill, fullLayout.paper_bgcolor);\n\n    // subplot-specific to-SVG methods\n    // which notably add the contents of the gl-container\n    // into the main svg node\n    var basePlotModules = fullLayout._basePlotModules || [];\n    for(i = 0; i < basePlotModules.length; i++) {\n        var _module = basePlotModules[i];\n\n        if(_module.toSVG) _module.toSVG(gd);\n    }\n\n    // add top items above them assumes everything in toppaper is either\n    // a group or a defs, and if it's empty (like hoverlayer) we can ignore it.\n    if(toppaper) {\n        var nodes = toppaper.node().childNodes;\n\n        // make copy of nodes as childNodes prop gets mutated in loop below\n        var topGroups = Array.prototype.slice.call(nodes);\n\n        for(i = 0; i < topGroups.length; i++) {\n            var topGroup = topGroups[i];\n\n            if(topGroup.childNodes.length) svg.node().appendChild(topGroup);\n        }\n    }\n\n    // remove draglayer for Adobe Illustrator compatibility\n    if(fullLayout._draggers) {\n        fullLayout._draggers.remove();\n    }\n\n    // in case the svg element had an explicit background color, remove this\n    // we want the rect to get the color so it's the right size; svg bg will\n    // fill whatever container it's displayed in regardless of plot size.\n    svg.node().style.background = '';\n\n    svg.selectAll('text')\n        .attr('data-unformatted', null)\n        .each(function() {\n            var txt = d3.select(this);\n\n            // hidden text is pre-formatting mathjax,\n            // the browser ignores it but it can still confuse batik\n            if(txt.style('visibility') === 'hidden') {\n                txt.remove();\n                return;\n            }\n            else {\n                // force other visibility value to export as visible\n                // to not potentially confuse non-browser SVG implementations\n                txt.style('visibility', 'visible');\n            }\n\n            // Font family styles break things because of quotation marks,\n            // so we must remove them *after* the SVG DOM has been serialized\n            // to a string (browsers convert singles back)\n            var ff = txt.style('font-family');\n            if(ff && ff.indexOf('\"') !== -1) {\n                txt.style('font-family', ff.replace(/\"/g, 'TOBESTRIPPED'));\n            }\n        });\n\n    if(format === 'pdf' || format === 'eps') {\n        // these formats make the extra line MathJax adds around symbols look super thick in some cases\n        // it looks better if this is removed entirely.\n        svg.selectAll('#MathJax_SVG_glyphs path')\n            .attr('stroke-width', 0);\n    }\n\n    // fix for IE namespacing quirk?\n    // http://stackoverflow.com/questions/19610089/unwanted-namespaces-on-svg-markup-when-using-xmlserializer-in-javascript-with-ie\n    svg.node().setAttributeNS(xmlnsNamespaces.xmlns, 'xmlns', xmlnsNamespaces.svg);\n    svg.node().setAttributeNS(xmlnsNamespaces.xmlns, 'xmlns:xlink', xmlnsNamespaces.xlink);\n\n    var s = new window.XMLSerializer().serializeToString(svg.node());\n    s = svgTextUtils.html_entity_decode(s);\n    s = svgTextUtils.xml_entity_encode(s);\n\n    // Fix quotations around font strings\n    s = s.replace(/(\"TOBESTRIPPED)|(TOBESTRIPPED\")/g, '\\'');\n\n    return s;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/snapshot/svgtoimg.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../lib');\nvar EventEmitter = require('events').EventEmitter;\n\nfunction svgToImg(opts) {\n\n    var ev = opts.emitter || new EventEmitter();\n\n    var promise = new Promise(function(resolve, reject) {\n\n        var Image = window.Image;\n\n        var svg = opts.svg;\n        var format = opts.format || 'png';\n\n        // IE is very strict, so we will need to clean\n        //  svg with the following regex\n        //  yes this is messy, but do not know a better way\n        // Even with this IE will not work due to tainted canvas\n        //  see https://github.com/kangax/fabric.js/issues/1957\n        //      http://stackoverflow.com/questions/18112047/canvas-todataurl-working-in-all-browsers-except-ie10\n        // Leave here just in case the CORS/tainted IE issue gets resolved\n        if(Lib.isIE()) {\n            // replace double quote with single quote\n            svg = svg.replace(/\"/gi, '\\'');\n            // url in svg are single quoted\n            //   since we changed double to single\n            //   we'll need to change these to double-quoted\n            svg = svg.replace(/(\\('#)(.*)('\\))/gi, '(\\\"$2\\\")');\n            // font names with spaces will be escaped single-quoted\n            //   we'll need to change these to double-quoted\n            svg = svg.replace(/(\\\\')/gi, '\\\"');\n            // IE only support svg\n            if(format !== 'svg') {\n                var ieSvgError = new Error('Sorry IE does not support downloading from canvas. Try {format:\\'svg\\'} instead.');\n                reject(ieSvgError);\n                // eventually remove the ev\n                //  in favor of promises\n                if(!opts.promise) {\n                    return ev.emit('error', ieSvgError);\n                } else {\n                    return promise;\n                }\n            }\n        }\n\n        var canvas = opts.canvas;\n\n        var ctx = canvas.getContext('2d');\n        var img = new Image();\n\n        // for Safari support, eliminate createObjectURL\n        //  this decision could cause problems if content\n        //  is not restricted to svg\n        var url = 'data:image/svg+xml,' + encodeURIComponent(svg);\n\n        canvas.height = opts.height || 150;\n        canvas.width = opts.width || 300;\n\n        img.onload = function() {\n            var imgData;\n\n            // don't need to draw to canvas if svg\n            //  save some time and also avoid failure on IE\n            if(format !== 'svg') {\n                ctx.drawImage(img, 0, 0);\n            }\n\n            switch(format) {\n                case 'jpeg':\n                    imgData = canvas.toDataURL('image/jpeg');\n                    break;\n                case 'png':\n                    imgData = canvas.toDataURL('image/png');\n                    break;\n                case 'webp':\n                    imgData = canvas.toDataURL('image/webp');\n                    break;\n                case 'svg':\n                    imgData = url;\n                    break;\n                default:\n                    reject(new Error('Image format is not jpeg, png or svg'));\n                    // eventually remove the ev\n                    //  in favor of promises\n                    if(!opts.promise) {\n                        return ev.emit('error', 'Image format is not jpeg, png or svg');\n                    }\n            }\n            resolve(imgData);\n            // eventually remove the ev\n            //  in favor of promises\n            if(!opts.promise) {\n                ev.emit('success', imgData);\n            }\n        };\n\n        img.onerror = function(err) {\n            reject(err);\n            // eventually remove the ev\n            //  in favor of promises\n            if(!opts.promise) {\n                return ev.emit('error', err);\n            }\n        };\n\n        img.src = url;\n    });\n\n    // temporary for backward compatibility\n    //  move to only Promise in 2.0.0\n    //  and eliminate the EventEmitter\n    if(opts.promise) {\n        return promise;\n    }\n\n    return ev;\n}\n\nmodule.exports = svgToImg;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/snapshot/filesaver.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n/*\n* substantial portions of this code from FileSaver.js\n* https://github.com/eligrey/FileSaver.js\n* License: https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md\n* FileSaver.js\n* A saveAs() FileSaver implementation.\n* 1.1.20160328\n*\n* By Eli Grey, http://eligrey.com\n* License: MIT\n*   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md\n*/\n\n'use strict';\n\nvar fileSaver = function(url, name) {\n    var saveLink = document.createElement('a');\n    var canUseSaveLink = 'download' in saveLink;\n    var isSafari = /Version\\/[\\d\\.]+.*Safari/.test(navigator.userAgent);\n    var promise = new Promise(function(resolve, reject) {\n        // IE <10 is explicitly unsupported\n        if(typeof navigator !== 'undefined' && /MSIE [1-9]\\./.test(navigator.userAgent)) {\n            reject(new Error('IE < 10 unsupported'));\n        }\n\n        // First try a.download, then web filesystem, then object URLs\n        if(isSafari) {\n            // Safari doesn't allow downloading of blob urls\n            document.location.href = 'data:application/octet-stream' + url.slice(url.search(/[,;]/));\n            resolve(name);\n        }\n\n        if(!name) {\n            name = 'download';\n        }\n\n        if(canUseSaveLink) {\n            saveLink.href = url;\n            saveLink.download = name;\n            document.body.appendChild(saveLink);\n            saveLink.click();\n            document.body.removeChild(saveLink);\n            resolve(name);\n        }\n\n        // IE 10+ (native saveAs)\n        if(typeof navigator !== 'undefined' && navigator.msSaveBlob) {\n            navigator.msSaveBlob(new Blob([url]), name);\n            resolve(name);\n        }\n\n        reject(new Error('download error'));\n    });\n\n    return promise;\n};\n\nmodule.exports = fileSaver;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plot_api/plot_api.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\n\nvar d3 = require('d3');\nvar isNumeric = require('fast-isnumeric');\n\nvar Plotly = require('../plotly');\nvar Lib = require('../lib');\nvar Events = require('../lib/events');\nvar Queue = require('../lib/queue');\n\nvar Registry = require('../registry');\nvar Plots = require('../plots/plots');\nvar Fx = require('../plots/cartesian/graph_interact');\nvar Polar = require('../plots/polar');\n\nvar Drawing = require('../components/drawing');\nvar ErrorBars = require('../components/errorbars');\nvar xmlnsNamespaces = require('../constants/xmlns_namespaces');\nvar svgTextUtils = require('../lib/svg_text_utils');\n\nvar manageArrays = require('./manage_arrays');\nvar helpers = require('./helpers');\nvar subroutines = require('./subroutines');\nvar cartesianConstants = require('../plots/cartesian/constants');\nvar enforceAxisConstraints = require('../plots/cartesian/constraints');\nvar axisIds = require('../plots/cartesian/axis_ids');\n\n\n/**\n * Main plot-creation function\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {array of objects} data\n *      array of traces, containing the data and display information for each trace\n * @param {object} layout\n *      object describing the overall display of the plot,\n *      all the stuff that doesn't pertain to any individual trace\n * @param {object} config\n *      configuration options (see ./plot_config.js for more info)\n *\n */\nPlotly.plot = function(gd, data, layout, config) {\n    var frames;\n\n    gd = helpers.getGraphDiv(gd);\n\n    // Events.init is idempotent and bails early if gd has already been init'd\n    Events.init(gd);\n\n    if(Lib.isPlainObject(data)) {\n        var obj = data;\n        data = obj.data;\n        layout = obj.layout;\n        config = obj.config;\n        frames = obj.frames;\n    }\n\n    var okToPlot = Events.triggerHandler(gd, 'plotly_beforeplot', [data, layout, config]);\n    if(okToPlot === false) return Promise.reject();\n\n    // if there's no data or layout, and this isn't yet a plotly plot\n    // container, log a warning to help plotly.js users debug\n    if(!data && !layout && !Lib.isPlotDiv(gd)) {\n        Lib.warn('Calling Plotly.plot as if redrawing ' +\n            'but this container doesn\\'t yet have a plot.', gd);\n    }\n\n    function addFrames() {\n        if(frames) {\n            return Plotly.addFrames(gd, frames);\n        }\n    }\n\n    // transfer configuration options to gd until we move over to\n    // a more OO like model\n    setPlotContext(gd, config);\n\n    if(!layout) layout = {};\n\n    // hook class for plots main container (in case of plotly.js\n    // this won't be #embedded-graph or .js-tab-contents)\n    d3.select(gd).classed('js-plotly-plot', true);\n\n    // off-screen getBoundingClientRect testing space,\n    // in #js-plotly-tester (and stored as gd._tester)\n    // so we can share cached text across tabs\n    Drawing.makeTester(gd);\n\n    // collect promises for any async actions during plotting\n    // any part of the plotting code can push to gd._promises, then\n    // before we move to the next step, we check that they're all\n    // complete, and empty out the promise list again.\n    gd._promises = [];\n\n    var graphWasEmpty = ((gd.data || []).length === 0 && Array.isArray(data));\n\n    // if there is already data on the graph, append the new data\n    // if you only want to redraw, pass a non-array for data\n    if(Array.isArray(data)) {\n        helpers.cleanData(data, gd.data);\n\n        if(graphWasEmpty) gd.data = data;\n        else gd.data.push.apply(gd.data, data);\n\n        // for routines outside graph_obj that want a clean tab\n        // (rather than appending to an existing one) gd.empty\n        // is used to determine whether to make a new tab\n        gd.empty = false;\n    }\n\n    if(!gd.layout || graphWasEmpty) gd.layout = helpers.cleanLayout(layout);\n\n    // if the user is trying to drag the axes, allow new data and layout\n    // to come in but don't allow a replot.\n    if(gd._dragging && !gd._transitioning) {\n        // signal to drag handler that after everything else is done\n        // we need to replot, because something has changed\n        gd._replotPending = true;\n        return Promise.reject();\n    } else {\n        // we're going ahead with a replot now\n        gd._replotPending = false;\n    }\n\n    Plots.supplyDefaults(gd);\n\n    var fullLayout = gd._fullLayout;\n\n    // Polar plots\n    if(data && data[0] && data[0].r) return plotPolar(gd, data, layout);\n\n    // so we don't try to re-call Plotly.plot from inside\n    // legend and colorbar, if margins changed\n    fullLayout._replotting = true;\n\n    // make or remake the framework if we need to\n    if(graphWasEmpty) makePlotFramework(gd);\n\n    // polar need a different framework\n    if(gd.framework !== makePlotFramework) {\n        gd.framework = makePlotFramework;\n        makePlotFramework(gd);\n    }\n\n    // save initial show spikes once per graph\n    if(graphWasEmpty) Plotly.Axes.saveShowSpikeInitial(gd);\n\n    // prepare the data and find the autorange\n\n    // generate calcdata, if we need to\n    // to force redoing calcdata, just delete it before calling Plotly.plot\n    var recalc = !gd.calcdata || gd.calcdata.length !== (gd._fullData || []).length;\n    if(recalc) Plots.doCalcdata(gd);\n\n    // in case it has changed, attach fullData traces to calcdata\n    for(var i = 0; i < gd.calcdata.length; i++) {\n        gd.calcdata[i][0].trace = gd._fullData[i];\n    }\n\n    /*\n     * start async-friendly code - now we're actually drawing things\n     */\n\n    var oldmargins = JSON.stringify(fullLayout._size);\n\n    // draw framework first so that margin-pushing\n    // components can position themselves correctly\n    function drawFramework() {\n        var basePlotModules = fullLayout._basePlotModules;\n\n        for(var i = 0; i < basePlotModules.length; i++) {\n            if(basePlotModules[i].drawFramework) {\n                basePlotModules[i].drawFramework(gd);\n            }\n        }\n\n        return Lib.syncOrAsync([\n            subroutines.layoutStyles,\n            drawAxes,\n            Fx.init\n        ], gd);\n    }\n\n    // draw anything that can affect margins.\n    function marginPushers() {\n        var calcdata = gd.calcdata;\n        var i, cd, trace;\n\n        Registry.getComponentMethod('legend', 'draw')(gd);\n        Registry.getComponentMethod('rangeselector', 'draw')(gd);\n        Registry.getComponentMethod('sliders', 'draw')(gd);\n        Registry.getComponentMethod('updatemenus', 'draw')(gd);\n\n        for(i = 0; i < calcdata.length; i++) {\n            cd = calcdata[i];\n            trace = cd[0].trace;\n            if(trace.visible !== true || !trace._module.colorbar) {\n                Plots.autoMargin(gd, 'cb' + trace.uid);\n            }\n            else trace._module.colorbar(gd, cd);\n        }\n\n        Plots.doAutoMargin(gd);\n        return Plots.previousPromises(gd);\n    }\n\n    // in case the margins changed, draw margin pushers again\n    function marginPushersAgain() {\n        var seq = JSON.stringify(fullLayout._size) === oldmargins ?\n            [] :\n            [marginPushers, subroutines.layoutStyles];\n\n        // re-initialize cartesian interaction,\n        // which are sometimes cleared during marginPushers\n        seq = seq.concat(Fx.init);\n\n        return Lib.syncOrAsync(seq, gd);\n    }\n\n    function positionAndAutorange() {\n        if(!recalc) return;\n\n        var subplots = Plots.getSubplotIds(fullLayout, 'cartesian'),\n            modules = fullLayout._modules;\n\n        // position and range calculations for traces that\n        // depend on each other ie bars (stacked or grouped)\n        // and boxes (grouped) push each other out of the way\n\n        var subplotInfo, _module;\n\n        for(var i = 0; i < subplots.length; i++) {\n            subplotInfo = fullLayout._plots[subplots[i]];\n\n            for(var j = 0; j < modules.length; j++) {\n                _module = modules[j];\n                if(_module.setPositions) _module.setPositions(gd, subplotInfo);\n            }\n        }\n\n        // calc and autorange for errorbars\n        ErrorBars.calc(gd);\n\n        // TODO: autosize extra for text markers and images\n        // see https://github.com/plotly/plotly.js/issues/1111\n        return Lib.syncOrAsync([\n            Registry.getComponentMethod('shapes', 'calcAutorange'),\n            Registry.getComponentMethod('annotations', 'calcAutorange'),\n            doAutoRangeAndConstraints,\n            Registry.getComponentMethod('rangeslider', 'calcAutorange')\n        ], gd);\n    }\n\n    function doAutoRangeAndConstraints() {\n        if(gd._transitioning) return;\n\n        var axList = Plotly.Axes.list(gd, '', true);\n        for(var i = 0; i < axList.length; i++) {\n            Plotly.Axes.doAutoRange(axList[i]);\n        }\n\n        enforceAxisConstraints(gd);\n\n        // store initial ranges *after* enforcing constraints, otherwise\n        // we will never look like we're at the initial ranges\n        if(graphWasEmpty) Plotly.Axes.saveRangeInitial(gd);\n    }\n\n    // draw ticks, titles, and calculate axis scaling (._b, ._m)\n    function drawAxes() {\n        return Plotly.Axes.doTicks(gd, 'redraw');\n    }\n\n    // Now plot the data\n    function drawData() {\n        var calcdata = gd.calcdata,\n            i;\n\n        // in case of traces that were heatmaps or contour maps\n        // previously, remove them and their colorbars explicitly\n        for(i = 0; i < calcdata.length; i++) {\n            var trace = calcdata[i][0].trace,\n                isVisible = (trace.visible === true),\n                uid = trace.uid;\n\n            if(!isVisible || !Registry.traceIs(trace, '2dMap')) {\n                var query = (\n                    '.hm' + uid +\n                    ',.contour' + uid +\n                    ',#clip' + uid\n                );\n\n                fullLayout._paper\n                    .selectAll(query)\n                    .remove();\n\n                fullLayout._infolayer.selectAll('g.rangeslider-container')\n                    .selectAll(query)\n                    .remove();\n            }\n\n            if(!isVisible || !trace._module.colorbar) {\n                fullLayout._infolayer.selectAll('.cb' + uid).remove();\n            }\n        }\n\n        // loop over the base plot modules present on graph\n        var basePlotModules = fullLayout._basePlotModules;\n        for(i = 0; i < basePlotModules.length; i++) {\n            basePlotModules[i].plot(gd);\n        }\n\n        // keep reference to shape layers in subplots\n        var layerSubplot = fullLayout._paper.selectAll('.layer-subplot');\n        fullLayout._shapeSubplotLayers = layerSubplot.selectAll('.shapelayer');\n\n        // styling separate from drawing\n        Plots.style(gd);\n\n        // show annotations and shapes\n        Registry.getComponentMethod('shapes', 'draw')(gd);\n        Registry.getComponentMethod('annotations', 'draw')(gd);\n\n        // source links\n        Plots.addLinks(gd);\n\n        // Mark the first render as complete\n        fullLayout._replotting = false;\n\n        return Plots.previousPromises(gd);\n    }\n\n    // An initial paint must be completed before these components can be\n    // correctly sized and the whole plot re-margined. fullLayout._replotting must\n    // be set to false before these will work properly.\n    function finalDraw() {\n        Registry.getComponentMethod('shapes', 'draw')(gd);\n        Registry.getComponentMethod('images', 'draw')(gd);\n        Registry.getComponentMethod('annotations', 'draw')(gd);\n        Registry.getComponentMethod('legend', 'draw')(gd);\n        Registry.getComponentMethod('rangeslider', 'draw')(gd);\n        Registry.getComponentMethod('rangeselector', 'draw')(gd);\n        Registry.getComponentMethod('sliders', 'draw')(gd);\n        Registry.getComponentMethod('updatemenus', 'draw')(gd);\n    }\n\n    var seq = [\n        Plots.previousPromises,\n        addFrames,\n        drawFramework,\n        marginPushers,\n        marginPushersAgain,\n        positionAndAutorange,\n        subroutines.layoutStyles,\n        drawAxes,\n        drawData,\n        finalDraw,\n        Plots.rehover\n    ];\n\n    Lib.syncOrAsync(seq, gd);\n\n    // even if everything we did was synchronous, return a promise\n    // so that the caller doesn't care which route we took\n    return Promise.all(gd._promises).then(function() {\n        gd.emit('plotly_afterplot');\n        return gd;\n    });\n};\n\n\nfunction opaqueSetBackground(gd, bgColor) {\n    gd._fullLayout._paperdiv.style('background', 'white');\n    Plotly.defaultConfig.setBackground(gd, bgColor);\n}\n\nfunction setPlotContext(gd, config) {\n    if(!gd._context) gd._context = Lib.extendFlat({}, Plotly.defaultConfig);\n    var context = gd._context;\n\n    if(config) {\n        Object.keys(config).forEach(function(key) {\n            if(key in context) {\n                if(key === 'setBackground' && config[key] === 'opaque') {\n                    context[key] = opaqueSetBackground;\n                }\n                else context[key] = config[key];\n            }\n        });\n\n        // map plot3dPixelRatio to plotGlPixelRatio for backward compatibility\n        if(config.plot3dPixelRatio && !context.plotGlPixelRatio) {\n            context.plotGlPixelRatio = context.plot3dPixelRatio;\n        }\n    }\n\n    // staticPlot forces a bunch of others:\n    if(context.staticPlot) {\n        context.editable = false;\n        context.autosizable = false;\n        context.scrollZoom = false;\n        context.doubleClick = false;\n        context.showTips = false;\n        context.showLink = false;\n        context.displayModeBar = false;\n    }\n}\n\nfunction plotPolar(gd, data, layout) {\n    // build or reuse the container skeleton\n    var plotContainer = d3.select(gd).selectAll('.plot-container')\n        .data([0]);\n    plotContainer.enter()\n        .insert('div', ':first-child')\n        .classed('plot-container plotly', true);\n    var paperDiv = plotContainer.selectAll('.svg-container')\n        .data([0]);\n    paperDiv.enter().append('div')\n        .classed('svg-container', true)\n        .style('position', 'relative');\n\n    // empty it everytime for now\n    paperDiv.html('');\n\n    // fulfill gd requirements\n    if(data) gd.data = data;\n    if(layout) gd.layout = layout;\n    Polar.manager.fillLayout(gd);\n\n    // resize canvas\n    paperDiv.style({\n        width: gd._fullLayout.width + 'px',\n        height: gd._fullLayout.height + 'px'\n    });\n\n    // instantiate framework\n    gd.framework = Polar.manager.framework(gd);\n\n    // plot\n    gd.framework({data: gd.data, layout: gd.layout}, paperDiv.node());\n\n    // set undo point\n    gd.framework.setUndoPoint();\n\n    // get the resulting svg for extending it\n    var polarPlotSVG = gd.framework.svg();\n\n    // editable title\n    var opacity = 1;\n    var txt = gd._fullLayout.title;\n    if(txt === '' || !txt) opacity = 0;\n    var placeholderText = 'Click to enter title';\n\n    var titleLayout = function() {\n        this.call(svgTextUtils.convertToTspans);\n        // TODO: html/mathjax\n        // TODO: center title\n    };\n\n    var title = polarPlotSVG.select('.title-group text')\n        .call(titleLayout);\n\n    if(gd._context.editable) {\n        title.attr({'data-unformatted': txt});\n        if(!txt || txt === placeholderText) {\n            opacity = 0.2;\n            title.attr({'data-unformatted': placeholderText})\n                .text(placeholderText)\n                .style({opacity: opacity})\n                .on('mouseover.opacity', function() {\n                    d3.select(this).transition().duration(100)\n                        .style('opacity', 1);\n                })\n                .on('mouseout.opacity', function() {\n                    d3.select(this).transition().duration(1000)\n                        .style('opacity', 0);\n                });\n        }\n\n        var setContenteditable = function() {\n            this.call(svgTextUtils.makeEditable)\n                .on('edit', function(text) {\n                    gd.framework({layout: {title: text}});\n                    this.attr({'data-unformatted': text})\n                        .text(text)\n                        .call(titleLayout);\n                    this.call(setContenteditable);\n                })\n                .on('cancel', function() {\n                    var txt = this.attr('data-unformatted');\n                    this.text(txt).call(titleLayout);\n                });\n        };\n        title.call(setContenteditable);\n    }\n\n    gd._context.setBackground(gd, gd._fullLayout.paper_bgcolor);\n    Plots.addLinks(gd);\n\n    return Promise.resolve();\n}\n\n// convenience function to force a full redraw, mostly for use by plotly.js\nPlotly.redraw = function(gd) {\n    gd = helpers.getGraphDiv(gd);\n\n    if(!Lib.isPlotDiv(gd)) {\n        throw new Error('This element is not a Plotly plot: ' + gd);\n    }\n\n    helpers.cleanData(gd.data, gd.data);\n    helpers.cleanLayout(gd.layout);\n\n    gd.calcdata = undefined;\n    return Plotly.plot(gd).then(function() {\n        gd.emit('plotly_redraw');\n        return gd;\n    });\n};\n\n/**\n * Convenience function to make idempotent plot option obvious to users.\n *\n * @param gd\n * @param {Object[]} data\n * @param {Object} layout\n * @param {Object} config\n */\nPlotly.newPlot = function(gd, data, layout, config) {\n    gd = helpers.getGraphDiv(gd);\n\n    // remove gl contexts\n    Plots.cleanPlot([], {}, gd._fullData || {}, gd._fullLayout || {});\n\n    Plots.purge(gd);\n    return Plotly.plot(gd, data, layout, config);\n};\n\n/**\n * Wrap negative indicies to their positive counterparts.\n *\n * @param {Number[]} indices An array of indices\n * @param {Number} maxIndex The maximum index allowable (arr.length - 1)\n */\nfunction positivifyIndices(indices, maxIndex) {\n    var parentLength = maxIndex + 1,\n        positiveIndices = [],\n        i,\n        index;\n\n    for(i = 0; i < indices.length; i++) {\n        index = indices[i];\n        if(index < 0) {\n            positiveIndices.push(parentLength + index);\n        } else {\n            positiveIndices.push(index);\n        }\n    }\n    return positiveIndices;\n}\n\n/**\n * Ensures that an index array for manipulating gd.data is valid.\n *\n * Intended for use with addTraces, deleteTraces, and moveTraces.\n *\n * @param gd\n * @param indices\n * @param arrayName\n */\nfunction assertIndexArray(gd, indices, arrayName) {\n    var i,\n        index;\n\n    for(i = 0; i < indices.length; i++) {\n        index = indices[i];\n\n        // validate that indices are indeed integers\n        if(index !== parseInt(index, 10)) {\n            throw new Error('all values in ' + arrayName + ' must be integers');\n        }\n\n        // check that all indices are in bounds for given gd.data array length\n        if(index >= gd.data.length || index < -gd.data.length) {\n            throw new Error(arrayName + ' must be valid indices for gd.data.');\n        }\n\n        // check that indices aren't repeated\n        if(indices.indexOf(index, i + 1) > -1 ||\n                index >= 0 && indices.indexOf(-gd.data.length + index) > -1 ||\n                index < 0 && indices.indexOf(gd.data.length + index) > -1) {\n            throw new Error('each index in ' + arrayName + ' must be unique.');\n        }\n    }\n}\n\n/**\n * Private function used by Plotly.moveTraces to check input args\n *\n * @param gd\n * @param currentIndices\n * @param newIndices\n */\nfunction checkMoveTracesArgs(gd, currentIndices, newIndices) {\n\n    // check that gd has attribute 'data' and 'data' is array\n    if(!Array.isArray(gd.data)) {\n        throw new Error('gd.data must be an array.');\n    }\n\n    // validate currentIndices array\n    if(typeof currentIndices === 'undefined') {\n        throw new Error('currentIndices is a required argument.');\n    } else if(!Array.isArray(currentIndices)) {\n        currentIndices = [currentIndices];\n    }\n    assertIndexArray(gd, currentIndices, 'currentIndices');\n\n    // validate newIndices array if it exists\n    if(typeof newIndices !== 'undefined' && !Array.isArray(newIndices)) {\n        newIndices = [newIndices];\n    }\n    if(typeof newIndices !== 'undefined') {\n        assertIndexArray(gd, newIndices, 'newIndices');\n    }\n\n    // check currentIndices and newIndices are the same length if newIdices exists\n    if(typeof newIndices !== 'undefined' && currentIndices.length !== newIndices.length) {\n        throw new Error('current and new indices must be of equal length.');\n    }\n\n}\n/**\n * A private function to reduce the type checking clutter in addTraces.\n *\n * @param gd\n * @param traces\n * @param newIndices\n */\nfunction checkAddTracesArgs(gd, traces, newIndices) {\n    var i, value;\n\n    // check that gd has attribute 'data' and 'data' is array\n    if(!Array.isArray(gd.data)) {\n        throw new Error('gd.data must be an array.');\n    }\n\n    // make sure traces exists\n    if(typeof traces === 'undefined') {\n        throw new Error('traces must be defined.');\n    }\n\n    // make sure traces is an array\n    if(!Array.isArray(traces)) {\n        traces = [traces];\n    }\n\n    // make sure each value in traces is an object\n    for(i = 0; i < traces.length; i++) {\n        value = traces[i];\n        if(typeof value !== 'object' || (Array.isArray(value) || value === null)) {\n            throw new Error('all values in traces array must be non-array objects');\n        }\n    }\n\n    // make sure we have an index for each trace\n    if(typeof newIndices !== 'undefined' && !Array.isArray(newIndices)) {\n        newIndices = [newIndices];\n    }\n    if(typeof newIndices !== 'undefined' && newIndices.length !== traces.length) {\n        throw new Error(\n            'if indices is specified, traces.length must equal indices.length'\n        );\n    }\n}\n\n/**\n * A private function to reduce the type checking clutter in spliceTraces.\n * Get all update Properties from gd.data. Validate inputs and outputs.\n * Used by prependTrace and extendTraces\n *\n * @param gd\n * @param update\n * @param indices\n * @param maxPoints\n */\nfunction assertExtendTracesArgs(gd, update, indices, maxPoints) {\n\n    var maxPointsIsObject = Lib.isPlainObject(maxPoints);\n\n    if(!Array.isArray(gd.data)) {\n        throw new Error('gd.data must be an array');\n    }\n    if(!Lib.isPlainObject(update)) {\n        throw new Error('update must be a key:value object');\n    }\n\n    if(typeof indices === 'undefined') {\n        throw new Error('indices must be an integer or array of integers');\n    }\n\n    assertIndexArray(gd, indices, 'indices');\n\n    for(var key in update) {\n\n        /*\n         * Verify that the attribute to be updated contains as many trace updates\n         * as indices. Failure must result in throw and no-op\n         */\n        if(!Array.isArray(update[key]) || update[key].length !== indices.length) {\n            throw new Error('attribute ' + key + ' must be an array of length equal to indices array length');\n        }\n\n        /*\n         * if maxPoints is an object it must match keys and array lengths of 'update' 1:1\n         */\n        if(maxPointsIsObject &&\n            (!(key in maxPoints) || !Array.isArray(maxPoints[key]) ||\n            maxPoints[key].length !== update[key].length)) {\n            throw new Error('when maxPoints is set as a key:value object it must contain a 1:1 ' +\n                            'corrispondence with the keys and number of traces in the update object');\n        }\n    }\n}\n\n/**\n * A private function to reduce the type checking clutter in spliceTraces.\n *\n * @param {Object|HTMLDivElement} gd\n * @param {Object} update\n * @param {Number[]} indices\n * @param {Number||Object} maxPoints\n * @return {Object[]}\n */\nfunction getExtendProperties(gd, update, indices, maxPoints) {\n\n    var maxPointsIsObject = Lib.isPlainObject(maxPoints),\n        updateProps = [];\n    var trace, target, prop, insert, maxp;\n\n    // allow scalar index to represent a single trace position\n    if(!Array.isArray(indices)) indices = [indices];\n\n    // negative indices are wrapped around to their positive value. Equivalent to python indexing.\n    indices = positivifyIndices(indices, gd.data.length - 1);\n\n    // loop through all update keys and traces and harvest validated data.\n    for(var key in update) {\n\n        for(var j = 0; j < indices.length; j++) {\n\n            /*\n             * Choose the trace indexed by the indices map argument and get the prop setter-getter\n             * instance that references the key and value for this particular trace.\n             */\n            trace = gd.data[indices[j]];\n            prop = Lib.nestedProperty(trace, key);\n\n            /*\n             * Target is the existing gd.data.trace.dataArray value like \"x\" or \"marker.size\"\n             * Target must exist as an Array to allow the extend operation to be performed.\n             */\n            target = prop.get();\n            insert = update[key][j];\n\n            if(!Array.isArray(insert)) {\n                throw new Error('attribute: ' + key + ' index: ' + j + ' must be an array');\n            }\n            if(!Array.isArray(target)) {\n                throw new Error('cannot extend missing or non-array attribute: ' + key);\n            }\n\n            /*\n             * maxPoints may be an object map or a scalar. If object select the key:value, else\n             * Use the scalar maxPoints for all key and trace combinations.\n             */\n            maxp = maxPointsIsObject ? maxPoints[key][j] : maxPoints;\n\n            // could have chosen null here, -1 just tells us to not take a window\n            if(!isNumeric(maxp)) maxp = -1;\n\n            /*\n             * Wrap the nestedProperty in an object containing required data\n             * for lengthening and windowing this particular trace - key combination.\n             * Flooring maxp mirrors the behaviour of floats in the Array.slice JSnative function.\n             */\n            updateProps.push({\n                prop: prop,\n                target: target,\n                insert: insert,\n                maxp: Math.floor(maxp)\n            });\n        }\n    }\n\n    // all target and insertion data now validated\n    return updateProps;\n}\n\n/**\n * A private function to key Extend and Prepend traces DRY\n *\n * @param {Object|HTMLDivElement} gd\n * @param {Object} update\n * @param {Number[]} indices\n * @param {Number||Object} maxPoints\n * @param {Function} lengthenArray\n * @param {Function} spliceArray\n * @return {Object}\n */\nfunction spliceTraces(gd, update, indices, maxPoints, lengthenArray, spliceArray) {\n\n    assertExtendTracesArgs(gd, update, indices, maxPoints);\n\n    var updateProps = getExtendProperties(gd, update, indices, maxPoints),\n        remainder = [],\n        undoUpdate = {},\n        undoPoints = {};\n    var target, prop, maxp;\n\n    for(var i = 0; i < updateProps.length; i++) {\n\n        /*\n         * prop is the object returned by Lib.nestedProperties\n         */\n        prop = updateProps[i].prop;\n        maxp = updateProps[i].maxp;\n\n        target = lengthenArray(updateProps[i].target, updateProps[i].insert);\n\n        /*\n         * If maxp is set within post-extension trace.length, splice to maxp length.\n         * Otherwise skip function call as splice op will have no effect anyway.\n         */\n        if(maxp >= 0 && maxp < target.length) remainder = spliceArray(target, maxp);\n\n        /*\n         * to reverse this operation we need the size of the original trace as the reverse\n         * operation will need to window out any lengthening operation performed in this pass.\n         */\n        maxp = updateProps[i].target.length;\n\n        /*\n         * Magic happens here! update gd.data.trace[key] with new array data.\n         */\n        prop.set(target);\n\n        if(!Array.isArray(undoUpdate[prop.astr])) undoUpdate[prop.astr] = [];\n        if(!Array.isArray(undoPoints[prop.astr])) undoPoints[prop.astr] = [];\n\n        /*\n         * build the inverse update object for the undo operation\n         */\n        undoUpdate[prop.astr].push(remainder);\n\n        /*\n         * build the matching maxPoints undo object containing original trace lengths.\n         */\n        undoPoints[prop.astr].push(maxp);\n    }\n\n    return {update: undoUpdate, maxPoints: undoPoints};\n}\n\n/**\n * extend && prepend traces at indices with update arrays, window trace lengths to maxPoints\n *\n * Extend and Prepend have identical APIs. Prepend inserts an array at the head while Extend\n * inserts an array off the tail. Prepend truncates the tail of the array - counting maxPoints\n * from the head, whereas Extend truncates the head of the array, counting backward maxPoints\n * from the tail.\n *\n * If maxPoints is undefined, nonNumeric, negative or greater than extended trace length no\n * truncation / windowing will be performed. If its zero, well the whole trace is truncated.\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object} update The key:array map of target attributes to extend\n * @param {Number|Number[]} indices The locations of traces to be extended\n * @param {Number|Object} [maxPoints] Number of points for trace window after lengthening.\n *\n */\nPlotly.extendTraces = function extendTraces(gd, update, indices, maxPoints) {\n    gd = helpers.getGraphDiv(gd);\n\n    var undo = spliceTraces(gd, update, indices, maxPoints,\n\n                           /*\n                            * The Lengthen operation extends trace from end with insert\n                            */\n                            function(target, insert) {\n                                return target.concat(insert);\n                            },\n\n                            /*\n                             * Window the trace keeping maxPoints, counting back from the end\n                             */\n                            function(target, maxPoints) {\n                                return target.splice(0, target.length - maxPoints);\n                            });\n\n    var promise = Plotly.redraw(gd);\n\n    var undoArgs = [gd, undo.update, indices, undo.maxPoints];\n    Queue.add(gd, Plotly.prependTraces, undoArgs, extendTraces, arguments);\n\n    return promise;\n};\n\nPlotly.prependTraces = function prependTraces(gd, update, indices, maxPoints) {\n    gd = helpers.getGraphDiv(gd);\n\n    var undo = spliceTraces(gd, update, indices, maxPoints,\n\n                           /*\n                            * The Lengthen operation extends trace by appending insert to start\n                            */\n                            function(target, insert) {\n                                return insert.concat(target);\n                            },\n\n                            /*\n                             * Window the trace keeping maxPoints, counting forward from the start\n                             */\n                            function(target, maxPoints) {\n                                return target.splice(maxPoints, target.length);\n                            });\n\n    var promise = Plotly.redraw(gd);\n\n    var undoArgs = [gd, undo.update, indices, undo.maxPoints];\n    Queue.add(gd, Plotly.extendTraces, undoArgs, prependTraces, arguments);\n\n    return promise;\n};\n\n/**\n * Add data traces to an existing graph div.\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object[]} gd.data The array of traces we're adding to\n * @param {Object[]|Object} traces The object or array of objects to add\n * @param {Number[]|Number} [newIndices=[gd.data.length]] Locations to add traces\n *\n */\nPlotly.addTraces = function addTraces(gd, traces, newIndices) {\n    gd = helpers.getGraphDiv(gd);\n\n    var currentIndices = [],\n        undoFunc = Plotly.deleteTraces,\n        redoFunc = addTraces,\n        undoArgs = [gd, currentIndices],\n        redoArgs = [gd, traces],  // no newIndices here\n        i,\n        promise;\n\n    // all validation is done elsewhere to remove clutter here\n    checkAddTracesArgs(gd, traces, newIndices);\n\n    // make sure traces is an array\n    if(!Array.isArray(traces)) {\n        traces = [traces];\n    }\n\n    // make sure traces do not repeat existing ones\n    traces = traces.map(function(trace) {\n        return Lib.extendFlat({}, trace);\n    });\n\n    helpers.cleanData(traces, gd.data);\n\n    // add the traces to gd.data (no redrawing yet!)\n    for(i = 0; i < traces.length; i++) {\n        gd.data.push(traces[i]);\n    }\n\n    // to continue, we need to call moveTraces which requires currentIndices\n    for(i = 0; i < traces.length; i++) {\n        currentIndices.push(-traces.length + i);\n    }\n\n    // if the user didn't define newIndices, they just want the traces appended\n    // i.e., we can simply redraw and be done\n    if(typeof newIndices === 'undefined') {\n        promise = Plotly.redraw(gd);\n        Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n        return promise;\n    }\n\n    // make sure indices is property defined\n    if(!Array.isArray(newIndices)) {\n        newIndices = [newIndices];\n    }\n\n    try {\n\n        // this is redundant, but necessary to not catch later possible errors!\n        checkMoveTracesArgs(gd, currentIndices, newIndices);\n    }\n    catch(error) {\n\n        // something went wrong, reset gd to be safe and rethrow error\n        gd.data.splice(gd.data.length - traces.length, traces.length);\n        throw error;\n    }\n\n    // if we're here, the user has defined specific places to place the new traces\n    // this requires some extra work that moveTraces will do\n    Queue.startSequence(gd);\n    Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n    promise = Plotly.moveTraces(gd, currentIndices, newIndices);\n    Queue.stopSequence(gd);\n    return promise;\n};\n\n/**\n * Delete traces at `indices` from gd.data array.\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object[]} gd.data The array of traces we're removing from\n * @param {Number|Number[]} indices The indices\n */\nPlotly.deleteTraces = function deleteTraces(gd, indices) {\n    gd = helpers.getGraphDiv(gd);\n\n    var traces = [],\n        undoFunc = Plotly.addTraces,\n        redoFunc = deleteTraces,\n        undoArgs = [gd, traces, indices],\n        redoArgs = [gd, indices],\n        i,\n        deletedTrace;\n\n    // make sure indices are defined\n    if(typeof indices === 'undefined') {\n        throw new Error('indices must be an integer or array of integers.');\n    } else if(!Array.isArray(indices)) {\n        indices = [indices];\n    }\n    assertIndexArray(gd, indices, 'indices');\n\n    // convert negative indices to positive indices\n    indices = positivifyIndices(indices, gd.data.length - 1);\n\n    // we want descending here so that splicing later doesn't affect indexing\n    indices.sort(Lib.sorterDes);\n    for(i = 0; i < indices.length; i += 1) {\n        deletedTrace = gd.data.splice(indices[i], 1)[0];\n        traces.push(deletedTrace);\n    }\n\n    var promise = Plotly.redraw(gd);\n    Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n\n    return promise;\n};\n\n/**\n * Move traces at currentIndices array to locations in newIndices array.\n *\n * If newIndices is omitted, currentIndices will be moved to the end. E.g.,\n * these are equivalent:\n *\n * Plotly.moveTraces(gd, [1, 2, 3], [-3, -2, -1])\n * Plotly.moveTraces(gd, [1, 2, 3])\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object[]} gd.data The array of traces we're removing from\n * @param {Number|Number[]} currentIndices The locations of traces to be moved\n * @param {Number|Number[]} [newIndices] The locations to move traces to\n *\n * Example calls:\n *\n *      // move trace i to location x\n *      Plotly.moveTraces(gd, i, x)\n *\n *      // move trace i to end of array\n *      Plotly.moveTraces(gd, i)\n *\n *      // move traces i, j, k to end of array (i != j != k)\n *      Plotly.moveTraces(gd, [i, j, k])\n *\n *      // move traces [i, j, k] to [x, y, z] (i != j != k) (x != y != z)\n *      Plotly.moveTraces(gd, [i, j, k], [x, y, z])\n *\n *      // reorder all traces (assume there are 5--a, b, c, d, e)\n *      Plotly.moveTraces(gd, [b, d, e, a, c])  // same as 'move to end'\n */\nPlotly.moveTraces = function moveTraces(gd, currentIndices, newIndices) {\n    gd = helpers.getGraphDiv(gd);\n\n    var newData = [],\n        movingTraceMap = [],\n        undoFunc = moveTraces,\n        redoFunc = moveTraces,\n        undoArgs = [gd, newIndices, currentIndices],\n        redoArgs = [gd, currentIndices, newIndices],\n        i;\n\n    // to reduce complexity here, check args elsewhere\n    // this throws errors where appropriate\n    checkMoveTracesArgs(gd, currentIndices, newIndices);\n\n    // make sure currentIndices is an array\n    currentIndices = Array.isArray(currentIndices) ? currentIndices : [currentIndices];\n\n    // if undefined, define newIndices to point to the end of gd.data array\n    if(typeof newIndices === 'undefined') {\n        newIndices = [];\n        for(i = 0; i < currentIndices.length; i++) {\n            newIndices.push(-currentIndices.length + i);\n        }\n    }\n\n    // make sure newIndices is an array if it's user-defined\n    newIndices = Array.isArray(newIndices) ? newIndices : [newIndices];\n\n    // convert negative indices to positive indices (they're the same length)\n    currentIndices = positivifyIndices(currentIndices, gd.data.length - 1);\n    newIndices = positivifyIndices(newIndices, gd.data.length - 1);\n\n    // at this point, we've coerced the index arrays into predictable forms\n\n    // get the traces that aren't being moved around\n    for(i = 0; i < gd.data.length; i++) {\n\n        // if index isn't in currentIndices, include it in ignored!\n        if(currentIndices.indexOf(i) === -1) {\n            newData.push(gd.data[i]);\n        }\n    }\n\n    // get a mapping of indices to moving traces\n    for(i = 0; i < currentIndices.length; i++) {\n        movingTraceMap.push({newIndex: newIndices[i], trace: gd.data[currentIndices[i]]});\n    }\n\n    // reorder this mapping by newIndex, ascending\n    movingTraceMap.sort(function(a, b) {\n        return a.newIndex - b.newIndex;\n    });\n\n    // now, add the moving traces back in, in order!\n    for(i = 0; i < movingTraceMap.length; i += 1) {\n        newData.splice(movingTraceMap[i].newIndex, 0, movingTraceMap[i].trace);\n    }\n\n    gd.data = newData;\n\n    var promise = Plotly.redraw(gd);\n    Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n\n    return promise;\n};\n\n/**\n * restyle: update trace attributes of an existing plot\n *\n * Can be called two ways.\n *\n * Signature 1:\n * @param {String | HTMLDivElement} gd\n *  the id or DOM element of the graph container div\n * @param {String} astr\n *  attribute string (like `'marker.symbol'`) to update\n * @param {*} val\n *  value to give this attribute\n * @param {Number[] | Number} [traces]\n *  integer or array of integers for the traces to alter (all if omitted)\n *\n * Signature 2:\n * @param {String | HTMLDivElement} gd\n *  (as in signature 1)\n * @param {Object} aobj\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  allows setting multiple attributes simultaneously\n * @param {Number[] | Number} [traces]\n *  (as in signature 1)\n *\n * `val` (or `val1`, `val2` ... in the object form) can be an array,\n * to apply different values to each trace.\n *\n * If the array is too short, it will wrap around (useful for\n * style files that want to specify cyclical default values).\n */\nPlotly.restyle = function restyle(gd, astr, val, traces) {\n    gd = helpers.getGraphDiv(gd);\n    helpers.clearPromiseQueue(gd);\n\n    var aobj = {};\n    if(typeof astr === 'string') aobj[astr] = val;\n    else if(Lib.isPlainObject(astr)) {\n        // the 3-arg form\n        aobj = Lib.extendFlat({}, astr);\n        if(traces === undefined) traces = val;\n    }\n    else {\n        Lib.warn('Restyle fail.', astr, val, traces);\n        return Promise.reject();\n    }\n\n    if(Object.keys(aobj).length) gd.changed = true;\n\n    var specs = _restyle(gd, aobj, traces),\n        flags = specs.flags;\n\n    // clear calcdata if required\n    if(flags.clearCalc) gd.calcdata = undefined;\n\n    // fill in redraw sequence\n    var seq = [];\n\n    if(flags.fullReplot) {\n        seq.push(Plotly.plot);\n    } else {\n        seq.push(Plots.previousPromises);\n\n        Plots.supplyDefaults(gd);\n\n        if(flags.dostyle) seq.push(subroutines.doTraceStyle);\n        if(flags.docolorbars) seq.push(subroutines.doColorBars);\n    }\n\n    seq.push(Plots.rehover);\n\n    Queue.add(gd,\n        restyle, [gd, specs.undoit, specs.traces],\n        restyle, [gd, specs.redoit, specs.traces]\n    );\n\n    var plotDone = Lib.syncOrAsync(seq, gd);\n    if(!plotDone || !plotDone.then) plotDone = Promise.resolve();\n\n    return plotDone.then(function() {\n        gd.emit('plotly_restyle', specs.eventData);\n        return gd;\n    });\n};\n\nfunction _restyle(gd, aobj, _traces) {\n    var fullLayout = gd._fullLayout,\n        fullData = gd._fullData,\n        data = gd.data,\n        i;\n\n    var traces = helpers.coerceTraceIndices(gd, _traces);\n\n    // initialize flags\n    var flags = {\n        docalc: false,\n        docalcAutorange: false,\n        doplot: false,\n        dostyle: false,\n        docolorbars: false,\n        autorangeOn: false,\n        clearCalc: false,\n        fullReplot: false\n    };\n\n    // copies of the change (and previous values of anything affected)\n    // for the undo / redo queue\n    var redoit = {},\n        undoit = {},\n        axlist,\n        flagAxForDelete = {};\n\n    // recalcAttrs attributes need a full regeneration of calcdata\n    // as well as a replot, because the right objects may not exist,\n    // or autorange may need recalculating\n    // in principle we generally shouldn't need to redo ALL traces... that's\n    // harder though.\n    var recalcAttrs = [\n        'mode', 'visible', 'type', 'orientation', 'fill',\n        'histfunc', 'histnorm', 'text',\n        'x', 'y', 'z',\n        'a', 'b', 'c',\n        'open', 'high', 'low', 'close',\n        'base', 'width', 'offset',\n        'xtype', 'x0', 'dx', 'ytype', 'y0', 'dy', 'xaxis', 'yaxis',\n        'line.width',\n        'connectgaps', 'transpose', 'zsmooth',\n        'showscale', 'marker.showscale',\n        'zauto', 'marker.cauto',\n        'autocolorscale', 'marker.autocolorscale',\n        'colorscale', 'marker.colorscale',\n        'reversescale', 'marker.reversescale',\n        'autobinx', 'nbinsx', 'xbins', 'xbins.start', 'xbins.end', 'xbins.size',\n        'autobiny', 'nbinsy', 'ybins', 'ybins.start', 'ybins.end', 'ybins.size',\n        'autocontour', 'ncontours', 'contours', 'contours.coloring',\n        'contours.operation', 'contours.value', 'contours.type', 'contours.value[0]', 'contours.value[1]',\n        'error_y', 'error_y.visible', 'error_y.value', 'error_y.type',\n        'error_y.traceref', 'error_y.array', 'error_y.symmetric',\n        'error_y.arrayminus', 'error_y.valueminus', 'error_y.tracerefminus',\n        'error_x', 'error_x.visible', 'error_x.value', 'error_x.type',\n        'error_x.traceref', 'error_x.array', 'error_x.symmetric',\n        'error_x.arrayminus', 'error_x.valueminus', 'error_x.tracerefminus',\n        'swapxy', 'swapxyaxes', 'orientationaxes',\n        'marker.colors', 'values', 'labels', 'label0', 'dlabel', 'sort',\n        'textinfo', 'textposition', 'textfont.size', 'textfont.family', 'textfont.color',\n        'insidetextfont.size', 'insidetextfont.family', 'insidetextfont.color',\n        'outsidetextfont.size', 'outsidetextfont.family', 'outsidetextfont.color',\n        'hole', 'scalegroup', 'domain', 'domain.x', 'domain.y',\n        'domain.x[0]', 'domain.x[1]', 'domain.y[0]', 'domain.y[1]',\n        'tilt', 'tiltaxis', 'depth', 'direction', 'rotation', 'pull',\n        'line.showscale', 'line.cauto', 'line.autocolorscale', 'line.reversescale',\n        'marker.line.showscale', 'marker.line.cauto', 'marker.line.autocolorscale', 'marker.line.reversescale',\n        'xcalendar', 'ycalendar',\n        'cumulative', 'cumulative.enabled', 'cumulative.direction', 'cumulative.currentbin',\n        'a0', 'da', 'b0', 'db', 'atype', 'btype',\n        'cheaterslope', 'carpet', 'sum',\n    ];\n\n    var carpetAxisAttributes = [\n        'color', 'smoothing', 'title', 'titlefont', 'titlefont.size', 'titlefont.family',\n        'titlefont.color', 'titleoffset', 'type', 'autorange', 'rangemode', 'range',\n        'fixedrange', 'cheatertype', 'tickmode', 'nticks', 'tickvals', 'ticktext',\n        'ticks', 'mirror', 'ticklen', 'tickwidth', 'tickcolor', 'showticklabels',\n        'tickfont', 'tickfont.size', 'tickfont.family', 'tickfont.color', 'tickprefix',\n        'showtickprefix', 'ticksuffix', 'showticksuffix', 'showexponent', 'exponentformat',\n        'separatethousands', 'tickformat', 'categoryorder', 'categoryarray', 'labelpadding',\n        'labelprefix', 'labelsuffix', 'labelfont', 'labelfont.family', 'labelfont.size',\n        'labelfont.color', 'showline', 'linecolor', 'linewidth', 'gridcolor', 'gridwidth',\n        'showgrid', 'minorgridcount', 'minorgridwidth', 'minorgridcolor', 'startline',\n        'startlinecolor', 'startlinewidth', 'endline', 'endlinewidth', 'endlinecolor',\n        'tick0', 'dtick', 'arraytick0', 'arraydtick', 'hoverformat', 'tickangle'\n    ];\n\n    for(i = 0; i < carpetAxisAttributes.length; i++) {\n        recalcAttrs.push('aaxis.' + carpetAxisAttributes[i]);\n        recalcAttrs.push('baxis.' + carpetAxisAttributes[i]);\n    }\n\n    for(i = 0; i < traces.length; i++) {\n        if(Registry.traceIs(fullData[traces[i]], 'box')) {\n            recalcAttrs.push('name');\n            break;\n        }\n    }\n\n    // autorangeAttrs attributes need a full redo of calcdata\n    // only if an axis is autoranged,\n    // because .calc() is where the autorange gets determined\n    // TODO: could we break this out as well?\n    var autorangeAttrs = [\n        'marker', 'marker.size', 'textfont',\n        'boxpoints', 'jitter', 'pointpos', 'whiskerwidth', 'boxmean',\n        'tickwidth'\n    ];\n\n    // replotAttrs attributes need a replot (because different\n    // objects need to be made) but not a recalc\n    var replotAttrs = [\n        'zmin', 'zmax', 'zauto',\n        'xgap', 'ygap',\n        'marker.cmin', 'marker.cmax', 'marker.cauto',\n        'line.cmin', 'line.cmax',\n        'marker.line.cmin', 'marker.line.cmax',\n        'contours.start', 'contours.end', 'contours.size',\n        'contours.showlines',\n        'line', 'line.smoothing', 'line.shape',\n        'error_y.width', 'error_x.width', 'error_x.copy_ystyle',\n        'marker.maxdisplayed'\n    ];\n\n    // these ones may alter the axis type\n    // (at least if the first trace is involved)\n    var axtypeAttrs = [\n        'type', 'x', 'y', 'x0', 'y0', 'orientation', 'xaxis', 'yaxis'\n    ];\n\n    var zscl = ['zmin', 'zmax'],\n        xbins = ['xbins.start', 'xbins.end', 'xbins.size'],\n        ybins = ['ybins.start', 'ybins.end', 'ybins.size'],\n        contourAttrs = ['contours.start', 'contours.end', 'contours.size'];\n\n    // At the moment, only cartesian, pie and ternary plot types can afford\n    // to not go through a full replot\n    var doPlotWhiteList = ['cartesian', 'pie', 'ternary'];\n    fullLayout._basePlotModules.forEach(function(_module) {\n        if(doPlotWhiteList.indexOf(_module.name) === -1) flags.docalc = true;\n    });\n\n    // make a new empty vals array for undoit\n    function a0() { return traces.map(function() { return undefined; }); }\n\n    // for autoranging multiple axes\n    function addToAxlist(axid) {\n        var axName = Plotly.Axes.id2name(axid);\n        if(axlist.indexOf(axName) === -1) axlist.push(axName);\n    }\n\n    function autorangeAttr(axName) { return 'LAYOUT' + axName + '.autorange'; }\n\n    function rangeAttr(axName) { return 'LAYOUT' + axName + '.range'; }\n\n    // for attrs that interact (like scales & autoscales), save the\n    // old vals before making the change\n    // val=undefined will not set a value, just record what the value was.\n    // val=null will delete the attribute\n    // attr can be an array to set several at once (all to the same val)\n    function doextra(attr, val, i) {\n        if(Array.isArray(attr)) {\n            attr.forEach(function(a) { doextra(a, val, i); });\n            return;\n        }\n        // quit if explicitly setting this elsewhere\n        if(attr in aobj || helpers.hasParent(aobj, attr)) return;\n\n        var extraparam;\n        if(attr.substr(0, 6) === 'LAYOUT') {\n            extraparam = Lib.nestedProperty(gd.layout, attr.replace('LAYOUT', ''));\n        } else {\n            extraparam = Lib.nestedProperty(data[traces[i]], attr);\n        }\n\n        if(!(attr in undoit)) {\n            undoit[attr] = a0();\n        }\n        if(undoit[attr][i] === undefined) {\n            undoit[attr][i] = extraparam.get();\n        }\n        if(val !== undefined) {\n            extraparam.set(val);\n        }\n    }\n\n    // now make the changes to gd.data (and occasionally gd.layout)\n    // and figure out what kind of graphics update we need to do\n    for(var ai in aobj) {\n        if(helpers.hasParent(aobj, ai)) {\n            throw new Error('cannot set ' + ai + 'and a parent attribute simultaneously');\n        }\n\n        var vi = aobj[ai],\n            cont,\n            contFull,\n            param,\n            oldVal,\n            newVal;\n\n        redoit[ai] = vi;\n\n        if(ai.substr(0, 6) === 'LAYOUT') {\n            param = Lib.nestedProperty(gd.layout, ai.replace('LAYOUT', ''));\n            undoit[ai] = [param.get()];\n            // since we're allowing val to be an array, allow it here too,\n            // even though that's meaningless\n            param.set(Array.isArray(vi) ? vi[0] : vi);\n            // ironically, the layout attrs in restyle only require replot,\n            // not relayout\n            flags.docalc = true;\n            continue;\n        }\n\n        // set attribute in gd.data\n        undoit[ai] = a0();\n        for(i = 0; i < traces.length; i++) {\n            cont = data[traces[i]];\n            contFull = fullData[traces[i]];\n            param = Lib.nestedProperty(cont, ai);\n            oldVal = param.get();\n            newVal = Array.isArray(vi) ? vi[i % vi.length] : vi;\n\n            if(newVal === undefined) continue;\n\n            // setting bin or z settings should turn off auto\n            // and setting auto should save bin or z settings\n            if(zscl.indexOf(ai) !== -1) {\n                doextra('zauto', false, i);\n            }\n            else if(ai === 'colorscale') {\n                doextra('autocolorscale', false, i);\n            }\n            else if(ai === 'autocolorscale') {\n                doextra('colorscale', undefined, i);\n            }\n            else if(ai === 'marker.colorscale') {\n                doextra('marker.autocolorscale', false, i);\n            }\n            else if(ai === 'marker.autocolorscale') {\n                doextra('marker.colorscale', undefined, i);\n            }\n            else if(ai === 'zauto') {\n                doextra(zscl, undefined, i);\n            }\n            else if(xbins.indexOf(ai) !== -1) {\n                doextra('autobinx', false, i);\n            }\n            else if(ai === 'autobinx') {\n                doextra(xbins, undefined, i);\n            }\n            else if(ybins.indexOf(ai) !== -1) {\n                doextra('autobiny', false, i);\n            }\n            else if(ai === 'autobiny') {\n                doextra(ybins, undefined, i);\n            }\n            else if(contourAttrs.indexOf(ai) !== -1) {\n                doextra('autocontour', false, i);\n            }\n            else if(ai === 'autocontour') {\n                doextra(contourAttrs, undefined, i);\n            }\n            // heatmaps: setting x0 or dx, y0 or dy,\n            // should turn xtype/ytype to 'scaled' if 'array'\n            else if(['x0', 'dx'].indexOf(ai) !== -1 &&\n                    contFull.x && contFull.xtype !== 'scaled') {\n                doextra('xtype', 'scaled', i);\n            }\n            else if(['y0', 'dy'].indexOf(ai) !== -1 &&\n                    contFull.y && contFull.ytype !== 'scaled') {\n                doextra('ytype', 'scaled', i);\n            }\n            // changing colorbar size modes,\n            // make the resulting size not change\n            // note that colorbar fractional sizing is based on the\n            // original plot size, before anything (like a colorbar)\n            // increases the margins\n            else if(ai === 'colorbar.thicknessmode' && param.get() !== newVal &&\n                        ['fraction', 'pixels'].indexOf(newVal) !== -1 &&\n                        contFull.colorbar) {\n                var thicknorm =\n                    ['top', 'bottom'].indexOf(contFull.colorbar.orient) !== -1 ?\n                        (fullLayout.height - fullLayout.margin.t - fullLayout.margin.b) :\n                        (fullLayout.width - fullLayout.margin.l - fullLayout.margin.r);\n                doextra('colorbar.thickness', contFull.colorbar.thickness *\n                    (newVal === 'fraction' ? 1 / thicknorm : thicknorm), i);\n            }\n            else if(ai === 'colorbar.lenmode' && param.get() !== newVal &&\n                        ['fraction', 'pixels'].indexOf(newVal) !== -1 &&\n                        contFull.colorbar) {\n                var lennorm =\n                    ['top', 'bottom'].indexOf(contFull.colorbar.orient) !== -1 ?\n                        (fullLayout.width - fullLayout.margin.l - fullLayout.margin.r) :\n                        (fullLayout.height - fullLayout.margin.t - fullLayout.margin.b);\n                doextra('colorbar.len', contFull.colorbar.len *\n                    (newVal === 'fraction' ? 1 / lennorm : lennorm), i);\n            }\n            else if(ai === 'colorbar.tick0' || ai === 'colorbar.dtick') {\n                doextra('colorbar.tickmode', 'linear', i);\n            }\n            else if(ai === 'colorbar.tickmode') {\n                doextra(['colorbar.tick0', 'colorbar.dtick'], undefined, i);\n            }\n\n\n            if(ai === 'type' && (newVal === 'pie') !== (oldVal === 'pie')) {\n                var labelsTo = 'x',\n                    valuesTo = 'y';\n                if((newVal === 'bar' || oldVal === 'bar') && cont.orientation === 'h') {\n                    labelsTo = 'y';\n                    valuesTo = 'x';\n                }\n                Lib.swapAttrs(cont, ['?', '?src'], 'labels', labelsTo);\n                Lib.swapAttrs(cont, ['d?', '?0'], 'label', labelsTo);\n                Lib.swapAttrs(cont, ['?', '?src'], 'values', valuesTo);\n\n                if(oldVal === 'pie') {\n                    Lib.nestedProperty(cont, 'marker.color')\n                        .set(Lib.nestedProperty(cont, 'marker.colors').get());\n\n                    // super kludgy - but if all pies are gone we won't remove them otherwise\n                    fullLayout._pielayer.selectAll('g.trace').remove();\n                } else if(Registry.traceIs(cont, 'cartesian')) {\n                    Lib.nestedProperty(cont, 'marker.colors')\n                        .set(Lib.nestedProperty(cont, 'marker.color').get());\n                    // look for axes that are no longer in use and delete them\n                    flagAxForDelete[cont.xaxis || 'x'] = true;\n                    flagAxForDelete[cont.yaxis || 'y'] = true;\n                }\n            }\n\n            undoit[ai][i] = oldVal;\n            // set the new value - if val is an array, it's one el per trace\n            // first check for attributes that get more complex alterations\n            var swapAttrs = [\n                'swapxy', 'swapxyaxes', 'orientation', 'orientationaxes'\n            ];\n            if(swapAttrs.indexOf(ai) !== -1) {\n                // setting an orientation: make sure it's changing\n                // before we swap everything else\n                if(ai === 'orientation') {\n                    param.set(newVal);\n                    if(param.get() === undoit[ai][i]) continue;\n                }\n                // orientationaxes has no value,\n                // it flips everything and the axes\n                else if(ai === 'orientationaxes') {\n                    cont.orientation =\n                        {v: 'h', h: 'v'}[contFull.orientation];\n                }\n                helpers.swapXYData(cont);\n            }\n            else if(Plots.dataArrayContainers.indexOf(param.parts[0]) !== -1) {\n                // TODO: use manageArrays.applyContainerArrayChanges here too\n                helpers.manageArrayContainers(param, newVal, undoit);\n                flags.docalc = true;\n            }\n            else {\n                var moduleAttrs = (contFull._module || {}).attributes || {};\n                var valObject = Lib.nestedProperty(moduleAttrs, ai).get() || {};\n\n                // if restyling entire attribute container, assume worse case\n                if(!valObject.valType) {\n                    flags.docalc = true;\n                }\n\n                // must redo calcdata when restyling array values of arrayOk attributes\n                if(valObject.arrayOk && (Array.isArray(newVal) || Array.isArray(oldVal))) {\n                    flags.docalc = true;\n                }\n\n                // all the other ones, just modify that one attribute\n                param.set(newVal);\n            }\n        }\n\n        // swap the data attributes of the relevant x and y axes?\n        if(['swapxyaxes', 'orientationaxes'].indexOf(ai) !== -1) {\n            Plotly.Axes.swap(gd, traces);\n        }\n\n        // swap hovermode if set to \"compare x/y data\"\n        if(ai === 'orientationaxes') {\n            var hovermode = Lib.nestedProperty(gd.layout, 'hovermode');\n            if(hovermode.get() === 'x') {\n                hovermode.set('y');\n            } else if(hovermode.get() === 'y') {\n                hovermode.set('x');\n            }\n        }\n\n        // check if we need to call axis type\n        if((traces.indexOf(0) !== -1) && (axtypeAttrs.indexOf(ai) !== -1)) {\n            Plotly.Axes.clearTypes(gd, traces);\n            flags.docalc = true;\n        }\n\n        // switching from auto to manual binning or z scaling doesn't\n        // actually do anything but change what you see in the styling\n        // box. everything else at least needs to apply styles\n        if((['autobinx', 'autobiny', 'zauto'].indexOf(ai) === -1) ||\n                newVal !== false) {\n            flags.dostyle = true;\n        }\n        if(['colorbar', 'line'].indexOf(param.parts[0]) !== -1 ||\n            param.parts[0] === 'marker' && param.parts[1] === 'colorbar') {\n            flags.docolorbars = true;\n        }\n\n        var aiArrayStart = ai.indexOf('['),\n            aiAboveArray = aiArrayStart === -1 ? ai : ai.substr(0, aiArrayStart);\n\n        if(recalcAttrs.indexOf(aiAboveArray) !== -1) {\n            // major enough changes deserve autoscale, autobin, and\n            // non-reversed axes so people don't get confused\n            if(['orientation', 'type'].indexOf(ai) !== -1) {\n                axlist = [];\n                for(i = 0; i < traces.length; i++) {\n                    var trace = data[traces[i]];\n\n                    if(Registry.traceIs(trace, 'cartesian')) {\n                        addToAxlist(trace.xaxis || 'x');\n                        addToAxlist(trace.yaxis || 'y');\n\n                        if(ai === 'type') {\n                            doextra(['autobinx', 'autobiny'], true, i);\n                        }\n                    }\n                }\n\n                doextra(axlist.map(autorangeAttr), true, 0);\n                doextra(axlist.map(rangeAttr), [0, 1], 0);\n            }\n            flags.docalc = true;\n\n        } else if(replotAttrs.indexOf(aiAboveArray) !== -1) {\n            flags.doplot = true;\n        } else if(aiAboveArray.indexOf('aaxis') === 0 || aiAboveArray.indexOf('baxis') === 0) {\n            flags.doplot = true;\n        } else if(autorangeAttrs.indexOf(aiAboveArray) !== -1) {\n            flags.docalcAutorange = true;\n        }\n    }\n\n    // do we need to force a recalc?\n    Plotly.Axes.list(gd).forEach(function(ax) {\n        if(ax.autorange) flags.autorangeOn = true;\n    });\n\n    // check axes we've flagged for possible deletion\n    // flagAxForDelete is a hash so we can make sure we only get each axis once\n    var axListForDelete = Object.keys(flagAxForDelete);\n    axisLoop:\n    for(i = 0; i < axListForDelete.length; i++) {\n        var axId = axListForDelete[i],\n            axLetter = axId.charAt(0),\n            axAttr = axLetter + 'axis';\n\n        for(var j = 0; j < data.length; j++) {\n            if(Registry.traceIs(data[j], 'cartesian') &&\n                    (data[j][axAttr] || axLetter) === axId) {\n                continue axisLoop;\n            }\n        }\n\n        // no data on this axis - delete it.\n        doextra('LAYOUT' + Plotly.Axes.id2name(axId), null, 0);\n    }\n\n    // combine a few flags together;\n    if(flags.docalc || (flags.docalcAutorange && flags.autorangeOn)) {\n        flags.clearCalc = true;\n    }\n    if(flags.docalc || flags.doplot || flags.docalcAutorange) {\n        flags.fullReplot = true;\n    }\n\n    return {\n        flags: flags,\n        undoit: undoit,\n        redoit: redoit,\n        traces: traces,\n        eventData: Lib.extendDeepNoArrays([], [redoit, traces])\n    };\n}\n\n/**\n * relayout: update layout attributes of an existing plot\n *\n * Can be called two ways:\n *\n * Signature 1:\n * @param {String | HTMLDivElement} gd\n *  the id or dom element of the graph container div\n * @param {String} astr\n *  attribute string (like `'xaxis.range[0]'`) to update\n * @param {*} val\n *  value to give this attribute\n *\n * Signature 2:\n * @param {String | HTMLDivElement} gd\n *  (as in signature 1)\n * @param {Object} aobj\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  allows setting multiple attributes simultaneously\n */\nPlotly.relayout = function relayout(gd, astr, val) {\n    gd = helpers.getGraphDiv(gd);\n    helpers.clearPromiseQueue(gd);\n\n    if(gd.framework && gd.framework.isPolar) {\n        return Promise.resolve(gd);\n    }\n\n    var aobj = {};\n    if(typeof astr === 'string') {\n        aobj[astr] = val;\n    } else if(Lib.isPlainObject(astr)) {\n        aobj = Lib.extendFlat({}, astr);\n    } else {\n        Lib.warn('Relayout fail.', astr, val);\n        return Promise.reject();\n    }\n\n    if(Object.keys(aobj).length) gd.changed = true;\n\n    var specs = _relayout(gd, aobj),\n        flags = specs.flags;\n\n    // clear calcdata if required\n    if(flags.docalc) gd.calcdata = undefined;\n\n    // fill in redraw sequence\n\n    // even if we don't have anything left in aobj,\n    // something may have happened within relayout that we\n    // need to wait for\n    var seq = [Plots.previousPromises];\n\n    if(flags.layoutReplot) {\n        seq.push(subroutines.layoutReplot);\n    }\n    else if(Object.keys(aobj).length) {\n        Plots.supplyDefaults(gd);\n\n        if(flags.dolegend) seq.push(subroutines.doLegend);\n        if(flags.dolayoutstyle) seq.push(subroutines.layoutStyles);\n        if(flags.doticks) seq.push(subroutines.doTicksRelayout);\n        if(flags.domodebar) seq.push(subroutines.doModeBar);\n        if(flags.docamera) seq.push(subroutines.doCamera);\n    }\n\n    seq.push(Plots.rehover);\n\n    Queue.add(gd,\n        relayout, [gd, specs.undoit],\n        relayout, [gd, specs.redoit]\n    );\n\n    var plotDone = Lib.syncOrAsync(seq, gd);\n    if(!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);\n\n    return plotDone.then(function() {\n        gd.emit('plotly_relayout', specs.eventData);\n        return gd;\n    });\n};\n\nfunction _relayout(gd, aobj) {\n    var layout = gd.layout,\n        fullLayout = gd._fullLayout,\n        keys = Object.keys(aobj),\n        axes = Plotly.Axes.list(gd),\n        arrayEdits = {},\n        arrayStr,\n        i,\n        j;\n\n    // look for 'allaxes', split out into all axes\n    // in case of 3D the axis are nested within a scene which is held in _id\n    for(i = 0; i < keys.length; i++) {\n        if(keys[i].indexOf('allaxes') === 0) {\n            for(j = 0; j < axes.length; j++) {\n                var scene = axes[j]._id.substr(1),\n                    axisAttr = (scene.indexOf('scene') !== -1) ? (scene + '.') : '',\n                    newkey = keys[i].replace('allaxes', axisAttr + axes[j]._name);\n\n                if(!aobj[newkey]) aobj[newkey] = aobj[keys[i]];\n            }\n\n            delete aobj[keys[i]];\n        }\n    }\n\n    // initialize flags\n    var flags = {\n        dolegend: false,\n        doticks: false,\n        dolayoutstyle: false,\n        doplot: false,\n        docalc: false,\n        domodebar: false,\n        docamera: false,\n        layoutReplot: false\n    };\n\n    // copies of the change (and previous values of anything affected)\n    // for the undo / redo queue\n    var redoit = {},\n        undoit = {};\n\n    // for attrs that interact (like scales & autoscales), save the\n    // old vals before making the change\n    // val=undefined will not set a value, just record what the value was.\n    // attr can be an array to set several at once (all to the same val)\n    function doextra(attr, val) {\n        if(Array.isArray(attr)) {\n            attr.forEach(function(a) { doextra(a, val); });\n            return;\n        }\n\n        // if we have another value for this attribute (explicitly or\n        // via a parent) do not override with this auto-generated extra\n        if(attr in aobj || helpers.hasParent(aobj, attr)) return;\n\n        var p = Lib.nestedProperty(layout, attr);\n        if(!(attr in undoit)) undoit[attr] = p.get();\n        if(val !== undefined) p.set(val);\n    }\n\n    // for editing annotations or shapes - is it on autoscaled axes?\n    function refAutorange(obj, axLetter) {\n        if(!Lib.isPlainObject(obj)) return false;\n        var axRef = obj[axLetter + 'ref'] || axLetter,\n            ax = Plotly.Axes.getFromId(gd, axRef);\n\n        if(!ax && axRef.charAt(0) === axLetter) {\n            // fall back on the primary axis in case we've referenced a\n            // nonexistent axis (as we do above if axRef is missing).\n            // This assumes the object defaults to data referenced, which\n            // is the case for shapes and annotations but not for images.\n            // The only thing this is used for is to determine whether to\n            // do a full `recalc`, so the only ill effect of this error is\n            // to waste some time.\n            ax = Plotly.Axes.getFromId(gd, axLetter);\n        }\n        return (ax || {}).autorange;\n    }\n\n    // for constraint enforcement: keep track of all axes (as {id: name})\n    // we're editing the (auto)range of, so we can tell the others constrained\n    // to scale with them that it's OK for them to shrink\n    var rangesAltered = {};\n\n    function recordAlteredAxis(pleafPlus) {\n        var axId = axisIds.name2id(pleafPlus.split('.')[0]);\n        rangesAltered[axId] = 1;\n    }\n\n    // alter gd.layout\n    for(var ai in aobj) {\n        if(helpers.hasParent(aobj, ai)) {\n            throw new Error('cannot set ' + ai + 'and a parent attribute simultaneously');\n        }\n\n        var p = Lib.nestedProperty(layout, ai),\n            vi = aobj[ai],\n            plen = p.parts.length,\n            // p.parts may end with an index integer if the property is an array\n            pend = typeof p.parts[plen - 1] === 'string' ? (plen - 1) : (plen - 2),\n            // last property in chain (leaf node)\n            proot = p.parts[0],\n            pleaf = p.parts[pend],\n            // leaf plus immediate parent\n            pleafPlus = p.parts[pend - 1] + '.' + pleaf,\n            // trunk nodes (everything except the leaf)\n            ptrunk = p.parts.slice(0, pend).join('.'),\n            parentIn = Lib.nestedProperty(gd.layout, ptrunk).get(),\n            parentFull = Lib.nestedProperty(fullLayout, ptrunk).get();\n\n        if(vi === undefined) continue;\n\n        redoit[ai] = vi;\n\n        // axis reverse is special - it is its own inverse\n        // op and has no flag.\n        undoit[ai] = (pleaf === 'reverse') ? vi : p.get();\n\n        // Setting width or height to null must reset the graph's width / height\n        // back to its initial value as computed during the first pass in Plots.plotAutoSize.\n        //\n        // To do so, we must manually set them back here using the _initialAutoSize cache.\n        if(['width', 'height'].indexOf(ai) !== -1 && vi === null) {\n            fullLayout[ai] = gd._initialAutoSize[ai];\n        }\n        // check autorange vs range\n        else if(pleafPlus.match(/^[xyz]axis[0-9]*\\.range(\\[[0|1]\\])?$/)) {\n            doextra(ptrunk + '.autorange', false);\n            recordAlteredAxis(pleafPlus);\n        }\n        else if(pleafPlus.match(/^[xyz]axis[0-9]*\\.autorange$/)) {\n            doextra([ptrunk + '.range[0]', ptrunk + '.range[1]'],\n                undefined);\n            recordAlteredAxis(pleafPlus);\n        }\n        else if(pleafPlus.match(/^aspectratio\\.[xyz]$/)) {\n            doextra(proot + '.aspectmode', 'manual');\n        }\n        else if(pleafPlus.match(/^aspectmode$/)) {\n            doextra([ptrunk + '.x', ptrunk + '.y', ptrunk + '.z'], undefined);\n        }\n        else if(pleaf === 'tick0' || pleaf === 'dtick') {\n            doextra(ptrunk + '.tickmode', 'linear');\n        }\n        else if(pleaf === 'tickmode') {\n            doextra([ptrunk + '.tick0', ptrunk + '.dtick'], undefined);\n        }\n        else if(/[xy]axis[0-9]*?$/.test(pleaf) && !Object.keys(vi || {}).length) {\n            flags.docalc = true;\n        }\n        else if(/[xy]axis[0-9]*\\.categoryorder$/.test(pleafPlus)) {\n            flags.docalc = true;\n        }\n        else if(/[xy]axis[0-9]*\\.categoryarray/.test(pleafPlus)) {\n            flags.docalc = true;\n        }\n\n        if(pleafPlus.indexOf('rangeslider') !== -1) {\n            flags.docalc = true;\n        }\n\n        // toggling axis type between log and linear: we need to convert\n        // positions for components that are still using linearized values,\n        // not data values like newer components.\n        // previously we did this for log <-> not-log, but now only do it\n        // for log <-> linear\n        if(pleaf === 'type') {\n            var ax = parentIn,\n                toLog = parentFull.type === 'linear' && vi === 'log',\n                fromLog = parentFull.type === 'log' && vi === 'linear';\n\n            if(toLog || fromLog) {\n                if(!ax || !ax.range) {\n                    doextra(ptrunk + '.autorange', true);\n                }\n                else if(!parentFull.autorange) {\n                    // toggling log without autorange: need to also recalculate ranges\n                    // because log axes use linearized values for range endpoints\n                    var r0 = ax.range[0],\n                        r1 = ax.range[1];\n                    if(toLog) {\n                        // if both limits are negative, autorange\n                        if(r0 <= 0 && r1 <= 0) {\n                            doextra(ptrunk + '.autorange', true);\n                        }\n                        // if one is negative, set it 6 orders below the other.\n                        if(r0 <= 0) r0 = r1 / 1e6;\n                        else if(r1 <= 0) r1 = r0 / 1e6;\n                        // now set the range values as appropriate\n                        doextra(ptrunk + '.range[0]', Math.log(r0) / Math.LN10);\n                        doextra(ptrunk + '.range[1]', Math.log(r1) / Math.LN10);\n                    }\n                    else {\n                        doextra(ptrunk + '.range[0]', Math.pow(10, r0));\n                        doextra(ptrunk + '.range[1]', Math.pow(10, r1));\n                    }\n                }\n                else if(toLog) {\n                    // just make sure the range is positive and in the right\n                    // order, it'll get recalculated later\n                    ax.range = (ax.range[1] > ax.range[0]) ? [1, 2] : [2, 1];\n                }\n\n                // Annotations and images also need to convert to/from linearized coords\n                // Shapes do not need this :)\n                Registry.getComponentMethod('annotations', 'convertCoords')(gd, parentFull, vi, doextra);\n                Registry.getComponentMethod('images', 'convertCoords')(gd, parentFull, vi, doextra);\n            }\n            else {\n                // any other type changes: the range from the previous type\n                // will not make sense, so autorange it.\n                doextra(ptrunk + '.autorange', true);\n            }\n        }\n        else if(pleaf.match(cartesianConstants.AX_NAME_PATTERN)) {\n            var fullProp = Lib.nestedProperty(fullLayout, ai).get(),\n                newType = (vi || {}).type;\n\n            // This can potentially cause strange behavior if the autotype is not\n            // numeric (linear, because we don't auto-log) but the previous type\n            // was log. That's a very strange edge case though\n            if(!newType || newType === '-') newType = 'linear';\n            Registry.getComponentMethod('annotations', 'convertCoords')(gd, fullProp, newType, doextra);\n            Registry.getComponentMethod('images', 'convertCoords')(gd, fullProp, newType, doextra);\n        }\n\n        // alter gd.layout\n\n        // collect array component edits for execution all together\n        // so we can ensure consistent behavior adding/removing items\n        // and order-independence for add/remove/edit all together in\n        // one relayout call\n        var containerArrayMatch = manageArrays.containerArrayMatch(ai);\n        if(containerArrayMatch) {\n            arrayStr = containerArrayMatch.array;\n            i = containerArrayMatch.index;\n            var propStr = containerArrayMatch.property,\n                componentArray = Lib.nestedProperty(layout, arrayStr),\n                obji = (componentArray || [])[i] || {};\n\n            if(i === '') {\n                // replacing the entire array: too much going on, force recalc\n                if(ai.indexOf('updatemenus') === -1) flags.docalc = true;\n            }\n            else if(propStr === '') {\n                // special handling of undoit if we're adding or removing an element\n                // ie 'annotations[2]' which can be {...} (add) or null (remove)\n                var toggledObj = vi;\n                if(manageArrays.isAddVal(vi)) {\n                    undoit[ai] = null;\n                }\n                else if(manageArrays.isRemoveVal(vi)) {\n                    undoit[ai] = obji;\n                    toggledObj = obji;\n                }\n                else Lib.warn('unrecognized full object value', aobj);\n\n                if(refAutorange(toggledObj, 'x') || refAutorange(toggledObj, 'y') &&\n                        ai.indexOf('updatemenus') === -1) {\n                    flags.docalc = true;\n                }\n            }\n            else if((refAutorange(obji, 'x') || refAutorange(obji, 'y')) &&\n                    !Lib.containsAny(ai, ['color', 'opacity', 'align', 'dash', 'updatemenus'])) {\n                flags.docalc = true;\n            }\n\n            // prepare the edits object we'll send to applyContainerArrayChanges\n            if(!arrayEdits[arrayStr]) arrayEdits[arrayStr] = {};\n            var objEdits = arrayEdits[arrayStr][i];\n            if(!objEdits) objEdits = arrayEdits[arrayStr][i] = {};\n            objEdits[propStr] = vi;\n\n            delete aobj[ai];\n        }\n        // handle axis reversal explicitly, as there's no 'reverse' flag\n        else if(pleaf === 'reverse') {\n            if(parentIn.range) parentIn.range.reverse();\n            else {\n                doextra(ptrunk + '.autorange', true);\n                parentIn.range = [1, 0];\n            }\n\n            if(parentFull.autorange) flags.docalc = true;\n            else flags.doplot = true;\n        }\n        else {\n            var pp1 = String(p.parts[1] || '');\n            // check whether we can short-circuit a full redraw\n            // 3d or geo at this point just needs to redraw.\n            if(proot.indexOf('scene') === 0) {\n                if(p.parts[1] === 'camera') flags.docamera = true;\n                else flags.doplot = true;\n            }\n            else if(proot.indexOf('geo') === 0) flags.doplot = true;\n            else if(proot.indexOf('ternary') === 0) flags.doplot = true;\n            else if(ai === 'paper_bgcolor') flags.doplot = true;\n            else if(proot === 'margin' ||\n                    pp1 === 'autorange' ||\n                    pp1 === 'rangemode' ||\n                    pp1 === 'type' ||\n                    pp1 === 'domain' ||\n                    pp1 === 'fixedrange' ||\n                    pp1 === 'scaleanchor' ||\n                    pp1 === 'scaleratio' ||\n                    ai.indexOf('calendar') !== -1 ||\n                    ai.match(/^(bar|box|font)/)) {\n                flags.docalc = true;\n            }\n            else if(fullLayout._has('gl2d') &&\n                (ai.indexOf('axis') !== -1 || ai === 'plot_bgcolor')\n            ) flags.doplot = true;\n            else if(ai === 'hiddenlabels') flags.docalc = true;\n            else if(proot.indexOf('legend') !== -1) flags.dolegend = true;\n            else if(ai.indexOf('title') !== -1) flags.doticks = true;\n            else if(proot.indexOf('bgcolor') !== -1) flags.dolayoutstyle = true;\n            else if(plen > 1 && Lib.containsAny(pp1, ['tick', 'exponent', 'grid', 'zeroline'])) {\n                flags.doticks = true;\n            }\n            else if(ai.indexOf('.linewidth') !== -1 &&\n                    ai.indexOf('axis') !== -1) {\n                flags.doticks = flags.dolayoutstyle = true;\n            }\n            else if(plen > 1 && pp1.indexOf('line') !== -1) {\n                flags.dolayoutstyle = true;\n            }\n            else if(plen > 1 && pp1 === 'mirror') {\n                flags.doticks = flags.dolayoutstyle = true;\n            }\n            else if(ai === 'margin.pad') {\n                flags.doticks = flags.dolayoutstyle = true;\n            }\n            /*\n             * hovermode, dragmode, and spikes don't need any redrawing, since they just\n             * affect reaction to user input. Everything else, assume full replot.\n             * height, width, autosize get dealt with below. Except for the case of\n             * of subplots - scenes - which require scene.updateFx to be called.\n             */\n            else if(['hovermode', 'dragmode'].indexOf(ai) !== -1 ||\n                    ai.indexOf('spike') !== -1) {\n                flags.domodebar = true;\n            }\n            else if(['height', 'width', 'autosize'].indexOf(ai) === -1) {\n                flags.doplot = true;\n            }\n\n            p.set(vi);\n        }\n    }\n\n    // now we've collected component edits - execute them all together\n    for(arrayStr in arrayEdits) {\n        var finished = manageArrays.applyContainerArrayChanges(gd,\n            Lib.nestedProperty(layout, arrayStr), arrayEdits[arrayStr], flags);\n        if(!finished) flags.doplot = true;\n    }\n\n    // figure out if we need to recalculate axis constraints\n    var constraints = fullLayout._axisConstraintGroups;\n    for(var axId in rangesAltered) {\n        for(i = 0; i < constraints.length; i++) {\n            var group = constraints[i];\n            if(group[axId]) {\n                // Always recalc if we're changing constrained ranges.\n                // Otherwise it's possible to violate the constraints by\n                // specifying arbitrary ranges for all axes in the group.\n                // this way some ranges may expand beyond what's specified,\n                // as they do at first draw, to satisfy the constraints.\n                flags.docalc = true;\n                for(var groupAxId in group) {\n                    if(!rangesAltered[groupAxId]) {\n                        axisIds.getFromId(gd, groupAxId)._constraintShrinkable = true;\n                    }\n                }\n            }\n        }\n    }\n\n    var oldWidth = fullLayout.width,\n        oldHeight = fullLayout.height;\n\n    // calculate autosizing\n    if(gd.layout.autosize) Plots.plotAutoSize(gd, gd.layout, fullLayout);\n\n    // avoid unnecessary redraws\n    var hasSizechanged = aobj.height || aobj.width ||\n        (fullLayout.width !== oldWidth) ||\n        (fullLayout.height !== oldHeight);\n\n    if(hasSizechanged) flags.docalc = true;\n\n    if(flags.doplot || flags.docalc) {\n        flags.layoutReplot = true;\n    }\n\n    // now all attribute mods are done, as are\n    // redo and undo so we can save them\n\n    return {\n        flags: flags,\n        undoit: undoit,\n        redoit: redoit,\n        eventData: Lib.extendDeep({}, redoit)\n    };\n}\n\n/**\n * update: update trace and layout attributes of an existing plot\n *\n * @param {String | HTMLDivElement} gd\n *  the id or DOM element of the graph container div\n * @param {Object} traceUpdate\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  corresponding to updates in the plot's traces\n * @param {Object} layoutUpdate\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  corresponding to updates in the plot's layout\n * @param {Number[] | Number} [traces]\n *  integer or array of integers for the traces to alter (all if omitted)\n *\n */\nPlotly.update = function update(gd, traceUpdate, layoutUpdate, traces) {\n    gd = helpers.getGraphDiv(gd);\n    helpers.clearPromiseQueue(gd);\n\n    if(gd.framework && gd.framework.isPolar) {\n        return Promise.resolve(gd);\n    }\n\n    if(!Lib.isPlainObject(traceUpdate)) traceUpdate = {};\n    if(!Lib.isPlainObject(layoutUpdate)) layoutUpdate = {};\n\n    if(Object.keys(traceUpdate).length) gd.changed = true;\n    if(Object.keys(layoutUpdate).length) gd.changed = true;\n\n    var restyleSpecs = _restyle(gd, Lib.extendFlat({}, traceUpdate), traces),\n        restyleFlags = restyleSpecs.flags;\n\n    var relayoutSpecs = _relayout(gd, Lib.extendFlat({}, layoutUpdate)),\n        relayoutFlags = relayoutSpecs.flags;\n\n    // clear calcdata if required\n    if(restyleFlags.clearCalc || relayoutFlags.docalc) gd.calcdata = undefined;\n\n    // fill in redraw sequence\n    var seq = [];\n\n    if(restyleFlags.fullReplot && relayoutFlags.layoutReplot) {\n        var data = gd.data,\n            layout = gd.layout;\n\n        // clear existing data/layout on gd\n        // so that Plotly.plot doesn't try to extend them\n        gd.data = undefined;\n        gd.layout = undefined;\n\n        seq.push(function() { return Plotly.plot(gd, data, layout); });\n    }\n    else if(restyleFlags.fullReplot) {\n        seq.push(Plotly.plot);\n    }\n    else if(relayoutFlags.layoutReplot) {\n        seq.push(subroutines.layoutReplot);\n    }\n    else {\n        seq.push(Plots.previousPromises);\n        Plots.supplyDefaults(gd);\n\n        if(restyleFlags.dostyle) seq.push(subroutines.doTraceStyle);\n        if(restyleFlags.docolorbars) seq.push(subroutines.doColorBars);\n        if(relayoutFlags.dolegend) seq.push(subroutines.doLegend);\n        if(relayoutFlags.dolayoutstyle) seq.push(subroutines.layoutStyles);\n        if(relayoutFlags.doticks) seq.push(subroutines.doTicksRelayout);\n        if(relayoutFlags.domodebar) seq.push(subroutines.doModeBar);\n        if(relayoutFlags.doCamera) seq.push(subroutines.doCamera);\n    }\n\n    seq.push(Plots.rehover);\n\n    Queue.add(gd,\n        update, [gd, restyleSpecs.undoit, relayoutSpecs.undoit, restyleSpecs.traces],\n        update, [gd, restyleSpecs.redoit, relayoutSpecs.redoit, restyleSpecs.traces]\n    );\n\n    var plotDone = Lib.syncOrAsync(seq, gd);\n    if(!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);\n\n    return plotDone.then(function() {\n        gd.emit('plotly_update', {\n            data: restyleSpecs.eventData,\n            layout: relayoutSpecs.eventData\n        });\n\n        return gd;\n    });\n};\n\n/**\n * Animate to a frame, sequence of frame, frame group, or frame definition\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n *\n * @param {string or object or array of strings or array of objects} frameOrGroupNameOrFrameList\n *      a single frame, array of frames, or group to which to animate. The intent is\n *      inferred by the type of the input. Valid inputs are:\n *\n *      - string, e.g. 'groupname': animate all frames of a given `group` in the order\n *            in which they are defined via `Plotly.addFrames`.\n *\n *      - array of strings, e.g. ['frame1', frame2']: a list of frames by name to which\n *            to animate in sequence\n *\n *      - object: {data: ...}: a frame definition to which to animate. The frame is not\n *            and does not need to be added via `Plotly.addFrames`. It may contain any of\n *            the properties of a frame, including `data`, `layout`, and `traces`. The\n *            frame is used as provided and does not use the `baseframe` property.\n *\n *      - array of objects, e.g. [{data: ...}, {data: ...}]: a list of frame objects,\n *            each following the same rules as a single `object`.\n *\n * @param {object} animationOpts\n *      configuration for the animation\n */\nPlotly.animate = function(gd, frameOrGroupNameOrFrameList, animationOpts) {\n    gd = helpers.getGraphDiv(gd);\n\n    if(!Lib.isPlotDiv(gd)) {\n        throw new Error(\n            'This element is not a Plotly plot: ' + gd + '. It\\'s likely that you\\'ve failed ' +\n            'to create a plot before animating it. For more details, see ' +\n            'https://plot.ly/javascript/animations/'\n        );\n    }\n\n    var trans = gd._transitionData;\n\n    // This is the queue of frames that will be animated as soon as possible. They\n    // are popped immediately upon the *start* of a transition:\n    if(!trans._frameQueue) {\n        trans._frameQueue = [];\n    }\n\n    animationOpts = Plots.supplyAnimationDefaults(animationOpts);\n    var transitionOpts = animationOpts.transition;\n    var frameOpts = animationOpts.frame;\n\n    // Since frames are popped immediately, an empty queue only means all frames have\n    // *started* to transition, not that the animation is complete. To solve that,\n    // track a separate counter that increments at the same time as frames are added\n    // to the queue, but decrements only when the transition is complete.\n    if(trans._frameWaitingCnt === undefined) {\n        trans._frameWaitingCnt = 0;\n    }\n\n    function getTransitionOpts(i) {\n        if(Array.isArray(transitionOpts)) {\n            if(i >= transitionOpts.length) {\n                return transitionOpts[0];\n            } else {\n                return transitionOpts[i];\n            }\n        } else {\n            return transitionOpts;\n        }\n    }\n\n    function getFrameOpts(i) {\n        if(Array.isArray(frameOpts)) {\n            if(i >= frameOpts.length) {\n                return frameOpts[0];\n            } else {\n                return frameOpts[i];\n            }\n        } else {\n            return frameOpts;\n        }\n    }\n\n    // Execute a callback after the wrapper function has been called n times.\n    // This is used to defer the resolution until a transition has resovled *and*\n    // the frame has completed. If it's not done this way, then we get a race\n    // condition in which the animation might resolve before a transition is complete\n    // or vice versa.\n    function callbackOnNthTime(cb, n) {\n        var cnt = 0;\n        return function() {\n            if(cb && ++cnt === n) {\n                return cb();\n            }\n        };\n    }\n\n    return new Promise(function(resolve, reject) {\n        function discardExistingFrames() {\n            if(trans._frameQueue.length === 0) {\n                return;\n            }\n\n            while(trans._frameQueue.length) {\n                var next = trans._frameQueue.pop();\n                if(next.onInterrupt) {\n                    next.onInterrupt();\n                }\n            }\n\n            gd.emit('plotly_animationinterrupted', []);\n        }\n\n        function queueFrames(frameList) {\n            if(frameList.length === 0) return;\n\n            for(var i = 0; i < frameList.length; i++) {\n                var computedFrame;\n\n                if(frameList[i].type === 'byname') {\n                    // If it's a named frame, compute it:\n                    computedFrame = Plots.computeFrame(gd, frameList[i].name);\n                } else {\n                    // Otherwise we must have been given a simple object, so treat\n                    // the input itself as the computed frame.\n                    computedFrame = frameList[i].data;\n                }\n\n                var frameOpts = getFrameOpts(i);\n                var transitionOpts = getTransitionOpts(i);\n\n                // It doesn't make much sense for the transition duration to be greater than\n                // the frame duration, so limit it:\n                transitionOpts.duration = Math.min(transitionOpts.duration, frameOpts.duration);\n\n                var nextFrame = {\n                    frame: computedFrame,\n                    name: frameList[i].name,\n                    frameOpts: frameOpts,\n                    transitionOpts: transitionOpts,\n                };\n                if(i === frameList.length - 1) {\n                    // The last frame in this .animate call stores the promise resolve\n                    // and reject callbacks. This is how we ensure that the animation\n                    // loop (which may exist as a result of a *different* .animate call)\n                    // still resolves or rejecdts this .animate call's promise. once it's\n                    // complete.\n                    nextFrame.onComplete = callbackOnNthTime(resolve, 2);\n                    nextFrame.onInterrupt = reject;\n                }\n\n                trans._frameQueue.push(nextFrame);\n            }\n\n            // Set it as never having transitioned to a frame. This will cause the animation\n            // loop to immediately transition to the next frame (which, for immediate mode,\n            // is the first frame in the list since all others would have been discarded\n            // below)\n            if(animationOpts.mode === 'immediate') {\n                trans._lastFrameAt = -Infinity;\n            }\n\n            // Only it's not already running, start a RAF loop. This could be avoided in the\n            // case that there's only one frame, but it significantly complicated the logic\n            // and only sped things up by about 5% or so for a lorenz attractor simulation.\n            // It would be a fine thing to implement, but the benefit of that optimization\n            // doesn't seem worth the extra complexity.\n            if(!trans._animationRaf) {\n                beginAnimationLoop();\n            }\n        }\n\n        function stopAnimationLoop() {\n            gd.emit('plotly_animated');\n\n            // Be sure to unset also since it's how we know whether a loop is already running:\n            window.cancelAnimationFrame(trans._animationRaf);\n            trans._animationRaf = null;\n        }\n\n        function nextFrame() {\n            if(trans._currentFrame && trans._currentFrame.onComplete) {\n                // Execute the callback and unset it to ensure it doesn't\n                // accidentally get called twice\n                trans._currentFrame.onComplete();\n            }\n\n            var newFrame = trans._currentFrame = trans._frameQueue.shift();\n\n            if(newFrame) {\n                // Since it's sometimes necessary to do deep digging into frame data,\n                // we'll consider it not 100% impossible for nulls or numbers to sneak through,\n                // so check when casting the name, just to be absolutely certain:\n                var stringName = newFrame.name ? newFrame.name.toString() : null;\n                gd._fullLayout._currentFrame = stringName;\n\n                trans._lastFrameAt = Date.now();\n                trans._timeToNext = newFrame.frameOpts.duration;\n\n                // This is simply called and it's left to .transition to decide how to manage\n                // interrupting current transitions. That means we don't need to worry about\n                // how it resolves or what happens after this:\n                Plots.transition(gd,\n                    newFrame.frame.data,\n                    newFrame.frame.layout,\n                    helpers.coerceTraceIndices(gd, newFrame.frame.traces),\n                    newFrame.frameOpts,\n                    newFrame.transitionOpts\n                ).then(function() {\n                    if(newFrame.onComplete) {\n                        newFrame.onComplete();\n                    }\n\n                });\n\n                gd.emit('plotly_animatingframe', {\n                    name: stringName,\n                    frame: newFrame.frame,\n                    animation: {\n                        frame: newFrame.frameOpts,\n                        transition: newFrame.transitionOpts,\n                    }\n                });\n            } else {\n                // If there are no more frames, then stop the RAF loop:\n                stopAnimationLoop();\n            }\n        }\n\n        function beginAnimationLoop() {\n            gd.emit('plotly_animating');\n\n            // If no timer is running, then set last frame = long ago so that the next\n            // frame is immediately transitioned:\n            trans._lastFrameAt = -Infinity;\n            trans._timeToNext = 0;\n            trans._runningTransitions = 0;\n            trans._currentFrame = null;\n\n            var doFrame = function() {\n                // This *must* be requested before nextFrame since nextFrame may decide\n                // to cancel it if there's nothing more to animated:\n                trans._animationRaf = window.requestAnimationFrame(doFrame);\n\n                // Check if we're ready for a new frame:\n                if(Date.now() - trans._lastFrameAt > trans._timeToNext) {\n                    nextFrame();\n                }\n            };\n\n            doFrame();\n        }\n\n        // This is an animate-local counter that helps match up option input list\n        // items with the particular frame.\n        var configCounter = 0;\n        function setTransitionConfig(frame) {\n            if(Array.isArray(transitionOpts)) {\n                if(configCounter >= transitionOpts.length) {\n                    frame.transitionOpts = transitionOpts[configCounter];\n                } else {\n                    frame.transitionOpts = transitionOpts[0];\n                }\n            } else {\n                frame.transitionOpts = transitionOpts;\n            }\n            configCounter++;\n            return frame;\n        }\n\n        // Disambiguate what's sort of frames have been received\n        var i, frame;\n        var frameList = [];\n        var allFrames = frameOrGroupNameOrFrameList === undefined || frameOrGroupNameOrFrameList === null;\n        var isFrameArray = Array.isArray(frameOrGroupNameOrFrameList);\n        var isSingleFrame = !allFrames && !isFrameArray && Lib.isPlainObject(frameOrGroupNameOrFrameList);\n\n        if(isSingleFrame) {\n            // In this case, a simple object has been passed to animate.\n            frameList.push({\n                type: 'object',\n                data: setTransitionConfig(Lib.extendFlat({}, frameOrGroupNameOrFrameList))\n            });\n        } else if(allFrames || ['string', 'number'].indexOf(typeof frameOrGroupNameOrFrameList) !== -1) {\n            // In this case, null or undefined has been passed so that we want to\n            // animate *all* currently defined frames\n            for(i = 0; i < trans._frames.length; i++) {\n                frame = trans._frames[i];\n\n                if(!frame) continue;\n\n                if(allFrames || String(frame.group) === String(frameOrGroupNameOrFrameList)) {\n                    frameList.push({\n                        type: 'byname',\n                        name: String(frame.name),\n                        data: setTransitionConfig({name: frame.name})\n                    });\n                }\n            }\n        } else if(isFrameArray) {\n            for(i = 0; i < frameOrGroupNameOrFrameList.length; i++) {\n                var frameOrName = frameOrGroupNameOrFrameList[i];\n                if(['number', 'string'].indexOf(typeof frameOrName) !== -1) {\n                    frameOrName = String(frameOrName);\n                    // In this case, there's an array and this frame is a string name:\n                    frameList.push({\n                        type: 'byname',\n                        name: frameOrName,\n                        data: setTransitionConfig({name: frameOrName})\n                    });\n                } else if(Lib.isPlainObject(frameOrName)) {\n                    frameList.push({\n                        type: 'object',\n                        data: setTransitionConfig(Lib.extendFlat({}, frameOrName))\n                    });\n                }\n            }\n        }\n\n        // Verify that all of these frames actually exist; return and reject if not:\n        for(i = 0; i < frameList.length; i++) {\n            frame = frameList[i];\n            if(frame.type === 'byname' && !trans._frameHash[frame.data.name]) {\n                Lib.warn('animate failure: frame not found: \"' + frame.data.name + '\"');\n                reject();\n                return;\n            }\n        }\n\n        // If the mode is either next or immediate, then all currently queued frames must\n        // be dumped and the corresponding .animate promises rejected.\n        if(['next', 'immediate'].indexOf(animationOpts.mode) !== -1) {\n            discardExistingFrames();\n        }\n\n        if(animationOpts.direction === 'reverse') {\n            frameList.reverse();\n        }\n\n        var currentFrame = gd._fullLayout._currentFrame;\n        if(currentFrame && animationOpts.fromcurrent) {\n            var idx = -1;\n            for(i = 0; i < frameList.length; i++) {\n                frame = frameList[i];\n                if(frame.type === 'byname' && frame.name === currentFrame) {\n                    idx = i;\n                    break;\n                }\n            }\n\n            if(idx > 0 && idx < frameList.length - 1) {\n                var filteredFrameList = [];\n                for(i = 0; i < frameList.length; i++) {\n                    frame = frameList[i];\n                    if(frameList[i].type !== 'byname' || i > idx) {\n                        filteredFrameList.push(frame);\n                    }\n                }\n                frameList = filteredFrameList;\n            }\n        }\n\n        if(frameList.length > 0) {\n            queueFrames(frameList);\n        } else {\n            // This is the case where there were simply no frames. It's a little strange\n            // since there's not much to do:\n            gd.emit('plotly_animated');\n            resolve();\n        }\n    });\n};\n\n/**\n * Register new frames\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n *\n * @param {array of objects} frameList\n *      list of frame definitions, in which each object includes any of:\n *      - name: {string} name of frame to add\n *      - data: {array of objects} trace data\n *      - layout {object} layout definition\n *      - traces {array} trace indices\n *      - baseframe {string} name of frame from which this frame gets defaults\n *\n *  @param {array of integers) indices\n *      an array of integer indices matching the respective frames in `frameList`. If not\n *      provided, an index will be provided in serial order. If already used, the frame\n *      will be overwritten.\n */\nPlotly.addFrames = function(gd, frameList, indices) {\n    gd = helpers.getGraphDiv(gd);\n\n    var numericNameWarningCount = 0;\n\n    if(frameList === null || frameList === undefined) {\n        return Promise.resolve();\n    }\n\n    if(!Lib.isPlotDiv(gd)) {\n        throw new Error(\n            'This element is not a Plotly plot: ' + gd + '. It\\'s likely that you\\'ve failed ' +\n            'to create a plot before adding frames. For more details, see ' +\n            'https://plot.ly/javascript/animations/'\n        );\n    }\n\n    var i, frame, j, idx;\n    var _frames = gd._transitionData._frames;\n    var _hash = gd._transitionData._frameHash;\n\n\n    if(!Array.isArray(frameList)) {\n        throw new Error('addFrames failure: frameList must be an Array of frame definitions' + frameList);\n    }\n\n    // Create a sorted list of insertions since we run into lots of problems if these\n    // aren't in ascending order of index:\n    //\n    // Strictly for sorting. Make sure this is guaranteed to never collide with any\n    // already-exisisting indices:\n    var bigIndex = _frames.length + frameList.length * 2;\n\n    var insertions = [];\n    for(i = frameList.length - 1; i >= 0; i--) {\n        if(!Lib.isPlainObject(frameList[i])) continue;\n\n        var name = (_hash[frameList[i].name] || {}).name;\n        var newName = frameList[i].name;\n\n        if(name && newName && typeof newName === 'number' && _hash[name]) {\n            numericNameWarningCount++;\n\n            Lib.warn('addFrames: overwriting frame \"' + _hash[name].name +\n                '\" with a frame whose name of type \"number\" also equates to \"' +\n                name + '\". This is valid but may potentially lead to unexpected ' +\n                'behavior since all plotly.js frame names are stored internally ' +\n                'as strings.');\n\n            if(numericNameWarningCount > 5) {\n                Lib.warn('addFrames: This API call has yielded too many warnings. ' +\n                    'For the rest of this call, further warnings about numeric frame ' +\n                    'names will be suppressed.');\n            }\n        }\n\n        insertions.push({\n            frame: Plots.supplyFrameDefaults(frameList[i]),\n            index: (indices && indices[i] !== undefined && indices[i] !== null) ? indices[i] : bigIndex + i\n        });\n    }\n\n    // Sort this, taking note that undefined insertions end up at the end:\n    insertions.sort(function(a, b) {\n        if(a.index > b.index) return -1;\n        if(a.index < b.index) return 1;\n        return 0;\n    });\n\n    var ops = [];\n    var revops = [];\n    var frameCount = _frames.length;\n\n    for(i = insertions.length - 1; i >= 0; i--) {\n        frame = insertions[i].frame;\n\n        if(typeof frame.name === 'number') {\n            Lib.warn('Warning: addFrames accepts frames with numeric names, but the numbers are' +\n                'implicitly cast to strings');\n\n        }\n\n        if(!frame.name) {\n            // Repeatedly assign a default name, incrementing the counter each time until\n            // we get a name that's not in the hashed lookup table:\n            while(_hash[(frame.name = 'frame ' + gd._transitionData._counter++)]);\n        }\n\n        if(_hash[frame.name]) {\n            // If frame is present, overwrite its definition:\n            for(j = 0; j < _frames.length; j++) {\n                if((_frames[j] || {}).name === frame.name) break;\n            }\n            ops.push({type: 'replace', index: j, value: frame});\n            revops.unshift({type: 'replace', index: j, value: _frames[j]});\n        } else {\n            // Otherwise insert it at the end of the list:\n            idx = Math.max(0, Math.min(insertions[i].index, frameCount));\n\n            ops.push({type: 'insert', index: idx, value: frame});\n            revops.unshift({type: 'delete', index: idx});\n            frameCount++;\n        }\n    }\n\n    var undoFunc = Plots.modifyFrames,\n        redoFunc = Plots.modifyFrames,\n        undoArgs = [gd, revops],\n        redoArgs = [gd, ops];\n\n    if(Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n\n    return Plots.modifyFrames(gd, ops);\n};\n\n/**\n * Delete frame\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n *\n * @param {array of integers} frameList\n *      list of integer indices of frames to be deleted\n */\nPlotly.deleteFrames = function(gd, frameList) {\n    gd = helpers.getGraphDiv(gd);\n\n    if(!Lib.isPlotDiv(gd)) {\n        throw new Error('This element is not a Plotly plot: ' + gd);\n    }\n\n    var i, idx;\n    var _frames = gd._transitionData._frames;\n    var ops = [];\n    var revops = [];\n\n    if(!frameList) {\n        frameList = [];\n        for(i = 0; i < _frames.length; i++) {\n            frameList.push(i);\n        }\n    }\n\n    frameList = frameList.slice(0);\n    frameList.sort();\n\n    for(i = frameList.length - 1; i >= 0; i--) {\n        idx = frameList[i];\n        ops.push({type: 'delete', index: idx});\n        revops.unshift({type: 'insert', index: idx, value: _frames[idx]});\n    }\n\n    var undoFunc = Plots.modifyFrames,\n        redoFunc = Plots.modifyFrames,\n        undoArgs = [gd, revops],\n        redoArgs = [gd, ops];\n\n    if(Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n\n    return Plots.modifyFrames(gd, ops);\n};\n\n/**\n * Purge a graph container div back to its initial pre-Plotly.plot state\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n */\nPlotly.purge = function purge(gd) {\n    gd = helpers.getGraphDiv(gd);\n\n    var fullLayout = gd._fullLayout || {},\n        fullData = gd._fullData || [];\n\n    // remove gl contexts\n    Plots.cleanPlot([], {}, fullData, fullLayout);\n\n    // purge properties\n    Plots.purge(gd);\n\n    // purge event emitter methods\n    Events.purge(gd);\n\n    // remove plot container\n    if(fullLayout._container) fullLayout._container.remove();\n\n    delete gd._context;\n    delete gd._replotPending;\n    delete gd._mouseDownTime;\n    delete gd._legendMouseDownTime;\n    delete gd._hmpixcount;\n    delete gd._hmlumcount;\n\n    return gd;\n};\n\n// -------------------------------------------------------\n// makePlotFramework: Create the plot container and axes\n// -------------------------------------------------------\nfunction makePlotFramework(gd) {\n    var gd3 = d3.select(gd),\n        fullLayout = gd._fullLayout;\n\n    // Plot container\n    fullLayout._container = gd3.selectAll('.plot-container').data([0]);\n    fullLayout._container.enter().insert('div', ':first-child')\n        .classed('plot-container', true)\n        .classed('plotly', true);\n\n    // Make the svg container\n    fullLayout._paperdiv = fullLayout._container.selectAll('.svg-container').data([0]);\n    fullLayout._paperdiv.enter().append('div')\n        .classed('svg-container', true)\n        .style('position', 'relative');\n\n    // Make the graph containers\n    // start fresh each time we get here, so we know the order comes out\n    // right, rather than enter/exit which can muck up the order\n    // TODO: sort out all the ordering so we don't have to\n    // explicitly delete anything\n    fullLayout._glcontainer = fullLayout._paperdiv.selectAll('.gl-container')\n        .data([0]);\n    fullLayout._glcontainer.enter().append('div')\n        .classed('gl-container', true);\n\n    fullLayout._paperdiv.selectAll('.main-svg').remove();\n\n    fullLayout._paper = fullLayout._paperdiv.insert('svg', ':first-child')\n        .classed('main-svg', true);\n\n    fullLayout._toppaper = fullLayout._paperdiv.append('svg')\n        .classed('main-svg', true);\n\n    if(!fullLayout._uid) {\n        var otherUids = [];\n        d3.selectAll('defs').each(function() {\n            if(this.id) otherUids.push(this.id.split('-')[1]);\n        });\n        fullLayout._uid = Lib.randstr(otherUids);\n    }\n\n    fullLayout._paperdiv.selectAll('.main-svg')\n        .attr(xmlnsNamespaces.svgAttrs);\n\n    fullLayout._defs = fullLayout._paper.append('defs')\n        .attr('id', 'defs-' + fullLayout._uid);\n\n    fullLayout._topdefs = fullLayout._toppaper.append('defs')\n        .attr('id', 'topdefs-' + fullLayout._uid);\n\n    fullLayout._bgLayer = fullLayout._paper.append('g')\n        .classed('bglayer', true);\n\n    fullLayout._draggers = fullLayout._paper.append('g')\n        .classed('draglayer', true);\n\n    // lower shape/image layer - note that this is behind\n    // all subplots data/grids but above the backgrounds\n    // except inset subplots, whose backgrounds are drawn\n    // inside their own group so that they appear above\n    // the data for the main subplot\n    // lower shapes and images which are fully referenced to\n    // a subplot still get drawn within the subplot's group\n    // so they will work correctly on insets\n    var layerBelow = fullLayout._paper.append('g')\n        .classed('layer-below', true);\n    fullLayout._imageLowerLayer = layerBelow.append('g')\n        .classed('imagelayer', true);\n    fullLayout._shapeLowerLayer = layerBelow.append('g')\n        .classed('shapelayer', true);\n\n    // single cartesian layer for the whole plot\n    fullLayout._cartesianlayer = fullLayout._paper.append('g').classed('cartesianlayer', true);\n\n    // single ternary layer for the whole plot\n    fullLayout._ternarylayer = fullLayout._paper.append('g').classed('ternarylayer', true);\n\n    // single geo layer for the whole plot\n    fullLayout._geolayer = fullLayout._paper.append('g').classed('geolayer', true);\n\n    // upper shape layer\n    // (only for shapes to be drawn above the whole plot, including subplots)\n    var layerAbove = fullLayout._paper.append('g')\n        .classed('layer-above', true);\n    fullLayout._imageUpperLayer = layerAbove.append('g')\n        .classed('imagelayer', true);\n    fullLayout._shapeUpperLayer = layerAbove.append('g')\n        .classed('shapelayer', true);\n\n    // single pie layer for the whole plot\n    fullLayout._pielayer = fullLayout._paper.append('g').classed('pielayer', true);\n\n    // fill in image server scrape-svg\n    fullLayout._glimages = fullLayout._paper.append('g').classed('glimages', true);\n\n    // lastly info (legend, annotations) and hover layers go on top\n    // these are in a different svg element normally, but get collapsed into a single\n    // svg when exporting (after inserting 3D)\n    fullLayout._infolayer = fullLayout._toppaper.append('g').classed('infolayer', true);\n    fullLayout._zoomlayer = fullLayout._toppaper.append('g').classed('zoomlayer', true);\n    fullLayout._hoverlayer = fullLayout._toppaper.append('g').classed('hoverlayer', true);\n\n    gd.emit('plotly_framework');\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/lib/queue.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Lib = require('../lib');\nvar config = require('../plot_api/plot_config');\n\n\n/**\n * Copy arg array *without* removing `undefined` values from objects.\n *\n * @param gd\n * @param args\n * @returns {Array}\n */\nfunction copyArgArray(gd, args) {\n    var copy = [];\n    var arg;\n\n    for(var i = 0; i < args.length; i++) {\n        arg = args[i];\n\n        if(arg === gd) copy[i] = arg;\n        else if(typeof arg === 'object') {\n            copy[i] = Array.isArray(arg) ?\n                Lib.extendDeep([], arg) :\n                Lib.extendDeepAll({}, arg);\n        }\n        else copy[i] = arg;\n    }\n\n    return copy;\n}\n\n\n// -----------------------------------------------------\n// Undo/Redo queue for plots\n// -----------------------------------------------------\n\n\nvar queue = {};\n\n// TODO: disable/enable undo and redo buttons appropriately\n\n/**\n * Add an item to the undoQueue for a graphDiv\n *\n * @param gd\n * @param undoFunc Function undo this operation\n * @param undoArgs Args to supply undoFunc with\n * @param redoFunc Function to redo this operation\n * @param redoArgs Args to supply redoFunc with\n */\nqueue.add = function(gd, undoFunc, undoArgs, redoFunc, redoArgs) {\n    var queueObj,\n        queueIndex;\n\n    // make sure we have the queue and our position in it\n    gd.undoQueue = gd.undoQueue || {index: 0, queue: [], sequence: false};\n    queueIndex = gd.undoQueue.index;\n\n    // if we're already playing an undo or redo, or if this is an auto operation\n    // (like pane resize... any others?) then we don't save this to the undo queue\n    if(gd.autoplay) {\n        if(!gd.undoQueue.inSequence) gd.autoplay = false;\n        return;\n    }\n\n    // if we're not in a sequence or are just starting, we need a new queue item\n    if(!gd.undoQueue.sequence || gd.undoQueue.beginSequence) {\n        queueObj = {undo: {calls: [], args: []}, redo: {calls: [], args: []}};\n        gd.undoQueue.queue.splice(queueIndex, gd.undoQueue.queue.length - queueIndex, queueObj);\n        gd.undoQueue.index += 1;\n    } else {\n        queueObj = gd.undoQueue.queue[queueIndex - 1];\n    }\n    gd.undoQueue.beginSequence = false;\n\n    // we unshift to handle calls for undo in a forward for loop later\n    if(queueObj) {\n        queueObj.undo.calls.unshift(undoFunc);\n        queueObj.undo.args.unshift(undoArgs);\n        queueObj.redo.calls.push(redoFunc);\n        queueObj.redo.args.push(redoArgs);\n    }\n\n    if(gd.undoQueue.queue.length > config.queueLength) {\n        gd.undoQueue.queue.shift();\n        gd.undoQueue.index--;\n    }\n};\n\n/**\n * Begin a sequence of undoQueue changes\n *\n * @param gd\n */\nqueue.startSequence = function(gd) {\n    gd.undoQueue = gd.undoQueue || {index: 0, queue: [], sequence: false};\n    gd.undoQueue.sequence = true;\n    gd.undoQueue.beginSequence = true;\n};\n\n/**\n * Stop a sequence of undoQueue changes\n *\n * Call this *after* you're sure your undo chain has ended\n *\n * @param gd\n */\nqueue.stopSequence = function(gd) {\n    gd.undoQueue = gd.undoQueue || {index: 0, queue: [], sequence: false};\n    gd.undoQueue.sequence = false;\n    gd.undoQueue.beginSequence = false;\n};\n\n/**\n * Move one step back in the undo queue, and undo the object there.\n *\n * @param gd\n */\nqueue.undo = function undo(gd) {\n    var queueObj, i;\n\n    if(gd.framework && gd.framework.isPolar) {\n        gd.framework.undo();\n        return;\n    }\n    if(gd.undoQueue === undefined ||\n            isNaN(gd.undoQueue.index) ||\n            gd.undoQueue.index <= 0) {\n        return;\n    }\n\n    // index is pointing to next *forward* queueObj, point to the one we're undoing\n    gd.undoQueue.index--;\n\n    // get the queueObj for instructions on how to undo\n    queueObj = gd.undoQueue.queue[gd.undoQueue.index];\n\n    // this sequence keeps things from adding to the queue during undo/redo\n    gd.undoQueue.inSequence = true;\n    for(i = 0; i < queueObj.undo.calls.length; i++) {\n        queue.plotDo(gd, queueObj.undo.calls[i], queueObj.undo.args[i]);\n    }\n    gd.undoQueue.inSequence = false;\n    gd.autoplay = false;\n};\n\n/**\n * Redo the current object in the undo, then move forward in the queue.\n *\n * @param gd\n */\nqueue.redo = function redo(gd) {\n    var queueObj, i;\n\n    if(gd.framework && gd.framework.isPolar) {\n        gd.framework.redo();\n        return;\n    }\n    if(gd.undoQueue === undefined ||\n            isNaN(gd.undoQueue.index) ||\n            gd.undoQueue.index >= gd.undoQueue.queue.length) {\n        return;\n    }\n\n    // get the queueObj for instructions on how to undo\n    queueObj = gd.undoQueue.queue[gd.undoQueue.index];\n\n    // this sequence keeps things from adding to the queue during undo/redo\n    gd.undoQueue.inSequence = true;\n    for(i = 0; i < queueObj.redo.calls.length; i++) {\n        queue.plotDo(gd, queueObj.redo.calls[i], queueObj.redo.args[i]);\n    }\n    gd.undoQueue.inSequence = false;\n    gd.autoplay = false;\n\n    // index is pointing to the thing we just redid, move it\n    gd.undoQueue.index++;\n};\n\n/**\n * Called by undo/redo to make the actual changes.\n *\n * Not meant to be called publically, but included for mocking out in tests.\n *\n * @param gd\n * @param func\n * @param args\n */\nqueue.plotDo = function(gd, func, args) {\n    gd.autoplay = true;\n\n    // this *won't* copy gd and it preserves `undefined` properties!\n    args = copyArgArray(gd, args);\n\n    // call the supplied function\n    func.apply(null, args);\n};\n\nmodule.exports = queue;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/polar/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Polar = module.exports = require('./micropolar');\n\nPolar.manager = require('./micropolar_manager');\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/polar/micropolar.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\nvar d3 = require('d3');\nvar Lib = require('../../lib');\nvar extendDeepAll = Lib.extendDeepAll;\n\nvar  = module.exports = { version: '0.2.2' };\n\n.Axis = function module() {\n    var config = {\n        data: [],\n        layout: {}\n    }, inputConfig = {}, liveConfig = {};\n    var svg, container, dispatch = d3.dispatch('hover'), radialScale, angularScale;\n    var exports = {};\n    function render(_container) {\n        container = _container || container;\n        var data = config.data;\n        var axisConfig = config.layout;\n        if (typeof container == 'string' || container.nodeName) container = d3.select(container);\n        container.datum(data).each(function(_data, _index) {\n            var dataOriginal = _data.slice();\n            liveConfig = {\n                data: .util.cloneJson(dataOriginal),\n                layout: .util.cloneJson(axisConfig)\n            };\n            var colorIndex = 0;\n            dataOriginal.forEach(function(d, i) {\n                if (!d.color) {\n                    d.color = axisConfig.defaultColorRange[colorIndex];\n                    colorIndex = (colorIndex + 1) % axisConfig.defaultColorRange.length;\n                }\n                if (!d.strokeColor) {\n                    d.strokeColor = d.geometry === 'LinePlot' ? d.color : d3.rgb(d.color).darker().toString();\n                }\n                liveConfig.data[i].color = d.color;\n                liveConfig.data[i].strokeColor = d.strokeColor;\n                liveConfig.data[i].strokeDash = d.strokeDash;\n                liveConfig.data[i].strokeSize = d.strokeSize;\n            });\n            var data = dataOriginal.filter(function(d, i) {\n                var visible = d.visible;\n                return typeof visible === 'undefined' || visible === true;\n            });\n            var isStacked = false;\n            var dataWithGroupId = data.map(function(d, i) {\n                isStacked = isStacked || typeof d.groupId !== 'undefined';\n                return d;\n            });\n            if (isStacked) {\n                var grouped = d3.nest().key(function(d, i) {\n                    return typeof d.groupId != 'undefined' ? d.groupId : 'unstacked';\n                }).entries(dataWithGroupId);\n                var dataYStack = [];\n                var stacked = grouped.map(function(d, i) {\n                    if (d.key === 'unstacked') return d.values; else {\n                        var prevArray = d.values[0].r.map(function(d, i) {\n                            return 0;\n                        });\n                        d.values.forEach(function(d, i, a) {\n                            d.yStack = [ prevArray ];\n                            dataYStack.push(prevArray);\n                            prevArray = .util.sumArrays(d.r, prevArray);\n                        });\n                        return d.values;\n                    }\n                });\n                data = d3.merge(stacked);\n            }\n            data.forEach(function(d, i) {\n                d.t = Array.isArray(d.t[0]) ? d.t : [ d.t ];\n                d.r = Array.isArray(d.r[0]) ? d.r : [ d.r ];\n            });\n            var radius = Math.min(axisConfig.width - axisConfig.margin.left - axisConfig.margin.right, axisConfig.height - axisConfig.margin.top - axisConfig.margin.bottom) / 2;\n            radius = Math.max(10, radius);\n            var chartCenter = [ axisConfig.margin.left + radius, axisConfig.margin.top + radius ];\n            var extent;\n            if (isStacked) {\n                var highestStackedValue = d3.max(.util.sumArrays(.util.arrayLast(data).r[0], .util.arrayLast(dataYStack)));\n                extent = [ 0, highestStackedValue ];\n            } else extent = d3.extent(.util.flattenArray(data.map(function(d, i) {\n                return d.r;\n            })));\n            if (axisConfig.radialAxis.domain != .DATAEXTENT) extent[0] = 0;\n            radialScale = d3.scale.linear().domain(axisConfig.radialAxis.domain != .DATAEXTENT && axisConfig.radialAxis.domain ? axisConfig.radialAxis.domain : extent).range([ 0, radius ]);\n            liveConfig.layout.radialAxis.domain = radialScale.domain();\n            var angularDataMerged = .util.flattenArray(data.map(function(d, i) {\n                return d.t;\n            }));\n            var isOrdinal = typeof angularDataMerged[0] === 'string';\n            var ticks;\n            if (isOrdinal) {\n                angularDataMerged = .util.deduplicate(angularDataMerged);\n                ticks = angularDataMerged.slice();\n                angularDataMerged = d3.range(angularDataMerged.length);\n                data = data.map(function(d, i) {\n                    var result = d;\n                    d.t = [ angularDataMerged ];\n                    if (isStacked) result.yStack = d.yStack;\n                    return result;\n                });\n            }\n            var hasOnlyLineOrDotPlot = data.filter(function(d, i) {\n                return d.geometry === 'LinePlot' || d.geometry === 'DotPlot';\n            }).length === data.length;\n            var needsEndSpacing = axisConfig.needsEndSpacing === null ? isOrdinal || !hasOnlyLineOrDotPlot : axisConfig.needsEndSpacing;\n            var useProvidedDomain = axisConfig.angularAxis.domain && axisConfig.angularAxis.domain != .DATAEXTENT && !isOrdinal && axisConfig.angularAxis.domain[0] >= 0;\n            var angularDomain = useProvidedDomain ? axisConfig.angularAxis.domain : d3.extent(angularDataMerged);\n            var angularDomainStep = Math.abs(angularDataMerged[1] - angularDataMerged[0]);\n            if (hasOnlyLineOrDotPlot && !isOrdinal) angularDomainStep = 0;\n            var angularDomainWithPadding = angularDomain.slice();\n            if (needsEndSpacing && isOrdinal) angularDomainWithPadding[1] += angularDomainStep;\n            var tickCount = axisConfig.angularAxis.ticksCount || 4;\n            if (tickCount > 8) tickCount = tickCount / (tickCount / 8) + tickCount % 8;\n            if (axisConfig.angularAxis.ticksStep) {\n                tickCount = (angularDomainWithPadding[1] - angularDomainWithPadding[0]) / tickCount;\n            }\n            var angularTicksStep = axisConfig.angularAxis.ticksStep || (angularDomainWithPadding[1] - angularDomainWithPadding[0]) / (tickCount * (axisConfig.minorTicks + 1));\n            if (ticks) angularTicksStep = Math.max(Math.round(angularTicksStep), 1);\n            if (!angularDomainWithPadding[2]) angularDomainWithPadding[2] = angularTicksStep;\n            var angularAxisRange = d3.range.apply(this, angularDomainWithPadding);\n            angularAxisRange = angularAxisRange.map(function(d, i) {\n                return parseFloat(d.toPrecision(12));\n            });\n            angularScale = d3.scale.linear().domain(angularDomainWithPadding.slice(0, 2)).range(axisConfig.direction === 'clockwise' ? [ 0, 360 ] : [ 360, 0 ]);\n            liveConfig.layout.angularAxis.domain = angularScale.domain();\n            liveConfig.layout.angularAxis.endPadding = needsEndSpacing ? angularDomainStep : 0;\n            svg = d3.select(this).select('svg.chart-root');\n            if (typeof svg === 'undefined' || svg.empty()) {\n                var skeleton = \"<svg xmlns='http://www.w3.org/2000/svg' class='chart-root'>' + '<g class='outer-group'>' + '<g class='chart-group'>' + '<circle class='background-circle'></circle>' + '<g class='geometry-group'></g>' + '<g class='radial axis-group'>' + '<circle class='outside-circle'></circle>' + '</g>' + '<g class='angular axis-group'></g>' + '<g class='guides-group'><line></line><circle r='0'></circle></g>' + '</g>' + '<g class='legend-group'></g>' + '<g class='tooltips-group'></g>' + '<g class='title-group'><text></text></g>' + '</g>' + '</svg>\";\n                var doc = new DOMParser().parseFromString(skeleton, 'application/xml');\n                var newSvg = this.appendChild(this.ownerDocument.importNode(doc.documentElement, true));\n                svg = d3.select(newSvg);\n            }\n            svg.select('.guides-group').style({\n                'pointer-events': 'none'\n            });\n            svg.select('.angular.axis-group').style({\n                'pointer-events': 'none'\n            });\n            svg.select('.radial.axis-group').style({\n                'pointer-events': 'none'\n            });\n            var chartGroup = svg.select('.chart-group');\n            var lineStyle = {\n                fill: 'none',\n                stroke: axisConfig.tickColor\n            };\n            var fontStyle = {\n                'font-size': axisConfig.font.size,\n                'font-family': axisConfig.font.family,\n                fill: axisConfig.font.color,\n                'text-shadow': [ '-1px 0px', '1px -1px', '-1px 1px', '1px 1px' ].map(function(d, i) {\n                    return ' ' + d + ' 0 ' + axisConfig.font.outlineColor;\n                }).join(',')\n            };\n            var legendContainer;\n            if (axisConfig.showLegend) {\n                legendContainer = svg.select('.legend-group').attr({\n                    transform: 'translate(' + [ radius, axisConfig.margin.top ] + ')'\n                }).style({\n                    display: 'block'\n                });\n                var elements = data.map(function(d, i) {\n                    var datumClone = .util.cloneJson(d);\n                    datumClone.symbol = d.geometry === 'DotPlot' ? d.dotType || 'circle' : d.geometry != 'LinePlot' ? 'square' : 'line';\n                    datumClone.visibleInLegend = typeof d.visibleInLegend === 'undefined' || d.visibleInLegend;\n                    datumClone.color = d.geometry === 'LinePlot' ? d.strokeColor : d.color;\n                    return datumClone;\n                });\n\n                .Legend().config({\n                    data: data.map(function(d, i) {\n                        return d.name || 'Element' + i;\n                    }),\n                    legendConfig: extendDeepAll({},\n                        .Legend.defaultConfig().legendConfig,\n                        {\n                            container: legendContainer,\n                            elements: elements,\n                            reverseOrder: axisConfig.legend.reverseOrder\n                        }\n                    )\n                })();\n\n                var legendBBox = legendContainer.node().getBBox();\n                radius = Math.min(axisConfig.width - legendBBox.width - axisConfig.margin.left - axisConfig.margin.right, axisConfig.height - axisConfig.margin.top - axisConfig.margin.bottom) / 2;\n                radius = Math.max(10, radius);\n                chartCenter = [ axisConfig.margin.left + radius, axisConfig.margin.top + radius ];\n                radialScale.range([ 0, radius ]);\n                liveConfig.layout.radialAxis.domain = radialScale.domain();\n                legendContainer.attr('transform', 'translate(' + [ chartCenter[0] + radius, chartCenter[1] - radius ] + ')');\n            } else {\n                legendContainer = svg.select('.legend-group').style({\n                    display: 'none'\n                });\n            }\n            svg.attr({\n                width: axisConfig.width,\n                height: axisConfig.height\n            }).style({\n                opacity: axisConfig.opacity\n            });\n            chartGroup.attr('transform', 'translate(' + chartCenter + ')').style({\n                cursor: 'crosshair'\n            });\n            var centeringOffset = [ (axisConfig.width - (axisConfig.margin.left + axisConfig.margin.right + radius * 2 + (legendBBox ? legendBBox.width : 0))) / 2, (axisConfig.height - (axisConfig.margin.top + axisConfig.margin.bottom + radius * 2)) / 2 ];\n            centeringOffset[0] = Math.max(0, centeringOffset[0]);\n            centeringOffset[1] = Math.max(0, centeringOffset[1]);\n            svg.select('.outer-group').attr('transform', 'translate(' + centeringOffset + ')');\n            if (axisConfig.title) {\n                var title = svg.select('g.title-group text').style(fontStyle).text(axisConfig.title);\n                var titleBBox = title.node().getBBox();\n                title.attr({\n                    x: chartCenter[0] - titleBBox.width / 2,\n                    y: chartCenter[1] - radius - 20\n                });\n            }\n            var radialAxis = svg.select('.radial.axis-group');\n            if (axisConfig.radialAxis.gridLinesVisible) {\n                var gridCircles = radialAxis.selectAll('circle.grid-circle').data(radialScale.ticks(5));\n                gridCircles.enter().append('circle').attr({\n                    'class': 'grid-circle'\n                }).style(lineStyle);\n                gridCircles.attr('r', radialScale);\n                gridCircles.exit().remove();\n            }\n            radialAxis.select('circle.outside-circle').attr({\n                r: radius\n            }).style(lineStyle);\n            var backgroundCircle = svg.select('circle.background-circle').attr({\n                r: radius\n            }).style({\n                fill: axisConfig.backgroundColor,\n                stroke: axisConfig.stroke\n            });\n            function currentAngle(d, i) {\n                return angularScale(d) % 360 + axisConfig.orientation;\n            }\n            if (axisConfig.radialAxis.visible) {\n                var axis = d3.svg.axis().scale(radialScale).ticks(5).tickSize(5);\n                radialAxis.call(axis).attr({\n                    transform: 'rotate(' + axisConfig.radialAxis.orientation + ')'\n                });\n                radialAxis.selectAll('.domain').style(lineStyle);\n                radialAxis.selectAll('g>text').text(function(d, i) {\n                    return this.textContent + axisConfig.radialAxis.ticksSuffix;\n                }).style(fontStyle).style({\n                    'text-anchor': 'start'\n                }).attr({\n                    x: 0,\n                    y: 0,\n                    dx: 0,\n                    dy: 0,\n                    transform: function(d, i) {\n                        if (axisConfig.radialAxis.tickOrientation === 'horizontal') {\n                            return 'rotate(' + -axisConfig.radialAxis.orientation + ') translate(' + [ 0, fontStyle['font-size'] ] + ')';\n                        } else return 'translate(' + [ 0, fontStyle['font-size'] ] + ')';\n                    }\n                });\n                radialAxis.selectAll('g>line').style({\n                    stroke: 'black'\n                });\n            }\n            var angularAxis = svg.select('.angular.axis-group').selectAll('g.angular-tick').data(angularAxisRange);\n            var angularAxisEnter = angularAxis.enter().append('g').classed('angular-tick', true);\n            angularAxis.attr({\n                transform: function(d, i) {\n                    return 'rotate(' + currentAngle(d, i) + ')';\n                }\n            }).style({\n                display: axisConfig.angularAxis.visible ? 'block' : 'none'\n            });\n            angularAxis.exit().remove();\n            angularAxisEnter.append('line').classed('grid-line', true).classed('major', function(d, i) {\n                return i % (axisConfig.minorTicks + 1) == 0;\n            }).classed('minor', function(d, i) {\n                return !(i % (axisConfig.minorTicks + 1) == 0);\n            }).style(lineStyle);\n            angularAxisEnter.selectAll('.minor').style({\n                stroke: axisConfig.minorTickColor\n            });\n            angularAxis.select('line.grid-line').attr({\n                x1: axisConfig.tickLength ? radius - axisConfig.tickLength : 0,\n                x2: radius\n            }).style({\n                display: axisConfig.angularAxis.gridLinesVisible ? 'block' : 'none'\n            });\n            angularAxisEnter.append('text').classed('axis-text', true).style(fontStyle);\n            var ticksText = angularAxis.select('text.axis-text').attr({\n                x: radius + axisConfig.labelOffset,\n                dy: '.35em',\n                transform: function(d, i) {\n                    var angle = currentAngle(d, i);\n                    var rad = radius + axisConfig.labelOffset;\n                    var orient = axisConfig.angularAxis.tickOrientation;\n                    if (orient == 'horizontal') return 'rotate(' + -angle + ' ' + rad + ' 0)'; else if (orient == 'radial') return angle < 270 && angle > 90 ? 'rotate(180 ' + rad + ' 0)' : null; else return 'rotate(' + (angle <= 180 && angle > 0 ? -90 : 90) + ' ' + rad + ' 0)';\n                }\n            }).style({\n                'text-anchor': 'middle',\n                display: axisConfig.angularAxis.labelsVisible ? 'block' : 'none'\n            }).text(function(d, i) {\n                if (i % (axisConfig.minorTicks + 1) != 0) return '';\n                if (ticks) {\n                    return ticks[d] + axisConfig.angularAxis.ticksSuffix;\n                } else return d + axisConfig.angularAxis.ticksSuffix;\n            }).style(fontStyle);\n            if (axisConfig.angularAxis.rewriteTicks) ticksText.text(function(d, i) {\n                if (i % (axisConfig.minorTicks + 1) != 0) return '';\n                return axisConfig.angularAxis.rewriteTicks(this.textContent, i);\n            });\n            var rightmostTickEndX = d3.max(chartGroup.selectAll('.angular-tick text')[0].map(function(d, i) {\n                return d.getCTM().e + d.getBBox().width;\n            }));\n            legendContainer.attr({\n                transform: 'translate(' + [ radius + rightmostTickEndX, axisConfig.margin.top ] + ')'\n            });\n            var hasGeometry = svg.select('g.geometry-group').selectAll('g').size() > 0;\n            var geometryContainer = svg.select('g.geometry-group').selectAll('g.geometry').data(data);\n            geometryContainer.enter().append('g').attr({\n                'class': function(d, i) {\n                    return 'geometry geometry' + i;\n                }\n            });\n            geometryContainer.exit().remove();\n            if (data[0] || hasGeometry) {\n                var geometryConfigs = [];\n                data.forEach(function(d, i) {\n                    var geometryConfig = {};\n                    geometryConfig.radialScale = radialScale;\n                    geometryConfig.angularScale = angularScale;\n                    geometryConfig.container = geometryContainer.filter(function(dB, iB) {\n                        return iB == i;\n                    });\n                    geometryConfig.geometry = d.geometry;\n                    geometryConfig.orientation = axisConfig.orientation;\n                    geometryConfig.direction = axisConfig.direction;\n                    geometryConfig.index = i;\n                    geometryConfigs.push({\n                        data: d,\n                        geometryConfig: geometryConfig\n                    });\n                });\n                var geometryConfigsGrouped = d3.nest().key(function(d, i) {\n                    return typeof d.data.groupId != 'undefined' || 'unstacked';\n                }).entries(geometryConfigs);\n                var geometryConfigsGrouped2 = [];\n                geometryConfigsGrouped.forEach(function(d, i) {\n                    if (d.key === 'unstacked') geometryConfigsGrouped2 = geometryConfigsGrouped2.concat(d.values.map(function(d, i) {\n                        return [ d ];\n                    })); else geometryConfigsGrouped2.push(d.values);\n                });\n                geometryConfigsGrouped2.forEach(function(d, i) {\n                    var geometry;\n                    if (Array.isArray(d)) geometry = d[0].geometryConfig.geometry; else geometry = d.geometryConfig.geometry;\n                    var finalGeometryConfig = d.map(function(dB, iB) {\n                        return extendDeepAll([geometry].defaultConfig(), dB);\n                    });\n                    [geometry]().config(finalGeometryConfig)();\n                });\n            }\n            var guides = svg.select('.guides-group');\n            var tooltipContainer = svg.select('.tooltips-group');\n            var angularTooltip = .tooltipPanel().config({\n                container: tooltipContainer,\n                fontSize: 8\n            })();\n            var radialTooltip = .tooltipPanel().config({\n                container: tooltipContainer,\n                fontSize: 8\n            })();\n            var geometryTooltip = .tooltipPanel().config({\n                container: tooltipContainer,\n                hasTick: true\n            })();\n            var angularValue, radialValue;\n            if (!isOrdinal) {\n                var angularGuideLine = guides.select('line').attr({\n                    x1: 0,\n                    y1: 0,\n                    y2: 0\n                }).style({\n                    stroke: 'grey',\n                    'pointer-events': 'none'\n                });\n                chartGroup.on('mousemove.angular-guide', function(d, i) {\n                    var mouseAngle = .util.getMousePos(backgroundCircle).angle;\n                    angularGuideLine.attr({\n                        x2: -radius,\n                        transform: 'rotate(' + mouseAngle + ')'\n                    }).style({\n                        opacity: .5\n                    });\n                    var angleWithOriginOffset = (mouseAngle + 180 + 360 - axisConfig.orientation) % 360;\n                    angularValue = angularScale.invert(angleWithOriginOffset);\n                    var pos = .util.convertToCartesian(radius + 12, mouseAngle + 180);\n                    angularTooltip.text(.util.round(angularValue)).move([ pos[0] + chartCenter[0], pos[1] + chartCenter[1] ]);\n                }).on('mouseout.angular-guide', function(d, i) {\n                    guides.select('line').style({\n                        opacity: 0\n                    });\n                });\n            }\n            var angularGuideCircle = guides.select('circle').style({\n                stroke: 'grey',\n                fill: 'none'\n            });\n            chartGroup.on('mousemove.radial-guide', function(d, i) {\n                var r = .util.getMousePos(backgroundCircle).radius;\n                angularGuideCircle.attr({\n                    r: r\n                }).style({\n                    opacity: .5\n                });\n                radialValue = radialScale.invert(.util.getMousePos(backgroundCircle).radius);\n                var pos = .util.convertToCartesian(r, axisConfig.radialAxis.orientation);\n                radialTooltip.text(.util.round(radialValue)).move([ pos[0] + chartCenter[0], pos[1] + chartCenter[1] ]);\n            }).on('mouseout.radial-guide', function(d, i) {\n                angularGuideCircle.style({\n                    opacity: 0\n                });\n                geometryTooltip.hide();\n                angularTooltip.hide();\n                radialTooltip.hide();\n            });\n            svg.selectAll('.geometry-group .mark').on('mouseover.tooltip', function(d, i) {\n                var el = d3.select(this);\n                var color = el.style('fill');\n                var newColor = 'black';\n                var opacity = el.style('opacity') || 1;\n                el.attr({\n                    'data-opacity': opacity\n                });\n                if (color != 'none') {\n                    el.attr({\n                        'data-fill': color\n                    });\n                    newColor = d3.hsl(color).darker().toString();\n                    el.style({\n                        fill: newColor,\n                        opacity: 1\n                    });\n                    var textData = {\n                        t: .util.round(d[0]),\n                        r: .util.round(d[1])\n                    };\n                    if (isOrdinal) textData.t = ticks[d[0]];\n                    var text = 't: ' + textData.t + ', r: ' + textData.r;\n                    var bbox = this.getBoundingClientRect();\n                    var svgBBox = svg.node().getBoundingClientRect();\n                    var pos = [ bbox.left + bbox.width / 2 - centeringOffset[0] - svgBBox.left, bbox.top + bbox.height / 2 - centeringOffset[1] - svgBBox.top ];\n                    geometryTooltip.config({\n                        color: newColor\n                    }).text(text);\n                    geometryTooltip.move(pos);\n                } else {\n                    color = el.style('stroke');\n                    el.attr({\n                        'data-stroke': color\n                    });\n                    newColor = d3.hsl(color).darker().toString();\n                    el.style({\n                        stroke: newColor,\n                        opacity: 1\n                    });\n                }\n            }).on('mousemove.tooltip', function(d, i) {\n                if (d3.event.which != 0) return false;\n                if (d3.select(this).attr('data-fill')) geometryTooltip.show();\n            }).on('mouseout.tooltip', function(d, i) {\n                geometryTooltip.hide();\n                var el = d3.select(this);\n                var fillColor = el.attr('data-fill');\n                if (fillColor) el.style({\n                    fill: fillColor,\n                    opacity: el.attr('data-opacity')\n                }); else el.style({\n                    stroke: el.attr('data-stroke'),\n                    opacity: el.attr('data-opacity')\n                });\n            });\n        });\n        return exports;\n    }\n    exports.render = function(_container) {\n        render(_container);\n        return this;\n    };\n    exports.config = function(_x) {\n        if (!arguments.length) return config;\n        var xClone = .util.cloneJson(_x);\n        xClone.data.forEach(function(d, i) {\n            if (!config.data[i]) config.data[i] = {};\n            extendDeepAll(config.data[i], .Axis.defaultConfig().data[0]);\n            extendDeepAll(config.data[i], d);\n        });\n        extendDeepAll(config.layout, .Axis.defaultConfig().layout);\n        extendDeepAll(config.layout, xClone.layout);\n        return this;\n    };\n    exports.getLiveConfig = function() {\n        return liveConfig;\n    };\n    exports.getinputConfig = function() {\n        return inputConfig;\n    };\n    exports.radialScale = function(_x) {\n        return radialScale;\n    };\n    exports.angularScale = function(_x) {\n        return angularScale;\n    };\n    exports.svg = function() {\n        return svg;\n    };\n    d3.rebind(exports, dispatch, 'on');\n    return exports;\n};\n\n.Axis.defaultConfig = function(d, i) {\n    var config = {\n        data: [ {\n            t: [ 1, 2, 3, 4 ],\n            r: [ 10, 11, 12, 13 ],\n            name: 'Line1',\n            geometry: 'LinePlot',\n            color: null,\n            strokeDash: 'solid',\n            strokeColor: null,\n            strokeSize: '1',\n            visibleInLegend: true,\n            opacity: 1\n        } ],\n        layout: {\n            defaultColorRange: d3.scale.category10().range(),\n            title: null,\n            height: 450,\n            width: 500,\n            margin: {\n                top: 40,\n                right: 40,\n                bottom: 40,\n                left: 40\n            },\n            font: {\n                size: 12,\n                color: 'gray',\n                outlineColor: 'white',\n                family: 'Tahoma, sans-serif'\n            },\n            direction: 'clockwise',\n            orientation: 0,\n            labelOffset: 10,\n            radialAxis: {\n                domain: null,\n                orientation: -45,\n                ticksSuffix: '',\n                visible: true,\n                gridLinesVisible: true,\n                tickOrientation: 'horizontal',\n                rewriteTicks: null\n            },\n            angularAxis: {\n                domain: [ 0, 360 ],\n                ticksSuffix: '',\n                visible: true,\n                gridLinesVisible: true,\n                labelsVisible: true,\n                tickOrientation: 'horizontal',\n                rewriteTicks: null,\n                ticksCount: null,\n                ticksStep: null\n            },\n            minorTicks: 0,\n            tickLength: null,\n            tickColor: 'silver',\n            minorTickColor: '#eee',\n            backgroundColor: 'none',\n            needsEndSpacing: null,\n            showLegend: true,\n            legend: {\n                reverseOrder: false\n            },\n            opacity: 1\n        }\n    };\n    return config;\n};\n\n.util = {};\n\n.DATAEXTENT = 'dataExtent';\n\n.AREA = 'AreaChart';\n\n.LINE = 'LinePlot';\n\n.DOT = 'DotPlot';\n\n.BAR = 'BarChart';\n\n.util._override = function(_objA, _objB) {\n    for (var x in _objA) if (x in _objB) _objB[x] = _objA[x];\n};\n\n.util._extend = function(_objA, _objB) {\n    for (var x in _objA) _objB[x] = _objA[x];\n};\n\n.util._rndSnd = function() {\n    return Math.random() * 2 - 1 + (Math.random() * 2 - 1) + (Math.random() * 2 - 1);\n};\n\n.util.dataFromEquation2 = function(_equation, _step) {\n    var step = _step || 6;\n    var data = d3.range(0, 360 + step, step).map(function(deg, index) {\n        var theta = deg * Math.PI / 180;\n        var radius = _equation(theta);\n        return [ deg, radius ];\n    });\n    return data;\n};\n\n.util.dataFromEquation = function(_equation, _step, _name) {\n    var step = _step || 6;\n    var t = [], r = [];\n    d3.range(0, 360 + step, step).forEach(function(deg, index) {\n        var theta = deg * Math.PI / 180;\n        var radius = _equation(theta);\n        t.push(deg);\n        r.push(radius);\n    });\n    var result = {\n        t: t,\n        r: r\n    };\n    if (_name) result.name = _name;\n    return result;\n};\n\n.util.ensureArray = function(_val, _count) {\n    if (typeof _val === 'undefined') return null;\n    var arr = [].concat(_val);\n    return d3.range(_count).map(function(d, i) {\n        return arr[i] || arr[0];\n    });\n};\n\n.util.fillArrays = function(_obj, _valueNames, _count) {\n    _valueNames.forEach(function(d, i) {\n        _obj[d] = .util.ensureArray(_obj[d], _count);\n    });\n    return _obj;\n};\n\n.util.cloneJson = function(json) {\n    return JSON.parse(JSON.stringify(json));\n};\n\n.util.validateKeys = function(obj, keys) {\n    if (typeof keys === 'string') keys = keys.split('.');\n    var next = keys.shift();\n    return obj[next] && (!keys.length || objHasKeys(obj[next], keys));\n};\n\n.util.sumArrays = function(a, b) {\n    return d3.zip(a, b).map(function(d, i) {\n        return d3.sum(d);\n    });\n};\n\n.util.arrayLast = function(a) {\n    return a[a.length - 1];\n};\n\n.util.arrayEqual = function(a, b) {\n    var i = Math.max(a.length, b.length, 1);\n    while (i-- >= 0 && a[i] === b[i]) ;\n    return i === -2;\n};\n\n.util.flattenArray = function(arr) {\n    var r = [];\n    while (!.util.arrayEqual(r, arr)) {\n        r = arr;\n        arr = [].concat.apply([], arr);\n    }\n    return arr;\n};\n\n.util.deduplicate = function(arr) {\n    return arr.filter(function(v, i, a) {\n        return a.indexOf(v) == i;\n    });\n};\n\n.util.convertToCartesian = function(radius, theta) {\n    var thetaRadians = theta * Math.PI / 180;\n    var x = radius * Math.cos(thetaRadians);\n    var y = radius * Math.sin(thetaRadians);\n    return [ x, y ];\n};\n\n.util.round = function(_value, _digits) {\n    var digits = _digits || 2;\n    var mult = Math.pow(10, digits);\n    return Math.round(_value * mult) / mult;\n};\n\n.util.getMousePos = function(_referenceElement) {\n    var mousePos = d3.mouse(_referenceElement.node());\n    var mouseX = mousePos[0];\n    var mouseY = mousePos[1];\n    var mouse = {};\n    mouse.x = mouseX;\n    mouse.y = mouseY;\n    mouse.pos = mousePos;\n    mouse.angle = (Math.atan2(mouseY, mouseX) + Math.PI) * 180 / Math.PI;\n    mouse.radius = Math.sqrt(mouseX * mouseX + mouseY * mouseY);\n    return mouse;\n};\n\n.util.duplicatesCount = function(arr) {\n    var uniques = {}, val;\n    var dups = {};\n    for (var i = 0, len = arr.length; i < len; i++) {\n        val = arr[i];\n        if (val in uniques) {\n            uniques[val]++;\n            dups[val] = uniques[val];\n        } else {\n            uniques[val] = 1;\n        }\n    }\n    return dups;\n};\n\n.util.duplicates = function(arr) {\n    return Object.keys(.util.duplicatesCount(arr));\n};\n\n.util.translator = function(obj, sourceBranch, targetBranch, reverse) {\n    if (reverse) {\n        var targetBranchCopy = targetBranch.slice();\n        targetBranch = sourceBranch;\n        sourceBranch = targetBranchCopy;\n    }\n    var value = sourceBranch.reduce(function(previousValue, currentValue) {\n        if (typeof previousValue != 'undefined') return previousValue[currentValue];\n    }, obj);\n    if (typeof value === 'undefined') return;\n    sourceBranch.reduce(function(previousValue, currentValue, index) {\n        if (typeof previousValue == 'undefined') return;\n        if (index === sourceBranch.length - 1) delete previousValue[currentValue];\n        return previousValue[currentValue];\n    }, obj);\n    targetBranch.reduce(function(previousValue, currentValue, index) {\n        if (typeof previousValue[currentValue] === 'undefined') previousValue[currentValue] = {};\n        if (index === targetBranch.length - 1) previousValue[currentValue] = value;\n        return previousValue[currentValue];\n    }, obj);\n};\n\n.PolyChart = function module() {\n    var config = [ .PolyChart.defaultConfig() ];\n    var dispatch = d3.dispatch('hover');\n    var dashArray = {\n        solid: 'none',\n        dash: [ 5, 2 ],\n        dot: [ 2, 5 ]\n    };\n    var colorScale;\n    function exports() {\n        var geometryConfig = config[0].geometryConfig;\n        var container = geometryConfig.container;\n        if (typeof container == 'string') container = d3.select(container);\n        container.datum(config).each(function(_config, _index) {\n            var isStack = !!_config[0].data.yStack;\n            var data = _config.map(function(d, i) {\n                if (isStack) return d3.zip(d.data.t[0], d.data.r[0], d.data.yStack[0]); else return d3.zip(d.data.t[0], d.data.r[0]);\n            });\n            var angularScale = geometryConfig.angularScale;\n            var domainMin = geometryConfig.radialScale.domain()[0];\n            var generator = {};\n            generator.bar = function(d, i, pI) {\n                var dataConfig = _config[pI].data;\n                var h = geometryConfig.radialScale(d[1]) - geometryConfig.radialScale(0);\n                var stackTop = geometryConfig.radialScale(d[2] || 0);\n                var w = dataConfig.barWidth;\n                d3.select(this).attr({\n                    'class': 'mark bar',\n                    d: 'M' + [ [ h + stackTop, -w / 2 ], [ h + stackTop, w / 2 ], [ stackTop, w / 2 ], [ stackTop, -w / 2 ] ].join('L') + 'Z',\n                    transform: function(d, i) {\n                        return 'rotate(' + (geometryConfig.orientation + angularScale(d[0])) + ')';\n                    }\n                });\n            };\n            generator.dot = function(d, i, pI) {\n                var stackedData = d[2] ? [ d[0], d[1] + d[2] ] : d;\n                var symbol = d3.svg.symbol().size(_config[pI].data.dotSize).type(_config[pI].data.dotType)(d, i);\n                d3.select(this).attr({\n                    'class': 'mark dot',\n                    d: symbol,\n                    transform: function(d, i) {\n                        var coord = convertToCartesian(getPolarCoordinates(stackedData));\n                        return 'translate(' + [ coord.x, coord.y ] + ')';\n                    }\n                });\n            };\n            var line = d3.svg.line.radial().interpolate(_config[0].data.lineInterpolation).radius(function(d) {\n                return geometryConfig.radialScale(d[1]);\n            }).angle(function(d) {\n                return geometryConfig.angularScale(d[0]) * Math.PI / 180;\n            });\n            generator.line = function(d, i, pI) {\n                var lineData = d[2] ? data[pI].map(function(d, i) {\n                    return [ d[0], d[1] + d[2] ];\n                }) : data[pI];\n                d3.select(this).each(generator['dot']).style({\n                    opacity: function(dB, iB) {\n                        return +_config[pI].data.dotVisible;\n                    },\n                    fill: markStyle.stroke(d, i, pI)\n                }).attr({\n                    'class': 'mark dot'\n                });\n                if (i > 0) return;\n                var lineSelection = d3.select(this.parentNode).selectAll('path.line').data([ 0 ]);\n                lineSelection.enter().insert('path');\n                lineSelection.attr({\n                    'class': 'line',\n                    d: line(lineData),\n                    transform: function(dB, iB) {\n                        return 'rotate(' + (geometryConfig.orientation + 90) + ')';\n                    },\n                    'pointer-events': 'none'\n                }).style({\n                    fill: function(dB, iB) {\n                        return markStyle.fill(d, i, pI);\n                    },\n                    'fill-opacity': 0,\n                    stroke: function(dB, iB) {\n                        return markStyle.stroke(d, i, pI);\n                    },\n                    'stroke-width': function(dB, iB) {\n                        return markStyle['stroke-width'](d, i, pI);\n                    },\n                    'stroke-dasharray': function(dB, iB) {\n                        return markStyle['stroke-dasharray'](d, i, pI);\n                    },\n                    opacity: function(dB, iB) {\n                        return markStyle.opacity(d, i, pI);\n                    },\n                    display: function(dB, iB) {\n                        return markStyle.display(d, i, pI);\n                    }\n                });\n            };\n            var angularRange = geometryConfig.angularScale.range();\n            var triangleAngle = Math.abs(angularRange[1] - angularRange[0]) / data[0].length * Math.PI / 180;\n            var arc = d3.svg.arc().startAngle(function(d) {\n                return -triangleAngle / 2;\n            }).endAngle(function(d) {\n                return triangleAngle / 2;\n            }).innerRadius(function(d) {\n                return geometryConfig.radialScale(domainMin + (d[2] || 0));\n            }).outerRadius(function(d) {\n                return geometryConfig.radialScale(domainMin + (d[2] || 0)) + geometryConfig.radialScale(d[1]);\n            });\n            generator.arc = function(d, i, pI) {\n                d3.select(this).attr({\n                    'class': 'mark arc',\n                    d: arc,\n                    transform: function(d, i) {\n                        return 'rotate(' + (geometryConfig.orientation + angularScale(d[0]) + 90) + ')';\n                    }\n                });\n            };\n            var markStyle = {\n                fill: function(d, i, pI) {\n                    return _config[pI].data.color;\n                },\n                stroke: function(d, i, pI) {\n                    return _config[pI].data.strokeColor;\n                },\n                'stroke-width': function(d, i, pI) {\n                    return _config[pI].data.strokeSize + 'px';\n                },\n                'stroke-dasharray': function(d, i, pI) {\n                    return dashArray[_config[pI].data.strokeDash];\n                },\n                opacity: function(d, i, pI) {\n                    return _config[pI].data.opacity;\n                },\n                display: function(d, i, pI) {\n                    return typeof _config[pI].data.visible === 'undefined' || _config[pI].data.visible ? 'block' : 'none';\n                }\n            };\n            var geometryLayer = d3.select(this).selectAll('g.layer').data(data);\n            geometryLayer.enter().append('g').attr({\n                'class': 'layer'\n            });\n            var geometry = geometryLayer.selectAll('path.mark').data(function(d, i) {\n                return d;\n            });\n            geometry.enter().append('path').attr({\n                'class': 'mark'\n            });\n            geometry.style(markStyle).each(generator[geometryConfig.geometryType]);\n            geometry.exit().remove();\n            geometryLayer.exit().remove();\n            function getPolarCoordinates(d, i) {\n                var r = geometryConfig.radialScale(d[1]);\n                var t = (geometryConfig.angularScale(d[0]) + geometryConfig.orientation) * Math.PI / 180;\n                return {\n                    r: r,\n                    t: t\n                };\n            }\n            function convertToCartesian(polarCoordinates) {\n                var x = polarCoordinates.r * Math.cos(polarCoordinates.t);\n                var y = polarCoordinates.r * Math.sin(polarCoordinates.t);\n                return {\n                    x: x,\n                    y: y\n                };\n            }\n        });\n    }\n    exports.config = function(_x) {\n        if (!arguments.length) return config;\n        _x.forEach(function(d, i) {\n            if (!config[i]) config[i] = {};\n            extendDeepAll(config[i], .PolyChart.defaultConfig());\n            extendDeepAll(config[i], d);\n        });\n        return this;\n    };\n    exports.getColorScale = function() {\n        return colorScale;\n    };\n    d3.rebind(exports, dispatch, 'on');\n    return exports;\n};\n\n.PolyChart.defaultConfig = function() {\n    var config = {\n        data: {\n            name: 'geom1',\n            t: [ [ 1, 2, 3, 4 ] ],\n            r: [ [ 1, 2, 3, 4 ] ],\n            dotType: 'circle',\n            dotSize: 64,\n            dotVisible: false,\n            barWidth: 20,\n            color: '#ffa500',\n            strokeSize: 1,\n            strokeColor: 'silver',\n            strokeDash: 'solid',\n            opacity: 1,\n            index: 0,\n            visible: true,\n            visibleInLegend: true\n        },\n        geometryConfig: {\n            geometry: 'LinePlot',\n            geometryType: 'arc',\n            direction: 'clockwise',\n            orientation: 0,\n            container: 'body',\n            radialScale: null,\n            angularScale: null,\n            colorScale: d3.scale.category20()\n        }\n    };\n    return config;\n};\n\n.BarChart = function module() {\n    return .PolyChart();\n};\n\n.BarChart.defaultConfig = function() {\n    var config = {\n        geometryConfig: {\n            geometryType: 'bar'\n        }\n    };\n    return config;\n};\n\n.AreaChart = function module() {\n    return .PolyChart();\n};\n\n.AreaChart.defaultConfig = function() {\n    var config = {\n        geometryConfig: {\n            geometryType: 'arc'\n        }\n    };\n    return config;\n};\n\n.DotPlot = function module() {\n    return .PolyChart();\n};\n\n.DotPlot.defaultConfig = function() {\n    var config = {\n        geometryConfig: {\n            geometryType: 'dot',\n            dotType: 'circle'\n        }\n    };\n    return config;\n};\n\n.LinePlot = function module() {\n    return .PolyChart();\n};\n\n.LinePlot.defaultConfig = function() {\n    var config = {\n        geometryConfig: {\n            geometryType: 'line'\n        }\n    };\n    return config;\n};\n\n.Legend = function module() {\n    var config = .Legend.defaultConfig();\n    var dispatch = d3.dispatch('hover');\n    function exports() {\n        var legendConfig = config.legendConfig;\n        var flattenData = config.data.map(function(d, i) {\n            return [].concat(d).map(function(dB, iB) {\n                var element = extendDeepAll({}, legendConfig.elements[i]);\n                element.name = dB;\n                element.color = [].concat(legendConfig.elements[i].color)[iB];\n                return element;\n            });\n        });\n        var data = d3.merge(flattenData);\n        data = data.filter(function(d, i) {\n            return legendConfig.elements[i] && (legendConfig.elements[i].visibleInLegend || typeof legendConfig.elements[i].visibleInLegend === 'undefined');\n        });\n        if (legendConfig.reverseOrder) data = data.reverse();\n        var container = legendConfig.container;\n        if (typeof container == 'string' || container.nodeName) container = d3.select(container);\n        var colors = data.map(function(d, i) {\n            return d.color;\n        });\n        var lineHeight = legendConfig.fontSize;\n        var isContinuous = legendConfig.isContinuous == null ? typeof data[0] === 'number' : legendConfig.isContinuous;\n        var height = isContinuous ? legendConfig.height : lineHeight * data.length;\n        var legendContainerGroup = container.classed('legend-group', true);\n        var svg = legendContainerGroup.selectAll('svg').data([ 0 ]);\n        var svgEnter = svg.enter().append('svg').attr({\n            width: 300,\n            height: height + lineHeight,\n            xmlns: 'http://www.w3.org/2000/svg',\n            'xmlns:xlink': 'http://www.w3.org/1999/xlink',\n            version: '1.1'\n        });\n        svgEnter.append('g').classed('legend-axis', true);\n        svgEnter.append('g').classed('legend-marks', true);\n        var dataNumbered = d3.range(data.length);\n        var colorScale = d3.scale[isContinuous ? 'linear' : 'ordinal']().domain(dataNumbered).range(colors);\n        var dataScale = d3.scale[isContinuous ? 'linear' : 'ordinal']().domain(dataNumbered)[isContinuous ? 'range' : 'rangePoints']([ 0, height ]);\n        var shapeGenerator = function(_type, _size) {\n            var squareSize = _size * 3;\n            if (_type === 'line') {\n                return 'M' + [ [ -_size / 2, -_size / 12 ], [ _size / 2, -_size / 12 ], [ _size / 2, _size / 12 ], [ -_size / 2, _size / 12 ] ] + 'Z';\n            } else if (d3.svg.symbolTypes.indexOf(_type) != -1) return d3.svg.symbol().type(_type).size(squareSize)(); else return d3.svg.symbol().type('square').size(squareSize)();\n        };\n        if (isContinuous) {\n            var gradient = svg.select('.legend-marks').append('defs').append('linearGradient').attr({\n                id: 'grad1',\n                x1: '0%',\n                y1: '0%',\n                x2: '0%',\n                y2: '100%'\n            }).selectAll('stop').data(colors);\n            gradient.enter().append('stop');\n            gradient.attr({\n                offset: function(d, i) {\n                    return i / (colors.length - 1) * 100 + '%';\n                }\n            }).style({\n                'stop-color': function(d, i) {\n                    return d;\n                }\n            });\n            svg.append('rect').classed('legend-mark', true).attr({\n                height: legendConfig.height,\n                width: legendConfig.colorBandWidth,\n                fill: 'url(#grad1)'\n            });\n        } else {\n            var legendElement = svg.select('.legend-marks').selectAll('path.legend-mark').data(data);\n            legendElement.enter().append('path').classed('legend-mark', true);\n            legendElement.attr({\n                transform: function(d, i) {\n                    return 'translate(' + [ lineHeight / 2, dataScale(i) + lineHeight / 2 ] + ')';\n                },\n                d: function(d, i) {\n                    var symbolType = d.symbol;\n                    return shapeGenerator(symbolType, lineHeight);\n                },\n                fill: function(d, i) {\n                    return colorScale(i);\n                }\n            });\n            legendElement.exit().remove();\n        }\n        var legendAxis = d3.svg.axis().scale(dataScale).orient('right');\n        var axis = svg.select('g.legend-axis').attr({\n            transform: 'translate(' + [ isContinuous ? legendConfig.colorBandWidth : lineHeight, lineHeight / 2 ] + ')'\n        }).call(legendAxis);\n        axis.selectAll('.domain').style({\n            fill: 'none',\n            stroke: 'none'\n        });\n        axis.selectAll('line').style({\n            fill: 'none',\n            stroke: isContinuous ? legendConfig.textColor : 'none'\n        });\n        axis.selectAll('text').style({\n            fill: legendConfig.textColor,\n            'font-size': legendConfig.fontSize\n        }).text(function(d, i) {\n            return data[i].name;\n        });\n        return exports;\n    }\n    exports.config = function(_x) {\n        if (!arguments.length) return config;\n        extendDeepAll(config, _x);\n        return this;\n    };\n    d3.rebind(exports, dispatch, 'on');\n    return exports;\n};\n\n.Legend.defaultConfig = function(d, i) {\n    var config = {\n        data: [ 'a', 'b', 'c' ],\n        legendConfig: {\n            elements: [ {\n                symbol: 'line',\n                color: 'red'\n            }, {\n                symbol: 'square',\n                color: 'yellow'\n            }, {\n                symbol: 'diamond',\n                color: 'limegreen'\n            } ],\n            height: 150,\n            colorBandWidth: 30,\n            fontSize: 12,\n            container: 'body',\n            isContinuous: null,\n            textColor: 'grey',\n            reverseOrder: false\n        }\n    };\n    return config;\n};\n\n.tooltipPanel = function() {\n    var tooltipEl, tooltipTextEl, backgroundEl;\n    var config = {\n        container: null,\n        hasTick: false,\n        fontSize: 12,\n        color: 'white',\n        padding: 5\n    };\n    var id = 'tooltip-' + .tooltipPanel.uid++;\n    var tickSize = 10;\n    var exports = function() {\n        tooltipEl = config.container.selectAll('g.' + id).data([ 0 ]);\n        var tooltipEnter = tooltipEl.enter().append('g').classed(id, true).style({\n            'pointer-events': 'none',\n            display: 'none'\n        });\n        backgroundEl = tooltipEnter.append('path').style({\n            fill: 'white',\n            'fill-opacity': .9\n        }).attr({\n            d: 'M0 0'\n        });\n        tooltipTextEl = tooltipEnter.append('text').attr({\n            dx: config.padding + tickSize,\n            dy: +config.fontSize * .3\n        });\n        return exports;\n    };\n    exports.text = function(_text) {\n        var l = d3.hsl(config.color).l;\n        var strokeColor = l >= .5 ? '#aaa' : 'white';\n        var fillColor = l >= .5 ? 'black' : 'white';\n        var text = _text || '';\n        tooltipTextEl.style({\n            fill: fillColor,\n            'font-size': config.fontSize + 'px'\n        }).text(text);\n        var padding = config.padding;\n        var bbox = tooltipTextEl.node().getBBox();\n        var boxStyle = {\n            fill: config.color,\n            stroke: strokeColor,\n            'stroke-width': '2px'\n        };\n        var backGroundW = bbox.width + padding * 2 + tickSize;\n        var backGroundH = bbox.height + padding * 2;\n        backgroundEl.attr({\n            d: 'M' + [ [ tickSize, -backGroundH / 2 ], [ tickSize, -backGroundH / 4 ], [ config.hasTick ? 0 : tickSize, 0 ], [ tickSize, backGroundH / 4 ], [ tickSize, backGroundH / 2 ], [ backGroundW, backGroundH / 2 ], [ backGroundW, -backGroundH / 2 ] ].join('L') + 'Z'\n        }).style(boxStyle);\n        tooltipEl.attr({\n            transform: 'translate(' + [ tickSize, -backGroundH / 2 + padding * 2 ] + ')'\n        });\n        tooltipEl.style({\n            display: 'block'\n        });\n        return exports;\n    };\n    exports.move = function(_pos) {\n        if (!tooltipEl) return;\n        tooltipEl.attr({\n            transform: 'translate(' + [ _pos[0], _pos[1] ] + ')'\n        }).style({\n            display: 'block'\n        });\n        return exports;\n    };\n    exports.hide = function() {\n        if (!tooltipEl) return;\n        tooltipEl.style({\n            display: 'none'\n        });\n        return exports;\n    };\n    exports.show = function() {\n        if (!tooltipEl) return;\n        tooltipEl.style({\n            display: 'block'\n        });\n        return exports;\n    };\n    exports.config = function(_x) {\n        extendDeepAll(config, _x);\n        return exports;\n    };\n    return exports;\n};\n\n.tooltipPanel.uid = 1;\n\n.adapter = {};\n\n.adapter.plotly = function module() {\n    var exports = {};\n    exports.convert = function(_inputConfig, reverse) {\n        var outputConfig = {};\n        if (_inputConfig.data) {\n            outputConfig.data = _inputConfig.data.map(function(d, i) {\n                var r = extendDeepAll({}, d);\n                var toTranslate = [\n                    [ r, [ 'marker', 'color' ], [ 'color' ] ],\n                    [ r, [ 'marker', 'opacity' ], [ 'opacity' ] ],\n                    [ r, [ 'marker', 'line', 'color' ], [ 'strokeColor' ] ],\n                    [ r, [ 'marker', 'line', 'dash' ], [ 'strokeDash' ] ],\n                    [ r, [ 'marker', 'line', 'width' ], [ 'strokeSize' ] ],\n                    [ r, [ 'marker', 'symbol' ], [ 'dotType' ] ],\n                    [ r, [ 'marker', 'size' ], [ 'dotSize' ] ],\n                    [ r, [ 'marker', 'barWidth' ], [ 'barWidth' ] ],\n                    [ r, [ 'line', 'interpolation' ], [ 'lineInterpolation' ] ],\n                    [ r, [ 'showlegend' ], [ 'visibleInLegend' ] ]\n                ];\n                toTranslate.forEach(function(d, i) {\n                    .util.translator.apply(null, d.concat(reverse));\n                });\n\n                if (!reverse) delete r.marker;\n                if (reverse) delete r.groupId;\n                if (!reverse) {\n                    if (r.type === 'scatter') {\n                        if (r.mode === 'lines') r.geometry = 'LinePlot'; else if (r.mode === 'markers') r.geometry = 'DotPlot'; else if (r.mode === 'lines+markers') {\n                            r.geometry = 'LinePlot';\n                            r.dotVisible = true;\n                        }\n                    } else if (r.type === 'area') r.geometry = 'AreaChart'; else if (r.type === 'bar') r.geometry = 'BarChart';\n                    delete r.mode;\n                    delete r.type;\n                } else {\n                    if (r.geometry === 'LinePlot') {\n                        r.type = 'scatter';\n                        if (r.dotVisible === true) {\n                            delete r.dotVisible;\n                            r.mode = 'lines+markers';\n                        } else r.mode = 'lines';\n                    } else if (r.geometry === 'DotPlot') {\n                        r.type = 'scatter';\n                        r.mode = 'markers';\n                    } else if (r.geometry === 'AreaChart') r.type = 'area'; else if (r.geometry === 'BarChart') r.type = 'bar';\n                    delete r.geometry;\n                }\n                return r;\n            });\n            if (!reverse && _inputConfig.layout && _inputConfig.layout.barmode === 'stack') {\n                var duplicates = .util.duplicates(outputConfig.data.map(function(d, i) {\n                    return d.geometry;\n                }));\n                outputConfig.data.forEach(function(d, i) {\n                    var idx = duplicates.indexOf(d.geometry);\n                    if (idx != -1) outputConfig.data[i].groupId = idx;\n                });\n            }\n        }\n        if (_inputConfig.layout) {\n            var r = extendDeepAll({}, _inputConfig.layout);\n            var toTranslate = [\n                [ r, [ 'plot_bgcolor' ], [ 'backgroundColor' ] ],\n                [ r, [ 'showlegend' ], [ 'showLegend' ] ],\n                [ r, [ 'radialaxis' ], [ 'radialAxis' ] ],\n                [ r, [ 'angularaxis' ], [ 'angularAxis' ] ],\n                [ r.angularaxis, [ 'showline' ], [ 'gridLinesVisible' ] ],\n                [ r.angularaxis, [ 'showticklabels' ], [ 'labelsVisible' ] ],\n                [ r.angularaxis, [ 'nticks' ], [ 'ticksCount' ] ],\n                [ r.angularaxis, [ 'tickorientation' ], [ 'tickOrientation' ] ],\n                [ r.angularaxis, [ 'ticksuffix' ], [ 'ticksSuffix' ] ],\n                [ r.angularaxis, [ 'range' ], [ 'domain' ] ],\n                [ r.angularaxis, [ 'endpadding' ], [ 'endPadding' ] ],\n                [ r.radialaxis, [ 'showline' ], [ 'gridLinesVisible' ] ],\n                [ r.radialaxis, [ 'tickorientation' ], [ 'tickOrientation' ] ],\n                [ r.radialaxis, [ 'ticksuffix' ], [ 'ticksSuffix' ] ],\n                [ r.radialaxis, [ 'range' ], [ 'domain' ] ],\n                [ r.angularAxis, [ 'showline' ], [ 'gridLinesVisible' ] ],\n                [ r.angularAxis, [ 'showticklabels' ], [ 'labelsVisible' ] ],\n                [ r.angularAxis, [ 'nticks' ], [ 'ticksCount' ] ],\n                [ r.angularAxis, [ 'tickorientation' ], [ 'tickOrientation' ] ],\n                [ r.angularAxis, [ 'ticksuffix' ], [ 'ticksSuffix' ] ],\n                [ r.angularAxis, [ 'range' ], [ 'domain' ] ],\n                [ r.angularAxis, [ 'endpadding' ], [ 'endPadding' ] ],\n                [ r.radialAxis, [ 'showline' ], [ 'gridLinesVisible' ] ],\n                [ r.radialAxis, [ 'tickorientation' ], [ 'tickOrientation' ] ],\n                [ r.radialAxis, [ 'ticksuffix' ], [ 'ticksSuffix' ] ],\n                [ r.radialAxis, [ 'range' ], [ 'domain' ] ],\n                [ r.font, [ 'outlinecolor' ], [ 'outlineColor' ] ],\n                [ r.legend, [ 'traceorder' ], [ 'reverseOrder' ] ],\n                [ r, [ 'labeloffset' ], [ 'labelOffset' ] ],\n                [ r, [ 'defaultcolorrange' ], [ 'defaultColorRange' ] ]\n            ];\n            toTranslate.forEach(function(d, i) {\n                .util.translator.apply(null, d.concat(reverse));\n            });\n\n            if (!reverse) {\n                if (r.angularAxis && typeof r.angularAxis.ticklen !== 'undefined') r.tickLength = r.angularAxis.ticklen;\n                if (r.angularAxis && typeof r.angularAxis.tickcolor !== 'undefined') r.tickColor = r.angularAxis.tickcolor;\n            } else {\n                if (typeof r.tickLength !== 'undefined') {\n                    r.angularaxis.ticklen = r.tickLength;\n                    delete r.tickLength;\n                }\n                if (r.tickColor) {\n                    r.angularaxis.tickcolor = r.tickColor;\n                    delete r.tickColor;\n                }\n            }\n            if (r.legend && typeof r.legend.reverseOrder != 'boolean') {\n                r.legend.reverseOrder = r.legend.reverseOrder != 'normal';\n            }\n            if (r.legend && typeof r.legend.traceorder == 'boolean') {\n                r.legend.traceorder = r.legend.traceorder ? 'reversed' : 'normal';\n                delete r.legend.reverseOrder;\n            }\n            if (r.margin && typeof r.margin.t != 'undefined') {\n                var source = [ 't', 'r', 'b', 'l', 'pad' ];\n                var target = [ 'top', 'right', 'bottom', 'left', 'pad' ];\n                var margin = {};\n                d3.entries(r.margin).forEach(function(dB, iB) {\n                    margin[target[source.indexOf(dB.key)]] = dB.value;\n                });\n                r.margin = margin;\n            }\n            if (reverse) {\n                delete r.needsEndSpacing;\n                delete r.minorTickColor;\n                delete r.minorTicks;\n                delete r.angularaxis.ticksCount;\n                delete r.angularaxis.ticksCount;\n                delete r.angularaxis.ticksStep;\n                delete r.angularaxis.rewriteTicks;\n                delete r.angularaxis.nticks;\n                delete r.radialaxis.ticksCount;\n                delete r.radialaxis.ticksCount;\n                delete r.radialaxis.ticksStep;\n                delete r.radialaxis.rewriteTicks;\n                delete r.radialaxis.nticks;\n            }\n            outputConfig.layout = r;\n        }\n        return outputConfig;\n    };\n    return exports;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/polar/micropolar_manager.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n/* eslint-disable new-cap */\n\n'use strict';\n\nvar d3 = require('d3');\nvar Lib = require('../../lib');\nvar Color = require('../../components/color');\n\nvar micropolar = require('./micropolar');\nvar UndoManager = require('./undo_manager');\nvar extendDeepAll = Lib.extendDeepAll;\n\nvar manager = module.exports = {};\n\nmanager.framework = function(_gd) {\n    var config, previousConfigClone, plot, convertedInput, container;\n    var undoManager = new UndoManager();\n\n    function exports(_inputConfig, _container) {\n        if(_container) container = _container;\n        d3.select(d3.select(container).node().parentNode).selectAll('.svg-container>*:not(.chart-root)').remove();\n\n        config = (!config) ?\n            _inputConfig :\n            extendDeepAll(config, _inputConfig);\n\n        if(!plot) plot = micropolar.Axis();\n        convertedInput = micropolar.adapter.plotly().convert(config);\n        plot.config(convertedInput).render(container);\n        _gd.data = config.data;\n        _gd.layout = config.layout;\n        manager.fillLayout(_gd);\n        return config;\n    }\n    exports.isPolar = true;\n    exports.svg = function() { return plot.svg(); };\n    exports.getConfig = function() { return config; };\n    exports.getLiveConfig = function() {\n        return micropolar.adapter.plotly().convert(plot.getLiveConfig(), true);\n    };\n    exports.getLiveScales = function() { return {t: plot.angularScale(), r: plot.radialScale()}; };\n    exports.setUndoPoint = function() {\n        var that = this;\n        var configClone = micropolar.util.cloneJson(config);\n        (function(_configClone, _previousConfigClone) {\n            undoManager.add({\n                undo: function() {\n                    if(_previousConfigClone) that(_previousConfigClone);\n                },\n                redo: function() {\n                    that(_configClone);\n                }\n            });\n        })(configClone, previousConfigClone);\n        previousConfigClone = micropolar.util.cloneJson(configClone);\n    };\n    exports.undo = function() { undoManager.undo(); };\n    exports.redo = function() { undoManager.redo(); };\n    return exports;\n};\n\nmanager.fillLayout = function(_gd) {\n    var container = d3.select(_gd).selectAll('.plot-container'),\n        paperDiv = container.selectAll('.svg-container'),\n        paper = _gd.framework && _gd.framework.svg && _gd.framework.svg(),\n        dflts = {\n            width: 800,\n            height: 600,\n            paper_bgcolor: Color.background,\n            _container: container,\n            _paperdiv: paperDiv,\n            _paper: paper\n        };\n\n    _gd._fullLayout = extendDeepAll(dflts, _gd.layout);\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/polar/undo_manager.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n// Modified from https://github.com/ArthurClemens/Javascript-Undo-Manager\n// Copyright (c) 2010-2013 Arthur Clemens, arthur@visiblearea.com\nmodule.exports = function UndoManager() {\n    var undoCommands = [],\n        index = -1,\n        isExecuting = false,\n        callback;\n\n    function execute(command, action) {\n        if(!command) return this;\n\n        isExecuting = true;\n        command[action]();\n        isExecuting = false;\n\n        return this;\n    }\n\n    return {\n        add: function(command) {\n            if(isExecuting) return this;\n            undoCommands.splice(index + 1, undoCommands.length - index);\n            undoCommands.push(command);\n            index = undoCommands.length - 1;\n            return this;\n        },\n        setCallback: function(callbackFunc) { callback = callbackFunc; },\n        undo: function() {\n            var command = undoCommands[index];\n            if(!command) return this;\n            execute(command, 'undo');\n            index -= 1;\n            if(callback) callback(command.undo);\n            return this;\n        },\n        redo: function() {\n            var command = undoCommands[index + 1];\n            if(!command) return this;\n            execute(command, 'redo');\n            index += 1;\n            if(callback) callback(command.redo);\n            return this;\n        },\n        clear: function() {\n            undoCommands = [];\n            index = -1;\n        },\n        hasUndo: function() { return index !== -1; },\n        hasRedo: function() { return index < (undoCommands.length - 1); },\n        getCommands: function() { return undoCommands; },\n        getPreviousCommand: function() { return undoCommands[index - 1]; },\n        getIndex: function() { return index; }\n    };\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plot_api/manage_arrays.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar nestedProperty = require('../lib/nested_property');\nvar isPlainObject = require('../lib/is_plain_object');\nvar noop = require('../lib/noop');\nvar Loggers = require('../lib/loggers');\nvar Registry = require('../registry');\n\n\nexports.containerArrayMatch = require('./container_array_match');\n\nvar isAddVal = exports.isAddVal = function isAddVal(val) {\n    return val === 'add' || isPlainObject(val);\n};\n\nvar isRemoveVal = exports.isRemoveVal = function isRemoveVal(val) {\n    return val === null || val === 'remove';\n};\n\n/*\n * applyContainerArrayChanges: for managing arrays of layout components in relayout\n * handles them all with a consistent interface.\n *\n * Here are the supported actions -> relayout calls -> edits we get here\n * (as prepared in _relayout):\n *\n * add an empty obj -> {'annotations[2]': 'add'} -> {2: {'': 'add'}}\n * add a specific obj -> {'annotations[2]': {attrs}} -> {2: {'': {attrs}}}\n * delete an obj -> {'annotations[2]': 'remove'} -> {2: {'': 'remove'}}\n *               -> {'annotations[2]': null} -> {2: {'': null}}\n * delete the whole array -> {'annotations': 'remove'} -> {'': {'': 'remove'}}\n *                        -> {'annotations': null} -> {'': {'': null}}\n * edit an object -> {'annotations[2].text': 'boo'} -> {2: {'text': 'boo'}}\n *\n * You can combine many edits to different objects. Objects are added and edited\n * in ascending order, then removed in descending order.\n * For example, starting with [a, b, c], if you want to:\n * - replace b with d:\n *   {'annotations[1]': d, 'annotations[2]': null} (b is item 2 after adding d)\n * - add a new item d between a and b, and edit b:\n *    {'annotations[1]': d, 'annotations[2].x': newX} (b is item 2 after adding d)\n * - delete b and edit c:\n *    {'annotations[1]': null, 'annotations[2].x': newX} (c is edited before b is removed)\n *\n * You CANNOT combine adding/deleting an item at index `i` with edits to the same index `i`\n * You CANNOT combine replacing/deleting the whole array with anything else (for the same array).\n *\n * @param {HTMLDivElement} gd\n *  the DOM element of the graph container div\n * @param {Lib.nestedProperty} componentType: the array we are editing\n * @param {Object} edits\n *  the changes to make; keys are indices to edit, values are themselves objects:\n *  {attr: newValue} of changes to make to that index (with add/remove behavior\n *  in special values of the empty attr)\n * @param {Object} flags\n *  the flags for which actions we're going to perform to display these (and\n *  any other) changes. If we're already `recalc`ing, we don't need to redraw\n *  individual items\n *\n * @returns {bool} `true` if it managed to complete drawing of the changes\n *  `false` would mean the parent should replot.\n */\nexports.applyContainerArrayChanges = function applyContainerArrayChanges(gd, np, edits, flags) {\n    var componentType = np.astr,\n        supplyComponentDefaults = Registry.getComponentMethod(componentType, 'supplyLayoutDefaults'),\n        draw = Registry.getComponentMethod(componentType, 'draw'),\n        drawOne = Registry.getComponentMethod(componentType, 'drawOne'),\n        replotLater = flags.replot || flags.recalc || (supplyComponentDefaults === noop) ||\n            (draw === noop),\n        layout = gd.layout,\n        fullLayout = gd._fullLayout;\n\n    if(edits['']) {\n        if(Object.keys(edits).length > 1) {\n            Loggers.warn('Full array edits are incompatible with other edits',\n                componentType);\n        }\n\n        var fullVal = edits[''][''];\n\n        if(isRemoveVal(fullVal)) np.set(null);\n        else if(Array.isArray(fullVal)) np.set(fullVal);\n        else {\n            Loggers.warn('Unrecognized full array edit value', componentType, fullVal);\n            return true;\n        }\n\n        if(replotLater) return false;\n\n        supplyComponentDefaults(layout, fullLayout);\n        draw(gd);\n        return true;\n    }\n\n    var componentNums = Object.keys(edits).map(Number).sort(),\n        componentArrayIn = np.get(),\n        componentArray = componentArrayIn || [],\n        // componentArrayFull is used just to keep splices in line between\n        // full and input arrays, so private keys can be copied over after\n        // redoing supplyDefaults\n        // TODO: this assumes componentArray is in gd.layout - which will not be\n        // true after we extend this to restyle\n        componentArrayFull = nestedProperty(fullLayout, componentType).get();\n\n    var deletes = [],\n        firstIndexChange = -1,\n        maxIndex = componentArray.length,\n        i,\n        j,\n        componentNum,\n        objEdits,\n        objKeys,\n        objVal,\n        adding;\n\n    // first make the add and edit changes\n    for(i = 0; i < componentNums.length; i++) {\n        componentNum = componentNums[i];\n        objEdits = edits[componentNum];\n        objKeys = Object.keys(objEdits);\n        objVal = objEdits[''],\n        adding = isAddVal(objVal);\n\n        if(componentNum < 0 || componentNum > componentArray.length - (adding ? 0 : 1)) {\n            Loggers.warn('index out of range', componentType, componentNum);\n            continue;\n        }\n\n        if(objVal !== undefined) {\n            if(objKeys.length > 1) {\n                Loggers.warn(\n                    'Insertion & removal are incompatible with edits to the same index.',\n                    componentType, componentNum);\n            }\n\n            if(isRemoveVal(objVal)) {\n                deletes.push(componentNum);\n            }\n            else if(adding) {\n                if(objVal === 'add') objVal = {};\n                componentArray.splice(componentNum, 0, objVal);\n                if(componentArrayFull) componentArrayFull.splice(componentNum, 0, {});\n            }\n            else {\n                Loggers.warn('Unrecognized full object edit value',\n                    componentType, componentNum, objVal);\n            }\n\n            if(firstIndexChange === -1) firstIndexChange = componentNum;\n        }\n        else {\n            for(j = 0; j < objKeys.length; j++) {\n                nestedProperty(componentArray[componentNum], objKeys[j]).set(objEdits[objKeys[j]]);\n            }\n        }\n    }\n\n    // now do deletes\n    for(i = deletes.length - 1; i >= 0; i--) {\n        componentArray.splice(deletes[i], 1);\n        // TODO: this drops private keys that had been stored in componentArrayFull\n        // does this have any ill effects?\n        if(componentArrayFull) componentArrayFull.splice(deletes[i], 1);\n    }\n\n    if(!componentArray.length) np.set(null);\n    else if(!componentArrayIn) np.set(componentArray);\n\n    if(replotLater) return false;\n\n    supplyComponentDefaults(layout, fullLayout);\n\n    // finally draw all the components we need to\n    // if we added or removed any, redraw all after it\n    if(drawOne !== noop) {\n        var indicesToDraw;\n        if(firstIndexChange === -1) {\n            // there's no re-indexing to do, so only redraw components that changed\n            indicesToDraw = componentNums;\n        }\n        else {\n            // in case the component array was shortened, we still need do call\n            // drawOne on the latter items so they get properly removed\n            maxIndex = Math.max(componentArray.length, maxIndex);\n            indicesToDraw = [];\n            for(i = 0; i < componentNums.length; i++) {\n                componentNum = componentNums[i];\n                if(componentNum >= firstIndexChange) break;\n                indicesToDraw.push(componentNum);\n            }\n            for(i = firstIndexChange; i < maxIndex; i++) {\n                indicesToDraw.push(i);\n            }\n        }\n        for(i = 0; i < indicesToDraw.length; i++) {\n            drawOne(gd, indicesToDraw[i]);\n        }\n    }\n    else draw(gd);\n\n    return true;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plot_api/helpers.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar m4FromQuat = require('gl-mat4/fromQuat');\n\nvar Registry = require('../registry');\nvar Lib = require('../lib');\nvar Plots = require('../plots/plots');\nvar Axes = require('../plots/cartesian/axes');\nvar Color = require('../components/color');\n\n\n// Get the container div: we store all variables for this plot as\n// properties of this div\n// some callers send this in by DOM element, others by id (string)\nexports.getGraphDiv = function(gd) {\n    var gdElement;\n\n    if(typeof gd === 'string') {\n        gdElement = document.getElementById(gd);\n\n        if(gdElement === null) {\n            throw new Error('No DOM element with id \\'' + gd + '\\' exists on the page.');\n        }\n\n        return gdElement;\n    }\n    else if(gd === null || gd === undefined) {\n        throw new Error('DOM element provided is null or undefined');\n    }\n\n    return gd;  // otherwise assume that gd is a DOM element\n};\n\n// clear the promise queue if one of them got rejected\nexports.clearPromiseQueue = function(gd) {\n    if(Array.isArray(gd._promises) && gd._promises.length > 0) {\n        Lib.log('Clearing previous rejected promises from queue.');\n    }\n\n    gd._promises = [];\n};\n\n// make a few changes to the layout right away\n// before it gets used for anything\n// backward compatibility and cleanup of nonstandard options\nexports.cleanLayout = function(layout) {\n    var i, j;\n\n    if(!layout) layout = {};\n\n    // cannot have (x|y)axis1, numbering goes axis, axis2, axis3...\n    if(layout.xaxis1) {\n        if(!layout.xaxis) layout.xaxis = layout.xaxis1;\n        delete layout.xaxis1;\n    }\n    if(layout.yaxis1) {\n        if(!layout.yaxis) layout.yaxis = layout.yaxis1;\n        delete layout.yaxis1;\n    }\n\n    var axList = Axes.list({_fullLayout: layout});\n    for(i = 0; i < axList.length; i++) {\n        var ax = axList[i];\n        if(ax.anchor && ax.anchor !== 'free') {\n            ax.anchor = Axes.cleanId(ax.anchor);\n        }\n        if(ax.overlaying) ax.overlaying = Axes.cleanId(ax.overlaying);\n\n        // old method of axis type - isdate and islog (before category existed)\n        if(!ax.type) {\n            if(ax.isdate) ax.type = 'date';\n            else if(ax.islog) ax.type = 'log';\n            else if(ax.isdate === false && ax.islog === false) ax.type = 'linear';\n        }\n        if(ax.autorange === 'withzero' || ax.autorange === 'tozero') {\n            ax.autorange = true;\n            ax.rangemode = 'tozero';\n        }\n        delete ax.islog;\n        delete ax.isdate;\n        delete ax.categories; // replaced by _categories\n\n        // prune empty domain arrays made before the new nestedProperty\n        if(emptyContainer(ax, 'domain')) delete ax.domain;\n\n        // autotick -> tickmode\n        if(ax.autotick !== undefined) {\n            if(ax.tickmode === undefined) {\n                ax.tickmode = ax.autotick ? 'auto' : 'linear';\n            }\n            delete ax.autotick;\n        }\n    }\n\n    var annotationsLen = Array.isArray(layout.annotations) ? layout.annotations.length : 0;\n    for(i = 0; i < annotationsLen; i++) {\n        var ann = layout.annotations[i];\n\n        if(!Lib.isPlainObject(ann)) continue;\n\n        if(ann.ref) {\n            if(ann.ref === 'paper') {\n                ann.xref = 'paper';\n                ann.yref = 'paper';\n            }\n            else if(ann.ref === 'data') {\n                ann.xref = 'x';\n                ann.yref = 'y';\n            }\n            delete ann.ref;\n        }\n\n        cleanAxRef(ann, 'xref');\n        cleanAxRef(ann, 'yref');\n    }\n\n    var shapesLen = Array.isArray(layout.shapes) ? layout.shapes.length : 0;\n    for(i = 0; i < shapesLen; i++) {\n        var shape = layout.shapes[i];\n\n        if(!Lib.isPlainObject(shape)) continue;\n\n        cleanAxRef(shape, 'xref');\n        cleanAxRef(shape, 'yref');\n    }\n\n    var legend = layout.legend;\n    if(legend) {\n        // check for old-style legend positioning (x or y is +/- 100)\n        if(legend.x > 3) {\n            legend.x = 1.02;\n            legend.xanchor = 'left';\n        }\n        else if(legend.x < -2) {\n            legend.x = -0.02;\n            legend.xanchor = 'right';\n        }\n\n        if(legend.y > 3) {\n            legend.y = 1.02;\n            legend.yanchor = 'bottom';\n        }\n        else if(legend.y < -2) {\n            legend.y = -0.02;\n            legend.yanchor = 'top';\n        }\n    }\n\n    /*\n     * Moved from rotate -> orbit for dragmode\n     */\n    if(layout.dragmode === 'rotate') layout.dragmode = 'orbit';\n\n    // cannot have scene1, numbering goes scene, scene2, scene3...\n    if(layout.scene1) {\n        if(!layout.scene) layout.scene = layout.scene1;\n        delete layout.scene1;\n    }\n\n    /*\n     * Clean up Scene layouts\n     */\n    var sceneIds = Plots.getSubplotIds(layout, 'gl3d');\n    for(i = 0; i < sceneIds.length; i++) {\n        var scene = layout[sceneIds[i]];\n\n        // clean old Camera coords\n        var cameraposition = scene.cameraposition;\n        if(Array.isArray(cameraposition) && cameraposition[0].length === 4) {\n            var rotation = cameraposition[0],\n                center = cameraposition[1],\n                radius = cameraposition[2],\n                mat = m4FromQuat([], rotation),\n                eye = [];\n\n            for(j = 0; j < 3; ++j) {\n                eye[j] = center[i] + radius * mat[2 + 4 * j];\n            }\n\n            scene.camera = {\n                eye: {x: eye[0], y: eye[1], z: eye[2]},\n                center: {x: center[0], y: center[1], z: center[2]},\n                up: {x: mat[1], y: mat[5], z: mat[9]}\n            };\n\n            delete scene.cameraposition;\n        }\n    }\n\n    // sanitize rgb(fractions) and rgba(fractions) that old tinycolor\n    // supported, but new tinycolor does not because they're not valid css\n    Color.clean(layout);\n\n    return layout;\n};\n\nfunction cleanAxRef(container, attr) {\n    var valIn = container[attr],\n        axLetter = attr.charAt(0);\n    if(valIn && valIn !== 'paper') {\n        container[attr] = Axes.cleanId(valIn, axLetter);\n    }\n}\n\n// Make a few changes to the data right away\n// before it gets used for anything\nexports.cleanData = function(data, existingData) {\n\n    // Enforce unique IDs\n    var suids = [], // seen uids --- so we can weed out incoming repeats\n        uids = data.concat(Array.isArray(existingData) ? existingData : [])\n               .filter(function(trace) { return 'uid' in trace; })\n               .map(function(trace) { return trace.uid; });\n\n    for(var tracei = 0; tracei < data.length; tracei++) {\n        var trace = data[tracei];\n        var i;\n\n        // assign uids to each trace and detect collisions.\n        if(!('uid' in trace) || suids.indexOf(trace.uid) !== -1) {\n            var newUid;\n\n            for(i = 0; i < 100; i++) {\n                newUid = Lib.randstr(uids);\n                if(suids.indexOf(newUid) === -1) break;\n            }\n            trace.uid = Lib.randstr(uids);\n            uids.push(trace.uid);\n        }\n        // keep track of already seen uids, so that if there are\n        // doubles we force the trace with a repeat uid to\n        // acquire a new one\n        suids.push(trace.uid);\n\n        // BACKWARD COMPATIBILITY FIXES\n\n        // use xbins to bin data in x, and ybins to bin data in y\n        if(trace.type === 'histogramy' && 'xbins' in trace && !('ybins' in trace)) {\n            trace.ybins = trace.xbins;\n            delete trace.xbins;\n        }\n\n        // error_y.opacity is obsolete - merge into color\n        if(trace.error_y && 'opacity' in trace.error_y) {\n            var dc = Color.defaults,\n                yeColor = trace.error_y.color ||\n                (Registry.traceIs(trace, 'bar') ? Color.defaultLine : dc[tracei % dc.length]);\n            trace.error_y.color = Color.addOpacity(\n                Color.rgb(yeColor),\n                Color.opacity(yeColor) * trace.error_y.opacity);\n            delete trace.error_y.opacity;\n        }\n\n        // convert bardir to orientation, and put the data into\n        // the axes it's eventually going to be used with\n        if('bardir' in trace) {\n            if(trace.bardir === 'h' && (Registry.traceIs(trace, 'bar') ||\n                     trace.type.substr(0, 9) === 'histogram')) {\n                trace.orientation = 'h';\n                exports.swapXYData(trace);\n            }\n            delete trace.bardir;\n        }\n\n        // now we have only one 1D histogram type, and whether\n        // it uses x or y data depends on trace.orientation\n        if(trace.type === 'histogramy') exports.swapXYData(trace);\n        if(trace.type === 'histogramx' || trace.type === 'histogramy') {\n            trace.type = 'histogram';\n        }\n\n        // scl->scale, reversescl->reversescale\n        if('scl' in trace) {\n            trace.colorscale = trace.scl;\n            delete trace.scl;\n        }\n        if('reversescl' in trace) {\n            trace.reversescale = trace.reversescl;\n            delete trace.reversescl;\n        }\n\n        // axis ids x1 -> x, y1-> y\n        if(trace.xaxis) trace.xaxis = Axes.cleanId(trace.xaxis, 'x');\n        if(trace.yaxis) trace.yaxis = Axes.cleanId(trace.yaxis, 'y');\n\n        // scene ids scene1 -> scene\n        if(Registry.traceIs(trace, 'gl3d') && trace.scene) {\n            trace.scene = Plots.subplotsRegistry.gl3d.cleanId(trace.scene);\n        }\n\n        if(!Registry.traceIs(trace, 'pie') && !Registry.traceIs(trace, 'bar')) {\n            if(Array.isArray(trace.textposition)) {\n                trace.textposition = trace.textposition.map(cleanTextPosition);\n            }\n            else if(trace.textposition) {\n                trace.textposition = cleanTextPosition(trace.textposition);\n            }\n        }\n\n        // fix typo in colorscale definition\n        if(Registry.traceIs(trace, '2dMap')) {\n            if(trace.colorscale === 'YIGnBu') trace.colorscale = 'YlGnBu';\n            if(trace.colorscale === 'YIOrRd') trace.colorscale = 'YlOrRd';\n        }\n        if(Registry.traceIs(trace, 'markerColorscale') && trace.marker) {\n            var cont = trace.marker;\n            if(cont.colorscale === 'YIGnBu') cont.colorscale = 'YlGnBu';\n            if(cont.colorscale === 'YIOrRd') cont.colorscale = 'YlOrRd';\n        }\n\n        // fix typo in surface 'highlight*' definitions\n        if(trace.type === 'surface' && Lib.isPlainObject(trace.contours)) {\n            var dims = ['x', 'y', 'z'];\n\n            for(i = 0; i < dims.length; i++) {\n                var opts = trace.contours[dims[i]];\n\n                if(!Lib.isPlainObject(opts)) continue;\n\n                if(opts.highlightColor) {\n                    opts.highlightcolor = opts.highlightColor;\n                    delete opts.highlightColor;\n                }\n\n                if(opts.highlightWidth) {\n                    opts.highlightwidth = opts.highlightWidth;\n                    delete opts.highlightWidth;\n                }\n            }\n        }\n\n        // transforms backward compatibility fixes\n        if(Array.isArray(trace.transforms)) {\n            var transforms = trace.transforms;\n\n            for(i = 0; i < transforms.length; i++) {\n                var transform = transforms[i];\n\n                if(!Lib.isPlainObject(transform)) continue;\n\n                if(transform.type === 'filter') {\n                    if(transform.filtersrc) {\n                        transform.target = transform.filtersrc;\n                        delete transform.filtersrc;\n                    }\n\n                    if(transform.calendar) {\n                        if(!transform.valuecalendar) {\n                            transform.valuecalendar = transform.calendar;\n                        }\n                        delete transform.calendar;\n                    }\n                }\n            }\n        }\n\n        // prune empty containers made before the new nestedProperty\n        if(emptyContainer(trace, 'line')) delete trace.line;\n        if('marker' in trace) {\n            if(emptyContainer(trace.marker, 'line')) delete trace.marker.line;\n            if(emptyContainer(trace, 'marker')) delete trace.marker;\n        }\n\n        // sanitize rgb(fractions) and rgba(fractions) that old tinycolor\n        // supported, but new tinycolor does not because they're not valid css\n        Color.clean(trace);\n    }\n};\n\n// textposition - support partial attributes (ie just 'top')\n// and incorrect use of middle / center etc.\nfunction cleanTextPosition(textposition) {\n    var posY = 'middle',\n        posX = 'center';\n    if(textposition.indexOf('top') !== -1) posY = 'top';\n    else if(textposition.indexOf('bottom') !== -1) posY = 'bottom';\n\n    if(textposition.indexOf('left') !== -1) posX = 'left';\n    else if(textposition.indexOf('right') !== -1) posX = 'right';\n\n    return posY + ' ' + posX;\n}\n\nfunction emptyContainer(outer, innerStr) {\n    return (innerStr in outer) &&\n        (typeof outer[innerStr] === 'object') &&\n        (Object.keys(outer[innerStr]).length === 0);\n}\n\n\n// swap all the data and data attributes associated with x and y\nexports.swapXYData = function(trace) {\n    var i;\n    Lib.swapAttrs(trace, ['?', '?0', 'd?', '?bins', 'nbins?', 'autobin?', '?src', 'error_?']);\n    if(Array.isArray(trace.z) && Array.isArray(trace.z[0])) {\n        if(trace.transpose) delete trace.transpose;\n        else trace.transpose = true;\n    }\n    if(trace.error_x && trace.error_y) {\n        var errorY = trace.error_y,\n            copyYstyle = ('copy_ystyle' in errorY) ? errorY.copy_ystyle :\n                !(errorY.color || errorY.thickness || errorY.width);\n        Lib.swapAttrs(trace, ['error_?.copy_ystyle']);\n        if(copyYstyle) {\n            Lib.swapAttrs(trace, ['error_?.color', 'error_?.thickness', 'error_?.width']);\n        }\n    }\n    if(trace.hoverinfo) {\n        var hoverInfoParts = trace.hoverinfo.split('+');\n        for(i = 0; i < hoverInfoParts.length; i++) {\n            if(hoverInfoParts[i] === 'x') hoverInfoParts[i] = 'y';\n            else if(hoverInfoParts[i] === 'y') hoverInfoParts[i] = 'x';\n        }\n        trace.hoverinfo = hoverInfoParts.join('+');\n    }\n};\n\n// coerce traceIndices input to array of trace indices\nexports.coerceTraceIndices = function(gd, traceIndices) {\n    if(isNumeric(traceIndices)) {\n        return [traceIndices];\n    }\n    else if(!Array.isArray(traceIndices) || !traceIndices.length) {\n        return gd.data.map(function(_, i) { return i; });\n    }\n\n    return traceIndices;\n};\n\n/**\n * Manages logic around array container item creation / deletion / update\n * that nested property alone can't handle.\n *\n * @param {Object} np\n *  nested property of update attribute string about trace or layout object\n * @param {*} newVal\n *  update value passed to restyle / relayout / update\n * @param {Object} undoit\n *  undo hash (N.B. undoit may be mutated here).\n *\n */\nexports.manageArrayContainers = function(np, newVal, undoit) {\n    var obj = np.obj,\n        parts = np.parts,\n        pLength = parts.length,\n        pLast = parts[pLength - 1];\n\n    var pLastIsNumber = isNumeric(pLast);\n\n    // delete item\n    if(pLastIsNumber && newVal === null) {\n\n        // Clear item in array container when new value is null\n        var contPath = parts.slice(0, pLength - 1).join('.'),\n            cont = Lib.nestedProperty(obj, contPath).get();\n        cont.splice(pLast, 1);\n\n        // Note that nested property clears null / undefined at end of\n        // array container, but not within them.\n    }\n    // create item\n    else if(pLastIsNumber && np.get() === undefined) {\n\n        // When adding a new item, make sure undo command will remove it\n        if(np.get() === undefined) undoit[np.astr] = null;\n\n        np.set(newVal);\n    }\n    // update item\n    else {\n\n        // If the last part of attribute string isn't a number,\n        // np.set is all we need.\n        np.set(newVal);\n    }\n};\n\n/*\n * Match the part to strip off to turn an attribute into its parent\n * really it should be either '.some_characters' or '[number]'\n * but we're a little more permissive here and match either\n * '.not_brackets_or_dot' or '[not_brackets_or_dot]'\n */\nvar ATTR_TAIL_RE = /(\\.[^\\[\\]\\.]+|\\[[^\\[\\]\\.]+\\])$/;\n\nfunction getParent(attr) {\n    var tail = attr.search(ATTR_TAIL_RE);\n    if(tail > 0) return attr.substr(0, tail);\n}\n\n/*\n * hasParent: does an attribute object contain a parent of the given attribute?\n * for example, given 'images[2].x' do we also have 'images' or 'images[2]'?\n *\n * @param {Object} aobj\n *  update object, whose keys are attribute strings and values are their new settings\n * @param {string} attr\n *  the attribute string to test against\n * @returns {Boolean}\n *  is a parent of attr present in aobj?\n */\nexports.hasParent = function(aobj, attr) {\n    var attrParent = getParent(attr);\n    while(attrParent) {\n        if(attrParent in aobj) return true;\n        attrParent = getParent(attrParent);\n    }\n    return false;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plot_api/subroutines.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\nvar Plotly = require('../plotly');\nvar Registry = require('../registry');\nvar Plots = require('../plots/plots');\nvar Lib = require('../lib');\n\nvar Color = require('../components/color');\nvar Drawing = require('../components/drawing');\nvar Titles = require('../components/titles');\nvar ModeBar = require('../components/modebar');\n\n\nexports.layoutStyles = function(gd) {\n    return Lib.syncOrAsync([Plots.doAutoMargin, exports.lsInner], gd);\n};\n\nfunction overlappingDomain(xDomain, yDomain, domains) {\n    for(var i = 0; i < domains.length; i++) {\n        var existingX = domains[i][0],\n            existingY = domains[i][1];\n\n        if(existingX[0] >= xDomain[1] || existingX[1] <= xDomain[0]) {\n            continue;\n        }\n        if(existingY[0] < yDomain[1] && existingY[1] > yDomain[0]) {\n            return true;\n        }\n    }\n    return false;\n}\n\nexports.lsInner = function(gd) {\n    var fullLayout = gd._fullLayout,\n        gs = fullLayout._size,\n        axList = Plotly.Axes.list(gd),\n        i;\n\n    // clear axis line positions, to be set in the subplot loop below\n    for(i = 0; i < axList.length; i++) axList[i]._linepositions = {};\n\n    fullLayout._paperdiv\n        .style({\n            width: fullLayout.width + 'px',\n            height: fullLayout.height + 'px'\n        })\n        .selectAll('.main-svg')\n            .call(Drawing.setSize, fullLayout.width, fullLayout.height);\n\n    gd._context.setBackground(gd, fullLayout.paper_bgcolor);\n\n    var subplotSelection = fullLayout._paper.selectAll('g.subplot');\n\n    // figure out which backgrounds we need to draw, and in which layers\n    // to put them\n    var lowerBackgroundIDs = [];\n    var lowerDomains = [];\n    subplotSelection.each(function(subplot) {\n        var plotinfo = fullLayout._plots[subplot];\n\n        if(plotinfo.mainplot) {\n            // mainplot is a reference to the main plot this one is overlaid on\n            // so if it exists, this is an overlaid plot and we don't need to\n            // give it its own background\n            if(plotinfo.bg) {\n                plotinfo.bg.remove();\n            }\n            plotinfo.bg = undefined;\n            return;\n        }\n\n        var xa = Plotly.Axes.getFromId(gd, subplot, 'x'),\n            ya = Plotly.Axes.getFromId(gd, subplot, 'y'),\n            xDomain = xa.domain,\n            yDomain = ya.domain,\n            plotgroupBgData = [];\n\n        if(overlappingDomain(xDomain, yDomain, lowerDomains)) {\n            plotgroupBgData = [0];\n        }\n        else {\n            lowerBackgroundIDs.push(subplot);\n            lowerDomains.push([xDomain, yDomain]);\n        }\n\n        // create the plot group backgrounds now, since\n        // they're all independent selections\n        var plotgroupBg = plotinfo.plotgroup.selectAll('.bg')\n            .data(plotgroupBgData);\n\n        plotgroupBg.enter().append('rect')\n            .classed('bg', true);\n\n        plotgroupBg.exit().remove();\n\n        plotgroupBg.each(function() {\n            plotinfo.bg = plotgroupBg;\n            var pgNode = plotinfo.plotgroup.node();\n            pgNode.insertBefore(this, pgNode.childNodes[0]);\n        });\n    });\n\n    // now create all the lower-layer backgrounds at once now that\n    // we have the list of subplots that need them\n    var lowerBackgrounds = fullLayout._bgLayer.selectAll('.bg')\n        .data(lowerBackgroundIDs);\n\n    lowerBackgrounds.enter().append('rect')\n        .classed('bg', true);\n\n    lowerBackgrounds.exit().remove();\n\n    lowerBackgrounds.each(function(subplot) {\n        fullLayout._plots[subplot].bg = d3.select(this);\n    });\n\n    var freefinished = [];\n    subplotSelection.each(function(subplot) {\n        var plotinfo = fullLayout._plots[subplot],\n            xa = Plotly.Axes.getFromId(gd, subplot, 'x'),\n            ya = Plotly.Axes.getFromId(gd, subplot, 'y');\n\n        // reset scale in case the margins have changed\n        xa.setScale();\n        ya.setScale();\n\n        if(plotinfo.bg) {\n            plotinfo.bg\n                .call(Drawing.setRect,\n                    xa._offset - gs.p, ya._offset - gs.p,\n                    xa._length + 2 * gs.p, ya._length + 2 * gs.p)\n                .call(Color.fill, fullLayout.plot_bgcolor)\n                .style('stroke-width', 0);\n        }\n\n        // Clip so that data only shows up on the plot area.\n        plotinfo.clipId = 'clip' + fullLayout._uid + subplot + 'plot';\n\n        var plotClip = fullLayout._defs.selectAll('g.clips')\n            .selectAll('#' + plotinfo.clipId)\n            .data([0]);\n\n        plotClip.enter().append('clipPath')\n            .attr({\n                'class': 'plotclip',\n                'id': plotinfo.clipId\n            })\n            .append('rect');\n\n        plotClip.selectAll('rect')\n            .attr({\n                'width': xa._length,\n                'height': ya._length\n            });\n\n\n        plotinfo.plot.call(Drawing.setTranslate, xa._offset, ya._offset);\n        plotinfo.plot.call(Drawing.setClipUrl, plotinfo.clipId);\n\n        var xlw = Drawing.crispRound(gd, xa.linewidth, 1),\n            ylw = Drawing.crispRound(gd, ya.linewidth, 1),\n            xp = gs.p + ylw,\n            xpathPrefix = 'M' + (-xp) + ',',\n            xpathSuffix = 'h' + (xa._length + 2 * xp),\n            showfreex = xa.anchor === 'free' &&\n                freefinished.indexOf(xa._id) === -1,\n            freeposx = gs.h * (1 - (xa.position||0)) + ((xlw / 2) % 1),\n            showbottom =\n                (xa.anchor === ya._id && (xa.mirror || xa.side !== 'top')) ||\n                xa.mirror === 'all' || xa.mirror === 'allticks' ||\n                (xa.mirrors && xa.mirrors[ya._id + 'bottom']),\n            bottompos = ya._length + gs.p + xlw / 2,\n            showtop =\n                (xa.anchor === ya._id && (xa.mirror || xa.side === 'top')) ||\n                xa.mirror === 'all' || xa.mirror === 'allticks' ||\n                (xa.mirrors && xa.mirrors[ya._id + 'top']),\n            toppos = -gs.p - xlw / 2,\n\n            // shorten y axis lines so they don't overlap x axis lines\n            yp = gs.p,\n            // except where there's no x line\n            // TODO: this gets more complicated with multiple x and y axes\n            ypbottom = showbottom ? 0 : xlw,\n            yptop = showtop ? 0 : xlw,\n            ypathSuffix = ',' + (-yp - yptop) +\n                'v' + (ya._length + 2 * yp + yptop + ypbottom),\n            showfreey = ya.anchor === 'free' &&\n                freefinished.indexOf(ya._id) === -1,\n            freeposy = gs.w * (ya.position||0) + ((ylw / 2) % 1),\n            showleft =\n                (ya.anchor === xa._id && (ya.mirror || ya.side !== 'right')) ||\n                ya.mirror === 'all' || ya.mirror === 'allticks' ||\n                (ya.mirrors && ya.mirrors[xa._id + 'left']),\n            leftpos = -gs.p - ylw / 2,\n            showright =\n                (ya.anchor === xa._id && (ya.mirror || ya.side === 'right')) ||\n                ya.mirror === 'all' || ya.mirror === 'allticks' ||\n                (ya.mirrors && ya.mirrors[xa._id + 'right']),\n            rightpos = xa._length + gs.p + ylw / 2;\n\n        // save axis line positions for ticks, draggers, etc to reference\n        // each subplot gets an entry:\n        //    [left or bottom, right or top, free, main]\n        // main is the position at which to draw labels and draggers, if any\n        xa._linepositions[subplot] = [\n            showbottom ? bottompos : undefined,\n            showtop ? toppos : undefined,\n            showfreex ? freeposx : undefined\n        ];\n        if(xa.anchor === ya._id) {\n            xa._linepositions[subplot][3] = xa.side === 'top' ?\n                toppos : bottompos;\n        }\n        else if(showfreex) {\n            xa._linepositions[subplot][3] = freeposx;\n        }\n\n        ya._linepositions[subplot] = [\n            showleft ? leftpos : undefined,\n            showright ? rightpos : undefined,\n            showfreey ? freeposy : undefined\n        ];\n        if(ya.anchor === xa._id) {\n            ya._linepositions[subplot][3] = ya.side === 'right' ?\n                rightpos : leftpos;\n        }\n        else if(showfreey) {\n            ya._linepositions[subplot][3] = freeposy;\n        }\n\n        // translate all the extra stuff to have the\n        // same origin as the plot area or axes\n        var origin = 'translate(' + xa._offset + ',' + ya._offset + ')',\n            originx = origin,\n            originy = origin;\n        if(showfreex) {\n            originx = 'translate(' + xa._offset + ',' + gs.t + ')';\n            toppos += ya._offset - gs.t;\n            bottompos += ya._offset - gs.t;\n        }\n        if(showfreey) {\n            originy = 'translate(' + gs.l + ',' + ya._offset + ')';\n            leftpos += xa._offset - gs.l;\n            rightpos += xa._offset - gs.l;\n        }\n\n        plotinfo.xlines\n            .attr('transform', originx)\n            .attr('d', (\n                (showbottom ? (xpathPrefix + bottompos + xpathSuffix) : '') +\n                (showtop ? (xpathPrefix + toppos + xpathSuffix) : '') +\n                (showfreex ? (xpathPrefix + freeposx + xpathSuffix) : '')) ||\n                // so it doesn't barf with no lines shown\n                'M0,0')\n            .style('stroke-width', xlw + 'px')\n            .call(Color.stroke, xa.showline ?\n                xa.linecolor : 'rgba(0,0,0,0)');\n        plotinfo.ylines\n            .attr('transform', originy)\n            .attr('d', (\n                (showleft ? ('M' + leftpos + ypathSuffix) : '') +\n                (showright ? ('M' + rightpos + ypathSuffix) : '') +\n                (showfreey ? ('M' + freeposy + ypathSuffix) : '')) ||\n                'M0,0')\n            .attr('stroke-width', ylw + 'px')\n            .call(Color.stroke, ya.showline ?\n                ya.linecolor : 'rgba(0,0,0,0)');\n\n        plotinfo.xaxislayer.attr('transform', originx);\n        plotinfo.yaxislayer.attr('transform', originy);\n        plotinfo.gridlayer.attr('transform', origin);\n        plotinfo.zerolinelayer.attr('transform', origin);\n        plotinfo.draglayer.attr('transform', origin);\n\n        // mark free axes as displayed, so we don't draw them again\n        if(showfreex) { freefinished.push(xa._id); }\n        if(showfreey) { freefinished.push(ya._id); }\n    });\n\n    Plotly.Axes.makeClipPaths(gd);\n    exports.drawMainTitle(gd);\n    ModeBar.manage(gd);\n\n    return gd._promises.length && Promise.all(gd._promises);\n};\n\nexports.drawMainTitle = function(gd) {\n    var fullLayout = gd._fullLayout;\n\n    Titles.draw(gd, 'gtitle', {\n        propContainer: fullLayout,\n        propName: 'title',\n        dfltName: 'Plot',\n        attributes: {\n            x: fullLayout.width / 2,\n            y: fullLayout._size.t / 2,\n            'text-anchor': 'middle'\n        }\n    });\n};\n\n// First, see if we need to do arraysToCalcdata\n// call it regardless of what change we made, in case\n// supplyDefaults brought in an array that was already\n// in gd.data but not in gd._fullData previously\nexports.doTraceStyle = function(gd) {\n    for(var i = 0; i < gd.calcdata.length; i++) {\n        var cdi = gd.calcdata[i],\n            _module = ((cdi[0] || {}).trace || {})._module || {},\n            arraysToCalcdata = _module.arraysToCalcdata;\n\n        if(arraysToCalcdata) arraysToCalcdata(cdi, cdi[0].trace);\n    }\n\n    Plots.style(gd);\n    Registry.getComponentMethod('legend', 'draw')(gd);\n\n    return Plots.previousPromises(gd);\n};\n\nexports.doColorBars = function(gd) {\n    for(var i = 0; i < gd.calcdata.length; i++) {\n        var cdi0 = gd.calcdata[i][0];\n\n        if((cdi0.t || {}).cb) {\n            var trace = cdi0.trace,\n                cb = cdi0.t.cb;\n\n            if(Registry.traceIs(trace, 'contour')) {\n                cb.line({\n                    width: trace.contours.showlines !== false ?\n                        trace.line.width : 0,\n                    dash: trace.line.dash,\n                    color: trace.contours.coloring === 'line' ?\n                        cb._opts.line.color : trace.line.color\n                });\n            }\n            if(Registry.traceIs(trace, 'markerColorscale')) {\n                cb.options(trace.marker.colorbar)();\n            }\n            else cb.options(trace.colorbar)();\n        }\n    }\n\n    return Plots.previousPromises(gd);\n};\n\n// force plot() to redo the layout and replot with the modified layout\nexports.layoutReplot = function(gd) {\n    var layout = gd.layout;\n    gd.layout = undefined;\n    return Plotly.plot(gd, '', layout);\n};\n\nexports.doLegend = function(gd) {\n    Registry.getComponentMethod('legend', 'draw')(gd);\n    return Plots.previousPromises(gd);\n};\n\nexports.doTicksRelayout = function(gd) {\n    Plotly.Axes.doTicks(gd, 'redraw');\n    exports.drawMainTitle(gd);\n    return Plots.previousPromises(gd);\n};\n\nexports.doModeBar = function(gd) {\n    var fullLayout = gd._fullLayout;\n    var subplotIds, i;\n\n    ModeBar.manage(gd);\n    Plotly.Fx.init(gd);\n\n    subplotIds = Plots.getSubplotIds(fullLayout, 'gl3d');\n    for(i = 0; i < subplotIds.length; i++) {\n        var scene = fullLayout[subplotIds[i]]._scene;\n        scene.updateFx(fullLayout.dragmode, fullLayout.hovermode);\n    }\n\n    // no need to do this for gl2d subplots,\n    // Plots.linkSubplots takes care of it all.\n\n    return Plots.previousPromises(gd);\n};\n\nexports.doCamera = function(gd) {\n    var fullLayout = gd._fullLayout,\n        sceneIds = Plots.getSubplotIds(fullLayout, 'gl3d');\n\n    for(var i = 0; i < sceneIds.length; i++) {\n        var sceneLayout = fullLayout[sceneIds[i]],\n            scene = sceneLayout._scene;\n\n        scene.setCamera(sceneLayout.camera);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/cartesian/constraints.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar id2name = require('./axis_ids').id2name;\nvar scaleZoom = require('./scale_zoom');\n\nvar ALMOST_EQUAL = require('../../constants/numerical').ALMOST_EQUAL;\n\n\nmodule.exports = function enforceAxisConstraints(gd) {\n    var fullLayout = gd._fullLayout;\n    var constraintGroups = fullLayout._axisConstraintGroups;\n\n    var i, j, axisID, ax, normScale;\n\n    for(i = 0; i < constraintGroups.length; i++) {\n        var group = constraintGroups[i];\n        var axisIDs = Object.keys(group);\n\n        var minScale = Infinity;\n        var maxScale = 0;\n        // mostly matchScale will be the same as minScale\n        // ie we expand axis ranges to encompass *everything*\n        // that's currently in any of their ranges, but during\n        // autorange of a subset of axes we will ignore other\n        // axes for this purpose.\n        var matchScale = Infinity;\n        var normScales = {};\n        var axes = {};\n\n        // find the (normalized) scale of each axis in the group\n        for(j = 0; j < axisIDs.length; j++) {\n            axisID = axisIDs[j];\n            axes[axisID] = ax = fullLayout[id2name(axisID)];\n\n            // set axis scale here so we can use _m rather than\n            // having to calculate it from length and range\n            ax.setScale();\n\n            // abs: inverted scales still satisfy the constraint\n            normScales[axisID] = normScale = Math.abs(ax._m) / group[axisID];\n            minScale = Math.min(minScale, normScale);\n            if(ax._constraintShrinkable) {\n                // this has served its purpose, so remove it\n                delete ax._constraintShrinkable;\n            }\n            else {\n                matchScale = Math.min(matchScale, normScale);\n            }\n            maxScale = Math.max(maxScale, normScale);\n        }\n\n        // Do we have a constraint mismatch? Give a small buffer for rounding errors\n        if(minScale > ALMOST_EQUAL * maxScale) continue;\n\n        // now increase any ranges we need to until all normalized scales are equal\n        for(j = 0; j < axisIDs.length; j++) {\n            axisID = axisIDs[j];\n            normScale = normScales[axisID];\n\n            if(normScale !== matchScale) {\n                scaleZoom(axes[axisID], normScale / matchScale);\n            }\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/build/plotcss.js":"'use strict';\n\nvar Lib = require('../src/lib');\nvar rules = {\n    \"X,X div\": \"font-family:'Open Sans', verdana, arial, sans-serif;margin:0;padding:0;\",\n    \"X input,X button\": \"font-family:'Open Sans', verdana, arial, sans-serif;\",\n    \"X input:focus,X button:focus\": \"outline:none;\",\n    \"X a\": \"text-decoration:none;\",\n    \"X a:hover\": \"text-decoration:none;\",\n    \"X .crisp\": \"shape-rendering:crispEdges;\",\n    \"X .user-select-none\": \"-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-o-user-select:none;user-select:none;\",\n    \"X svg\": \"overflow:hidden;\",\n    \"X svg a\": \"fill:#447adb;\",\n    \"X svg a:hover\": \"fill:#3c6dc5;\",\n    \"X .main-svg\": \"position:absolute;top:0;left:0;pointer-events:none;\",\n    \"X .main-svg .draglayer\": \"pointer-events:all;\",\n    \"X .cursor-default\": \"cursor:default;\",\n    \"X .cursor-pointer\": \"cursor:pointer;\",\n    \"X .cursor-crosshair\": \"cursor:crosshair;\",\n    \"X .cursor-move\": \"cursor:move;\",\n    \"X .cursor-col-resize\": \"cursor:col-resize;\",\n    \"X .cursor-row-resize\": \"cursor:row-resize;\",\n    \"X .cursor-ns-resize\": \"cursor:ns-resize;\",\n    \"X .cursor-ew-resize\": \"cursor:ew-resize;\",\n    \"X .cursor-sw-resize\": \"cursor:sw-resize;\",\n    \"X .cursor-s-resize\": \"cursor:s-resize;\",\n    \"X .cursor-se-resize\": \"cursor:se-resize;\",\n    \"X .cursor-w-resize\": \"cursor:w-resize;\",\n    \"X .cursor-e-resize\": \"cursor:e-resize;\",\n    \"X .cursor-nw-resize\": \"cursor:nw-resize;\",\n    \"X .cursor-n-resize\": \"cursor:n-resize;\",\n    \"X .cursor-ne-resize\": \"cursor:ne-resize;\",\n    \"X .modebar\": \"position:absolute;top:2px;right:2px;z-index:1001;background:rgba(255,255,255,0.7);\",\n    \"X .modebar--hover\": \"opacity:0;-webkit-transition:opacity 0.3s ease 0s;-moz-transition:opacity 0.3s ease 0s;-ms-transition:opacity 0.3s ease 0s;-o-transition:opacity 0.3s ease 0s;transition:opacity 0.3s ease 0s;\",\n    \"X:hover .modebar--hover\": \"opacity:1;\",\n    \"X .modebar-group\": \"float:left;display:inline-block;box-sizing:border-box;margin-left:8px;position:relative;vertical-align:middle;white-space:nowrap;\",\n    \"X .modebar-group:first-child\": \"margin-left:0px;\",\n    \"X .modebar-btn\": \"position:relative;font-size:16px;padding:3px 4px;cursor:pointer;line-height:normal;box-sizing:border-box;\",\n    \"X .modebar-btn svg\": \"position:relative;top:2px;\",\n    \"X .modebar-btn path\": \"fill:rgba(0,31,95,0.3);\",\n    \"X .modebar-btn.active path,X .modebar-btn:hover path\": \"fill:rgba(0,22,72,0.5);\",\n    \"X .modebar-btn.modebar-btn--logo\": \"padding:3px 1px;\",\n    \"X .modebar-btn.modebar-btn--logo path\": \"fill:#447adb !important;\",\n    \"X [data-title]:before,X [data-title]:after\": \"position:absolute;-webkit-transform:translate3d(0, 0, 0);-moz-transform:translate3d(0, 0, 0);-ms-transform:translate3d(0, 0, 0);-o-transform:translate3d(0, 0, 0);transform:translate3d(0, 0, 0);display:none;opacity:0;z-index:1001;pointer-events:none;top:110%;right:50%;\",\n    \"X [data-title]:hover:before,X [data-title]:hover:after\": \"display:block;opacity:1;\",\n    \"X [data-title]:before\": \"content:'';position:absolute;background:transparent;border:6px solid transparent;z-index:1002;margin-top:-12px;border-bottom-color:#69738a;margin-right:-6px;\",\n    \"X [data-title]:after\": \"content:attr(data-title);background:#69738a;color:white;padding:8px 10px;font-size:12px;line-height:12px;white-space:nowrap;margin-right:-18px;border-radius:2px;\",\n    \"X .select-outline\": \"fill:none;stroke-width:1;shape-rendering:crispEdges;\",\n    \"X .select-outline-1\": \"stroke:white;\",\n    \"X .select-outline-2\": \"stroke:black;stroke-dasharray:2px 2px;\",\n    Y: \"font-family:'Open Sans';position:fixed;top:50px;right:20px;z-index:10000;font-size:10pt;max-width:180px;\",\n    \"Y p\": \"margin:0;\",\n    \"Y .notifier-note\": \"min-width:180px;max-width:250px;border:1px solid #fff;z-index:3000;margin:0;background-color:#8c97af;background-color:rgba(140,151,175,0.9);color:#fff;padding:10px;\",\n    \"Y .notifier-close\": \"color:#fff;opacity:0.8;float:right;padding:0 5px;background:none;border:none;font-size:20px;font-weight:bold;line-height:20px;\",\n    \"Y .notifier-close:hover\": \"color:#444;text-decoration:none;cursor:pointer;\"\n};\n\nfor(var selector in rules) {\n    var fullSelector = selector.replace(/^,/,' ,')\n        .replace(/X/g, '.js-plotly-plot .plotly')\n        .replace(/Y/g, '.plotly-notifier');\n    Lib.addStyleRule(fullSelector, rules[selector]);\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/lib/bar.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = require('../src/traces/bar');\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/bar/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Bar = {};\n\nBar.attributes = require('./attributes');\nBar.layoutAttributes = require('./layout_attributes');\nBar.supplyDefaults = require('./defaults');\nBar.supplyLayoutDefaults = require('./layout_defaults');\nBar.calc = require('./calc');\nBar.setPositions = require('./set_positions');\nBar.colorbar = require('../scatter/colorbar');\nBar.arraysToCalcdata = require('./arrays_to_calcdata');\nBar.plot = require('./plot');\nBar.style = require('./style');\nBar.hoverPoints = require('./hover');\n\nBar.moduleType = 'trace';\nBar.name = 'bar';\nBar.basePlotModule = require('../../plots/cartesian');\nBar.categories = ['cartesian', 'bar', 'oriented', 'markerColorscale', 'errorBarsOK', 'showLegend'];\nBar.meta = {\n    description: [\n        'The data visualized by the span of the bars is set in `y`',\n        'if `orientation` is set th *v* (the default)',\n        'and the labels are set in `x`.',\n        'By setting `orientation` to *h*, the roles are interchanged.'\n    ].join(' ')\n};\n\nmodule.exports = Bar;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/bar/attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar scatterAttrs = require('../scatter/attributes');\nvar colorAttributes = require('../../components/colorscale/color_attributes');\nvar errorBarAttrs = require('../../components/errorbars/attributes');\nvar colorbarAttrs = require('../../components/colorbar/attributes');\nvar fontAttrs = require('../../plots/font_attributes');\n\nvar extendFlat = require('../../lib/extend').extendFlat;\nvar extendDeep = require('../../lib/extend').extendDeep;\n\nvar textFontAttrs = extendDeep({}, fontAttrs);\ntextFontAttrs.family.arrayOk = true;\ntextFontAttrs.size.arrayOk = true;\ntextFontAttrs.color.arrayOk = true;\n\nvar scatterMarkerAttrs = scatterAttrs.marker;\nvar scatterMarkerLineAttrs = scatterMarkerAttrs.line;\n\nvar markerLineWidth = extendFlat({},\n    scatterMarkerLineAttrs.width, { dflt: 0 });\n\nvar markerLine = extendFlat({}, {\n    width: markerLineWidth\n}, colorAttributes('marker.line'));\n\nvar marker = extendFlat({}, {\n    line: markerLine\n}, colorAttributes('marker'), {\n    showscale: scatterMarkerAttrs.showscale,\n    colorbar: colorbarAttrs\n});\n\n\nmodule.exports = {\n    x: scatterAttrs.x,\n    x0: scatterAttrs.x0,\n    dx: scatterAttrs.dx,\n    y: scatterAttrs.y,\n    y0: scatterAttrs.y0,\n    dy: scatterAttrs.dy,\n\n    text: scatterAttrs.text,\n    hovertext: scatterAttrs.hovertext,\n\n    textposition: {\n        valType: 'enumerated',\n        role: 'info',\n        values: ['inside', 'outside', 'auto', 'none'],\n        dflt: 'none',\n        arrayOk: true,\n        description: [\n            'Specifies the location of the `text`.',\n            '*inside* positions `text` inside, next to the bar end',\n            '(rotated and scaled if needed).',\n            '*outside* positions `text` outside, next to the bar end',\n            '(scaled if needed).',\n            '*auto* positions `text` inside or outside',\n            'so that `text` size is maximized.'\n        ].join(' ')\n    },\n\n    textfont: extendFlat({}, textFontAttrs, {\n        description: 'Sets the font used for `text`.'\n    }),\n\n    insidetextfont: extendFlat({}, textFontAttrs, {\n        description: 'Sets the font used for `text` lying inside the bar.'\n    }),\n\n    outsidetextfont: extendFlat({}, textFontAttrs, {\n        description: 'Sets the font used for `text` lying outside the bar.'\n    }),\n\n    orientation: {\n        valType: 'enumerated',\n        role: 'info',\n        values: ['v', 'h'],\n        description: [\n            'Sets the orientation of the bars.',\n            'With *v* (*h*), the value of the each bar spans',\n            'along the vertical (horizontal).'\n        ].join(' ')\n    },\n\n    base: {\n        valType: 'any',\n        dflt: null,\n        arrayOk: true,\n        role: 'info',\n        description: [\n            'Sets where the bar base is drawn (in position axis units).',\n            'In *stack* or *relative* barmode,',\n            'traces that set *base* will be excluded',\n            'and drawn in *overlay* mode instead.'\n        ].join(' ')\n    },\n\n    offset: {\n        valType: 'number',\n        dflt: null,\n        arrayOk: true,\n        role: 'info',\n        description: [\n            'Shifts the position where the bar is drawn',\n            '(in position axis units).',\n            'In *group* barmode,',\n            'traces that set *offset* will be excluded',\n            'and drawn in *overlay* mode instead.'\n        ].join(' ')\n    },\n\n    width: {\n        valType: 'number',\n        dflt: null,\n        min: 0,\n        arrayOk: true,\n        role: 'info',\n        description: [\n            'Sets the bar width (in position axis units).'\n        ].join(' ')\n    },\n\n    marker: marker,\n\n    r: scatterAttrs.r,\n    t: scatterAttrs.t,\n\n    error_y: errorBarAttrs,\n    error_x: errorBarAttrs,\n\n    _deprecated: {\n        bardir: {\n            valType: 'enumerated',\n            role: 'info',\n            values: ['v', 'h'],\n            description: 'Renamed to `orientation`.'\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/scatter/attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar colorAttributes = require('../../components/colorscale/color_attributes');\nvar errorBarAttrs = require('../../components/errorbars/attributes');\nvar colorbarAttrs = require('../../components/colorbar/attributes');\nvar dash = require('../../components/drawing/attributes').dash;\n\nvar Drawing = require('../../components/drawing');\nvar constants = require('./constants');\nvar extendFlat = require('../../lib/extend').extendFlat;\n\nmodule.exports = {\n    x: {\n        valType: 'data_array',\n        description: 'Sets the x coordinates.'\n    },\n    x0: {\n        valType: 'any',\n        dflt: 0,\n        role: 'info',\n        description: [\n            'Alternate to `x`.',\n            'Builds a linear space of x coordinates.',\n            'Use with `dx`',\n            'where `x0` is the starting coordinate and `dx` the step.'\n        ].join(' ')\n    },\n    dx: {\n        valType: 'number',\n        dflt: 1,\n        role: 'info',\n        description: [\n            'Sets the x coordinate step.',\n            'See `x0` for more info.'\n        ].join(' ')\n    },\n    y: {\n        valType: 'data_array',\n        description: 'Sets the y coordinates.'\n    },\n    y0: {\n        valType: 'any',\n        dflt: 0,\n        role: 'info',\n        description: [\n            'Alternate to `y`.',\n            'Builds a linear space of y coordinates.',\n            'Use with `dy`',\n            'where `y0` is the starting coordinate and `dy` the step.'\n        ].join(' ')\n    },\n    customdata: {\n        valType: 'data_array',\n        description: 'Assigns extra data to each scatter point DOM element'\n    },\n    dy: {\n        valType: 'number',\n        dflt: 1,\n        role: 'info',\n        description: [\n            'Sets the y coordinate step.',\n            'See `y0` for more info.'\n        ].join(' ')\n    },\n    ids: {\n        valType: 'data_array',\n        description: 'A list of keys for object constancy of data points during animation'\n    },\n    text: {\n        valType: 'string',\n        role: 'info',\n        dflt: '',\n        arrayOk: true,\n        description: [\n            'Sets text elements associated with each (x,y) pair.',\n            'If a single string, the same string appears over',\n            'all the data points.',\n            'If an array of string, the items are mapped in order to the',\n            'this trace\\'s (x,y) coordinates.',\n            'If trace `hoverinfo` contains a *text* flag and *hovertext* is not set,',\n            'these elements will be seen in the hover labels.'\n        ].join(' ')\n    },\n    hovertext: {\n        valType: 'string',\n        role: 'info',\n        dflt: '',\n        arrayOk: true,\n        description: [\n            'Sets hover text elements associated with each (x,y) pair.',\n            'If a single string, the same string appears over',\n            'all the data points.',\n            'If an array of string, the items are mapped in order to the',\n            'this trace\\'s (x,y) coordinates.',\n            'To be seen, trace `hoverinfo` must contain a *text* flag.'\n        ].join(' ')\n    },\n    mode: {\n        valType: 'flaglist',\n        flags: ['lines', 'markers', 'text'],\n        extras: ['none'],\n        role: 'info',\n        description: [\n            'Determines the drawing mode for this scatter trace.',\n            'If the provided `mode` includes *text* then the `text` elements',\n            'appear at the coordinates. Otherwise, the `text` elements',\n            'appear on hover.',\n            'If there are less than ' + constants.PTS_LINESONLY + ' points,',\n            'then the default is *lines+markers*. Otherwise, *lines*.'\n        ].join(' ')\n    },\n    hoveron: {\n        valType: 'flaglist',\n        flags: ['points', 'fills'],\n        role: 'info',\n        description: [\n            'Do the hover effects highlight individual points (markers or',\n            'line points) or do they highlight filled regions?',\n            'If the fill is *toself* or *tonext* and there are no markers',\n            'or text, then the default is *fills*, otherwise it is *points*.'\n        ].join(' ')\n    },\n    line: {\n        color: {\n            valType: 'color',\n            role: 'style',\n            description: 'Sets the line color.'\n        },\n        width: {\n            valType: 'number',\n            min: 0,\n            dflt: 2,\n            role: 'style',\n            description: 'Sets the line width (in px).'\n        },\n        shape: {\n            valType: 'enumerated',\n            values: ['linear', 'spline', 'hv', 'vh', 'hvh', 'vhv'],\n            dflt: 'linear',\n            role: 'style',\n            description: [\n                'Determines the line shape.',\n                'With *spline* the lines are drawn using spline interpolation.',\n                'The other available values correspond to step-wise line shapes.'\n            ].join(' ')\n        },\n        smoothing: {\n            valType: 'number',\n            min: 0,\n            max: 1.3,\n            dflt: 1,\n            role: 'style',\n            description: [\n                'Has an effect only if `shape` is set to *spline*',\n                'Sets the amount of smoothing.',\n                '*0* corresponds to no smoothing (equivalent to a *linear* shape).'\n            ].join(' ')\n        },\n        dash: dash,\n        simplify: {\n            valType: 'boolean',\n            dflt: true,\n            role: 'info',\n            description: [\n                'Simplifies lines by removing nearly-collinear points. When transitioning',\n                'lines, it may be desirable to disable this so that the number of points',\n                'along the resulting SVG path is unaffected.'\n            ].join(' ')\n        }\n    },\n    connectgaps: {\n        valType: 'boolean',\n        dflt: false,\n        role: 'info',\n        description: [\n            'Determines whether or not gaps',\n            '(i.e. {nan} or missing values)',\n            'in the provided data arrays are connected.'\n        ].join(' ')\n    },\n    fill: {\n        valType: 'enumerated',\n        values: ['none', 'tozeroy', 'tozerox', 'tonexty', 'tonextx', 'toself', 'tonext'],\n        dflt: 'none',\n        role: 'style',\n        description: [\n            'Sets the area to fill with a solid color.',\n            'Use with `fillcolor` if not *none*.',\n            '*tozerox* and *tozeroy* fill to x=0 and y=0 respectively.',\n            '*tonextx* and *tonexty* fill between the endpoints of this',\n            'trace and the endpoints of the trace before it, connecting those',\n            'endpoints with straight lines (to make a stacked area graph);',\n            'if there is no trace before it, they behave like *tozerox* and',\n            '*tozeroy*.',\n            '*toself* connects the endpoints of the trace (or each segment',\n            'of the trace if it has gaps) into a closed shape.',\n            '*tonext* fills the space between two traces if one completely',\n            'encloses the other (eg consecutive contour lines), and behaves like',\n            '*toself* if there is no trace before it. *tonext* should not be',\n            'used if one trace does not enclose the other.'\n        ].join(' ')\n    },\n    fillcolor: {\n        valType: 'color',\n        role: 'style',\n        description: [\n            'Sets the fill color.',\n            'Defaults to a half-transparent variant of the line color,',\n            'marker color, or marker line color, whichever is available.'\n        ].join(' ')\n    },\n    marker: extendFlat({}, {\n        symbol: {\n            valType: 'enumerated',\n            values: Drawing.symbolList,\n            dflt: 'circle',\n            arrayOk: true,\n            role: 'style',\n            description: [\n                'Sets the marker symbol type.',\n                'Adding 100 is equivalent to appending *-open* to a symbol name.',\n                'Adding 200 is equivalent to appending *-dot* to a symbol name.',\n                'Adding 300 is equivalent to appending *-open-dot*',\n                'or *dot-open* to a symbol name.'\n            ].join(' ')\n        },\n        opacity: {\n            valType: 'number',\n            min: 0,\n            max: 1,\n            arrayOk: true,\n            role: 'style',\n            description: 'Sets the marker opacity.'\n        },\n        size: {\n            valType: 'number',\n            min: 0,\n            dflt: 6,\n            arrayOk: true,\n            role: 'style',\n            description: 'Sets the marker size (in px).'\n        },\n        maxdisplayed: {\n            valType: 'number',\n            min: 0,\n            dflt: 0,\n            role: 'style',\n            description: [\n                'Sets a maximum number of points to be drawn on the graph.',\n                '*0* corresponds to no limit.'\n            ].join(' ')\n        },\n        sizeref: {\n            valType: 'number',\n            dflt: 1,\n            role: 'style',\n            description: [\n                'Has an effect only if `marker.size` is set to a numerical array.',\n                'Sets the scale factor used to determine the rendered size of',\n                'marker points. Use with `sizemin` and `sizemode`.'\n            ].join(' ')\n        },\n        sizemin: {\n            valType: 'number',\n            min: 0,\n            dflt: 0,\n            role: 'style',\n            description: [\n                'Has an effect only if `marker.size` is set to a numerical array.',\n                'Sets the minimum size (in px) of the rendered marker points.'\n            ].join(' ')\n        },\n        sizemode: {\n            valType: 'enumerated',\n            values: ['diameter', 'area'],\n            dflt: 'diameter',\n            role: 'info',\n            description: [\n                'Has an effect only if `marker.size` is set to a numerical array.',\n                'Sets the rule for which the data in `size` is converted',\n                'to pixels.'\n            ].join(' ')\n        },\n\n        showscale: {\n            valType: 'boolean',\n            role: 'info',\n            dflt: false,\n            description: [\n                'Has an effect only if `marker.color` is set to a numerical array.',\n                'Determines whether or not a colorbar is displayed.'\n            ].join(' ')\n        },\n        colorbar: colorbarAttrs,\n\n        line: extendFlat({}, {\n            width: {\n                valType: 'number',\n                min: 0,\n                arrayOk: true,\n                role: 'style',\n                description: 'Sets the width (in px) of the lines bounding the marker points.'\n            }\n        },\n            colorAttributes('marker.line')\n        )\n    },\n        colorAttributes('marker')\n    ),\n    textposition: {\n        valType: 'enumerated',\n        values: [\n            'top left', 'top center', 'top right',\n            'middle left', 'middle center', 'middle right',\n            'bottom left', 'bottom center', 'bottom right'\n        ],\n        dflt: 'middle center',\n        arrayOk: true,\n        role: 'style',\n        description: [\n            'Sets the positions of the `text` elements',\n            'with respects to the (x,y) coordinates.'\n        ].join(' ')\n    },\n    textfont: {\n        family: {\n            valType: 'string',\n            role: 'style',\n            noBlank: true,\n            strict: true,\n            arrayOk: true\n        },\n        size: {\n            valType: 'number',\n            role: 'style',\n            min: 1,\n            arrayOk: true\n        },\n        color: {\n            valType: 'color',\n            role: 'style',\n            arrayOk: true\n        },\n        description: 'Sets the text font.'\n    },\n\n    r: {\n        valType: 'data_array',\n        description: [\n            'For polar chart only.',\n            'Sets the radial coordinates.'\n        ].join('')\n    },\n    t: {\n        valType: 'data_array',\n        description: [\n            'For polar chart only.',\n            'Sets the angular coordinates.'\n        ].join('')\n    },\n\n    error_y: errorBarAttrs,\n    error_x: errorBarAttrs\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/colorscale/color_attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar colorScaleAttributes = require('./attributes');\nvar extendDeep = require('../../lib/extend').extendDeep;\nvar palettes = require('./scales.js');\n\nmodule.exports = function makeColorScaleAttributes(context) {\n    return {\n        color: {\n            valType: 'color',\n            arrayOk: true,\n            role: 'style',\n            description: [\n                'Sets the ', context, ' color. It accepts either a specific color',\n                ' or an array of numbers that are mapped to the colorscale',\n                ' relative to the max and min values of the array or relative to',\n                ' `cmin` and `cmax` if set.'\n            ].join('')\n        },\n        colorscale: extendDeep({}, colorScaleAttributes.colorscale, {\n            description: [\n                'Sets the colorscale and only has an effect',\n                ' if `', context, '.color` is set to a numerical array.',\n                ' The colorscale must be an array containing',\n                ' arrays mapping a normalized value to an',\n                ' rgb, rgba, hex, hsl, hsv, or named color string.',\n                ' At minimum, a mapping for the lowest (0) and highest (1)',\n                ' values are required. For example,',\n                ' `[[0, \\'rgb(0,0,255)\\', [1, \\'rgb(255,0,0)\\']]`.',\n                ' To control the bounds of the colorscale in color space,',\n                ' use `', context, '.cmin` and `', context, '.cmax`.',\n                ' Alternatively, `colorscale` may be a palette name string',\n                ' of the following list: '\n            ].join('').concat(Object.keys(palettes).join(', '))\n        }),\n        cauto: extendDeep({}, colorScaleAttributes.zauto, {\n            description: [\n                'Has an effect only if `', context, '.color` is set to a numerical array',\n                ' and `cmin`, `cmax` are set by the user. In this case,',\n                ' it controls whether the range of colors in `colorscale` is mapped to',\n                ' the range of values in the `color` array (`cauto: true`), or the `cmin`/`cmax`',\n                ' values (`cauto: false`).',\n                ' Defaults to `false` when `cmin`, `cmax` are set by the user.'\n            ].join('')\n        }),\n        cmax: extendDeep({}, colorScaleAttributes.zmax, {\n            description: [\n                'Has an effect only if `', context, '.color` is set to a numerical array.',\n                ' Sets the upper bound of the color domain.',\n                ' Value should be associated to the `', context, '.color` array index,',\n                ' and if set, `', context, '.cmin` must be set as well.'\n            ].join('')\n        }),\n        cmin: extendDeep({}, colorScaleAttributes.zmin, {\n            description: [\n                'Has an effect only if `', context, '.color` is set to a numerical array.',\n                ' Sets the lower bound of the color domain.',\n                ' Value should be associated to the `', context, '.color` array index,',\n                ' and if set, `', context, '.cmax` must be set as well.'\n            ].join('')\n        }),\n        autocolorscale: extendDeep({}, colorScaleAttributes.autocolorscale, {\n            description: [\n                'Has an effect only if `', context, '.color` is set to a numerical array.',\n                ' Determines whether the colorscale is a default palette (`autocolorscale: true`)',\n                ' or the palette determined by `', context, '.colorscale`.',\n                ' In case `colorscale` is unspecified or `autocolorscale` is true, the default ',\n                ' palette will be chosen according to whether numbers in the `color` array are',\n                ' all positive, all negative or mixed.'\n            ].join('')\n        }),\n        reversescale: extendDeep({}, colorScaleAttributes.reversescale, {\n            description: [\n                'Has an effect only if `', context, '.color` is set to a numerical array.',\n                ' Reverses the color mapping if true (`cmin` will correspond to the last color',\n                ' in the array and `cmax` will correspond to the first color).'\n            ].join('')\n        })\n    };\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/scatter/constants.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nmodule.exports = {\n    PTS_LINESONLY: 20\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/lib/box.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = require('../src/traces/box');\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/box/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Box = {};\n\nBox.attributes = require('./attributes');\nBox.layoutAttributes = require('./layout_attributes');\nBox.supplyDefaults = require('./defaults');\nBox.supplyLayoutDefaults = require('./layout_defaults');\nBox.calc = require('./calc');\nBox.setPositions = require('./set_positions');\nBox.plot = require('./plot');\nBox.style = require('./style');\nBox.hoverPoints = require('./hover');\n\nBox.moduleType = 'trace';\nBox.name = 'box';\nBox.basePlotModule = require('../../plots/cartesian');\nBox.categories = ['cartesian', 'symbols', 'oriented', 'box', 'showLegend'];\nBox.meta = {\n    description: [\n        'In vertical (horizontal) box plots,',\n        'statistics are computed using `y` (`x`) values.',\n        'By supplying an `x` (`y`) array, one box per distinct x (y) value',\n        'is drawn',\n        'If no `x` (`y`) {array} is provided, a single box is drawn.',\n        'That box position is then positioned with',\n        'with `name` or with `x0` (`y0`) if provided.',\n        'Each box spans from quartile 1 (Q1) to quartile 3 (Q3).',\n        'The second quartile (Q2) is marked by a line inside the box.',\n        'By default, the whiskers correspond to the box\\' edges',\n        '+/- 1.5 times the interquartile range (IQR = Q3-Q1),',\n        'see *boxpoints* for other options.'\n    ].join(' ')\n};\n\nmodule.exports = Box;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/box/attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar scatterAttrs = require('../scatter/attributes');\nvar colorAttrs = require('../../components/color/attributes');\nvar extendFlat = require('../../lib/extend').extendFlat;\n\nvar scatterMarkerAttrs = scatterAttrs.marker,\n    scatterMarkerLineAttrs = scatterMarkerAttrs.line;\n\n\nmodule.exports = {\n    y: {\n        valType: 'data_array',\n        description: [\n            'Sets the y sample data or coordinates.',\n            'See overview for more info.'\n        ].join(' ')\n    },\n    x: {\n        valType: 'data_array',\n        description: [\n            'Sets the x sample data or coordinates.',\n            'See overview for more info.'\n        ].join(' ')\n    },\n    x0: {\n        valType: 'any',\n        role: 'info',\n        description: [\n            'Sets the x coordinate of the box.',\n            'See overview for more info.'\n        ].join(' ')\n    },\n    y0: {\n        valType: 'any',\n        role: 'info',\n        description: [\n            'Sets the y coordinate of the box.',\n            'See overview for more info.'\n        ].join(' ')\n    },\n    xcalendar: scatterAttrs.xcalendar,\n    ycalendar: scatterAttrs.ycalendar,\n    whiskerwidth: {\n        valType: 'number',\n        min: 0,\n        max: 1,\n        dflt: 0.5,\n        role: 'style',\n        description: [\n            'Sets the width of the whiskers relative to',\n            'the box\\' width.',\n            'For example, with 1, the whiskers are as wide as the box(es).'\n        ].join(' ')\n    },\n    boxpoints: {\n        valType: 'enumerated',\n        values: ['all', 'outliers', 'suspectedoutliers', false],\n        dflt: 'outliers',\n        role: 'style',\n        description: [\n            'If *outliers*, only the sample points lying outside the whiskers',\n            'are shown',\n            'If *suspectedoutliers*, the outlier points are shown and',\n            'points either less than 4*Q1-3*Q3 or greater than 4*Q3-3*Q1',\n            'are highlighted (see `outliercolor`)',\n            'If *all*, all sample points are shown',\n            'If *false*, only the box(es) are shown with no sample points'\n        ].join(' ')\n    },\n    boxmean: {\n        valType: 'enumerated',\n        values: [true, 'sd', false],\n        dflt: false,\n        role: 'style',\n        description: [\n            'If *true*, the mean of the box(es)\\' underlying distribution is',\n            'drawn as a dashed line inside the box(es).',\n            'If *sd* the standard deviation is also drawn.'\n        ].join(' ')\n    },\n    jitter: {\n        valType: 'number',\n        min: 0,\n        max: 1,\n        role: 'style',\n        description: [\n            'Sets the amount of jitter in the sample points drawn.',\n            'If *0*, the sample points align along the distribution axis.',\n            'If *1*, the sample points are drawn in a random jitter of width',\n            'equal to the width of the box(es).'\n        ].join(' ')\n    },\n    pointpos: {\n        valType: 'number',\n        min: -2,\n        max: 2,\n        role: 'style',\n        description: [\n            'Sets the position of the sample points in relation to the box(es).',\n            'If *0*, the sample points are places over the center of the box(es).',\n            'Positive (negative) values correspond to positions to the',\n            'right (left) for vertical boxes and above (below) for horizontal boxes'\n        ].join(' ')\n    },\n    orientation: {\n        valType: 'enumerated',\n        values: ['v', 'h'],\n        role: 'style',\n        description: [\n            'Sets the orientation of the box(es).',\n            'If *v* (*h*), the distribution is visualized along',\n            'the vertical (horizontal).'\n        ].join(' ')\n    },\n    marker: {\n        outliercolor: {\n            valType: 'color',\n            dflt: 'rgba(0, 0, 0, 0)',\n            role: 'style',\n            description: 'Sets the color of the outlier sample points.'\n        },\n        symbol: extendFlat({}, scatterMarkerAttrs.symbol,\n            {arrayOk: false}),\n        opacity: extendFlat({}, scatterMarkerAttrs.opacity,\n            {arrayOk: false, dflt: 1}),\n        size: extendFlat({}, scatterMarkerAttrs.size,\n            {arrayOk: false}),\n        color: extendFlat({}, scatterMarkerAttrs.color,\n            {arrayOk: false}),\n        line: {\n            color: extendFlat({}, scatterMarkerLineAttrs.color,\n                {arrayOk: false, dflt: colorAttrs.defaultLine}),\n            width: extendFlat({}, scatterMarkerLineAttrs.width,\n                {arrayOk: false, dflt: 0}),\n            outliercolor: {\n                valType: 'color',\n                role: 'style',\n                description: [\n                    'Sets the border line color of the outlier sample points.',\n                    'Defaults to marker.color'\n                ].join(' ')\n            },\n            outlierwidth: {\n                valType: 'number',\n                min: 0,\n                dflt: 1,\n                role: 'style',\n                description: [\n                    'Sets the border line width (in px) of the outlier sample points.'\n                ].join(' ')\n            }\n        }\n    },\n    line: {\n        color: {\n            valType: 'color',\n            role: 'style',\n            description: 'Sets the color of line bounding the box(es).'\n        },\n        width: {\n            valType: 'number',\n            role: 'style',\n            min: 0,\n            dflt: 2,\n            description: 'Sets the width (in px) of line bounding the box(es).'\n        }\n    },\n    fillcolor: scatterAttrs.fillcolor\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/lib/calendars.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = require('../src/components/calendars');\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/calendars/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar calendars = require('./calendars');\n\nvar Lib = require('../../lib');\nvar constants = require('../../constants/numerical');\n\nvar EPOCHJD = constants.EPOCHJD;\nvar ONEDAY = constants.ONEDAY;\n\nvar attributes = {\n    valType: 'enumerated',\n    values: Object.keys(calendars.calendars),\n    role: 'info',\n    dflt: 'gregorian'\n};\n\nvar handleDefaults = function(contIn, contOut, attr, dflt) {\n    var attrs = {};\n    attrs[attr] = attributes;\n\n    return Lib.coerce(contIn, contOut, attrs, attr, dflt);\n};\n\nvar handleTraceDefaults = function(traceIn, traceOut, coords, layout) {\n    for(var i = 0; i < coords.length; i++) {\n        handleDefaults(traceIn, traceOut, coords[i] + 'calendar', layout.calendar);\n    }\n};\n\n// each calendar needs its own default canonical tick. I would love to use\n// 2000-01-01 (or even 0000-01-01) for them all but they don't necessarily\n// all support either of those dates. Instead I'll use the most significant\n// number they *do* support, biased toward the present day.\nvar CANONICAL_TICK = {\n    chinese: '2000-01-01',\n    coptic: '2000-01-01',\n    discworld: '2000-01-01',\n    ethiopian: '2000-01-01',\n    hebrew: '5000-01-01',\n    islamic: '1000-01-01',\n    julian: '2000-01-01',\n    mayan: '5000-01-01',\n    nanakshahi: '1000-01-01',\n    nepali: '2000-01-01',\n    persian: '1000-01-01',\n    jalali: '1000-01-01',\n    taiwan: '1000-01-01',\n    thai: '2000-01-01',\n    ummalqura: '1400-01-01'\n};\n\n// Start on a Sunday - for week ticks\n// Discworld and Mayan calendars don't have 7-day weeks but we're going to give them\n// 7-day week ticks so start on our Sundays.\n// If anyone really cares we can customize the auto tick spacings for these calendars.\nvar CANONICAL_SUNDAY = {\n    chinese: '2000-01-02',\n    coptic: '2000-01-03',\n    discworld: '2000-01-03',\n    ethiopian: '2000-01-05',\n    hebrew: '5000-01-01',\n    islamic: '1000-01-02',\n    julian: '2000-01-03',\n    mayan: '5000-01-01',\n    nanakshahi: '1000-01-05',\n    nepali: '2000-01-05',\n    persian: '1000-01-01',\n    jalali: '1000-01-01',\n    taiwan: '1000-01-04',\n    thai: '2000-01-04',\n    ummalqura: '1400-01-06'\n};\n\nvar DFLTRANGE = {\n    chinese: ['2000-01-01', '2001-01-01'],\n    coptic: ['1700-01-01', '1701-01-01'],\n    discworld: ['1800-01-01', '1801-01-01'],\n    ethiopian: ['2000-01-01', '2001-01-01'],\n    hebrew: ['5700-01-01', '5701-01-01'],\n    islamic: ['1400-01-01', '1401-01-01'],\n    julian: ['2000-01-01', '2001-01-01'],\n    mayan: ['5200-01-01', '5201-01-01'],\n    nanakshahi: ['0500-01-01', '0501-01-01'],\n    nepali: ['2000-01-01', '2001-01-01'],\n    persian: ['1400-01-01', '1401-01-01'],\n    jalali: ['1400-01-01', '1401-01-01'],\n    taiwan: ['0100-01-01', '0101-01-01'],\n    thai: ['2500-01-01', '2501-01-01'],\n    ummalqura: ['1400-01-01', '1401-01-01']\n};\n\n/*\n * convert d3 templates to world-calendars templates, so our users only need\n * to know d3's specifiers. Map space padding to no padding, and unknown fields\n * to an ugly placeholder\n */\nvar UNKNOWN = '##';\nvar d3ToWorldCalendars = {\n    'd': {'0': 'dd', '-': 'd'}, // 2-digit or unpadded day of month\n    'e': {'0': 'd', '-': 'd'}, // alternate, always unpadded day of month\n    'a': {'0': 'D', '-': 'D'}, // short weekday name\n    'A': {'0': 'DD', '-': 'DD'}, // full weekday name\n    'j': {'0': 'oo', '-': 'o'}, // 3-digit or unpadded day of the year\n    'W': {'0': 'ww', '-': 'w'}, // 2-digit or unpadded week of the year (Monday first)\n    'm': {'0': 'mm', '-': 'm'}, // 2-digit or unpadded month number\n    'b': {'0': 'M', '-': 'M'}, // short month name\n    'B': {'0': 'MM', '-': 'MM'}, // full month name\n    'y': {'0': 'yy', '-': 'yy'}, // 2-digit year (map unpadded to zero-padded)\n    'Y': {'0': 'yyyy', '-': 'yyyy'}, // 4-digit year (map unpadded to zero-padded)\n    'U': UNKNOWN, // Sunday-first week of the year\n    'w': UNKNOWN, // day of the week [0(sunday),6]\n    // combined format, we replace the date part with the world-calendar version\n    // and the %X stays there for d3 to handle with time parts\n    'c': {'0': 'D M d %X yyyy', '-': 'D M d %X yyyy'},\n    'x': {'0': 'mm/dd/yyyy', '-': 'mm/dd/yyyy'}\n};\n\nfunction worldCalFmt(fmt, x, calendar) {\n    var dateJD = Math.floor((x + 0.05) / ONEDAY) + EPOCHJD,\n        cDate = getCal(calendar).fromJD(dateJD),\n        i = 0,\n        modifier, directive, directiveLen, directiveObj, replacementPart;\n    while((i = fmt.indexOf('%', i)) !== -1) {\n        modifier = fmt.charAt(i + 1);\n        if(modifier === '0' || modifier === '-' || modifier === '_') {\n            directiveLen = 3;\n            directive = fmt.charAt(i + 2);\n            if(modifier === '_') modifier = '-';\n        }\n        else {\n            directive = modifier;\n            modifier = '0';\n            directiveLen = 2;\n        }\n        directiveObj = d3ToWorldCalendars[directive];\n        if(!directiveObj) {\n            i += directiveLen;\n        }\n        else {\n            // code is recognized as a date part but world-calendars doesn't support it\n            if(directiveObj === UNKNOWN) replacementPart = UNKNOWN;\n\n            // format the cDate according to the translated directive\n            else replacementPart = cDate.formatDate(directiveObj[modifier]);\n\n            fmt = fmt.substr(0, i) + replacementPart + fmt.substr(i + directiveLen);\n            i += replacementPart.length;\n        }\n    }\n    return fmt;\n}\n\n// cache world calendars, so we don't have to reinstantiate\n// during each date-time conversion\nvar allCals = {};\nfunction getCal(calendar) {\n    var calendarObj = allCals[calendar];\n    if(calendarObj) return calendarObj;\n\n    calendarObj = allCals[calendar] = calendars.instance(calendar);\n    return calendarObj;\n}\n\nfunction makeAttrs(description) {\n    return Lib.extendFlat({}, attributes, { description: description });\n}\n\nfunction makeTraceAttrsDescription(coord) {\n    return 'Sets the calendar system to use with `' + coord + '` date data.';\n}\n\nvar xAttrs = {\n    xcalendar: makeAttrs(makeTraceAttrsDescription('x'))\n};\n\nvar xyAttrs = Lib.extendFlat({}, xAttrs, {\n    ycalendar: makeAttrs(makeTraceAttrsDescription('y'))\n});\n\nvar xyzAttrs = Lib.extendFlat({}, xyAttrs, {\n    zcalendar: makeAttrs(makeTraceAttrsDescription('z'))\n});\n\nvar axisAttrs = makeAttrs([\n    'Sets the calendar system to use for `range` and `tick0`',\n    'if this is a date axis. This does not set the calendar for',\n    'interpreting data on this axis, that\\'s specified in the trace',\n    'or via the global `layout.calendar`'\n].join(' '));\n\nmodule.exports = {\n    moduleType: 'component',\n    name: 'calendars',\n\n    schema: {\n        traces: {\n            scatter: xyAttrs,\n            bar: xyAttrs,\n            heatmap: xyAttrs,\n            contour: xyAttrs,\n            histogram: xyAttrs,\n            histogram2d: xyAttrs,\n            histogram2dcontour: xyAttrs,\n            scatter3d: xyzAttrs,\n            surface: xyzAttrs,\n            mesh3d: xyzAttrs,\n            scattergl: xyAttrs,\n            ohlc: xAttrs,\n            candlestick: xAttrs\n        },\n        layout: {\n            calendar: makeAttrs([\n                'Sets the default calendar system to use for interpreting and',\n                'displaying dates throughout the plot.'\n            ].join(' ')),\n            'xaxis.calendar': axisAttrs,\n            'yaxis.calendar': axisAttrs,\n            'scene.xaxis.calendar': axisAttrs,\n            'scene.yaxis.calendar': axisAttrs,\n            'scene.zaxis.calendar': axisAttrs\n        },\n        transforms: {\n            filter: {\n                valuecalendar: makeAttrs([\n                    'Sets the calendar system to use for `value`, if it is a date.'\n                ].join(' ')),\n                targetcalendar: makeAttrs([\n                    'Sets the calendar system to use for `target`, if it is an',\n                    'array of dates. If `target` is a string (eg *x*) we use the',\n                    'corresponding trace attribute (eg `xcalendar`) if it exists,',\n                    'even if `targetcalendar` is provided.'\n                ].join(' '))\n            }\n        }\n    },\n\n    layoutAttributes: attributes,\n\n    handleDefaults: handleDefaults,\n    handleTraceDefaults: handleTraceDefaults,\n\n    CANONICAL_SUNDAY: CANONICAL_SUNDAY,\n    CANONICAL_TICK: CANONICAL_TICK,\n    DFLTRANGE: DFLTRANGE,\n\n    getCal: getCal,\n    worldCalFmt: worldCalFmt\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/calendars/calendars.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n// a trimmed down version of:\n// https://github.com/alexcjohnson/world-calendars/blob/master/dist/index.js\n\nmodule.exports = require('world-calendars/dist/main');\n\nrequire('world-calendars/dist/plus');\n\nrequire('world-calendars/dist/calendars/chinese');\nrequire('world-calendars/dist/calendars/coptic');\nrequire('world-calendars/dist/calendars/discworld');\nrequire('world-calendars/dist/calendars/ethiopian');\nrequire('world-calendars/dist/calendars/hebrew');\nrequire('world-calendars/dist/calendars/islamic');\nrequire('world-calendars/dist/calendars/julian');\nrequire('world-calendars/dist/calendars/mayan');\nrequire('world-calendars/dist/calendars/nanakshahi');\nrequire('world-calendars/dist/calendars/nepali');\nrequire('world-calendars/dist/calendars/persian');\nrequire('world-calendars/dist/calendars/taiwan');\nrequire('world-calendars/dist/calendars/thai');\nrequire('world-calendars/dist/calendars/ummalqura');\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/lib/candlestick.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = require('../src/traces/candlestick');\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/candlestick/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar register = require('../../plot_api/register');\n\nmodule.exports = {\n    moduleType: 'trace',\n    name: 'candlestick',\n    basePlotModule: require('../../plots/cartesian'),\n    categories: ['cartesian', 'showLegend', 'candlestick'],\n    meta: {\n        description: [\n            'The candlestick is a style of financial chart describing',\n            'open, high, low and close for a given `x` coordinate (most likely time).',\n\n            'The boxes represent the spread between the `open` and `close` values and',\n            'the lines represent the spread between the `low` and `high` values',\n\n            'Sample points where the close value is higher (lower) then the open',\n            'value are called increasing (decreasing).',\n\n            'By default, increasing candles are drawn in green whereas',\n            'decreasing are drawn in red.'\n        ].join(' ')\n    },\n\n    attributes: require('./attributes'),\n    supplyDefaults: require('./defaults'),\n};\n\nregister(require('../box'));\nregister(require('./transform'));\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plot_api/register.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Registry = require('../registry');\nvar Lib = require('../lib');\n\n\nmodule.exports = function register(_modules) {\n    if(!_modules) {\n        throw new Error('No argument passed to Plotly.register.');\n    }\n    else if(_modules && !Array.isArray(_modules)) {\n        _modules = [_modules];\n    }\n\n    for(var i = 0; i < _modules.length; i++) {\n        var newModule = _modules[i];\n\n        if(!newModule) {\n            throw new Error('Invalid module was attempted to be registered!');\n        }\n\n        switch(newModule.moduleType) {\n            case 'trace':\n                registerTraceModule(newModule);\n                break;\n\n            case 'transform':\n                registerTransformModule(newModule);\n                break;\n\n            case 'component':\n                registerComponentModule(newModule);\n                break;\n\n            default:\n                throw new Error('Invalid module was attempted to be registered!');\n        }\n    }\n};\n\nfunction registerTraceModule(newModule) {\n    Registry.register(newModule, newModule.name, newModule.categories, newModule.meta);\n\n    if(!Registry.subplotsRegistry[newModule.basePlotModule.name]) {\n        Registry.registerSubplot(newModule.basePlotModule);\n    }\n}\n\nfunction registerTransformModule(newModule) {\n    if(typeof newModule.name !== 'string') {\n        throw new Error('Transform module *name* must be a string.');\n    }\n\n    var prefix = 'Transform module ' + newModule.name;\n\n    var hasTransform = typeof newModule.transform === 'function',\n        hasCalcTransform = typeof newModule.calcTransform === 'function';\n\n\n    if(!hasTransform && !hasCalcTransform) {\n        throw new Error(prefix + ' is missing a *transform* or *calcTransform* method.');\n    }\n\n    if(hasTransform && hasCalcTransform) {\n        Lib.log([\n            prefix + ' has both a *transform* and *calcTransform* methods.',\n            'Please note that all *transform* methods are executed',\n            'before all *calcTransform* methods.'\n        ].join(' '));\n    }\n\n    if(!Lib.isPlainObject(newModule.attributes)) {\n        Lib.log(prefix + ' registered without an *attributes* object.');\n    }\n\n    if(typeof newModule.supplyDefaults !== 'function') {\n        Lib.log(prefix + ' registered without a *supplyDefaults* method.');\n    }\n\n    Registry.transformsRegistry[newModule.name] = newModule;\n}\n\nfunction registerComponentModule(newModule) {\n    if(typeof newModule.name !== 'string') {\n        throw new Error('Component module *name* must be a string.');\n    }\n\n    Registry.registerComponent(newModule);\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/cartesian/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\nvar Lib = require('../../lib');\nvar Plots = require('../plots');\n\nvar axisIds = require('./axis_ids');\nvar constants = require('./constants');\n\nexports.name = 'cartesian';\n\nexports.attr = ['xaxis', 'yaxis'];\n\nexports.idRoot = ['x', 'y'];\n\nexports.idRegex = constants.idRegex;\n\nexports.attrRegex = constants.attrRegex;\n\nexports.attributes = require('./attributes');\n\nexports.layoutAttributes = require('./layout_attributes');\n\nexports.transitionAxes = require('./transition_axes');\n\nexports.plot = function(gd, traces, transitionOpts, makeOnCompleteCallback) {\n    var fullLayout = gd._fullLayout,\n        subplots = Plots.getSubplotIds(fullLayout, 'cartesian'),\n        calcdata = gd.calcdata,\n        i;\n\n    // If traces is not provided, then it's a complete replot and missing\n    // traces are removed\n    if(!Array.isArray(traces)) {\n        traces = [];\n\n        for(i = 0; i < calcdata.length; i++) {\n            traces.push(i);\n        }\n    }\n\n    for(i = 0; i < subplots.length; i++) {\n        var subplot = subplots[i],\n            subplotInfo = fullLayout._plots[subplot];\n\n        // Get all calcdata for this subplot:\n        var cdSubplot = [];\n        var pcd;\n\n        for(var j = 0; j < calcdata.length; j++) {\n            var cd = calcdata[j],\n                trace = cd[0].trace;\n\n            // Skip trace if whitelist provided and it's not whitelisted:\n            // if (Array.isArray(traces) && traces.indexOf(i) === -1) continue;\n            if(trace.xaxis + trace.yaxis === subplot) {\n                // XXX: Should trace carpet dependencies. Only replot all carpet plots if the carpet\n                // axis has actually changed:\n                //\n                // If this trace is specifically requested, add it to the list:\n                if(traces.indexOf(trace.index) !== -1 || trace.carpet) {\n                    // Okay, so example: traces 0, 1, and 2 have fill = tonext. You animate\n                    // traces 0 and 2. Trace 1 also needs to be updated, otherwise its fill\n                    // is outdated. So this retroactively adds the previous trace if the\n                    // traces are interdependent.\n                    if(\n                        pcd &&\n                        pcd[0].trace.xaxis + pcd[0].trace.yaxis === subplot &&\n                        ['tonextx', 'tonexty', 'tonext'].indexOf(trace.fill) !== -1 &&\n                        cdSubplot.indexOf(pcd) === -1\n                    ) {\n                        cdSubplot.push(pcd);\n                    }\n\n                    cdSubplot.push(cd);\n                }\n\n                // Track the previous trace on this subplot for the retroactive-add step\n                // above:\n                pcd = cd;\n            }\n        }\n\n        plotOne(gd, subplotInfo, cdSubplot, transitionOpts, makeOnCompleteCallback);\n    }\n};\n\nfunction plotOne(gd, plotinfo, cdSubplot, transitionOpts, makeOnCompleteCallback) {\n    var fullLayout = gd._fullLayout,\n        modules = fullLayout._modules;\n\n    // remove old traces, then redraw everything\n    //\n    // TODO: scatterlayer is manually excluded from this since it knows how\n    // to update instead of fully removing and redrawing every time. The\n    // remaining plot traces should also be able to do this. Once implemented,\n    // we won't need this - which should sometimes be a big speedup.\n    if(plotinfo.plot) {\n        plotinfo.plot.selectAll('g:not(.scatterlayer)').selectAll('g.trace').remove();\n    }\n\n    // plot all traces for each module at once\n    for(var j = 0; j < modules.length; j++) {\n        var _module = modules[j];\n\n        // skip over non-cartesian trace modules\n        if(_module.basePlotModule.name !== 'cartesian') continue;\n\n        // plot all traces of this type on this subplot at once\n        var cdModule = [];\n        for(var k = 0; k < cdSubplot.length; k++) {\n            var cd = cdSubplot[k],\n                trace = cd[0].trace;\n\n            if((trace._module === _module) && (trace.visible === true)) {\n                cdModule.push(cd);\n            }\n        }\n\n        _module.plot(gd, plotinfo, cdModule, transitionOpts, makeOnCompleteCallback);\n    }\n}\n\nexports.clean = function(newFullData, newFullLayout, oldFullData, oldFullLayout) {\n    var oldModules = oldFullLayout._modules || [],\n        newModules = newFullLayout._modules || [];\n\n    var hadScatter, hasScatter, i;\n\n    for(i = 0; i < oldModules.length; i++) {\n        if(oldModules[i].name === 'scatter') {\n            hadScatter = true;\n            break;\n        }\n    }\n\n    for(i = 0; i < newModules.length; i++) {\n        if(newModules[i].name === 'scatter') {\n            hasScatter = true;\n            break;\n        }\n    }\n\n    if(hadScatter && !hasScatter) {\n        var oldPlots = oldFullLayout._plots,\n            ids = Object.keys(oldPlots || {});\n\n        for(i = 0; i < ids.length; i++) {\n            var subplotInfo = oldPlots[ids[i]];\n\n            if(subplotInfo.plot) {\n                subplotInfo.plot.select('g.scatterlayer')\n                    .selectAll('g.trace')\n                    .remove();\n            }\n        }\n\n        oldFullLayout._infolayer.selectAll('g.rangeslider-container')\n            .select('g.scatterlayer')\n            .selectAll('g.trace')\n            .remove();\n    }\n\n    var hadCartesian = (oldFullLayout._has && oldFullLayout._has('cartesian'));\n    var hasCartesian = (newFullLayout._has && newFullLayout._has('cartesian'));\n\n    if(hadCartesian && !hasCartesian) {\n        var subplotLayers = oldFullLayout._cartesianlayer.selectAll('.subplot');\n        var axIds = axisIds.listIds({ _fullLayout: oldFullLayout });\n\n        subplotLayers.call(purgeSubplotLayers, oldFullLayout);\n        oldFullLayout._defs.selectAll('.axesclip').remove();\n\n        for(i = 0; i < axIds.length; i++) {\n            oldFullLayout._infolayer.select('.' + axIds[i] + 'title').remove();\n        }\n    }\n};\n\nexports.drawFramework = function(gd) {\n    var fullLayout = gd._fullLayout,\n        subplotData = makeSubplotData(gd);\n\n    var subplotLayers = fullLayout._cartesianlayer.selectAll('.subplot')\n        .data(subplotData, Lib.identity);\n\n    subplotLayers.enter().append('g')\n        .attr('class', function(name) { return 'subplot ' + name; });\n\n    subplotLayers.order();\n\n    subplotLayers.exit()\n        .call(purgeSubplotLayers, fullLayout);\n\n    subplotLayers.each(function(name) {\n        var plotinfo = fullLayout._plots[name];\n\n        // keep ref to plot group\n        plotinfo.plotgroup = d3.select(this);\n\n        // initialize list of overlay subplots\n        plotinfo.overlays = [];\n\n        makeSubplotLayer(plotinfo);\n\n        // fill in list of overlay subplots\n        if(plotinfo.mainplot) {\n            var mainplot = fullLayout._plots[plotinfo.mainplot];\n            mainplot.overlays.push(plotinfo);\n        }\n\n        // make separate drag layers for each subplot,\n        // but append them to paper rather than the plot groups,\n        // so they end up on top of the rest\n        plotinfo.draglayer = joinLayer(fullLayout._draggers, 'g', name);\n    });\n};\n\nexports.rangePlot = function(gd, plotinfo, cdSubplot) {\n    makeSubplotLayer(plotinfo);\n    plotOne(gd, plotinfo, cdSubplot);\n    Plots.style(gd);\n};\n\nfunction makeSubplotData(gd) {\n    var fullLayout = gd._fullLayout,\n        subplots = Object.keys(fullLayout._plots);\n\n    var subplotData = [],\n        overlays = [];\n\n    for(var i = 0; i < subplots.length; i++) {\n        var subplot = subplots[i],\n            plotinfo = fullLayout._plots[subplot];\n\n        var xa = plotinfo.xaxis,\n            ya = plotinfo.yaxis;\n\n        // is this subplot overlaid on another?\n        // ax.overlaying is the id of another axis of the same\n        // dimension that this one overlays to be an overlaid subplot,\n        // the main plot must exist make sure we're not trying to\n        // overlay on an axis that's already overlaying another\n        var xa2 = axisIds.getFromId(gd, xa.overlaying) || xa;\n        if(xa2 !== xa && xa2.overlaying) {\n            xa2 = xa;\n            xa.overlaying = false;\n        }\n\n        var ya2 = axisIds.getFromId(gd, ya.overlaying) || ya;\n        if(ya2 !== ya && ya2.overlaying) {\n            ya2 = ya;\n            ya.overlaying = false;\n        }\n\n        var mainplot = xa2._id + ya2._id;\n        if(mainplot !== subplot && subplots.indexOf(mainplot) !== -1) {\n            plotinfo.mainplot = mainplot;\n            plotinfo.mainplotinfo = fullLayout._plots[mainplot];\n            overlays.push(subplot);\n\n            // for now force overlays to overlay completely... so they\n            // can drag together correctly and share backgrounds.\n            // Later perhaps we make separate axis domain and\n            // tick/line domain or something, so they can still share\n            // the (possibly larger) dragger and background but don't\n            // have to both be drawn over that whole domain\n            xa.domain = xa2.domain.slice();\n            ya.domain = ya2.domain.slice();\n        }\n        else {\n            subplotData.push(subplot);\n        }\n    }\n\n    // main subplots before overlays\n    subplotData = subplotData.concat(overlays);\n\n    return subplotData;\n}\n\nfunction makeSubplotLayer(plotinfo) {\n    var plotgroup = plotinfo.plotgroup,\n        id = plotinfo.id;\n\n    // Layers to keep plot types in the right order.\n    // from back to front:\n    // 1. heatmaps, 2D histos and contour maps\n    // 2. bars / 1D histos\n    // 3. errorbars for bars and scatter\n    // 4. scatter\n    // 5. box plots\n    function joinPlotLayers(parent) {\n        joinLayer(parent, 'g', 'imagelayer');\n        joinLayer(parent, 'g', 'maplayer');\n        joinLayer(parent, 'g', 'barlayer');\n        joinLayer(parent, 'g', 'carpetlayer');\n        joinLayer(parent, 'g', 'boxlayer');\n        joinLayer(parent, 'g', 'scatterlayer');\n    }\n\n    if(!plotinfo.mainplot) {\n        var backLayer = joinLayer(plotgroup, 'g', 'layer-subplot');\n        plotinfo.shapelayer = joinLayer(backLayer, 'g', 'shapelayer');\n        plotinfo.imagelayer = joinLayer(backLayer, 'g', 'imagelayer');\n\n        plotinfo.gridlayer = joinLayer(plotgroup, 'g', 'gridlayer');\n        plotinfo.overgrid = joinLayer(plotgroup, 'g', 'overgrid');\n\n        plotinfo.zerolinelayer = joinLayer(plotgroup, 'g', 'zerolinelayer');\n        plotinfo.overzero = joinLayer(plotgroup, 'g', 'overzero');\n\n        plotinfo.plot = joinLayer(plotgroup, 'g', 'plot');\n        plotinfo.overplot = joinLayer(plotgroup, 'g', 'overplot');\n\n        plotinfo.xlines = joinLayer(plotgroup, 'path', 'xlines');\n        plotinfo.ylines = joinLayer(plotgroup, 'path', 'ylines');\n        plotinfo.overlines = joinLayer(plotgroup, 'g', 'overlines');\n\n        plotinfo.xaxislayer = joinLayer(plotgroup, 'g', 'xaxislayer');\n        plotinfo.yaxislayer = joinLayer(plotgroup, 'g', 'yaxislayer');\n        plotinfo.overaxes = joinLayer(plotgroup, 'g', 'overaxes');\n    }\n    else {\n        var mainplotinfo = plotinfo.mainplotinfo;\n\n        // now make the components of overlaid subplots\n        // overlays don't have backgrounds, and append all\n        // their other components to the corresponding\n        // extra groups of their main plots.\n\n        plotinfo.gridlayer = joinLayer(mainplotinfo.overgrid, 'g', id);\n        plotinfo.zerolinelayer = joinLayer(mainplotinfo.overzero, 'g', id);\n\n        plotinfo.plot = joinLayer(mainplotinfo.overplot, 'g', id);\n        plotinfo.xlines = joinLayer(mainplotinfo.overlines, 'path', id);\n        plotinfo.ylines = joinLayer(mainplotinfo.overlines, 'path', id);\n        plotinfo.xaxislayer = joinLayer(mainplotinfo.overaxes, 'g', id);\n        plotinfo.yaxislayer = joinLayer(mainplotinfo.overaxes, 'g', id);\n    }\n\n    // common attributes for all subplots, overlays or not\n    plotinfo.plot.call(joinPlotLayers);\n\n    plotinfo.xlines\n        .style('fill', 'none')\n        .classed('crisp', true);\n\n    plotinfo.ylines\n        .style('fill', 'none')\n        .classed('crisp', true);\n}\n\nfunction purgeSubplotLayers(layers, fullLayout) {\n    if(!layers) return;\n\n    layers.each(function(subplot) {\n        var plotgroup = d3.select(this),\n            clipId = 'clip' + fullLayout._uid + subplot + 'plot';\n\n        plotgroup.remove();\n        fullLayout._draggers.selectAll('g.' + subplot).remove();\n        fullLayout._defs.select('#' + clipId).remove();\n\n        // do not remove individual axis <clipPath>s here\n        // as other subplots may need them\n    });\n}\n\nfunction joinLayer(parent, nodeType, className) {\n    var layer = parent.selectAll('.' + className)\n        .data([0]);\n\n    layer.enter().append(nodeType)\n        .classed(className, true);\n\n    return layer;\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/cartesian/attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n\nmodule.exports = {\n    xaxis: {\n        valType: 'subplotid',\n        role: 'info',\n        dflt: 'x',\n        description: [\n            'Sets a reference between this trace\\'s x coordinates and',\n            'a 2D cartesian x axis.',\n            'If *x* (the default value), the x coordinates refer to',\n            '`layout.xaxis`.',\n            'If *x2*, the x coordinates refer to `layout.xaxis2`, and so on.'\n        ].join(' ')\n    },\n    yaxis: {\n        valType: 'subplotid',\n        role: 'info',\n        dflt: 'y',\n        description: [\n            'Sets a reference between this trace\\'s y coordinates and',\n            'a 2D cartesian y axis.',\n            'If *y* (the default value), the y coordinates refer to',\n            '`layout.yaxis`.',\n            'If *y2*, the y coordinates refer to `layout.xaxis2`, and so on.'\n        ].join(' ')\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/cartesian/transition_axes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\n\nvar Plotly = require('../../plotly');\nvar Registry = require('../../registry');\nvar Drawing = require('../../components/drawing');\nvar Axes = require('./axes');\nvar axisRegex = /((x|y)([2-9]|[1-9][0-9]+)?)axis$/;\n\nmodule.exports = function transitionAxes(gd, newLayout, transitionOpts, makeOnCompleteCallback) {\n    var fullLayout = gd._fullLayout;\n    var axes = [];\n\n    function computeUpdates(layout) {\n        var ai, attrList, match, axis, update;\n        var updates = {};\n\n        for(ai in layout) {\n            attrList = ai.split('.');\n            match = attrList[0].match(axisRegex);\n            if(match) {\n                var axisLetter = match[1];\n                var axisName = axisLetter + 'axis';\n                axis = fullLayout[axisName];\n                update = {};\n\n                if(Array.isArray(layout[ai])) {\n                    update.to = layout[ai].slice(0);\n                } else {\n                    if(Array.isArray(layout[ai].range)) {\n                        update.to = layout[ai].range.slice(0);\n                    }\n                }\n                if(!update.to) continue;\n\n                update.axisName = axisName;\n                update.length = axis._length;\n\n                axes.push(axisLetter);\n\n                updates[axisLetter] = update;\n            }\n        }\n\n        return updates;\n    }\n\n    function computeAffectedSubplots(fullLayout, updatedAxisIds, updates) {\n        var plotName;\n        var plotinfos = fullLayout._plots;\n        var affectedSubplots = [];\n        var toX, toY;\n\n        for(plotName in plotinfos) {\n            var plotinfo = plotinfos[plotName];\n\n            if(affectedSubplots.indexOf(plotinfo) !== -1) continue;\n\n            var x = plotinfo.xaxis._id;\n            var y = plotinfo.yaxis._id;\n            var fromX = plotinfo.xaxis.range;\n            var fromY = plotinfo.yaxis.range;\n\n            // Store the initial range at the beginning of this transition:\n            plotinfo.xaxis._r = plotinfo.xaxis.range.slice();\n            plotinfo.yaxis._r = plotinfo.yaxis.range.slice();\n\n            if(updates[x]) {\n                toX = updates[x].to;\n            } else {\n                toX = fromX;\n            }\n            if(updates[y]) {\n                toY = updates[y].to;\n            } else {\n                toY = fromY;\n            }\n\n            if(fromX[0] === toX[0] && fromX[1] === toX[1] && fromY[0] === toY[0] && fromY[1] === toY[1]) continue;\n\n            if(updatedAxisIds.indexOf(x) !== -1 || updatedAxisIds.indexOf(y) !== -1) {\n                affectedSubplots.push(plotinfo);\n            }\n        }\n\n        return affectedSubplots;\n    }\n\n    var updates = computeUpdates(newLayout);\n    var updatedAxisIds = Object.keys(updates);\n    var affectedSubplots = computeAffectedSubplots(fullLayout, updatedAxisIds, updates);\n\n    if(!affectedSubplots.length) {\n        return false;\n    }\n\n    function ticksAndAnnotations(xa, ya) {\n        var activeAxIds = [],\n            i;\n\n        activeAxIds = [xa._id, ya._id];\n\n        for(i = 0; i < activeAxIds.length; i++) {\n            Axes.doTicks(gd, activeAxIds[i], true);\n        }\n\n        function redrawObjs(objArray, method) {\n            for(i = 0; i < objArray.length; i++) {\n                var obji = objArray[i];\n\n                if((activeAxIds.indexOf(obji.xref) !== -1) ||\n                    (activeAxIds.indexOf(obji.yref) !== -1)) {\n                    method(gd, i);\n                }\n            }\n        }\n\n        // annotations and shapes 'draw' method is slow,\n        // use the finer-grained 'drawOne' method instead\n\n        redrawObjs(fullLayout.annotations || [], Registry.getComponentMethod('annotations', 'drawOne'));\n        redrawObjs(fullLayout.shapes || [], Registry.getComponentMethod('shapes', 'drawOne'));\n        redrawObjs(fullLayout.images || [], Registry.getComponentMethod('images', 'draw'));\n    }\n\n    function unsetSubplotTransform(subplot) {\n        var xa2 = subplot.xaxis;\n        var ya2 = subplot.yaxis;\n\n        fullLayout._defs.selectAll('#' + subplot.clipId)\n            .call(Drawing.setTranslate, 0, 0)\n            .call(Drawing.setScale, 1, 1);\n\n        subplot.plot\n            .call(Drawing.setTranslate, xa2._offset, ya2._offset)\n            .call(Drawing.setScale, 1, 1)\n\n            // This is specifically directed at scatter traces, applying an inverse\n            // scale to individual points to counteract the scale of the trace\n            // as a whole:\n            .selectAll('.points').selectAll('.point')\n                .call(Drawing.setPointGroupScale, 1, 1);\n\n    }\n\n    function updateSubplot(subplot, progress) {\n        var axis, r0, r1;\n        var xUpdate = updates[subplot.xaxis._id];\n        var yUpdate = updates[subplot.yaxis._id];\n\n        var viewBox = [];\n\n        if(xUpdate) {\n            axis = gd._fullLayout[xUpdate.axisName];\n            r0 = axis._r;\n            r1 = xUpdate.to;\n            viewBox[0] = (r0[0] * (1 - progress) + progress * r1[0] - r0[0]) / (r0[1] - r0[0]) * subplot.xaxis._length;\n            var dx1 = r0[1] - r0[0];\n            var dx2 = r1[1] - r1[0];\n\n            axis.range[0] = r0[0] * (1 - progress) + progress * r1[0];\n            axis.range[1] = r0[1] * (1 - progress) + progress * r1[1];\n\n            viewBox[2] = subplot.xaxis._length * ((1 - progress) + progress * dx2 / dx1);\n        } else {\n            viewBox[0] = 0;\n            viewBox[2] = subplot.xaxis._length;\n        }\n\n        if(yUpdate) {\n            axis = gd._fullLayout[yUpdate.axisName];\n            r0 = axis._r;\n            r1 = yUpdate.to;\n            viewBox[1] = (r0[1] * (1 - progress) + progress * r1[1] - r0[1]) / (r0[0] - r0[1]) * subplot.yaxis._length;\n            var dy1 = r0[1] - r0[0];\n            var dy2 = r1[1] - r1[0];\n\n            axis.range[0] = r0[0] * (1 - progress) + progress * r1[0];\n            axis.range[1] = r0[1] * (1 - progress) + progress * r1[1];\n\n            viewBox[3] = subplot.yaxis._length * ((1 - progress) + progress * dy2 / dy1);\n        } else {\n            viewBox[1] = 0;\n            viewBox[3] = subplot.yaxis._length;\n        }\n\n        ticksAndAnnotations(subplot.xaxis, subplot.yaxis);\n\n\n        var xa2 = subplot.xaxis;\n        var ya2 = subplot.yaxis;\n\n        var editX = !!xUpdate;\n        var editY = !!yUpdate;\n\n        var xScaleFactor = editX ? xa2._length / viewBox[2] : 1,\n            yScaleFactor = editY ? ya2._length / viewBox[3] : 1;\n\n        var clipDx = editX ? viewBox[0] : 0,\n            clipDy = editY ? viewBox[1] : 0;\n\n        var fracDx = editX ? (viewBox[0] / viewBox[2] * xa2._length) : 0,\n            fracDy = editY ? (viewBox[1] / viewBox[3] * ya2._length) : 0;\n\n        var plotDx = xa2._offset - fracDx,\n            plotDy = ya2._offset - fracDy;\n\n        fullLayout._defs.selectAll('#' + subplot.clipId)\n            .call(Drawing.setTranslate, clipDx, clipDy)\n            .call(Drawing.setScale, 1 / xScaleFactor, 1 / yScaleFactor);\n\n        subplot.plot\n            .call(Drawing.setTranslate, plotDx, plotDy)\n            .call(Drawing.setScale, xScaleFactor, yScaleFactor)\n\n            // This is specifically directed at scatter traces, applying an inverse\n            // scale to individual points to counteract the scale of the trace\n            // as a whole:\n            .selectAll('.points').selectAll('.point')\n                .call(Drawing.setPointGroupScale, 1 / xScaleFactor, 1 / yScaleFactor);\n\n    }\n\n    var onComplete;\n    if(makeOnCompleteCallback) {\n        // This module makes the choice whether or not it notifies Plotly.transition\n        // about completion:\n        onComplete = makeOnCompleteCallback();\n    }\n\n    function transitionComplete() {\n        var aobj = {};\n        for(var i = 0; i < updatedAxisIds.length; i++) {\n            var axi = gd._fullLayout[updates[updatedAxisIds[i]].axisName];\n            var to = updates[updatedAxisIds[i]].to;\n            aobj[axi._name + '.range[0]'] = to[0];\n            aobj[axi._name + '.range[1]'] = to[1];\n\n            axi.range = to.slice();\n        }\n\n        // Signal that this transition has completed:\n        onComplete && onComplete();\n\n        return Plotly.relayout(gd, aobj).then(function() {\n            for(var i = 0; i < affectedSubplots.length; i++) {\n                unsetSubplotTransform(affectedSubplots[i]);\n            }\n        });\n    }\n\n    function transitionInterrupt() {\n        var aobj = {};\n        for(var i = 0; i < updatedAxisIds.length; i++) {\n            var axi = gd._fullLayout[updatedAxisIds[i] + 'axis'];\n            aobj[axi._name + '.range[0]'] = axi.range[0];\n            aobj[axi._name + '.range[1]'] = axi.range[1];\n\n            axi.range = axi._r.slice();\n        }\n\n        return Plotly.relayout(gd, aobj).then(function() {\n            for(var i = 0; i < affectedSubplots.length; i++) {\n                unsetSubplotTransform(affectedSubplots[i]);\n            }\n        });\n    }\n\n    var t1, t2, raf;\n    var easeFn = d3.ease(transitionOpts.easing);\n\n    gd._transitionData._interruptCallbacks.push(function() {\n        window.cancelAnimationFrame(raf);\n        raf = null;\n        return transitionInterrupt();\n    });\n\n    function doFrame() {\n        t2 = Date.now();\n\n        var tInterp = Math.min(1, (t2 - t1) / transitionOpts.duration);\n        var progress = easeFn(tInterp);\n\n        for(var i = 0; i < affectedSubplots.length; i++) {\n            updateSubplot(affectedSubplots[i], progress);\n        }\n\n        if(t2 - t1 > transitionOpts.duration) {\n            transitionComplete();\n            raf = window.cancelAnimationFrame(doFrame);\n        } else {\n            raf = window.requestAnimationFrame(doFrame);\n        }\n    }\n\n    t1 = Date.now();\n    raf = window.requestAnimationFrame(doFrame);\n\n    return Promise.resolve();\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/candlestick/attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar OHLCattrs = require('../ohlc/attributes');\nvar boxAttrs = require('../box/attributes');\n\nvar directionAttrs = {\n    name: OHLCattrs.increasing.name,\n    showlegend: OHLCattrs.increasing.showlegend,\n\n    line: {\n        color: Lib.extendFlat({}, boxAttrs.line.color),\n        width: Lib.extendFlat({}, boxAttrs.line.width)\n    },\n\n    fillcolor: Lib.extendFlat({}, boxAttrs.fillcolor),\n};\n\nmodule.exports = {\n    x: OHLCattrs.x,\n    open: OHLCattrs.open,\n    high: OHLCattrs.high,\n    low: OHLCattrs.low,\n    close: OHLCattrs.close,\n\n    line: {\n        width: Lib.extendFlat({}, boxAttrs.line.width, {\n            description: [\n                boxAttrs.line.width.description,\n                'Note that this style setting can also be set per',\n                'direction via `increasing.line.width` and',\n                '`decreasing.line.width`.'\n            ].join(' ')\n        })\n    },\n\n    increasing: Lib.extendDeep({}, directionAttrs, {\n        line: { color: { dflt: OHLCattrs.increasing.line.color.dflt } }\n    }),\n\n    decreasing: Lib.extendDeep({}, directionAttrs, {\n        line: { color: { dflt: OHLCattrs.decreasing.line.color.dflt } }\n    }),\n\n    text: OHLCattrs.text,\n    whiskerwidth: Lib.extendFlat({}, boxAttrs.whiskerwidth, { dflt: 0 })\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/ohlc/attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar scatterAttrs = require('../scatter/attributes');\nvar dash = require('../../components/drawing/attributes').dash;\n\nvar INCREASING_COLOR = '#3D9970';\nvar DECREASING_COLOR = '#FF4136';\n\nvar lineAttrs = scatterAttrs.line;\n\nvar directionAttrs = {\n    name: {\n        valType: 'string',\n        role: 'info',\n        description: [\n            'Sets the segment name.',\n            'The segment name appear as the legend item and on hover.'\n        ].join(' ')\n    },\n\n    showlegend: {\n        valType: 'boolean',\n        role: 'info',\n        dflt: true,\n        description: [\n            'Determines whether or not an item corresponding to this',\n            'segment is shown in the legend.'\n        ].join(' ')\n    },\n\n    line: {\n        color: lineAttrs.color,\n        width: lineAttrs.width,\n        dash: dash,\n    }\n};\n\nmodule.exports = {\n\n    x: {\n        valType: 'data_array',\n        description: [\n            'Sets the x coordinates.',\n            'If absent, linear coordinate will be generated.'\n        ].join(' ')\n    },\n\n    open: {\n        valType: 'data_array',\n        dflt: [],\n        description: 'Sets the open values.'\n    },\n\n    high: {\n        valType: 'data_array',\n        dflt: [],\n        description: 'Sets the high values.'\n    },\n\n    low: {\n        valType: 'data_array',\n        dflt: [],\n        description: 'Sets the low values.'\n    },\n\n    close: {\n        valType: 'data_array',\n        dflt: [],\n        description: 'Sets the close values.'\n    },\n\n    line: {\n        width: Lib.extendFlat({}, lineAttrs.width, {\n            description: [\n                lineAttrs.width,\n                'Note that this style setting can also be set per',\n                'direction via `increasing.line.width` and',\n                '`decreasing.line.width`.'\n            ].join(' ')\n        }),\n        dash: Lib.extendFlat({}, dash, {\n            description: [\n                dash.description,\n                'Note that this style setting can also be set per',\n                'direction via `increasing.line.dash` and',\n                '`decreasing.line.dash`.'\n            ].join(' ')\n        }),\n    },\n\n    increasing: Lib.extendDeep({}, directionAttrs, {\n        line: { color: { dflt: INCREASING_COLOR } }\n    }),\n\n    decreasing: Lib.extendDeep({}, directionAttrs, {\n        line: { color: { dflt: DECREASING_COLOR } }\n    }),\n\n    text: {\n        valType: 'string',\n        role: 'info',\n        dflt: '',\n        arrayOk: true,\n        description: [\n            'Sets hover text elements associated with each sample point.',\n            'If a single string, the same string appears over',\n            'all the data points.',\n            'If an array of string, the items are mapped in order to',\n            'this trace\\'s sample points.'\n        ].join(' ')\n    },\n\n    tickwidth: {\n        valType: 'number',\n        min: 0,\n        max: 0.5,\n        dflt: 0.3,\n        role: 'style',\n        description: [\n            'Sets the width of the open/close tick marks',\n            'relative to the *x* minimal interval.'\n        ].join(' ')\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/lib/carpet.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = require('../src/traces/carpet');\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/carpet/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Carpet = {};\n\nCarpet.attributes = require('./attributes');\nCarpet.supplyDefaults = require('./defaults');\nCarpet.plot = require('./plot');\nCarpet.calc = require('./calc');\nCarpet.animatable = true;\n\nCarpet.moduleType = 'trace';\nCarpet.name = 'carpet';\nCarpet.basePlotModule = require('../../plots/cartesian');\nCarpet.categories = ['cartesian', 'carpet', 'carpetAxis', 'notLegendIsolatable'];\nCarpet.meta = {\n    description: [\n        'The data describing carpet axis layout is set in `y` and (optionally)',\n        'also `x`. If only `y` is present, `x` the plot is interpreted as a',\n        'cheater plot and is filled in using the `y` values.',\n\n        '`x` and `y` may either be 2D arrays matching with each dimension matching',\n        'that of `a` and `b`, or they may be 1D arrays with total length equal to',\n        'that of `a` and `b`.'\n    ].join(' ')\n};\n\nmodule.exports = Carpet;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/carpet/attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar extendFlat = require('../../lib/extend').extendFlat;\nvar fontAttrs = require('../../plots/font_attributes');\nvar axisAttrs = require('./axis_attributes');\nvar colorAttrs = require('../../components/color/attributes');\n\nmodule.exports = {\n    carpet: {\n        valType: 'string',\n        role: 'info',\n        description: [\n            'An identifier for this carpet, so that `scattercarpet` and',\n            '`scattercontour` traces can specify a carpet plot on which',\n            'they lie'\n        ].join(' ')\n    },\n    x: {\n        valType: 'data_array',\n        description: [\n            'A two dimensional array of x coordinates at each carpet point.',\n            'If ommitted, the plot is a cheater plot and the xaxis is hidden',\n            'by default.'\n        ].join(' ')\n    },\n    y: {\n        valType: 'data_array',\n        description: 'A two dimensional array of y coordinates at each carpet point.'\n    },\n    a: {\n        valType: 'data_array',\n        description: [\n            'An array containing values of the first parameter value'\n        ].join(' ')\n    },\n    a0: {\n        valType: 'number',\n        dflt: 0,\n        role: 'info',\n        description: [\n            'Alternate to `a`.',\n            'Builds a linear space of a coordinates.',\n            'Use with `da`',\n            'where `a0` is the starting coordinate and `da` the step.'\n        ].join(' ')\n    },\n    da: {\n        valType: 'number',\n        dflt: 1,\n        role: 'info',\n        description: [\n            'Sets the a coordinate step.',\n            'See `a0` for more info.'\n        ].join(' ')\n    },\n    b: {\n        valType: 'data_array',\n        description: 'A two dimensional array of y coordinates at each carpet point.'\n    },\n    b0: {\n        valType: 'number',\n        dflt: 0,\n        role: 'info',\n        description: [\n            'Alternate to `b`.',\n            'Builds a linear space of a coordinates.',\n            'Use with `db`',\n            'where `b0` is the starting coordinate and `db` the step.'\n        ].join(' ')\n    },\n    db: {\n        valType: 'number',\n        dflt: 1,\n        role: 'info',\n        description: [\n            'Sets the b coordinate step.',\n            'See `b0` for more info.'\n        ].join(' ')\n    },\n    cheaterslope: {\n        valType: 'number',\n        role: 'info',\n        dflt: 1,\n        description: [\n            'The shift applied to each successive row of data in creating a cheater plot.',\n            'Only used if `x` is been ommitted.'\n        ].join(' ')\n    },\n    aaxis: extendFlat({}, axisAttrs),\n    baxis: extendFlat({}, axisAttrs),\n    font: {\n        family: extendFlat({}, fontAttrs.family, {\n            dflt: '\"Open Sans\", verdana, arial, sans-serif'\n        }),\n        size: extendFlat({}, fontAttrs.size, {\n            dflt: 12\n        }),\n        color: extendFlat({}, fontAttrs.color, {\n            dflt: colorAttrs.defaultLine\n        }),\n    },\n    color: {\n        valType: 'color',\n        dflt: colorAttrs.defaultLine,\n        role: 'style',\n        description: [\n            'Sets default for all colors associated with this axis',\n            'all at once: line, font, tick, and grid colors.',\n            'Grid color is lightened by blending this with the plot background',\n            'Individual pieces can override this.'\n        ].join(' ')\n    },\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/carpet/axis_attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar extendFlat = require('../../lib/extend').extendFlat;\nvar fontAttrs = require('../../plots/font_attributes');\nvar colorAttrs = require('../../components/color/attributes');\n\nmodule.exports = {\n    color: {\n        valType: 'color',\n        role: 'style',\n        description: [\n            'Sets default for all colors associated with this axis',\n            'all at once: line, font, tick, and grid colors.',\n            'Grid color is lightened by blending this with the plot background',\n            'Individual pieces can override this.'\n        ].join(' ')\n    },\n    smoothing: {\n        valType: 'number',\n        dflt: 1,\n        min: 0,\n        max: 1.3,\n        role: 'info'\n    },\n    title: {\n        valType: 'string',\n        role: 'info',\n        description: 'Sets the title of this axis.'\n    },\n    titlefont: extendFlat({}, fontAttrs, {\n        description: [\n            'Sets this axis\\' title font.'\n        ].join(' ')\n    }),\n    titleoffset: {\n        valType: 'number',\n        role: 'info',\n        dflt: 10,\n        description: [\n            'An additional amount by which to offset the title from the tick',\n            'labels, given in pixels'\n        ].join(' '),\n    },\n    type: {\n        valType: 'enumerated',\n        // '-' means we haven't yet run autotype or couldn't find any data\n        // it gets turned into linear in gd._fullLayout but not copied back\n        // to gd.data like the others are.\n        values: ['-', 'linear', 'date', 'category'],\n        dflt: '-',\n        role: 'info',\n        description: [\n            'Sets the axis type.',\n            'By default, plotly attempts to determined the axis type',\n            'by looking into the data of the traces that referenced',\n            'the axis in question.'\n        ].join(' ')\n    },\n    autorange: {\n        valType: 'enumerated',\n        values: [true, false, 'reversed'],\n        dflt: true,\n        role: 'style',\n        description: [\n            'Determines whether or not the range of this axis is',\n            'computed in relation to the input data.',\n            'See `rangemode` for more info.',\n            'If `range` is provided, then `autorange` is set to *false*.'\n        ].join(' ')\n    },\n    rangemode: {\n        valType: 'enumerated',\n        values: ['normal', 'tozero', 'nonnegative'],\n        dflt: 'normal',\n        role: 'style',\n        description: [\n            'If *normal*, the range is computed in relation to the extrema',\n            'of the input data.',\n            'If *tozero*`, the range extends to 0,',\n            'regardless of the input data',\n            'If *nonnegative*, the range is non-negative,',\n            'regardless of the input data.'\n        ].join(' ')\n    },\n    range: {\n        valType: 'info_array',\n        role: 'info',\n        items: [\n            {valType: 'any'},\n            {valType: 'any'}\n        ],\n        description: [\n            'Sets the range of this axis.',\n            'If the axis `type` is *log*, then you must take the log of your',\n            'desired range (e.g. to set the range from 1 to 100,',\n            'set the range from 0 to 2).',\n            'If the axis `type` is *date*, it should be date strings,',\n            'like date data, though Date objects and unix milliseconds',\n            'will be accepted and converted to strings.',\n            'If the axis `type` is *category*, it should be numbers,',\n            'using the scale where each category is assigned a serial',\n            'number from zero in the order it appears.'\n        ].join(' ')\n    },\n\n    fixedrange: {\n        valType: 'boolean',\n        dflt: false,\n        role: 'info',\n        description: [\n            'Determines whether or not this axis is zoom-able.',\n            'If true, then zoom is disabled.'\n        ].join(' ')\n    },\n    cheatertype: {\n        valType: 'enumerated',\n        values: ['index', 'value'],\n        dflt: 'value',\n        role: 'info'\n    },\n    tickmode: {\n        valType: 'enumerated',\n        values: ['linear', 'array'],\n        dflt: 'array',\n        role: 'info',\n    },\n    nticks: {\n        valType: 'integer',\n        min: 0,\n        dflt: 0,\n        role: 'style',\n        description: [\n            'Specifies the maximum number of ticks for the particular axis.',\n            'The actual number of ticks will be chosen automatically to be',\n            'less than or equal to `nticks`.',\n            'Has an effect only if `tickmode` is set to *auto*.'\n        ].join(' ')\n    },\n    tickvals: {\n        valType: 'data_array',\n        description: [\n            'Sets the values at which ticks on this axis appear.',\n            'Only has an effect if `tickmode` is set to *array*.',\n            'Used with `ticktext`.'\n        ].join(' ')\n    },\n    ticktext: {\n        valType: 'data_array',\n        description: [\n            'Sets the text displayed at the ticks position via `tickvals`.',\n            'Only has an effect if `tickmode` is set to *array*.',\n            'Used with `tickvals`.'\n        ].join(' ')\n    },\n    showticklabels: {\n        valType: 'enumerated',\n        values: ['start', 'end', 'both', 'none'],\n        dflt: 'start',\n        role: 'style',\n        description: [\n            'Determines whether axis labels are drawn on the low side,',\n            'the high side, both, or neither side of the axis.'\n        ].join(' ')\n    },\n    tickfont: extendFlat({}, fontAttrs, {\n        description: 'Sets the tick font.'\n    }),\n    tickangle: {\n        valType: 'angle',\n        dflt: 'auto',\n        role: 'style',\n        description: [\n            'Sets the angle of the tick labels with respect to the horizontal.',\n            'For example, a `tickangle` of -90 draws the tick labels',\n            'vertically.'\n        ].join(' ')\n    },\n    tickprefix: {\n        valType: 'string',\n        dflt: '',\n        role: 'style',\n        description: 'Sets a tick label prefix.'\n    },\n    showtickprefix: {\n        valType: 'enumerated',\n        values: ['all', 'first', 'last', 'none'],\n        dflt: 'all',\n        role: 'style',\n        description: [\n            'If *all*, all tick labels are displayed with a prefix.',\n            'If *first*, only the first tick is displayed with a prefix.',\n            'If *last*, only the last tick is displayed with a suffix.',\n            'If *none*, tick prefixes are hidden.'\n        ].join(' ')\n    },\n    ticksuffix: {\n        valType: 'string',\n        dflt: '',\n        role: 'style',\n        description: 'Sets a tick label suffix.'\n    },\n    showticksuffix: {\n        valType: 'enumerated',\n        values: ['all', 'first', 'last', 'none'],\n        dflt: 'all',\n        role: 'style',\n        description: 'Same as `showtickprefix` but for tick suffixes.'\n    },\n    showexponent: {\n        valType: 'enumerated',\n        values: ['all', 'first', 'last', 'none'],\n        dflt: 'all',\n        role: 'style',\n        description: [\n            'If *all*, all exponents are shown besides their significands.',\n            'If *first*, only the exponent of the first tick is shown.',\n            'If *last*, only the exponent of the last tick is shown.',\n            'If *none*, no exponents appear.'\n        ].join(' ')\n    },\n    exponentformat: {\n        valType: 'enumerated',\n        values: ['none', 'e', 'E', 'power', 'SI', 'B'],\n        dflt: 'B',\n        role: 'style',\n        description: [\n            'Determines a formatting rule for the tick exponents.',\n            'For example, consider the number 1,000,000,000.',\n            'If *none*, it appears as 1,000,000,000.',\n            'If *e*, 1e+9.',\n            'If *E*, 1E+9.',\n            'If *power*, 1x10^9 (with 9 in a super script).',\n            'If *SI*, 1G.',\n            'If *B*, 1B.'\n        ].join(' ')\n    },\n    separatethousands: {\n        valType: 'boolean',\n        dflt: false,\n        role: 'style',\n        description: [\n            'If \"true\", even 4-digit integers are separated'\n        ].join(' ')\n    },\n    tickformat: {\n        valType: 'string',\n        dflt: '',\n        role: 'style',\n        description: [\n            'Sets the tick label formatting rule using d3 formatting mini-languages',\n            'which are very similar to those in Python. For numbers, see:',\n            'https://github.com/d3/d3-format/blob/master/README.md#locale_format',\n            'And for dates see:',\n            'https://github.com/d3/d3-time-format/blob/master/README.md#locale_format',\n            'We add one item to d3\\'s date formatter: *%{n}f* for fractional seconds',\n            'with n digits. For example, *2016-10-13 09:15:23.456* with tickformat',\n            '*%H~%M~%S.%2f* would display *09~15~23.46*'\n        ].join(' ')\n    },\n    categoryorder: {\n        valType: 'enumerated',\n        values: [\n            'trace', 'category ascending', 'category descending', 'array'\n            /* , 'value ascending', 'value descending'*/ // value ascending / descending to be implemented later\n        ],\n        dflt: 'trace',\n        role: 'info',\n        description: [\n            'Specifies the ordering logic for the case of categorical variables.',\n            'By default, plotly uses *trace*, which specifies the order that is present in the data supplied.',\n            'Set `categoryorder` to *category ascending* or *category descending* if order should be determined by',\n            'the alphanumerical order of the category names.',\n            /* 'Set `categoryorder` to *value ascending* or *value descending* if order should be determined by the',\n            'numerical order of the values.',*/ // // value ascending / descending to be implemented later\n            'Set `categoryorder` to *array* to derive the ordering from the attribute `categoryarray`. If a category',\n            'is not found in the `categoryarray` array, the sorting behavior for that attribute will be identical to',\n            'the *trace* mode. The unspecified categories will follow the categories in `categoryarray`.'\n        ].join(' ')\n    },\n    categoryarray: {\n        valType: 'data_array',\n        role: 'info',\n        description: [\n            'Sets the order in which categories on this axis appear.',\n            'Only has an effect if `categoryorder` is set to *array*.',\n            'Used with `categoryorder`.'\n        ].join(' ')\n    },\n    labelpadding: {\n        valType: 'integer',\n        role: 'style',\n        dflt: 10,\n        description: 'Extra padding between label and the axis'\n    },\n    labelprefix: {\n        valType: 'string',\n        role: 'style',\n        description: 'Sets a axis label prefix.'\n    },\n    labelsuffix: {\n        valType: 'string',\n        dflt: '',\n        role: 'style',\n        description: 'Sets a axis label suffix.'\n    },\n    // lines and grids\n    showline: {\n        valType: 'boolean',\n        dflt: false,\n        role: 'style',\n        description: [\n            'Determines whether or not a line bounding this axis is drawn.'\n        ].join(' ')\n    },\n    linecolor: {\n        valType: 'color',\n        dflt: colorAttrs.defaultLine,\n        role: 'style',\n        description: 'Sets the axis line color.'\n    },\n    linewidth: {\n        valType: 'number',\n        min: 0,\n        dflt: 1,\n        role: 'style',\n        description: 'Sets the width (in px) of the axis line.'\n    },\n    gridcolor: {\n        valType: 'color',\n        role: 'style',\n        description: 'Sets the axis line color.'\n    },\n    gridwidth: {\n        valType: 'number',\n        min: 0,\n        dflt: 1,\n        role: 'style',\n        description: 'Sets the width (in px) of the axis line.'\n    },\n    showgrid: {\n        valType: 'boolean',\n        role: 'style',\n        dflt: true,\n        description: [\n            'Determines whether or not grid lines are drawn.',\n            'If *true*, the grid lines are drawn at every tick mark.'\n        ].join(' ')\n    },\n    minorgridcount: {\n        valType: 'integer',\n        min: 0,\n        dflt: 0,\n        role: 'info',\n        description: 'Sets the number of minor grid ticks per major grid tick'\n    },\n    minorgridwidth: {\n        valType: 'number',\n        min: 0,\n        dflt: 1,\n        role: 'style',\n        description: 'Sets the width (in px) of the grid lines.'\n    },\n    minorgridcolor: {\n        valType: 'color',\n        dflt: colorAttrs.lightLine,\n        role: 'style',\n        description: 'Sets the color of the grid lines.'\n    },\n    startline: {\n        valType: 'boolean',\n        role: 'style',\n        description: [\n            'Determines whether or not a line is drawn at along the starting value',\n            'of this axis.',\n            'If *true*, the start line is drawn on top of the grid lines.'\n        ].join(' ')\n    },\n    startlinecolor: {\n        valType: 'color',\n        role: 'style',\n        description: 'Sets the line color of the start line.'\n    },\n    startlinewidth: {\n        valType: 'number',\n        dflt: 1,\n        role: 'style',\n        description: 'Sets the width (in px) of the start line.'\n    },\n    endline: {\n        valType: 'boolean',\n        role: 'style',\n        description: [\n            'Determines whether or not a line is drawn at along the final value',\n            'of this axis.',\n            'If *true*, the end line is drawn on top of the grid lines.'\n        ].join(' ')\n    },\n    endlinewidth: {\n        valType: 'number',\n        dflt: 1,\n        role: 'style',\n        description: 'Sets the width (in px) of the end line.'\n    },\n    endlinecolor: {\n        valType: 'color',\n        role: 'style',\n        description: 'Sets the line color of the end line.'\n    },\n    tick0: {\n        valType: 'number',\n        min: 0,\n        dflt: 0,\n        role: 'info',\n        description: 'The starting index of grid lines along the axis'\n    },\n    dtick: {\n        valType: 'number',\n        min: 0,\n        dflt: 1,\n        role: 'info',\n        description: 'The stride between grid lines along the axis'\n    },\n    arraytick0: {\n        valType: 'integer',\n        min: 0,\n        dflt: 0,\n        role: 'info',\n        description: 'The starting index of grid lines along the axis'\n    },\n    arraydtick: {\n        valType: 'integer',\n        min: 1,\n        dflt: 1,\n        role: 'info',\n        description: 'The stride between grid lines along the axis'\n    },\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/carpet/defaults.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar handleXYDefaults = require('./xy_defaults');\nvar handleABDefaults = require('./ab_defaults');\nvar setConvert = require('./set_convert');\nvar attributes = require('./attributes');\nvar colorAttrs = require('../../components/color/attributes');\n\nmodule.exports = function supplyDefaults(traceIn, traceOut, dfltColor, fullLayout) {\n    function coerce(attr, dflt) {\n        return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);\n    }\n\n    var defaultColor = coerce('color', colorAttrs.defaultLine);\n    Lib.coerceFont(coerce, 'font');\n\n    coerce('carpet');\n\n    handleABDefaults(traceIn, traceOut, fullLayout, coerce, defaultColor);\n\n    if(!traceOut.a || !traceOut.b) {\n        traceOut.visible = false;\n        return;\n    }\n\n    if(traceOut.a.length < 3) {\n        traceOut.aaxis.smoothing = 0;\n    }\n\n    if(traceOut.b.length < 3) {\n        traceOut.baxis.smoothing = 0;\n    }\n\n    // NB: the input is x/y arrays. You should know that the *first* dimension of x and y\n    // corresponds to b and the second to a. This sounds backwards but ends up making sense\n    // the important part to know is that when you write y[j][i], j goes from 0 to b.length - 1\n    // and i goes from 0 to a.length - 1.\n    var len = handleXYDefaults(traceIn, traceOut, coerce);\n\n    setConvert(traceOut);\n\n    if(traceOut._cheater) {\n        coerce('cheaterslope');\n    }\n\n    if(!len) {\n        traceOut.visible = false;\n        return;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/carpet/xy_defaults.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar hasColumns = require('./has_columns');\nvar convertColumnData = require('../heatmap/convert_column_xyz');\n\nmodule.exports = function handleXYDefaults(traceIn, traceOut, coerce) {\n    var cols = [];\n    var x = coerce('x');\n\n    var needsXTransform = x && !hasColumns(x);\n    if(needsXTransform) cols.push('x');\n\n    traceOut._cheater = !x;\n\n    var y = coerce('y');\n\n    var needsYTransform = y && !hasColumns(y);\n    if(needsYTransform) cols.push('y');\n\n    if(!x && !y) return;\n\n    if(cols.length) {\n        convertColumnData(traceOut, traceOut.aaxis, traceOut.baxis, 'a', 'b', cols);\n    }\n\n    return true;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/carpet/has_columns.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nmodule.exports = function(data) {\n    return Array.isArray(data[0]);\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/heatmap/convert_column_xyz.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nmodule.exports = function convertColumnData(trace, ax1, ax2, var1Name, var2Name, arrayVarNames) {\n    var1Name = var1Name || 'x';\n    var2Name = var2Name || 'y';\n    arrayVarNames = arrayVarNames || ['z'];\n\n    var col1 = trace[var1Name].slice(),\n        col2 = trace[var2Name].slice(),\n        textCol = trace.text,\n        colLen = Math.min(col1.length, col2.length),\n        hasColumnText = (textCol !== undefined && !Array.isArray(textCol[0])),\n        col1Calendar = trace[var1Name + 'calendar'],\n        col2Calendar = trace[var2Name + 'calendar'];\n\n    var i, j, arrayVar, newArray, arrayVarName;\n\n    for(i = 0; i < arrayVarNames.length; i++) {\n        arrayVar = trace[arrayVarNames[i]];\n        if(arrayVar) colLen = Math.min(colLen, arrayVar.length);\n    }\n\n    if(colLen < col1.length) col1 = col1.slice(0, colLen);\n    if(colLen < col2.length) col2 = col2.slice(0, colLen);\n\n    for(i = 0; i < colLen; i++) {\n        col1[i] = ax1.d2c(col1[i], 0, col1Calendar);\n        col2[i] = ax2.d2c(col2[i], 0, col2Calendar);\n    }\n\n    var col1dv = Lib.distinctVals(col1),\n        col1vals = col1dv.vals,\n        col2dv = Lib.distinctVals(col2),\n        col2vals = col2dv.vals,\n        newArrays = [];\n\n    for(i = 0; i < arrayVarNames.length; i++) {\n        newArrays[i] = Lib.init2dArray(col2vals.length, col1vals.length);\n    }\n\n    var i1, i2, text;\n\n    if(hasColumnText) text = Lib.init2dArray(col2vals.length, col1vals.length);\n\n    for(i = 0; i < colLen; i++) {\n        if(col1[i] !== BADNUM && col2[i] !== BADNUM) {\n            i1 = Lib.findBin(col1[i] + col1dv.minDiff / 2, col1vals);\n            i2 = Lib.findBin(col2[i] + col2dv.minDiff / 2, col2vals);\n\n            for(j = 0; j < arrayVarNames.length; j++) {\n                arrayVarName = arrayVarNames[j];\n                arrayVar = trace[arrayVarName];\n                newArray = newArrays[j];\n                newArray[i2][i1] = arrayVar[i];\n            }\n\n            if(hasColumnText) text[i2][i1] = textCol[i];\n        }\n    }\n\n    trace[var1Name] = col1vals;\n    trace[var2Name] = col2vals;\n    for(j = 0; j < arrayVarNames.length; j++) {\n        trace[arrayVarNames[j]] = newArrays[j];\n    }\n    if(hasColumnText) trace.text = text;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/carpet/ab_defaults.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar handleAxisDefaults = require('./axis_defaults');\n\nmodule.exports = function handleABDefaults(traceIn, traceOut, fullLayout, coerce, dfltColor) {\n    var a = coerce('a');\n\n    if(!a) {\n        coerce('da');\n        coerce('a0');\n    }\n\n    var b = coerce('b');\n\n    if(!b) {\n        coerce('db');\n        coerce('b0');\n    }\n\n    mimickAxisDefaults(traceIn, traceOut, fullLayout, dfltColor);\n\n    return;\n};\n\nfunction mimickAxisDefaults(traceIn, traceOut, fullLayout, dfltColor) {\n    var axesList = ['aaxis', 'baxis'];\n\n    axesList.forEach(function(axName) {\n        var axLetter = axName.charAt(0);\n        var axIn = traceIn[axName] || {};\n        var axOut = {};\n\n        var defaultOptions = {\n            tickfont: 'x',\n            id: axLetter + 'axis',\n            letter: axLetter,\n            font: traceOut.font,\n            name: axName,\n            data: traceIn[axLetter],\n            calendar: traceOut.calendar,\n            dfltColor: dfltColor,\n            bgColor: fullLayout.paper_bgcolor,\n            fullLayout: fullLayout\n        };\n\n        handleAxisDefaults(axIn, axOut, defaultOptions);\n\n        axOut._categories = axOut._categories || [];\n\n        traceOut[axName] = axOut;\n\n        // so we don't have to repeat autotype unnecessarily,\n        // copy an autotype back to traceIn\n        if(!traceIn[axName] && axIn.type !== '-') {\n            traceIn[axName] = {type: axIn.type};\n        }\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/carpet/axis_defaults.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar carpetAttrs = require('./attributes');\n\nvar addOpacity = require('../../components/color').addOpacity;\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar handleTickValueDefaults = require('../../plots/cartesian/tick_value_defaults');\nvar handleTickLabelDefaults = require('../../plots/cartesian/tick_label_defaults');\nvar handleCategoryOrderDefaults = require('../../plots/cartesian/category_order_defaults');\nvar setConvert = require('../../plots/cartesian/set_convert');\nvar orderedCategories = require('../../plots/cartesian/ordered_categories');\nvar autoType = require('../../plots/cartesian/axis_autotype');\n\n/**\n * options: object containing:\n *\n *  letter: 'x' or 'y'\n *  title: name of the axis (ie 'Colorbar') to go in default title\n *  name: axis object name (ie 'xaxis') if one should be stored\n *  font: the default font to inherit\n *  outerTicks: boolean, should ticks default to outside?\n *  showGrid: boolean, should gridlines be shown by default?\n *  noHover: boolean, this axis doesn't support hover effects?\n *  data: the plot data to use in choosing auto type\n *  bgColor: the plot background color, to calculate default gridline colors\n */\nmodule.exports = function handleAxisDefaults(containerIn, containerOut, options) {\n    var letter = options.letter,\n        font = options.font || {},\n        attributes = carpetAttrs[letter + 'axis'];\n\n    options.noHover = true;\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(containerIn, containerOut, attributes, attr, dflt);\n    }\n\n    function coerce2(attr, dflt) {\n        return Lib.coerce2(containerIn, containerOut, attributes, attr, dflt);\n    }\n\n    // set up some private properties\n    if(options.name) {\n        containerOut._name = options.name;\n        containerOut._id = options.name;\n    }\n\n    // now figure out type and do some more initialization\n    var axType = coerce('type');\n    if(axType === '-') {\n        if(options.data) setAutoType(containerOut, options.data);\n\n        if(containerOut.type === '-') {\n            containerOut.type = 'linear';\n        }\n        else {\n            // copy autoType back to input axis\n            // note that if this object didn't exist\n            // in the input layout, we have to put it in\n            // this happens in the main supplyDefaults function\n            axType = containerIn.type = containerOut.type;\n        }\n    }\n\n    coerce('smoothing');\n    coerce('cheatertype');\n\n    coerce('showticklabels');\n    coerce('labelprefix', letter + ' = ');\n    coerce('labelsuffix');\n    coerce('showtickprefix');\n    coerce('showticksuffix');\n\n    coerce('separatethousands');\n    coerce('tickformat');\n    coerce('exponentformat');\n    coerce('showexponent');\n    coerce('categoryorder');\n\n    coerce('tickmode');\n    coerce('tickvals');\n    coerce('ticktext');\n    coerce('tick0');\n    coerce('dtick');\n\n    if(containerOut.tickmode === 'array') {\n        coerce('arraytick0');\n        coerce('arraydtick');\n    }\n\n    coerce('labelpadding');\n\n    containerOut._hovertitle = letter;\n\n\n    if(axType === 'date') {\n        var handleCalendarDefaults = Registry.getComponentMethod('calendars', 'handleDefaults');\n        handleCalendarDefaults(containerIn, containerOut, 'calendar', options.calendar);\n    }\n\n    setConvert(containerOut, options.fullLayout);\n\n    var dfltColor = coerce('color', options.dfltColor);\n    // if axis.color was provided, use it for fonts too; otherwise,\n    // inherit from global font color in case that was provided.\n    var dfltFontColor = (dfltColor === containerIn.color) ? dfltColor : font.color;\n\n    coerce('title');\n    Lib.coerceFont(coerce, 'titlefont', {\n        family: font.family,\n        size: Math.round(font.size * 1.2),\n        color: dfltFontColor\n    });\n\n    coerce('titleoffset');\n\n    coerce('tickangle');\n\n    var autoRange = coerce('autorange', !containerOut.isValidRange(containerIn.range));\n\n    if(autoRange) coerce('rangemode');\n\n    coerce('range');\n    containerOut.cleanRange();\n\n    coerce('fixedrange');\n\n    handleTickValueDefaults(containerIn, containerOut, coerce, axType);\n    handleTickLabelDefaults(containerIn, containerOut, coerce, axType, options);\n    handleCategoryOrderDefaults(containerIn, containerOut, coerce);\n\n    var gridColor = coerce2('gridcolor', addOpacity(dfltColor, 0.3));\n    var gridWidth = coerce2('gridwidth');\n    var showGrid = coerce('showgrid');\n\n    if(!showGrid) {\n        delete containerOut.gridcolor;\n        delete containerOut.gridwidth;\n    }\n\n    var startLineColor = coerce2('startlinecolor', dfltColor);\n    var startLineWidth = coerce2('startlinewidth', gridWidth);\n    var showStartLine = coerce('startline', containerOut.showgrid || !!startLineColor || !!startLineWidth);\n\n    if(!showStartLine) {\n        delete containerOut.startlinecolor;\n        delete containerOut.startlinewidth;\n    }\n\n    var endLineColor = coerce2('endlinecolor', dfltColor);\n    var endLineWidth = coerce2('endlinewidth', gridWidth);\n    var showEndLine = coerce('endline', containerOut.showgrid || !!endLineColor || !!endLineWidth);\n\n    if(!showEndLine) {\n        delete containerOut.endlinecolor;\n        delete containerOut.endlinewidth;\n    }\n\n    if(!showGrid) {\n        delete containerOut.gridcolor;\n        delete containerOut.gridWidth;\n    } else {\n        coerce('minorgridcount');\n        coerce('minorgridwidth', gridWidth);\n        coerce('minorgridcolor', addOpacity(gridColor, 0.06));\n\n        if(!containerOut.minorgridcount) {\n            delete containerOut.minorgridwidth;\n            delete containerOut.minorgridcolor;\n        }\n    }\n\n    containerOut._separators = options.fullLayout.separators;\n\n    // fill in categories\n    containerOut._initialCategories = axType === 'category' ?\n        orderedCategories(letter, containerOut.categoryorder, containerOut.categoryarray, options.data) :\n        [];\n\n    if(containerOut.showticklabels === 'none') {\n        delete containerOut.tickfont;\n        delete containerOut.tickangle;\n        delete containerOut.showexponent;\n        delete containerOut.exponentformat;\n        delete containerOut.tickformat;\n        delete containerOut.showticksuffix;\n        delete containerOut.showtickprefix;\n    }\n\n    if(!containerOut.showticksuffix) {\n        delete containerOut.ticksuffix;\n    }\n\n    if(!containerOut.showtickprefix) {\n        delete containerOut.tickprefix;\n    }\n\n    // It needs to be coerced, then something above overrides this deep in the axis code,\n    // but no, we *actually* want to coerce this.\n    coerce('tickmode');\n\n    if(!containerOut.title || (containerOut.title && containerOut.title.length === 0)) {\n        delete containerOut.titlefont;\n        delete containerOut.titleoffset;\n    }\n\n    return containerOut;\n};\n\nfunction setAutoType(ax, data) {\n    // new logic: let people specify any type they want,\n    // only autotype if type is '-'\n    if(ax.type !== '-') return;\n\n    var id = ax._id,\n        axLetter = id.charAt(0);\n\n    var calAttr = axLetter + 'calendar',\n        calendar = ax[calAttr];\n\n    ax.type = autoType(data, calendar);\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/carpet/set_convert.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar constants = require('./constants');\nvar search = require('../../lib/search').findBin;\nvar computeControlPoints = require('./compute_control_points');\nvar createSplineEvaluator = require('./create_spline_evaluator');\nvar createIDerivativeEvaluator = require('./create_i_derivative_evaluator');\nvar createJDerivativeEvaluator = require('./create_j_derivative_evaluator');\n\n/*\n * Create conversion functions to go from one basis to another. In particular the letter\n * abbreviations are:\n *\n *   i: i/j coordinates along the grid. Integer values correspond to data points\n *   a: real-valued coordinates along the a/b axes\n *   c: cartesian x-y coordinates\n *   p: screen-space pixel coordinates\n */\nmodule.exports = function setConvert(trace) {\n    var a = trace.a;\n    var b = trace.b;\n    var na = trace.a.length;\n    var nb = trace.b.length;\n    var aax = trace.aaxis;\n    var bax = trace.baxis;\n\n    // Grab the limits once rather than recomputing the bounds for every point\n    // independently:\n    var amin = a[0];\n    var amax = a[na - 1];\n    var bmin = b[0];\n    var bmax = b[nb - 1];\n    var arange = a[a.length - 1] - a[0];\n    var brange = b[b.length - 1] - b[0];\n\n    // Compute the tolerance so that points are visible slightly outside the\n    // defined carpet axis:\n    var atol = arange * constants.RELATIVE_CULL_TOLERANCE;\n    var btol = brange * constants.RELATIVE_CULL_TOLERANCE;\n\n    // Expand the limits to include the relative tolerance:\n    amin -= atol;\n    amax += atol;\n    bmin -= btol;\n    bmax += btol;\n\n    trace.isVisible = function(a, b) {\n        return a > amin && a < amax && b > bmin && b < bmax;\n    };\n\n    trace.isOccluded = function(a, b) {\n        return a < amin || a > amax || b < bmin || b > bmax;\n    };\n\n    // XXX: ONLY PASSTHRU. ONLY. No, ONLY.\n    aax.c2p = function(v) { return v; };\n    bax.c2p = function(v) { return v; };\n\n    trace.setScale = function() {\n        var x = trace.x;\n        var y = trace.y;\n\n        // This is potentially a very expensive step! It does the bulk of the work of constructing\n        // an expanded basis of control points. Note in particular that it overwrites the existing\n        // basis without creating a new array since that would potentially thrash the garbage\n        // collector.\n        var result = computeControlPoints(trace.xctrl, trace.yctrl, x, y, aax.smoothing, bax.smoothing);\n        trace.xctrl = result[0];\n        trace.yctrl = result[1];\n\n        // This step is the second step in the process, but it's somewhat simpler. It just unrolls\n        // some logic since it would be unnecessarily expensive to compute both interpolations\n        // nearly identically but separately and to include a bunch of linear vs. bicubic logic in\n        // every single call.\n        trace.evalxy = createSplineEvaluator([trace.xctrl, trace.yctrl], na, nb, aax.smoothing, bax.smoothing);\n\n        trace.dxydi = createIDerivativeEvaluator([trace.xctrl, trace.yctrl], aax.smoothing, bax.smoothing);\n        trace.dxydj = createJDerivativeEvaluator([trace.xctrl, trace.yctrl], aax.smoothing, bax.smoothing);\n    };\n\n    /*\n     * Convert from i/j data grid coordinates to a/b values. Note in particular that this\n     * is *linear* interpolation, even if the data is interpolated bicubically.\n     */\n    trace.i2a = function(i) {\n        var i0 = Math.max(0, Math.floor(i[0]), na - 2);\n        var ti = i[0] - i0;\n        return (1 - ti) * a[i0] + ti * a[i0 + 1];\n    };\n\n    trace.j2b = function(j) {\n        var j0 = Math.max(0, Math.floor(j[1]), na - 2);\n        var tj = j[1] - j0;\n        return (1 - tj) * b[j0] + tj * b[j0 + 1];\n    };\n\n    trace.ij2ab = function(ij) {\n        return [trace.i2a(ij[0]), trace.j2b(ij[1])];\n    };\n\n    /*\n     * Convert from a/b coordinates to i/j grid-numbered coordinates. This requires searching\n     * through the a/b data arrays and assumes they are monotonic, which is presumed to have\n     * been enforced already.\n     */\n    trace.a2i = function(aval) {\n        var i0 = Math.max(0, Math.min(search(aval, a), na - 2));\n        var a0 = a[i0];\n        var a1 = a[i0 + 1];\n        return Math.max(0, Math.min(na - 1, i0 + (aval - a0) / (a1 - a0)));\n    };\n\n    trace.b2j = function(bval) {\n        var j0 = Math.max(0, Math.min(search(bval, b), nb - 2));\n        var b0 = b[j0];\n        var b1 = b[j0 + 1];\n        return Math.max(0, Math.min(nb - 1, j0 + (bval - b0) / (b1 - b0)));\n    };\n\n    trace.ab2ij = function(ab) {\n        return [trace.a2i(ab[0]), trace.b2j(ab[1])];\n    };\n\n    /*\n     * Convert from i/j coordinates to x/y caretesian coordinates. This means either bilinear\n     * or bicubic spline evaluation, but the hard part is already done at this point.\n     */\n    trace.i2c = function(i, j) {\n        return trace.evalxy([], i, j);\n    };\n\n    trace.ab2xy = function(aval, bval, extrapolate) {\n        if(!extrapolate && (aval < a[0] || aval > a[na - 1] | bval < b[0] || bval > b[nb - 1])) {\n            return [false, false];\n        }\n        var i = trace.a2i(aval);\n        var j = trace.b2j(bval);\n\n        var pt = trace.evalxy([], i, j);\n\n        if(extrapolate) {\n            // This section uses the boundary derivatives to extrapolate linearly outside\n            // the defined range. Consider a scatter line with one point inside the carpet\n            // axis and one point outside. If we don't extrapolate, we can't draw the line\n            // at all.\n            var iex = 0;\n            var jex = 0;\n            var der = [];\n\n            var i0, ti, j0, tj;\n            if(aval < a[0]) {\n                i0 = 0;\n                ti = 0;\n                iex = (aval - a[0]) / (a[1] - a[0]);\n            } else if(aval > a[na - 1]) {\n                i0 = na - 2;\n                ti = 1;\n                iex = (aval - a[na - 1]) / (a[na - 1] - a[na - 2]);\n            } else {\n                i0 = Math.max(0, Math.min(na - 2, Math.floor(i)));\n                ti = i - i0;\n            }\n\n            if(bval < b[0]) {\n                j0 = 0;\n                tj = 0;\n                jex = (bval - b[0]) / (b[1] - b[0]);\n            } else if(bval > b[nb - 1]) {\n                j0 = nb - 2;\n                tj = 1;\n                jex = (bval - b[nb - 1]) / (b[nb - 1] - b[nb - 2]);\n            } else {\n                j0 = Math.max(0, Math.min(nb - 2, Math.floor(j)));\n                tj = j - j0;\n            }\n\n            if(iex) {\n                trace.dxydi(der, i0, j0, ti, tj);\n                pt[0] += der[0] * iex;\n                pt[1] += der[1] * iex;\n            }\n\n            if(jex) {\n                trace.dxydj(der, i0, j0, ti, tj);\n                pt[0] += der[0] * jex;\n                pt[1] += der[1] * jex;\n            }\n        }\n\n        return pt;\n    };\n\n\n    trace.c2p = function(xy, xa, ya) {\n        return [xa.c2p(xy[0]), ya.c2p(xy[1])];\n    };\n\n    trace.p2x = function(p, xa, ya) {\n        return [xa.p2c(p[0]), ya.p2c(p[1])];\n    };\n\n    trace.dadi = function(i /* , u*/) {\n        // Right now only a piecewise linear a or b basis is permitted since smoother interpolation\n        // would cause monotonicity problems. As a retult, u is entirely disregarded in this\n        // computation, though we'll specify it as a parameter for the sake of completeness and\n        // future-proofing. It would be possible to use monotonic cubic interpolation, for example.\n        //\n        // See: https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\n\n        // u = u || 0;\n\n        var i0 = Math.max(0, Math.min(a.length - 2, i));\n\n        // The step (demoninator) is implicitly 1 since that's the grid spacing.\n        return a[i0 + 1] - a[i0];\n    };\n\n    trace.dbdj = function(j /* , v*/) {\n        // See above caveats for dadi which also apply here\n        var j0 = Math.max(0, Math.min(b.length - 2, j));\n\n        // The step (demoninator) is implicitly 1 since that's the grid spacing.\n        return b[j0 + 1] - b[j0];\n    };\n\n    // Takes: grid cell coordinate (i, j) and fractional grid cell coordinates (u, v)\n    // Returns: (dx/da, dy/db)\n    //\n    // NB: separate grid cell + fractional grid cell coordinate format is due to the discontinuous\n    // derivative, as described better in create_i_derivative_evaluator.js\n    trace.dxyda = function(i0, j0, u, v) {\n        var dxydi = trace.dxydi(null, i0, j0, u, v);\n        var dadi = trace.dadi(i0, u);\n\n        return [dxydi[0] / dadi, dxydi[1] / dadi];\n    };\n\n    trace.dxydb = function(i0, j0, u, v) {\n        var dxydj = trace.dxydj(null, i0, j0, u, v);\n        var dbdj = trace.dbdj(j0, v);\n\n        return [dxydj[0] / dbdj, dxydj[1] / dbdj];\n    };\n\n    // Sometimes we don't care about precision and all we really want is decent rough\n    // directions (as is the case with labels). In that case, we can do a very rough finite\n    // difference and spare having to worry about precise grid coordinates:\n    trace.dxyda_rough = function(a, b, reldiff) {\n        var h = arange * (reldiff || 0.1);\n        var plus = trace.ab2xy(a + h, b, true);\n        var minus = trace.ab2xy(a - h, b, true);\n\n        return [\n            (plus[0] - minus[0]) * 0.5 / h,\n            (plus[1] - minus[1]) * 0.5 / h\n        ];\n    };\n\n    trace.dxydb_rough = function(a, b, reldiff) {\n        var h = brange * (reldiff || 0.1);\n        var plus = trace.ab2xy(a, b + h, true);\n        var minus = trace.ab2xy(a, b - h, true);\n\n        return [\n            (plus[0] - minus[0]) * 0.5 / h,\n            (plus[1] - minus[1]) * 0.5 / h\n        ];\n    };\n\n    trace.dpdx = function(xa) {\n        return xa._m;\n    };\n\n    trace.dpdy = function(ya) {\n        return ya._m;\n    };\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/carpet/constants.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nmodule.exports = {\n    RELATIVE_CULL_TOLERANCE: 1e-6\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/carpet/compute_control_points.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar makeControlPoints = require('./catmull_rom');\nvar ensureArray = require('../../lib').ensureArray;\n\n/*\n * Turns a coarse grid into a fine grid with control points.\n *\n * Here's an ASCII representation:\n *\n *       o ----- o ----- o ----- o\n *       |       |       |       |\n *       |       |       |       |\n *       |       |       |       |\n *       o ----- o ----- o ----- o\n *       |       |       |       |\n *       |       |       |       |\n *    ^  |       |       |       |\n *    |  o ----- o ----- o ----- o\n *  b |  |       |       |       |\n *    |  |       |       |       |\n *    |  |       |       |       |\n *       o ----- o ----- o ----- o\n *         ------>\n *           a\n *\n * First of all, note that we want to do this in *cartesian* space. This means\n * we might run into problems when there are extreme differences in x/y scaling,\n * but the alternative is that the topology of the contours might actually be\n * view-dependent, which seems worse. As a fallback, the only parameter that\n * actually affects the result is the *aspect ratio*, so that we can at least\n * improve the situation a bit without going all the way to screen coordinates.\n *\n * This function flattens the points + tangents  into a slightly denser grid of\n * *control points*. The resulting grid looks like this:\n *\n *       9 +--o-o--+ -o-o--+--o-o--+\n *       8 o  o o  o  o o  o  o o  o\n *         |       |       |       |\n *       7 o  o o  o  o o  o  o o  o\n *       6 +--o-o--+ -o-o--+--o-o--+\n *       5 o  o o  o  o o  o  o o  o\n *         |       |       |       |\n *    ^  4 o  o o  o  o o  o  o o  o\n *    |  3 +--o-o--+ -o-o--+--o-o--+\n *  b |  2 o  o o  o  o o  o  o o  o\n *    |    |       |       |       |\n *    |  1 o  o o  o  o o  o  o o  o\n *       0 +--o-o--+ -o-o--+--o-o--+\n *         0  1 2  3  4 5  6  7 8  9\n *         ------>\n *           a\n *\n * where `o`s represent newly-computed control points. the resulting dimension is\n *\n *     (m - 1) * 3 + 1\n *   = 3 * m - 2\n *\n * We could simply store the tangents separately, but that's a nightmare to organize\n * in two dimensions since we'll be slicing grid lines in both directions and since\n * that basically requires very nearly just as much storage as just storing the dense\n * grid.\n *\n * Wow!\n */\n\n\n/*\n * Catmull-rom is biased at the boundaries toward the interior and we actually\n * can't use catmull-rom to compute the control point closest to (but inside)\n * the boundary.\n *\n * A note on plotly's spline interpolation. It uses the catmull rom control point\n * closest to the boundary *as* a quadratic control point. This seems incorrect,\n * so I've elected not to follow that. Given control points 0 and 1, regular plotly\n * splines give *equivalent* cubic control points:\n *\n * Input:\n *\n *   boundary\n *     |                    |\n *     p0           p2      p3    --> interior\n *     0.0          0.667   1.0\n *     |                    |\n *\n * Cubic-equivalent of what plotly splines draw::\n *\n *   boundary\n *     |                    |\n *     p0   p1      p2      p3    --> interior\n *     0.0  0.4444  0.8888  1.0\n *     |                    |\n *\n * What this function fills in:\n *\n *   boundary\n *     |                    |\n *     p0    p1     p2      p3    --> interior\n *     0.0   0.333  0.667   1.0\n *     |                    |\n *\n * Parameters:\n *   p0: boundary point\n *   p2: catmull rom point based on computation at p3\n *   p3: first grid point\n *\n * Of course it works whichever way it's oriented; you just need to interpret the\n * input/output accordingly.\n */\nfunction inferCubicControlPoint(p0, p2, p3) {\n    // Extend p1 away from p0 by 50%. This is the equivalent quadratic point that\n    // would give the same slope as catmull rom at p0.\n    var p2e0 = -0.5 * p3[0] + 1.5 * p2[0];\n    var p2e1 = -0.5 * p3[1] + 1.5 * p2[1];\n\n    return [\n        (2 * p2e0 + p0[0]) / 3,\n        (2 * p2e1 + p0[1]) / 3,\n    ];\n}\n\nmodule.exports = function computeControlPoints(xe, ye, x, y, asmoothing, bsmoothing) {\n    var i, j, ie, je, xej, yej, xj, yj, cp, p1;\n    // At this point, we know these dimensions are correct and representative of\n    // the whole 2D arrays:\n    var na = x[0].length;\n    var nb = x.length;\n\n    // (n)umber of (e)xpanded points:\n    var nea = asmoothing ? 3 * na - 2 : na;\n    var neb = bsmoothing ? 3 * nb - 2 : nb;\n\n    xe = ensureArray(xe, neb);\n    ye = ensureArray(ye, neb);\n\n    for(ie = 0; ie < neb; ie++) {\n        xe[ie] = ensureArray(xe[ie], nea);\n        ye[ie] = ensureArray(ye[ie], nea);\n    }\n\n    // This loop fills in the X'd points:\n    //\n    //    .       .       .       .\n    //    .       .       .       .\n    //    |       |       |       |\n    //    |       |       |       |\n    //    X ----- X ----- X ----- X\n    //    |       |       |       |\n    //    |       |       |       |\n    //    |       |       |       |\n    //    X ----- X ----- X ----- X\n    //\n    //\n    // ie = (i) (e)xpanded:\n    for(j = 0, je = 0; j < nb; j++, je += bsmoothing ? 3 : 1) {\n        xej = xe[je];\n        yej = ye[je];\n        xj = x[j];\n        yj = y[j];\n\n        // je = (j) (e)xpanded:\n        for(i = 0, ie = 0; i < na; i++, ie += asmoothing ? 3 : 1) {\n            xej[ie] = xj[i];\n            yej[ie] = yj[i];\n        }\n    }\n\n    if(asmoothing) {\n        // If there's a-smoothing, this loop fills in the X'd points with catmull-rom\n        // control points computed along the a-axis:\n        //     .       .       .       .\n        //     .       .       .       .\n        //     |       |       |       |\n        //     |       |       |       |\n        //     o -Y-X- o -X-X- o -X-Y- o\n        //     |       |       |       |\n        //     |       |       |       |\n        //     |       |       |       |\n        //     o -Y-X- o -X-X- o -X-Y- o\n        //\n        // i:  0       1       2       3\n        // ie: 0  1 3  3  4 5  6  7 8  9\n        //\n        //           ------>\n        //             a\n        //\n        for(j = 0, je = 0; j < nb; j++, je += bsmoothing ? 3 : 1) {\n            // Fill in the points marked X for this a-row:\n            for(i = 1, ie = 3; i < na - 1; i++, ie += 3) {\n                cp = makeControlPoints(\n                    [x[j][i - 1], y[j][i - 1]],\n                    [x[j][i ], y[j][i]],\n                    [x[j][i + 1], y[j][i + 1]],\n                    asmoothing\n                );\n\n                xe[je][ie - 1] = cp[0][0];\n                ye[je][ie - 1] = cp[0][1];\n                xe[je][ie + 1] = cp[1][0];\n                ye[je][ie + 1] = cp[1][1];\n            }\n\n            // The very first cubic interpolation point (to the left for i = 1 above) is\n            // used as a *quadratic* interpolation point by the spline drawing function\n            // which isn't really correct. But for the sake of consistency, we'll use it\n            // as such. Since we're using cubic splines, that means we need to shorten the\n            // tangent by 1/3 and also construct a new cubic spline control point 1/3 from\n            // the original to the i = 0 point.\n            p1 = inferCubicControlPoint(\n                [xe[je][0], ye[je][0]],\n                [xe[je][2], ye[je][2]],\n                [xe[je][3], ye[je][3]]\n            );\n            xe[je][1] = p1[0];\n            ye[je][1] = p1[1];\n\n            // Ditto last points, sans explanation:\n            p1 = inferCubicControlPoint(\n                [xe[je][nea - 1], ye[je][nea - 1]],\n                [xe[je][nea - 3], ye[je][nea - 3]],\n                [xe[je][nea - 4], ye[je][nea - 4]]\n            );\n            xe[je][nea - 2] = p1[0];\n            ye[je][nea - 2] = p1[1];\n        }\n    }\n\n    if(bsmoothing) {\n        // If there's a-smoothing, this loop fills in the X'd points with catmull-rom\n        // control points computed along the b-axis:\n        //     .       .       .       .\n        //     X  X X  X  X X  X  X X  X\n        //     |       |       |       |\n        //     X  X X  X  X X  X  X X  X\n        //     o -o-o- o -o-o- o -o-o- o\n        //     X  X X  X  X X  X  X X  X\n        //     |       |       |       |\n        //     Y  Y Y  Y  Y Y  Y  Y Y  Y\n        //     o -o-o- o -o-o- o -o-o- o\n        //\n        // i:  0       1       2       3\n        // ie: 0  1 3  3  4 5  6  7 8  9\n        //\n        //           ------>\n        //             a\n        //\n        for(ie = 0; ie < nea; ie++) {\n            for(je = 3; je < neb - 3; je += 3) {\n                cp = makeControlPoints(\n                    [xe[je - 3][ie], ye[je - 3][ie]],\n                    [xe[je][ie], ye[je][ie]],\n                    [xe[je + 3][ie], ye[je + 3][ie]],\n                    bsmoothing\n                );\n\n                xe[je - 1][ie] = cp[0][0];\n                ye[je - 1][ie] = cp[0][1];\n                xe[je + 1][ie] = cp[1][0];\n                ye[je + 1][ie] = cp[1][1];\n            }\n            // Do the same boundary condition magic for these control points marked Y above:\n            p1 = inferCubicControlPoint(\n                [xe[0][ie], ye[0][ie]],\n                [xe[2][ie], ye[2][ie]],\n                [xe[3][ie], ye[3][ie]]\n            );\n            xe[1][ie] = p1[0];\n            ye[1][ie] = p1[1];\n\n            p1 = inferCubicControlPoint(\n                [xe[neb - 1][ie], ye[neb - 1][ie]],\n                [xe[neb - 3][ie], ye[neb - 3][ie]],\n                [xe[neb - 4][ie], ye[neb - 4][ie]]\n            );\n            xe[neb - 2][ie] = p1[0];\n            ye[neb - 2][ie] = p1[1];\n        }\n    }\n\n    if(asmoothing && bsmoothing) {\n        // Do one more pass, this time recomputing exactly what we just computed.\n        // It's overdetermined since we're peforming catmull-rom in two directions,\n        // so we'll just average the overdetermined. These points don't lie along the\n        // grid lines, so note that only grid lines will follow normal plotly spline\n        // interpolation.\n        //\n        // Unless of course there was no b smoothing. Then these intermediate points\n        // don't actually exist and this section is bypassed.\n        //     .       .       .       .\n        //     o  X X  o  X X  o  X X  o\n        //     |       |       |       |\n        //     o  X X  o  X X  o  X X  o\n        //     o -o-o- o -o-o- o -o-o- o\n        //     o  X X  o  X X  o  X X  o\n        //     |       |       |       |\n        //     o  Y Y  o  Y Y  o  Y Y  o\n        //     o -o-o- o -o-o- o -o-o- o\n        //\n        // i:  0       1       2       3\n        // ie: 0  1 3  3  4 5  6  7 8  9\n        //\n        //           ------>\n        //             a\n        //\n        for(je = 1; je < neb; je += (je + 1) % 3 === 0 ? 2 : 1) {\n            // Fill in the points marked X for this a-row:\n            for(ie = 3; ie < nea - 3; ie += 3) {\n                cp = makeControlPoints(\n                    [xe[je][ie - 3], ye[je][ie - 3]],\n                    [xe[je][ie], ye[je][ie]],\n                    [xe[je][ie + 3], ye[je][ie + 3]],\n                    asmoothing\n                );\n\n                xe[je][ie - 1] = 0.5 * (xe[je][ie - 1] + cp[0][0]);\n                ye[je][ie - 1] = 0.5 * (ye[je][ie - 1] + cp[0][1]);\n                xe[je][ie + 1] = 0.5 * (xe[je][ie + 1] + cp[1][0]);\n                ye[je][ie + 1] = 0.5 * (ye[je][ie + 1] + cp[1][1]);\n            }\n\n            // This case is just slightly different. The computation is the same,\n            // but having computed this, we'll average with the existing result.\n            p1 = inferCubicControlPoint(\n                [xe[je][0], ye[je][0]],\n                [xe[je][2], ye[je][2]],\n                [xe[je][3], ye[je][3]]\n            );\n            xe[je][1] = 0.5 * (xe[je][1] + p1[0]);\n            ye[je][1] = 0.5 * (ye[je][1] + p1[1]);\n\n            p1 = inferCubicControlPoint(\n                [xe[je][nea - 1], ye[je][nea - 1]],\n                [xe[je][nea - 3], ye[je][nea - 3]],\n                [xe[je][nea - 4], ye[je][nea - 4]]\n            );\n            xe[je][nea - 2] = 0.5 * (xe[je][nea - 2] + p1[0]);\n            ye[je][nea - 2] = 0.5 * (ye[je][nea - 2] + p1[1]);\n        }\n    }\n\n    return [xe, ye];\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/carpet/catmull_rom.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n/*\n * Compute the tangent vector according to catmull-rom cubic splines (centripetal,\n * I think). That differs from the control point in two ways:\n *   1. It is a vector, not a position relative to the point\n *   2. the vector is longer than the position relative to p1 by a factor of 3\n *\n * Close to the boundaries, we'll use these as *quadratic control points, so that\n * to make a nice grid, we'll need to divide the tangent by 2 instead of 3. (The\n * math works out this way if you work through the bezier derivatives)\n */\nvar CatmullRomExp = 0.5;\nmodule.exports = function makeControlPoints(p0, p1, p2, smoothness) {\n    var d1x = p0[0] - p1[0],\n        d1y = p0[1] - p1[1],\n        d2x = p2[0] - p1[0],\n        d2y = p2[1] - p1[1],\n        d1a = Math.pow(d1x * d1x + d1y * d1y, CatmullRomExp / 2),\n        d2a = Math.pow(d2x * d2x + d2y * d2y, CatmullRomExp / 2),\n        numx = (d2a * d2a * d1x - d1a * d1a * d2x) * smoothness,\n        numy = (d2a * d2a * d1y - d1a * d1a * d2y) * smoothness,\n        denom1 = d2a * (d1a + d2a) * 3,\n        denom2 = d1a * (d1a + d2a) * 3;\n    return [[\n        p1[0] + (denom1 && numx / denom1),\n        p1[1] + (denom1 && numy / denom1)\n    ], [\n        p1[0] - (denom2 && numx / denom2),\n        p1[1] - (denom2 && numy / denom2)\n    ]];\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/carpet/create_spline_evaluator.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n/*\n * Return a function that evaluates a set of linear or bicubic control points.\n * This will get evaluated a lot, so we'll at least do a bit of extra work to\n * flatten some of the choices. In particular, we'll unroll the linear/bicubic\n * combinations and we'll allow computing results in parallel to cut down\n * on repeated arithmetic.\n *\n * Take note that we don't search for the correct range in this function. The\n * reason is for consistency due to the corrresponding derivative function. In\n * particular, the derivatives aren't continuous across cells, so it's important\n * to be able control whether the derivative at a cell boundary is approached\n * from one side or the other.\n */\nmodule.exports = function(arrays, na, nb, asmoothing, bsmoothing) {\n    var imax = na - 2;\n    var jmax = nb - 2;\n\n    if(asmoothing && bsmoothing) {\n        return function(out, i, j) {\n            if(!out) out = [];\n            var f0, f1, f2, f3, ak, k;\n\n            var i0 = Math.max(0, Math.min(Math.floor(i), imax));\n            var j0 = Math.max(0, Math.min(Math.floor(j), jmax));\n            var u = Math.max(0, Math.min(1, i - i0));\n            var v = Math.max(0, Math.min(1, j - j0));\n\n            // Since it's a grid of control points, the actual indices are * 3:\n            i0 *= 3;\n            j0 *= 3;\n\n            // Precompute some numbers:\n            var u2 = u * u;\n            var u3 = u2 * u;\n            var ou = 1 - u;\n            var ou2 = ou * ou;\n            var ou3 = ou2 * ou;\n\n            var v2 = v * v;\n            var v3 = v2 * v;\n            var ov = 1 - v;\n            var ov2 = ov * ov;\n            var ov3 = ov2 * ov;\n\n            for(k = 0; k < arrays.length; k++) {\n                ak = arrays[k];\n                f0 = ou3 * ak[j0][i0] + 3 * (ou2 * u * ak[j0][i0 + 1] + ou * u2 * ak[j0][i0 + 2]) + u3 * ak[j0][i0 + 3];\n                f1 = ou3 * ak[j0 + 1][i0] + 3 * (ou2 * u * ak[j0 + 1][i0 + 1] + ou * u2 * ak[j0 + 1][i0 + 2]) + u3 * ak[j0 + 1][i0 + 3];\n                f2 = ou3 * ak[j0 + 2][i0] + 3 * (ou2 * u * ak[j0 + 2][i0 + 1] + ou * u2 * ak[j0 + 2][i0 + 2]) + u3 * ak[j0 + 2][i0 + 3];\n                f3 = ou3 * ak[j0 + 3][i0] + 3 * (ou2 * u * ak[j0 + 3][i0 + 1] + ou * u2 * ak[j0 + 3][i0 + 2]) + u3 * ak[j0 + 3][i0 + 3];\n                out[k] = ov3 * f0 + 3 * (ov2 * v * f1 + ov * v2 * f2) + v3 * f3;\n            }\n\n            return out;\n        };\n    } else if(asmoothing) {\n        // Handle smooth in the a-direction but linear in the b-direction by performing four\n        // linear interpolations followed by one cubic interpolation of the result\n        return function(out, i, j) {\n            if(!out) out = [];\n\n            var i0 = Math.max(0, Math.min(Math.floor(i), imax));\n            var j0 = Math.max(0, Math.min(Math.floor(j), jmax));\n            var u = Math.max(0, Math.min(1, i - i0));\n            var v = Math.max(0, Math.min(1, j - j0));\n\n            var f0, f1, f2, f3, k, ak;\n            i0 *= 3;\n            var u2 = u * u;\n            var u3 = u2 * u;\n            var ou = 1 - u;\n            var ou2 = ou * ou;\n            var ou3 = ou2 * ou;\n            var ov = 1 - v;\n            for(k = 0; k < arrays.length; k++) {\n                ak = arrays[k];\n                f0 = ov * ak[j0][i0] + v * ak[j0 + 1][i0];\n                f1 = ov * ak[j0][i0 + 1] + v * ak[j0 + 1][i0 + 1];\n                f2 = ov * ak[j0][i0 + 2] + v * ak[j0 + 1][i0 + 1];\n                f3 = ov * ak[j0][i0 + 3] + v * ak[j0 + 1][i0 + 1];\n\n                out[k] = ou3 * f0 + 3 * (ou2 * u * f1 + ou * u2 * f2) + u3 * f3;\n            }\n            return out;\n        };\n    } else if(bsmoothing) {\n        // Same as the above case, except reversed:\n        return function(out, i, j) {\n            if(!out) out = [];\n\n            var i0 = Math.max(0, Math.min(Math.floor(i), imax));\n            var j0 = Math.max(0, Math.min(Math.floor(j), jmax));\n            var u = Math.max(0, Math.min(1, i - i0));\n            var v = Math.max(0, Math.min(1, j - j0));\n\n            var f0, f1, f2, f3, k, ak;\n            j0 *= 3;\n            var v2 = v * v;\n            var v3 = v2 * v;\n            var ov = 1 - v;\n            var ov2 = ov * ov;\n            var ov3 = ov2 * ov;\n            var ou = 1 - u;\n            for(k = 0; k < arrays.length; k++) {\n                ak = arrays[k];\n                f0 = ou * ak[j0][i0] + u * ak[j0][i0 + 1];\n                f1 = ou * ak[j0 + 1][i0] + u * ak[j0 + 1][i0 + 1];\n                f2 = ou * ak[j0 + 2][i0] + u * ak[j0 + 2][i0 + 1];\n                f3 = ou * ak[j0 + 3][i0] + u * ak[j0 + 3][i0 + 1];\n\n                out[k] = ov3 * f0 + 3 * (ov2 * v * f1 + ov * v2 * f2) + v3 * f3;\n            }\n            return out;\n        };\n    } else {\n        // Finally, both directions are linear:\n        return function(out, i, j) {\n            if(!out) out = [];\n\n            var i0 = Math.max(0, Math.min(Math.floor(i), imax));\n            var j0 = Math.max(0, Math.min(Math.floor(j), jmax));\n            var u = Math.max(0, Math.min(1, i - i0));\n            var v = Math.max(0, Math.min(1, j - j0));\n\n            var f0, f1, k, ak;\n            var ov = 1 - v;\n            var ou = 1 - u;\n            for(k = 0; k < arrays.length; k++) {\n                ak = arrays[k];\n                f0 = ou * ak[j0][i0] + u * ak[j0][i0 + 1];\n                f1 = ou * ak[j0 + 1][i0] + u * ak[j0 + 1][i0 + 1];\n\n                out[k] = ov * f0 + v * f1;\n            }\n            return out;\n        };\n    }\n\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/carpet/create_i_derivative_evaluator.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n/*\n * Evaluates the derivative of a list of control point arrays. That is, it expects an array or arrays\n * that are expanded relative to the raw data to include the bicubic control points, if applicable. If\n * only linear interpolation is desired, then the data points correspond 1-1 along that axis to the\n * data itself. Since it's catmull-rom splines in either direction note in particular that the\n * derivatives are discontinuous across cell boundaries. That's the reason you need both the *cell*\n * and the *point within the cell*.\n *\n * Also note that the discontinuity of the derivative is in magnitude only. The direction *is*\n * continuous across cell boundaries.\n *\n * For example, to compute the derivative of the xcoordinate halfway betwen the 7 and 8th i-gridpoints\n * and the 10th and 11th j-gridpoints given bicubic smoothing in both dimensions, you'd write:\n *\n *     var deriv = createIDerivativeEvaluator([x], 1, 1);\n *\n *     var dxdi = deriv([], 7, 10, 0.5, 0.5);\n *     // => [0.12345]\n *\n * Since there'd be a bunch of duplicate computation to compute multiple derivatives, you can double\n * this up by providing more arrays:\n *\n *     var deriv = createIDerivativeEvaluator([x, y], 1, 1);\n *\n *     var dxdi = deriv([], 7, 10, 0.5, 0.5);\n *     // => [0.12345, 0.78910]\n *\n * NB: It's presumed that at this point all data has been sanitized and is valid numerical data arrays\n * of the correct dimension.\n */\nmodule.exports = function(arrays, asmoothing, bsmoothing) {\n    if(asmoothing && bsmoothing) {\n        return function(out, i0, j0, u, v) {\n            if(!out) out = [];\n            var f0, f1, f2, f3, ak, k;\n\n            // Since it's a grid of control points, the actual indices are * 3:\n            i0 *= 3;\n            j0 *= 3;\n\n            // Precompute some numbers:\n            var u2 = u * u;\n            var ou = 1 - u;\n            var ou2 = ou * ou;\n            var ouu2 = ou * u * 2;\n            var a = -3 * ou2;\n            var b = 3 * (ou2 - ouu2);\n            var c = 3 * (ouu2 - u2);\n            var d = 3 * u2;\n\n            var v2 = v * v;\n            var v3 = v2 * v;\n            var ov = 1 - v;\n            var ov2 = ov * ov;\n            var ov3 = ov2 * ov;\n\n            for(k = 0; k < arrays.length; k++) {\n                ak = arrays[k];\n                // Compute the derivatives in the u-direction:\n                f0 = a * ak[j0 ][i0] + b * ak[j0 ][i0 + 1] + c * ak[j0 ][i0 + 2] + d * ak[j0 ][i0 + 3];\n                f1 = a * ak[j0 + 1][i0] + b * ak[j0 + 1][i0 + 1] + c * ak[j0 + 1][i0 + 2] + d * ak[j0 + 1][i0 + 3];\n                f2 = a * ak[j0 + 2][i0] + b * ak[j0 + 2][i0 + 1] + c * ak[j0 + 2][i0 + 2] + d * ak[j0 + 2][i0 + 3];\n                f3 = a * ak[j0 + 3][i0] + b * ak[j0 + 3][i0 + 1] + c * ak[j0 + 3][i0 + 2] + d * ak[j0 + 3][i0 + 3];\n\n                // Now just interpolate in the v-direction since it's all separable:\n                out[k] = ov3 * f0 + 3 * (ov2 * v * f1 + ov * v2 * f2) + v3 * f3;\n            }\n\n            return out;\n        };\n    } else if(asmoothing) {\n        // Handle smooth in the a-direction but linear in the b-direction by performing four\n        // linear interpolations followed by one cubic interpolation of the result\n        return function(out, i0, j0, u, v) {\n            if(!out) out = [];\n            var f0, f1, k, ak;\n            i0 *= 3;\n            var u2 = u * u;\n            var ou = 1 - u;\n            var ou2 = ou * ou;\n            var ouu2 = ou * u * 2;\n            var a = -3 * ou2;\n            var b = 3 * (ou2 - ouu2);\n            var c = 3 * (ouu2 - u2);\n            var d = 3 * u2;\n            var ov = 1 - v;\n            for(k = 0; k < arrays.length; k++) {\n                ak = arrays[k];\n                f0 = a * ak[j0 ][i0] + b * ak[j0 ][i0 + 1] + c * ak[j0 ][i0 + 2] + d * ak[j0 ][i0 + 3];\n                f1 = a * ak[j0 + 1][i0] + b * ak[j0 + 1][i0 + 1] + c * ak[j0 + 1][i0 + 2] + d * ak[j0 + 1][i0 + 3];\n\n                out[k] = ov * f0 + v * f1;\n            }\n            return out;\n        };\n    } else if(bsmoothing) {\n        // Same as the above case, except reversed. I've disabled the no-unused vars rule\n        // so that this function is fully interpolation-agnostic. Otherwise it would need\n        // to be called differently in different cases. Which wouldn't be the worst, but\n        /* eslint-disable no-unused-vars */\n        return function(out, i0, j0, u, v) {\n        /* eslint-enable no-unused-vars */\n            if(!out) out = [];\n            var f0, f1, f2, f3, k, ak;\n            j0 *= 3;\n            var v2 = v * v;\n            var v3 = v2 * v;\n            var ov = 1 - v;\n            var ov2 = ov * ov;\n            var ov3 = ov2 * ov;\n            for(k = 0; k < arrays.length; k++) {\n                ak = arrays[k];\n                f0 = ak[j0][i0 + 1] - ak[j0][i0];\n                f1 = ak[j0 + 1][i0 + 1] - ak[j0 + 1][i0];\n                f2 = ak[j0 + 2][i0 + 1] - ak[j0 + 2][i0];\n                f3 = ak[j0 + 3][i0 + 1] - ak[j0 + 3][i0];\n\n                out[k] = ov3 * f0 + 3 * (ov2 * v * f1 + ov * v2 * f2) + v3 * f3;\n            }\n            return out;\n        };\n    } else {\n        // Finally, both directions are linear:\n        /* eslint-disable no-unused-vars */\n        return function(out, i0, j0, u, v) {\n        /* eslint-enable no-unused-vars */\n            if(!out) out = [];\n            var f0, f1, k, ak;\n            var ov = 1 - v;\n            for(k = 0; k < arrays.length; k++) {\n                ak = arrays[k];\n                f0 = ak[j0][i0 + 1] - ak[j0][i0];\n                f1 = ak[j0 + 1][i0 + 1] - ak[j0 + 1][i0];\n\n                out[k] = ov * f0 + v * f1;\n            }\n            return out;\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/carpet/create_j_derivative_evaluator.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = function(arrays, asmoothing, bsmoothing) {\n    if(asmoothing && bsmoothing) {\n        return function(out, i0, j0, u, v) {\n            if(!out) out = [];\n            var f0, f1, f2, f3, ak, k;\n\n            // Since it's a grid of control points, the actual indices are * 3:\n            i0 *= 3;\n            j0 *= 3;\n\n            // Precompute some numbers:\n            var u2 = u * u;\n            var u3 = u2 * u;\n            var ou = 1 - u;\n            var ou2 = ou * ou;\n            var ou3 = ou2 * ou;\n\n            var v2 = v * v;\n            var ov = 1 - v;\n            var ov2 = ov * ov;\n            var ovv2 = ov * v * 2;\n            var a = -3 * ov2;\n            var b = 3 * (ov2 - ovv2);\n            var c = 3 * (ovv2 - v2);\n            var d = 3 * v2;\n\n            for(k = 0; k < arrays.length; k++) {\n                ak = arrays[k];\n\n                // Compute the derivatives in the v-direction:\n                f0 = a * ak[j0][i0] + b * ak[j0 + 1][i0] + c * ak[j0 + 2][i0] + d * ak[j0 + 3][i0];\n                f1 = a * ak[j0][i0 + 1] + b * ak[j0 + 1][i0 + 1] + c * ak[j0 + 2][i0 + 1] + d * ak[j0 + 3][i0 + 1];\n                f2 = a * ak[j0][i0 + 2] + b * ak[j0 + 1][i0 + 2] + c * ak[j0 + 2][i0 + 2] + d * ak[j0 + 3][i0 + 2];\n                f3 = a * ak[j0][i0 + 3] + b * ak[j0 + 1][i0 + 3] + c * ak[j0 + 2][i0 + 3] + d * ak[j0 + 3][i0 + 3];\n\n                // Now just interpolate in the v-direction since it's all separable:\n                out[k] = ou3 * f0 + 3 * (ou2 * u * f1 + ou * u2 * f2) + u3 * f3;\n            }\n\n            return out;\n        };\n    } else if(asmoothing) {\n        // Handle smooth in the a-direction but linear in the b-direction by performing four\n        // linear interpolations followed by one cubic interpolation of the result\n        return function(out, i0, j0, v, u) {\n            if(!out) out = [];\n            var f0, f1, f2, f3, k, ak;\n            i0 *= 3;\n            var u2 = u * u;\n            var u3 = u2 * u;\n            var ou = 1 - u;\n            var ou2 = ou * ou;\n            var ou3 = ou2 * ou;\n            for(k = 0; k < arrays.length; k++) {\n                ak = arrays[k];\n\n                f0 = ak[j0 + 1][i0] - ak[j0][i0];\n                f1 = ak[j0 + 1][i0 + 1] - ak[j0][i0 + 1];\n                f2 = ak[j0 + 1][i0 + 2] - ak[j0][i0 + 2];\n                f3 = ak[j0 + 1][i0 + 3] - ak[j0][i0 + 3];\n\n                out[k] = ou3 * f0 + 3 * (ou2 * u * f1 + ou * u2 * f2) + u3 * f3;\n\n                // mathematically equivalent:\n                // f0 = ou3 * ak[j0    ][i0] + 3 * (ou2 * u * ak[j0    ][i0 + 1] + ou * u2 * ak[j0    ][i0 + 2]) + u3 * ak[j0    ][i0 + 3];\n                // f1 = ou3 * ak[j0 + 1][i0] + 3 * (ou2 * u * ak[j0 + 1][i0 + 1] + ou * u2 * ak[j0 + 1][i0 + 2]) + u3 * ak[j0 + 1][i0 + 3];\n                // out[k] = f1 - f0;\n            }\n            return out;\n        };\n    } else if(bsmoothing) {\n        // Same as the above case, except reversed:\n        /* eslint-disable no-unused-vars */\n        return function(out, i0, j0, u, v) {\n        /* eslint-enable no-unused-vars */\n            if(!out) out = [];\n            var f0, f1, k, ak;\n            j0 *= 3;\n            var ou = 1 - u;\n            var v2 = v * v;\n            var ov = 1 - v;\n            var ov2 = ov * ov;\n            var ovv2 = ov * v * 2;\n            var a = -3 * ov2;\n            var b = 3 * (ov2 - ovv2);\n            var c = 3 * (ovv2 - v2);\n            var d = 3 * v2;\n            for(k = 0; k < arrays.length; k++) {\n                ak = arrays[k];\n                f0 = a * ak[j0][i0] + b * ak[j0 + 1][i0] + c * ak[j0 + 2][i0] + d * ak[j0 + 3][i0];\n                f1 = a * ak[j0][i0 + 1] + b * ak[j0 + 1][i0 + 1] + c * ak[j0 + 2][i0 + 1] + d * ak[j0 + 3][i0 + 1];\n\n                out[k] = ou * f0 + u * f1;\n            }\n            return out;\n        };\n    } else {\n        // Finally, both directions are linear:\n        /* eslint-disable no-unused-vars */\n        return function(out, i0, j0, v, u) {\n        /* eslint-enable no-unused-vars */\n            if(!out) out = [];\n            var f0, f1, k, ak;\n            var ov = 1 - v;\n            for(k = 0; k < arrays.length; k++) {\n                ak = arrays[k];\n                f0 = ak[j0 + 1][i0] - ak[j0][i0];\n                f1 = ak[j0 + 1][i0 + 1] - ak[j0][i0 + 1];\n\n                out[k] = ov * f0 + v * f1;\n            }\n            return out;\n        };\n    }\n\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/carpet/plot.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\nvar Drawing = require('../../components/drawing');\nvar map1dArray = require('./map_1d_array');\nvar makepath = require('./makepath');\nvar orientText = require('./orient_text');\n\nmodule.exports = function plot(gd, plotinfo, cdcarpet) {\n    for(var i = 0; i < cdcarpet.length; i++) {\n        plotOne(gd, plotinfo, cdcarpet[i]);\n    }\n};\n\nfunction makeg(el, type, klass) {\n    var join = el.selectAll(type + '.' + klass).data([0]);\n    join.enter().append(type).classed(klass, true);\n    return join;\n}\n\nfunction plotOne(gd, plotinfo, cd) {\n    var t = cd[0];\n    var trace = cd[0].trace,\n        xa = plotinfo.xaxis,\n        ya = plotinfo.yaxis,\n        aax = trace.aaxis,\n        bax = trace.baxis,\n        fullLayout = gd._fullLayout;\n        // uid = trace.uid,\n        // id = 'carpet' + uid;\n\n    var gridLayer = plotinfo.plot.selectAll('.carpetlayer');\n    var clipLayer = makeg(fullLayout._defs, 'g', 'clips');\n\n    var axisLayer = makeg(gridLayer, 'g', 'carpet' + trace.uid).classed('trace', true);\n    var minorLayer = makeg(axisLayer, 'g', 'minorlayer');\n    var majorLayer = makeg(axisLayer, 'g', 'majorlayer');\n    var boundaryLayer = makeg(axisLayer, 'g', 'boundarylayer');\n    var labelLayer = makeg(axisLayer, 'g', 'labellayer');\n\n    axisLayer.style('opacity', trace.opacity);\n\n    drawGridLines(xa, ya, majorLayer, aax, 'a', aax._gridlines, true);\n    drawGridLines(xa, ya, majorLayer, bax, 'b', bax._gridlines, true);\n    drawGridLines(xa, ya, minorLayer, aax, 'a', aax._minorgridlines, true);\n    drawGridLines(xa, ya, minorLayer, bax, 'b', bax._minorgridlines, true);\n\n    // NB: These are not ommitted if the lines are not active. The joins must be executed\n    // in order for them to get cleaned up without a full redraw\n    drawGridLines(xa, ya, boundaryLayer, aax, 'a-boundary', aax._boundarylines);\n    drawGridLines(xa, ya, boundaryLayer, bax, 'b-boundary', bax._boundarylines);\n\n    var maxAExtent = drawAxisLabels(gd._tester, xa, ya, trace, t, labelLayer, aax._labels, 'a-label');\n    var maxBExtent = drawAxisLabels(gd._tester, xa, ya, trace, t, labelLayer, bax._labels, 'b-label');\n\n    drawAxisTitles(labelLayer, trace, t, xa, ya, maxAExtent, maxBExtent);\n\n    // Swap for debugging in order to draw directly:\n    // drawClipPath(trace, axisLayer, xa, ya);\n    drawClipPath(trace, t, clipLayer, xa, ya);\n}\n\nfunction drawClipPath(trace, t, layer, xaxis, yaxis) {\n    var seg, xp, yp, i;\n    // var clip = makeg(layer, 'g', 'carpetclip');\n    trace.clipPathId = 'clip' + trace.uid + 'carpet';\n\n    var clip = layer.select('#' + trace.clipPathId);\n\n    if(!clip.size()) {\n        clip = layer.append('clipPath')\n            .classed('carpetclip', true);\n    }\n\n    var path = makeg(clip, 'path', 'carpetboundary');\n    var segments = t.clipsegments;\n    var segs = [];\n\n    for(i = 0; i < segments.length; i++) {\n        seg = segments[i];\n        xp = map1dArray([], seg.x, xaxis.c2p);\n        yp = map1dArray([], seg.y, yaxis.c2p);\n        segs.push(makepath(xp, yp, seg.bicubic));\n    }\n\n    // This could be optimized ever so slightly to avoid no-op L segments\n    // at the corners, but it's so negligible that I don't think it's worth\n    // the extra complexity\n    trace.clipPathData = 'M' + segs.join('L') + 'Z';\n    clip.attr('id', trace.clipPathId);\n    path.attr('d', trace.clipPathData);\n        // .style('stroke-width', 20)\n        // .style('vector-effect', 'non-scaling-stroke')\n        // .style('stroke', 'black')\n        // .style('fill', 'rgba(0, 0, 0, 0.1)');\n}\n\nfunction drawGridLines(xaxis, yaxis, layer, axis, axisLetter, gridlines) {\n    var lineClass = 'const-' + axisLetter + '-lines';\n    var gridJoin = layer.selectAll('.' + lineClass).data(gridlines);\n\n    gridJoin.enter().append('path')\n        .classed(lineClass, true)\n        .style('vector-effect', 'non-scaling-stroke');\n\n    gridJoin.each(function(d) {\n        var gridline = d;\n        var x = gridline.x;\n        var y = gridline.y;\n\n        var xp = map1dArray([], x, xaxis.c2p);\n        var yp = map1dArray([], y, yaxis.c2p);\n\n        var path = 'M' + makepath(xp, yp, gridline.smoothing);\n\n        var el = d3.select(this);\n\n        el.attr('d', path)\n            .style('stroke-width', gridline.width)\n            .style('stroke', gridline.color)\n            .style('fill', 'none');\n    });\n\n    gridJoin.exit().remove();\n}\n\nfunction drawAxisLabels(tester, xaxis, yaxis, trace, t, layer, labels, labelClass) {\n    var labelJoin = layer.selectAll('text.' + labelClass).data(labels);\n\n    labelJoin.enter().append('text')\n        .classed(labelClass, true);\n\n    var maxExtent = 0;\n\n    labelJoin.each(function(label) {\n        // Most of the positioning is done in calc_labels. Only the parts that depend upon\n        // the screen space representation of the x and y axes are here:\n        var orientation;\n        if(label.axis.tickangle === 'auto') {\n            orientation = orientText(trace, xaxis, yaxis, label.xy, label.dxy);\n        } else {\n            var angle = (label.axis.tickangle + 180.0) * Math.PI / 180.0;\n            orientation = orientText(trace, xaxis, yaxis, label.xy, [Math.cos(angle), Math.sin(angle)]);\n        }\n        var direction = (label.endAnchor ? -1 : 1) * orientation.flip;\n        var bbox = Drawing.measureText(tester, label.text, label.font);\n\n        d3.select(this)\n            .attr('text-anchor', direction > 0 ? 'start' : 'end')\n            .text(label.text)\n            .attr('transform',\n                // Translate to the correct point:\n                'translate(' + orientation.p[0] + ',' + orientation.p[1] + ') ' +\n                // Rotate to line up with grid line tangent:\n                'rotate(' + orientation.angle + ')' +\n                // Adjust the baseline and indentation:\n                'translate(' + label.axis.labelpadding * direction + ',' + bbox.height * 0.3 + ')'\n            )\n            .call(Drawing.font, label.font.family, label.font.size, label.font.color);\n\n        maxExtent = Math.max(maxExtent, bbox.width + label.axis.labelpadding);\n    });\n\n    labelJoin.exit().remove();\n\n    return maxExtent;\n}\n\nfunction drawAxisTitles(layer, trace, t, xa, ya, maxAExtent, maxBExtent) {\n    var a, b, xy, dxy;\n\n    a = 0.5 * (trace.a[0] + trace.a[trace.a.length - 1]);\n    b = trace.b[0];\n    xy = trace.ab2xy(a, b, true);\n    dxy = trace.dxyda_rough(a, b);\n    drawAxisTitle(layer, trace, t, xy, dxy, trace.aaxis, xa, ya, maxAExtent, 'a-title');\n\n    a = trace.a[0];\n    b = 0.5 * (trace.b[0] + trace.b[trace.b.length - 1]);\n    xy = trace.ab2xy(a, b, true);\n    dxy = trace.dxydb_rough(a, b);\n    drawAxisTitle(layer, trace, t, xy, dxy, trace.baxis, xa, ya, maxBExtent, 'b-title');\n}\n\nfunction drawAxisTitle(layer, trace, t, xy, dxy, axis, xa, ya, offset, labelClass) {\n    var data = [];\n    if(axis.title) data.push(axis.title);\n    var titleJoin = layer.selectAll('text.' + labelClass).data(data);\n\n    titleJoin.enter().append('text')\n        .classed(labelClass, true);\n\n    // There's only one, but we'll do it as a join so it's updated nicely:\n    titleJoin.each(function() {\n        var orientation = orientText(trace, xa, ya, xy, dxy);\n\n        if(['start', 'both'].indexOf(axis.showticklabels) === -1) {\n            offset = 0;\n        }\n\n        // In addition to the size of the labels, add on some extra padding:\n        offset += axis.titlefont.size + axis.titleoffset;\n\n\n        var el = d3.select(this);\n\n        el.text(axis.title || '')\n            .attr('transform',\n                'translate(' + orientation.p[0] + ',' + orientation.p[1] + ') ' +\n                'rotate(' + orientation.angle + ') ' +\n                'translate(0,' + offset + ')'\n            )\n            .classed('user-select-none', true)\n            .attr('text-anchor', 'middle')\n            .call(Drawing.font, axis.titlefont);\n    });\n\n    titleJoin.exit().remove();\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/carpet/map_1d_array.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n/*\n * Map an array of x or y coordinates (c) to screen-space pixel coordinates (p).\n * The output array is optional, but if provided, it will be reused without\n * reallocation to the extent possible.\n */\nmodule.exports = function mapArray(out, data, func) {\n    var i;\n\n    if(!Array.isArray(out)) {\n        // If not an array, make it an array:\n        out = [];\n    } else if(out.length > data.length) {\n        // If too long, truncate. (If too short, it will grow\n        // automatically so we don't care about that case)\n        out = out.slice(0, data.length);\n    }\n\n    for(i = 0; i < data.length; i++) {\n        out[i] = func(data[i]);\n    }\n\n    return out;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/carpet/makepath.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = function makePath(xp, yp, isBicubic) {\n    // Prevent d3 errors that would result otherwise:\n    if(xp.length === 0) return '';\n\n    var i, path = [];\n    var stride = isBicubic ? 3 : 1;\n    for(i = 0; i < xp.length; i += stride) {\n        path.push(xp[i] + ',' + yp[i]);\n\n        if(isBicubic && i < xp.length - stride) {\n            path.push('C');\n            path.push([\n                xp[i + 1] + ',' + yp[i + 1],\n                xp[i + 2] + ',' + yp[i + 2] + ' ',\n            ].join(' '));\n        }\n    }\n    return path.join(isBicubic ? '' : 'L');\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/carpet/orient_text.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nmodule.exports = function orientText(trace, xaxis, yaxis, xy, dxy, refDxy) {\n    var dx = dxy[0] * trace.dpdx(xaxis);\n    var dy = dxy[1] * trace.dpdy(yaxis);\n    var flip = 1;\n\n    var offsetMultiplier = 1.0;\n    if(refDxy) {\n        var l1 = Math.sqrt(dxy[0] * dxy[0] + dxy[1] * dxy[1]);\n        var l2 = Math.sqrt(refDxy[0] * refDxy[0] + refDxy[1] * refDxy[1]);\n        var dot = (dxy[0] * refDxy[0] + dxy[1] * refDxy[1]) / l1 / l2;\n        offsetMultiplier = Math.max(0.0, dot);\n    }\n\n    var angle = Math.atan2(dy, dx) * 180 / Math.PI;\n    if(angle < -90) {\n        angle += 180;\n        flip = -flip;\n    } else if(angle > 90) {\n        angle -= 180;\n        flip = -flip;\n    }\n\n    return {\n        angle: angle,\n        flip: flip,\n        p: trace.c2p(xy, xaxis, yaxis),\n        offsetMultplier: offsetMultiplier\n    };\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/carpet/calc.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Axes = require('../../plots/cartesian/axes');\nvar cheaterBasis = require('./cheater_basis');\nvar arrayMinmax = require('./array_minmax');\nvar map2dArray = require('./map_2d_array');\nvar calcGridlines = require('./calc_gridlines');\nvar calcLabels = require('./calc_labels');\nvar calcClipPath = require('./calc_clippath');\nvar clean2dArray = require('../heatmap/clean_2d_array');\nvar smoothFill2dArray = require('./smooth_fill_2d_array');\n\nmodule.exports = function calc(gd, trace) {\n    var xa = Axes.getFromId(gd, trace.xaxis || 'x');\n    var ya = Axes.getFromId(gd, trace.yaxis || 'y');\n    var aax = trace.aaxis;\n    var bax = trace.baxis;\n    var a = trace._a = trace.a;\n    var b = trace._b = trace.b;\n\n    var t = {};\n    var x;\n    var y = trace.y;\n\n    if(trace._cheater) {\n        var avals = aax.cheatertype === 'index' ? a.length : a;\n        var bvals = bax.cheatertype === 'index' ? b.length : b;\n        trace.x = x = cheaterBasis(avals, bvals, trace.cheaterslope);\n    } else {\n        x = trace.x;\n    }\n\n    trace._x = trace.x = x = clean2dArray(x);\n    trace._y = trace.y = y = clean2dArray(y);\n\n    // Fill in any undefined values with elliptic smoothing. This doesn't take\n    // into account the spacing of the values. That is, the derivatives should\n    // be modified to use a and b values. It's not that hard, but this is already\n    // moderate overkill for just filling in missing values.\n    smoothFill2dArray(x, a, b);\n    smoothFill2dArray(y, a, b);\n\n    // create conversion functions that depend on the data\n    trace.setScale();\n\n    // Convert cartesian-space x/y coordinates to screen space pixel coordinates:\n    t.xp = trace.xp = map2dArray(trace.xp, x, xa.c2p);\n    t.yp = trace.yp = map2dArray(trace.yp, y, ya.c2p);\n\n    // This is a rather expensive scan. Nothing guarantees monotonicity,\n    // so we need to scan through all data to get proper ranges:\n    var xrange = arrayMinmax(x);\n    var yrange = arrayMinmax(y);\n\n    var dx = 0.5 * (xrange[1] - xrange[0]);\n    var xc = 0.5 * (xrange[1] + xrange[0]);\n\n    var dy = 0.5 * (yrange[1] - yrange[0]);\n    var yc = 0.5 * (yrange[1] + yrange[0]);\n\n    // Expand the axes to fit the plot, except just grow it by a factor of 1.3\n    // because the labels should be taken into account except that's difficult\n    // hence 1.3.\n    var grow = 1.3;\n    xrange = [xc - dx * grow, xc + dx * grow];\n    yrange = [yc - dy * grow, yc + dy * grow];\n\n    Axes.expand(xa, xrange, {padded: true});\n    Axes.expand(ya, yrange, {padded: true});\n\n    // Enumerate the gridlines, both major and minor, and store them on the trace\n    // object:\n    calcGridlines(trace, t, 'a', 'b');\n    calcGridlines(trace, t, 'b', 'a');\n\n    // Calculate the text labels for each major gridline and store them on the\n    // trace object:\n    calcLabels(trace, aax);\n    calcLabels(trace, bax);\n\n    // Tabulate points for the four segments that bound the axes so that we can\n    // map to pixel coordinates in the plot function and create a clip rect:\n    t.clipsegments = calcClipPath(trace.xctrl, trace.yctrl, aax, bax);\n\n    t.x = x;\n    t.y = y;\n    t.a = a;\n    t.b = b;\n\n    return [t];\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/carpet/cheater_basis.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar isArray = require('../../lib').isArray;\n\n/*\n * Construct a 2D array of cheater values given a, b, and a slope.\n * If\n */\nmodule.exports = function(a, b, cheaterslope) {\n    var i, j, ascal, bscal, aval, bval;\n    var data = [];\n\n    var na = isArray(a) ? a.length : a;\n    var nb = isArray(b) ? b.length : b;\n    var adata = isArray(a) ? a : null;\n    var bdata = isArray(b) ? b : null;\n\n    // If we're using data, scale it so that for data that's just barely\n    // not evenly spaced, the switch to value-based indexing is continuous.\n    // This means evenly spaced data should look the same whether value\n    // or index cheatertype.\n    if(adata) {\n        ascal = (adata.length - 1) / (adata[adata.length - 1] - adata[0]) / (na - 1);\n    }\n\n    if(bdata) {\n        bscal = (bdata.length - 1) / (bdata[bdata.length - 1] - bdata[0]) / (nb - 1);\n    }\n\n    var xval;\n    var xmin = Infinity;\n    var xmax = -Infinity;\n    for(j = 0; j < nb; j++) {\n        data[j] = [];\n        bval = bdata ? (bdata[j] - bdata[0]) * bscal : j / (nb - 1);\n        for(i = 0; i < na; i++) {\n            aval = adata ? (adata[i] - adata[0]) * ascal : i / (na - 1);\n            xval = aval - bval * cheaterslope;\n            xmin = Math.min(xval, xmin);\n            xmax = Math.max(xval, xmax);\n            data[j][i] = xval;\n        }\n    }\n\n    // Normalize cheater values to the 0-1 range. This comes into play when you have\n    // multiple cheater plots. After careful consideration, it seems better if cheater\n    // values are normalized to a consistent range. Otherwise one cheater affects the\n    // layout of other cheaters on the same axis.\n    var slope = 1.0 / (xmax - xmin);\n    var offset = -xmin * slope;\n    for(j = 0; j < nb; j++) {\n        for(i = 0; i < na; i++) {\n            data[j][i] = slope * data[j][i] + offset;\n        }\n    }\n\n    return data;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/carpet/array_minmax.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = function(a) {\n    return minMax(a, 0);\n};\n\nfunction minMax(a, depth) {\n    // Limit to ten dimensional datasets. This seems *exceedingly* unlikely to\n    // ever cause problems or even be a concern. It's include strictly so that\n    // circular arrays could never cause this to loop.\n    if(!Array.isArray(a) || depth >= 10) {\n        return null;\n    }\n\n    var min = Infinity;\n    var max = -Infinity;\n    var n = a.length;\n    for(var i = 0; i < n; i++) {\n        var datum = a[i];\n\n        if(Array.isArray(datum)) {\n            var result = minMax(datum, depth + 1);\n\n            if(result) {\n                min = Math.min(result[0], min);\n                max = Math.max(result[1], max);\n            }\n        } else {\n            min = Math.min(datum, min);\n            max = Math.max(datum, max);\n        }\n    }\n\n    return [min, max];\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/carpet/map_2d_array.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n/*\n * Map an array of x or y coordinates (c) to screen-space pixel coordinates (p).\n * The output array is optional, but if provided, it will be reused without\n * reallocation to the extent possible.\n */\nmodule.exports = function mapArray(out, data, func) {\n    var i, j;\n\n    if(!Array.isArray(out)) {\n        // If not an array, make it an array:\n        out = [];\n    } else if(out.length > data.length) {\n        // If too long, truncate. (If too short, it will grow\n        // automatically so we don't care about that case)\n        out = out.slice(0, data.length);\n    }\n\n    for(i = 0; i < data.length; i++) {\n        if(!Array.isArray(out[i])) {\n            // If not an array, make it an array:\n            out[i] = [];\n        } else if(out[i].length > data.length) {\n            // If too long, truncate. (If too short, it will grow\n            // automatically so we don't care about[i] that case)\n            out[i] = out[i].slice(0, data.length);\n        }\n\n        for(j = 0; j < data[0].length; j++) {\n            out[i][j] = func(data[i][j]);\n        }\n    }\n    return out;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/carpet/calc_gridlines.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Axes = require('../../plots/cartesian/axes');\nvar extendFlat = require('../../lib/extend').extendFlat;\n\nmodule.exports = function calcGridlines(trace, cd, axisLetter, crossAxisLetter) {\n    var i, j, j0;\n    var eps, bounds, n1, n2, n, value, v;\n    var j1, v0, v1, d;\n\n    var data = trace[axisLetter];\n    var axis = trace[axisLetter + 'axis'];\n\n    var gridlines = axis._gridlines = [];\n    var minorgridlines = axis._minorgridlines = [];\n    var boundarylines = axis._boundarylines = [];\n\n    var crossData = trace[crossAxisLetter];\n    var crossAxis = trace[crossAxisLetter + 'axis'];\n\n    if(axis.tickmode === 'array') {\n        axis.tickvals = [];\n        for(i = 0; i < data.length; i++) {\n            axis.tickvals.push(data[i]);\n        }\n    }\n\n    var xcp = trace.xctrl;\n    var ycp = trace.yctrl;\n    var nea = xcp[0].length;\n    var neb = xcp.length;\n    var na = trace.a.length;\n    var nb = trace.b.length;\n\n    Axes.calcTicks(axis);\n\n    // The default is an empty array that will cause the join to remove the gridline if\n    // it's just disappeared:\n    // axis._startline = axis._endline = [];\n\n    // If the cross axis uses bicubic interpolation, then the grid\n    // lines fall once every three expanded grid row/cols:\n    var stride = axis.smoothing ? 3 : 1;\n\n    function constructValueGridline(value) {\n        var i, j, j0, tj, pxy, i0, ti, xy, dxydi0, dxydi1, dxydj0, dxydj1;\n        var xpoints = [];\n        var ypoints = [];\n        var ret = {};\n        // Search for the fractional grid index giving this line:\n        if(axisLetter === 'b') {\n            // For the position we use just the i-j coordinates:\n            j = trace.b2j(value);\n\n            // The derivatives for catmull-rom splines are discontinuous across cell\n            // boundaries though, so we need to provide both the cell and the position\n            // within the cell separately:\n            j0 = Math.floor(Math.max(0, Math.min(nb - 2, j)));\n            tj = j - j0;\n\n            ret.length = nb;\n            ret.crossLength = na;\n\n            ret.xy = function(i) {\n                return trace.evalxy([], i, j);\n            };\n\n            ret.dxy = function(i0, ti) {\n                return trace.dxydi([], i0, j0, ti, tj);\n            };\n\n            for(i = 0; i < na; i++) {\n                i0 = Math.min(na - 2, i);\n                ti = i - i0;\n                xy = trace.evalxy([], i, j);\n\n                if(crossAxis.smoothing && i > 0) {\n                    // First control point:\n                    dxydi0 = trace.dxydi([], i - 1, j0, 0, tj);\n                    xpoints.push(pxy[0] + dxydi0[0] / 3);\n                    ypoints.push(pxy[1] + dxydi0[1] / 3);\n\n                    // Second control point:\n                    dxydi1 = trace.dxydi([], i - 1, j0, 1, tj);\n                    xpoints.push(xy[0] - dxydi1[0] / 3);\n                    ypoints.push(xy[1] - dxydi1[1] / 3);\n                }\n\n                xpoints.push(xy[0]);\n                ypoints.push(xy[1]);\n\n                pxy = xy;\n            }\n        } else {\n            i = trace.a2i(value);\n            i0 = Math.floor(Math.max(0, Math.min(na - 2, i)));\n            ti = i - i0;\n\n            ret.length = na;\n            ret.crossLength = nb;\n\n            ret.xy = function(j) {\n                return trace.evalxy([], i, j);\n            };\n\n            ret.dxy = function(j0, tj) {\n                return trace.dxydj([], i0, j0, ti, tj);\n            };\n\n            for(j = 0; j < nb; j++) {\n                j0 = Math.min(nb - 2, j);\n                tj = j - j0;\n                xy = trace.evalxy([], i, j);\n\n                if(crossAxis.smoothing && j > 0) {\n                    // First control point:\n                    dxydj0 = trace.dxydj([], i0, j - 1, ti, 0);\n                    xpoints.push(pxy[0] + dxydj0[0] / 3);\n                    ypoints.push(pxy[1] + dxydj0[1] / 3);\n\n                    // Second control point:\n                    dxydj1 = trace.dxydj([], i0, j - 1, ti, 1);\n                    xpoints.push(xy[0] - dxydj1[0] / 3);\n                    ypoints.push(xy[1] - dxydj1[1] / 3);\n                }\n\n                xpoints.push(xy[0]);\n                ypoints.push(xy[1]);\n\n                pxy = xy;\n            }\n        }\n\n        ret.axisLetter = axisLetter;\n        ret.axis = axis;\n        ret.crossAxis = crossAxis;\n        ret.value = value;\n        ret.constvar = crossAxisLetter;\n        ret.index = n;\n        ret.x = xpoints;\n        ret.y = ypoints;\n        ret.smoothing = crossAxis.smoothing;\n\n        return ret;\n    }\n\n    function constructArrayGridline(idx) {\n        var j, i0, j0, ti, tj;\n        var xpoints = [];\n        var ypoints = [];\n        var ret = {};\n        ret.length = data.length;\n        ret.crossLength = crossData.length;\n\n        if(axisLetter === 'b') {\n            j0 = Math.max(0, Math.min(nb - 2, idx));\n            tj = Math.min(1, Math.max(0, idx - j0));\n\n            ret.xy = function(i) {\n                return trace.evalxy([], i, idx);\n            };\n\n            ret.dxy = function(i0, ti) {\n                return trace.dxydi([], i0, j0, ti, tj);\n            };\n\n            // In the tickmode: array case, this operation is a simple\n            // transfer of data:\n            for(j = 0; j < nea; j++) {\n                xpoints[j] = xcp[idx * stride][j];\n                ypoints[j] = ycp[idx * stride][j];\n            }\n        } else {\n            i0 = Math.max(0, Math.min(na - 2, idx));\n            ti = Math.min(1, Math.max(0, idx - i0));\n\n            ret.xy = function(j) {\n                return trace.evalxy([], idx, j);\n            };\n\n            ret.dxy = function(j0, tj) {\n                return trace.dxydj([], i0, j0, ti, tj);\n            };\n\n            // In the tickmode: array case, this operation is a simple\n            // transfer of data:\n            for(j = 0; j < neb; j++) {\n                xpoints[j] = xcp[j][idx * stride];\n                ypoints[j] = ycp[j][idx * stride];\n            }\n        }\n\n        ret.axisLetter = axisLetter;\n        ret.axis = axis;\n        ret.crossAxis = crossAxis;\n        ret.value = data[idx];\n        ret.constvar = crossAxisLetter;\n        ret.index = idx;\n        ret.x = xpoints;\n        ret.y = ypoints;\n        ret.smoothing = crossAxis.smoothing;\n\n        return ret;\n    }\n\n    if(axis.tickmode === 'array') {\n        // var j0 = axis.startline ? 1 : 0;\n        // var j1 = data.length - (axis.endline ? 1 : 0);\n\n        eps = 5e-15;\n        bounds = [\n            Math.floor(((data.length - 1) - axis.arraytick0) / axis.arraydtick * (1 + eps)),\n            Math.ceil((- axis.arraytick0) / axis.arraydtick / (1 + eps))\n        ].sort(function(a, b) {return a - b;});\n\n        // Unpack sorted values so we can be sure to avoid infinite loops if something\n        // is backwards:\n        n1 = bounds[0] - 1;\n        n2 = bounds[1] + 1;\n\n        // If the axes fall along array lines, then this is a much simpler process since\n        // we already have all the control points we need\n        for(n = n1; n < n2; n++) {\n            j = axis.arraytick0 + axis.arraydtick * n;\n            if(j < 0 || j > data.length - 1) continue;\n            gridlines.push(extendFlat(constructArrayGridline(j), {\n                color: axis.gridcolor,\n                width: axis.gridwidth\n            }));\n        }\n\n        for(n = n1; n < n2; n++) {\n            j0 = axis.arraytick0 + axis.arraydtick * n;\n            j1 = Math.min(j0 + axis.arraydtick, data.length - 1);\n\n            // TODO: fix the bounds computation so we don't have to do a large range and then throw\n            // out unneeded numbers\n            if(j0 < 0 || j0 > data.length - 1) continue;\n            if(j1 < 0 || j1 > data.length - 1) continue;\n\n            v0 = data[j0];\n            v1 = data[j1];\n\n            for(i = 0; i < axis.minorgridcount; i++) {\n                d = j1 - j0;\n\n                // TODO: fix the bounds computation so we don't have to do a large range and then throw\n                // out unneeded numbers\n                if(d <= 0) continue;\n\n                // XXX: This calculation isn't quite right. Off by one somewhere?\n                v = v0 + (v1 - v0) * (i + 1) / (axis.minorgridcount + 1) * (axis.arraydtick / d);\n\n                // TODO: fix the bounds computation so we don't have to do a large range and then throw\n                // out unneeded numbers\n                if(v < data[0] || v > data[data.length - 1]) continue;\n                minorgridlines.push(extendFlat(constructValueGridline(v), {\n                    color: axis.minorgridcolor,\n                    width: axis.minorgridwidth\n                }));\n            }\n        }\n\n        if(axis.startline) {\n            boundarylines.push(extendFlat(constructArrayGridline(0), {\n                color: axis.startlinecolor,\n                width: axis.startlinewidth\n            }));\n        }\n\n        if(axis.endline) {\n            boundarylines.push(extendFlat(constructArrayGridline(data.length - 1), {\n                color: axis.endlinecolor,\n                width: axis.endlinewidth\n            }));\n        }\n    } else {\n        // If the lines do not fall along the axes, then we have to interpolate\n        // the contro points and so some math to figure out where the lines are\n        // in the first place.\n\n        // Compute the integer boudns of tick0 + n * dtick that fall within the range\n        // (roughly speaking):\n        // Give this a nice generous epsilon. We use at as * (1 + eps) in order to make\n        // inequalities a little tolerant in a more or less correct manner:\n        eps = 5e-15;\n        bounds = [\n            Math.floor((data[data.length - 1] - axis.tick0) / axis.dtick * (1 + eps)),\n            Math.ceil((data[0] - axis.tick0) / axis.dtick / (1 + eps))\n        ].sort(function(a, b) {return a - b;});\n\n        // Unpack sorted values so we can be sure to avoid infinite loops if something\n        // is backwards:\n        n1 = bounds[0];\n        n2 = bounds[1];\n\n        for(n = n1; n <= n2; n++) {\n            value = axis.tick0 + axis.dtick * n;\n\n            gridlines.push(extendFlat(constructValueGridline(value), {\n                color: axis.gridcolor,\n                width: axis.gridwidth\n            }));\n        }\n\n        for(n = n1 - 1; n < n2 + 1; n++) {\n            value = axis.tick0 + axis.dtick * n;\n\n            for(i = 0; i < axis.minorgridcount; i++) {\n                v = value + axis.dtick * (i + 1) / (axis.minorgridcount + 1);\n                if(v < data[0] || v > data[data.length - 1]) continue;\n                minorgridlines.push(extendFlat(constructValueGridline(v), {\n                    color: axis.minorgridcolor,\n                    width: axis.minorgridwidth\n                }));\n            }\n        }\n\n        if(axis.startline) {\n            boundarylines.push(extendFlat(constructValueGridline(data[0]), {\n                color: axis.startlinecolor,\n                width: axis.startlinewidth\n            }));\n        }\n\n        if(axis.endline) {\n            boundarylines.push(extendFlat(constructValueGridline(data[data.length - 1]), {\n                color: axis.endlinecolor,\n                width: axis.endlinewidth\n            }));\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/carpet/calc_labels.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Axes = require('../../plots/cartesian/axes');\nvar extendFlat = require('../../lib/extend').extendFlat;\n\nmodule.exports = function calcLabels(trace, axis) {\n    var i, tobj, prefix, suffix, gridline;\n\n    var labels = axis._labels = [];\n    var gridlines = axis._gridlines;\n\n    for(i = 0; i < gridlines.length; i++) {\n        gridline = gridlines[i];\n\n        if(['start', 'both'].indexOf(axis.showticklabels) !== -1) {\n            tobj = Axes.tickText(axis, gridline.value);\n\n            extendFlat(tobj, {\n                prefix: prefix,\n                suffix: suffix,\n                endAnchor: true,\n                xy: gridline.xy(0),\n                dxy: gridline.dxy(0, 0),\n                axis: gridline.axis,\n                length: gridline.crossAxis.length,\n                font: gridline.axis.tickfont,\n                isFirst: i === 0,\n                isLast: i === gridlines.length - 1\n            });\n\n            labels.push(tobj);\n        }\n\n        if(['end', 'both'].indexOf(axis.showticklabels) !== -1) {\n            tobj = Axes.tickText(axis, gridline.value);\n\n            extendFlat(tobj, {\n                endAnchor: false,\n                xy: gridline.xy(gridline.crossLength - 1),\n                dxy: gridline.dxy(gridline.crossLength - 2, 1),\n                axis: gridline.axis,\n                length: gridline.crossAxis.length,\n                font: gridline.axis.tickfont,\n                isFirst: i === 0,\n                isLast: i === gridlines.length - 1\n            });\n\n            labels.push(tobj);\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/carpet/calc_clippath.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nmodule.exports = function makeClipPath(xctrl, yctrl, aax, bax) {\n    var i, x, y;\n    var segments = [];\n\n    var asmoothing = !!aax.smoothing;\n    var bsmoothing = !!bax.smoothing;\n    var nea1 = xctrl[0].length - 1;\n    var neb1 = xctrl.length - 1;\n\n    // Along the lower a axis:\n    for(i = 0, x = [], y = []; i <= nea1; i++) {\n        x[i] = xctrl[0][i];\n        y[i] = yctrl[0][i];\n    }\n    segments.push({x: x, y: y, bicubic: asmoothing});\n\n    // Along the upper b axis:\n    for(i = 0, x = [], y = []; i <= neb1; i++) {\n        x[i] = xctrl[i][nea1];\n        y[i] = yctrl[i][nea1];\n    }\n    segments.push({x: x, y: y, bicubic: bsmoothing});\n\n    // Backwards along the upper a axis:\n    for(i = nea1, x = [], y = []; i >= 0; i--) {\n        x[nea1 - i] = xctrl[neb1][i];\n        y[nea1 - i] = yctrl[neb1][i];\n    }\n    segments.push({x: x, y: y, bicubic: asmoothing});\n\n    // Backwards along the lower b axis:\n    for(i = neb1, x = [], y = []; i >= 0; i--) {\n        x[neb1 - i] = xctrl[i][0];\n        y[neb1 - i] = yctrl[i][0];\n    }\n    segments.push({x: x, y: y, bicubic: bsmoothing});\n\n    return segments;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/heatmap/clean_2d_array.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nmodule.exports = function clean2dArray(zOld, transpose) {\n    var rowlen, collen, getCollen, old2new, i, j;\n\n    function cleanZvalue(v) {\n        if(!isNumeric(v)) return undefined;\n        return +v;\n    }\n\n    if(transpose) {\n        rowlen = 0;\n        for(i = 0; i < zOld.length; i++) rowlen = Math.max(rowlen, zOld[i].length);\n        if(rowlen === 0) return false;\n        getCollen = function(zOld) { return zOld.length; };\n        old2new = function(zOld, i, j) { return zOld[j][i]; };\n    }\n    else {\n        rowlen = zOld.length;\n        getCollen = function(zOld, i) { return zOld[i].length; };\n        old2new = function(zOld, i, j) { return zOld[i][j]; };\n    }\n\n    var zNew = new Array(rowlen);\n\n    for(i = 0; i < rowlen; i++) {\n        collen = getCollen(zOld, i);\n        zNew[i] = new Array(collen);\n        for(j = 0; j < collen; j++) zNew[i][j] = cleanZvalue(old2new(zOld, i, j));\n    }\n\n    return zNew;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/carpet/smooth_fill_2d_array.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\n\n/*\n * Given a 2D array as well as a basis in either direction, this function fills in the\n * 2D array using a combination of smoothing and extrapolation. This is rather important\n * for carpet plots since it's used for layout so that we can't simply omit or blank out\n * points. We need a reasonable guess so that the interpolation puts points somewhere\n * even if we were to somehow represent that the data was missing later on.\n *\n * input:\n *  - data: 2D array of arrays\n *  - a: array such that a.length === data[0].length\n *  - b: array such that b.length === data.length\n */\nmodule.exports = function smoothFill2dArray(data, a, b) {\n    var i, j, k;\n    var ip = [];\n    var jp = [];\n    // var neighborCnts = [];\n\n    var ni = data[0].length;\n    var nj = data.length;\n\n    function avgSurrounding(i, j) {\n        // As a low-quality start, we can simply average surrounding points (in a not\n        // non-uniform grid aware manner):\n        var sum = 0.0;\n        var val;\n        var cnt = 0;\n        if(i > 0 && (val = data[j][i - 1]) !== undefined) {\n            cnt++;\n            sum += val;\n        }\n        if(i < ni - 1 && (val = data[j][i + 1]) !== undefined) {\n            cnt++;\n            sum += val;\n        }\n        if(j > 0 && (val = data[j - 1][i]) !== undefined) {\n            cnt++;\n            sum += val;\n        }\n        if(j < nj - 1 && (val = data[j + 1][i]) !== undefined) {\n            cnt++;\n            sum += val;\n        }\n        return sum / Math.max(1, cnt);\n\n    }\n\n    // This loop iterates over all cells. Any cells that are null will be noted and those\n    // are the only points we will loop over and update via laplace's equation. Points with\n    // any neighbors will receive the average. If there are no neighboring points, then they\n    // will be set to zero. Also as we go, track the maximum magnitude so that we can scale\n    // our tolerance accordingly.\n    var dmax = 0.0;\n    for(i = 0; i < ni; i++) {\n        for(j = 0; j < nj; j++) {\n            if(data[j][i] === undefined) {\n                ip.push(i);\n                jp.push(j);\n\n                data[j][i] = avgSurrounding(i, j);\n                // neighborCnts.push(result.neighbors);\n            }\n            dmax = Math.max(dmax, Math.abs(data[j][i]));\n        }\n    }\n\n    if(!ip.length) return data;\n\n    // The tolerance doesn't need to be excessive. It's just for display positioning\n    var dxp, dxm, dap, dam, dbp, dbm, c, d, diff, reldiff, overrelaxation;\n    var tol = 1e-5;\n    var resid = 0;\n    var itermax = 100;\n    var iter = 0;\n    var n = ip.length;\n    do {\n        resid = 0;\n        // Normally we'd loop in two dimensions, but not all points are blank and need\n        // an update, so we instead loop only over the points that were tabulated above\n        for(k = 0; k < n; k++) {\n            i = ip[k];\n            j = jp[k];\n            // neighborCnt = neighborCnts[k];\n\n            // Track a counter for how many contributions there are. We'll use this counter\n            // to average at the end, which reduces to laplace's equation with neumann boundary\n            // conditions on the first derivative (second derivative is zero so that we get\n            // a nice linear extrapolation at the boundaries).\n            var boundaryCnt = 0;\n            var newVal = 0;\n\n            var d0, d1, x0, x1, i0, j0;\n            if(i === 0) {\n                // If this lies along the i = 0 boundary, extrapolate from the two points\n                // to the right of this point. Note that the finite differences take into\n                // account non-uniform grid spacing:\n                i0 = Math.min(ni - 1, 2);\n                x0 = a[i0];\n                x1 = a[1];\n                d0 = data[j][i0];\n                d1 = data[j][1];\n                newVal += d1 + (d1 - d0) * (a[0] - x1) / (x1 - x0);\n                boundaryCnt++;\n            } else if(i === ni - 1) {\n                // If along the high i boundary, extrapolate from the two points to the\n                // left of this point\n                i0 = Math.max(0, ni - 3);\n                x0 = a[i0];\n                x1 = a[ni - 2];\n                d0 = data[j][i0];\n                d1 = data[j][ni - 2];\n                newVal += d1 + (d1 - d0) * (a[ni - 1] - x1) / (x1 - x0);\n                boundaryCnt++;\n            }\n\n            if((i === 0 || i === ni - 1) && (j > 0 && j < nj - 1)) {\n                // If along the min(i) or max(i) boundaries, also smooth vertically as long\n                // as we're not in a corner. Note that the finite differences used here\n                // are also aware of nonuniform grid spacing:\n                dxp = b[j + 1] - b[j];\n                dxm = b[j] - b[j - 1];\n                newVal += (dxm * data[j + 1][i] + dxp * data[j - 1][i]) / (dxm + dxp);\n                boundaryCnt++;\n            }\n\n            if(j === 0) {\n                // If along the j = 0 boundary, extrpolate this point from the two points\n                // above it\n                j0 = Math.min(nj - 1, 2);\n                x0 = b[j0];\n                x1 = b[1];\n                d0 = data[j0][i];\n                d1 = data[1][i];\n                newVal += d1 + (d1 - d0) * (b[0] - x1) / (x1 - x0);\n                boundaryCnt++;\n            } else if(j === nj - 1) {\n                // Same for the max j boundary from the cells below it:\n                j0 = Math.max(0, nj - 3);\n                x0 = b[j0];\n                x1 = b[nj - 2];\n                d0 = data[j0][i];\n                d1 = data[nj - 2][i];\n                newVal += d1 + (d1 - d0) * (b[nj - 1] - x1) / (x1 - x0);\n                boundaryCnt++;\n            }\n\n            if((j === 0 || j === nj - 1) && (i > 0 && i < ni - 1)) {\n                // Now average points to the left/right as long as not in a corner:\n                dxp = a[i + 1] - a[i];\n                dxm = a[i] - a[i - 1];\n                newVal += (dxm * data[j][i + 1] + dxp * data[j][i - 1]) / (dxm + dxp);\n                boundaryCnt++;\n            }\n\n            if(!boundaryCnt) {\n                // If none of the above conditions were triggered, then this is an interior\n                // point and we can just do a laplace equation update. As above, these differences\n                // are aware of nonuniform grid spacing:\n                dap = a[i + 1] - a[i];\n                dam = a[i] - a[i - 1];\n                dbp = b[j + 1] - b[j];\n                dbm = b[j] - b[j - 1];\n\n                // These are just some useful constants for the iteration, which is perfectly\n                // straightforward but a little long to derive from f_xx + f_yy = 0.\n                c = dap * dam * (dap + dam);\n                d = dbp * dbm * (dbp + dbm);\n\n                newVal = (c * (dbm * data[j + 1][i] + dbp * data[j - 1][i]) +\n                          d * (dam * data[j][i + 1] + dap * data[j][i - 1])) /\n                          (d * (dam + dap) + c * (dbm + dbp));\n            } else {\n                // If we did have contributions from the boundary conditions, then average\n                // the result from the various contributions:\n                newVal /= boundaryCnt;\n            }\n\n            // Jacobi updates are ridiculously slow to converge, so this approach uses a\n            // Gauss-seidel iteration which is dramatically faster.\n            diff = newVal - data[j][i];\n            reldiff = diff / dmax;\n            resid += reldiff * reldiff;\n\n            // Gauss-Seidel-ish iteration, omega chosen based on heuristics and some\n            // quick tests.\n            //\n            // NB: Don't overrelax the boundarie. Otherwise set an overrelaxation factor\n            // which is a little low but safely optimal-ish:\n            overrelaxation = boundaryCnt ? 0 : 0.85;\n\n            // If there are four non-null neighbors, then we want a simple average without\n            // overrelaxation. If all the surrouding points are null, then we want the full\n            // overrelaxation\n            //\n            // Based on experiments, this actually seems to slow down convergence just a bit.\n            // I'll leave it here for reference in case this needs to be revisited, but\n            // it seems to work just fine without this.\n            // if (overrelaxation) overrelaxation *= (4 - neighborCnt) / 4;\n\n            data[j][i] += diff * (1 + overrelaxation);\n        }\n\n        resid = Math.sqrt(resid);\n    } while(iter++ < itermax && resid > tol);\n\n    Lib.log('Smoother converged to', resid, 'after', iter, 'iterations');\n\n    return data;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/lib/choropleth.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = require('../src/traces/choropleth');\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/choropleth/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Choropleth = {};\n\nChoropleth.attributes = require('./attributes');\nChoropleth.supplyDefaults = require('./defaults');\nChoropleth.colorbar = require('../heatmap/colorbar');\nChoropleth.calc = require('./calc');\nChoropleth.plot = require('./plot');\nChoropleth.hoverPoints = require('./hover');\nChoropleth.eventData = require('./event_data');\n\nChoropleth.moduleType = 'trace';\nChoropleth.name = 'choropleth';\nChoropleth.basePlotModule = require('../../plots/geo');\nChoropleth.categories = ['geo', 'noOpacity'];\nChoropleth.meta = {\n    description: [\n        'The data that describes the choropleth value-to-color mapping',\n        'is set in `z`.',\n        'The geographic locations corresponding to each value in `z`',\n        'are set in `locations`.'\n    ].join(' ')\n};\n\nmodule.exports = Choropleth;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/choropleth/attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar ScatterGeoAttrs = require('../scattergeo/attributes');\nvar colorscaleAttrs = require('../../components/colorscale/attributes');\nvar colorbarAttrs = require('../../components/colorbar/attributes');\nvar plotAttrs = require('../../plots/attributes');\n\nvar extendFlat = require('../../lib/extend').extendFlat;\n\nvar ScatterGeoMarkerLineAttrs = ScatterGeoAttrs.marker.line;\n\nmodule.exports = extendFlat({}, {\n    locations: {\n        valType: 'data_array',\n        description: [\n            'Sets the coordinates via location IDs or names.',\n            'See `locationmode` for more info.'\n        ].join(' ')\n    },\n    locationmode: ScatterGeoAttrs.locationmode,\n    z: {\n        valType: 'data_array',\n        description: 'Sets the color values.'\n    },\n    text: {\n        valType: 'data_array',\n        description: 'Sets the text elements associated with each location.'\n    },\n    marker: {\n        line: {\n            color: ScatterGeoMarkerLineAttrs.color,\n            width: extendFlat({}, ScatterGeoMarkerLineAttrs.width, {dflt: 1})\n        }\n    },\n    hoverinfo: extendFlat({}, plotAttrs.hoverinfo, {\n        flags: ['location', 'z', 'text', 'name']\n    }),\n},\n    colorscaleAttrs,\n    { colorbar: colorbarAttrs }\n);\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/scattergeo/attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar scatterAttrs = require('../scatter/attributes');\nvar plotAttrs = require('../../plots/attributes');\nvar colorAttributes = require('../../components/colorscale/color_attributes');\nvar dash = require('../../components/drawing/attributes').dash;\n\nvar extendFlat = require('../../lib/extend').extendFlat;\n\nvar scatterMarkerAttrs = scatterAttrs.marker,\n    scatterLineAttrs = scatterAttrs.line,\n    scatterMarkerLineAttrs = scatterMarkerAttrs.line;\n\nmodule.exports = {\n    lon: {\n        valType: 'data_array',\n        description: 'Sets the longitude coordinates (in degrees East).'\n    },\n    lat: {\n        valType: 'data_array',\n        description: 'Sets the latitude coordinates (in degrees North).'\n    },\n\n    locations: {\n        valType: 'data_array',\n        description: [\n            'Sets the coordinates via location IDs or names.',\n            'Coordinates correspond to the centroid of each location given.',\n            'See `locationmode` for more info.'\n        ].join(' ')\n    },\n    locationmode: {\n        valType: 'enumerated',\n        values: ['ISO-3', 'USA-states', 'country names'],\n        role: 'info',\n        dflt: 'ISO-3',\n        description: [\n            'Determines the set of locations used to match entries in `locations`',\n            'to regions on the map.'\n        ].join(' ')\n    },\n\n    mode: extendFlat({}, scatterAttrs.mode, {dflt: 'markers'}),\n\n    text: extendFlat({}, scatterAttrs.text, {\n        description: [\n            'Sets text elements associated with each (lon,lat) pair',\n            'or item in `locations`.',\n            'If a single string, the same string appears over',\n            'all the data points.',\n            'If an array of string, the items are mapped in order to the',\n            'this trace\\'s (lon,lat) or `locations` coordinates.',\n            'If trace `hoverinfo` contains a *text* flag and *hovertext* is not set,',\n            'these elements will be seen in the hover labels.'\n        ].join(' ')\n    }),\n    hovertext: extendFlat({}, scatterAttrs.hovertext, {\n        description: [\n            'Sets hover text elements associated with each (lon,lat) pair',\n            'or item in `locations`.',\n            'If a single string, the same string appears over',\n            'all the data points.',\n            'If an array of string, the items are mapped in order to the',\n            'this trace\\'s (lon,lat) or `locations` coordinates.',\n            'To be seen, trace `hoverinfo` must contain a *text* flag.'\n        ].join(' ')\n    }),\n\n    textfont: scatterAttrs.textfont,\n    textposition: scatterAttrs.textposition,\n\n    line: {\n        color: scatterLineAttrs.color,\n        width: scatterLineAttrs.width,\n        dash: dash\n    },\n    connectgaps: scatterAttrs.connectgaps,\n\n    marker: extendFlat({}, {\n        symbol: scatterMarkerAttrs.symbol,\n        opacity: scatterMarkerAttrs.opacity,\n        size: scatterMarkerAttrs.size,\n        sizeref: scatterMarkerAttrs.sizeref,\n        sizemin: scatterMarkerAttrs.sizemin,\n        sizemode: scatterMarkerAttrs.sizemode,\n        showscale: scatterMarkerAttrs.showscale,\n        colorbar: scatterMarkerAttrs.colorbar,\n        line: extendFlat({},\n            {width: scatterMarkerLineAttrs.width},\n            colorAttributes('marker.line')\n        )\n    },\n        colorAttributes('marker')\n    ),\n\n    fill: {\n        valType: 'enumerated',\n        values: ['none', 'toself'],\n        dflt: 'none',\n        role: 'style',\n        description: [\n            'Sets the area to fill with a solid color.',\n            'Use with `fillcolor` if not *none*.',\n            '*toself* connects the endpoints of the trace (or each segment',\n            'of the trace if it has gaps) into a closed shape.'\n        ].join(' ')\n    },\n    fillcolor: scatterAttrs.fillcolor,\n\n    hoverinfo: extendFlat({}, plotAttrs.hoverinfo, {\n        flags: ['lon', 'lat', 'location', 'text', 'name']\n    })\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/lib/contourcarpet.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = require('../src/traces/contourcarpet');\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/contourcarpet/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar ContourCarpet = {};\n\nContourCarpet.attributes = require('./attributes');\nContourCarpet.supplyDefaults = require('./defaults');\nContourCarpet.colorbar = require('../contour/colorbar');\nContourCarpet.calc = require('./calc');\nContourCarpet.plot = require('./plot');\nContourCarpet.style = require('./style');\n\nContourCarpet.moduleType = 'trace';\nContourCarpet.name = 'contourcarpet';\nContourCarpet.basePlotModule = require('../../plots/cartesian');\nContourCarpet.categories = ['cartesian', 'carpet', 'contour', 'symbols', 'showLegend', 'hasLines', 'carpetDependent'];\nContourCarpet.meta = {\n    hrName: 'contour_carpet',\n    description: [\n        'Plots contours on either the first carpet axis or the',\n        'carpet axis with a matching `carpet` attribute. Data `z`',\n        'is interpreted as matching that of the corresponding carpet',\n        'axis.'\n    ].join(' ')\n};\n\nmodule.exports = ContourCarpet;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/contourcarpet/attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar heatmapAttrs = require('../heatmap/attributes');\nvar scatterAttrs = require('../scatter/attributes');\nvar colorscaleAttrs = require('../../components/colorscale/attributes');\nvar colorbarAttrs = require('../../components/colorbar/attributes');\n\nvar extendFlat = require('../../lib/extend').extendFlat;\n\nvar scatterLineAttrs = scatterAttrs.line;\nvar constants = require('./constants');\n\nmodule.exports = extendFlat({}, {\n    carpet: {\n        valType: 'string',\n        role: 'info',\n        description: [\n            'The `carpet` of the carpet axes on which this contour trace lies'\n        ].join(' ')\n    },\n    z: heatmapAttrs.z,\n    a: heatmapAttrs.x,\n    a0: heatmapAttrs.x0,\n    da: heatmapAttrs.dx,\n    b: heatmapAttrs.y,\n    b0: heatmapAttrs.y0,\n    db: heatmapAttrs.dy,\n    text: heatmapAttrs.text,\n    transpose: heatmapAttrs.transpose,\n    atype: heatmapAttrs.xtype,\n    btype: heatmapAttrs.ytype,\n\n    mode: {\n        valType: 'flaglist',\n        flags: ['lines', 'fill'],\n        extras: ['none'],\n        role: 'info',\n        description: ['The mode.'].join(' ')\n    },\n\n    connectgaps: heatmapAttrs.connectgaps,\n\n    fillcolor: {\n        valType: 'color',\n        role: 'style',\n        description: [\n            'Sets the fill color.',\n            'Defaults to a half-transparent variant of the line color,',\n            'marker color, or marker line color, whichever is available.'\n        ].join(' ')\n    },\n\n    autocontour: {\n        valType: 'boolean',\n        dflt: true,\n        role: 'style',\n        description: [\n            'Determines whether or not the contour level attributes are',\n            'picked by an algorithm.',\n            'If *true*, the number of contour levels can be set in `ncontours`.',\n            'If *false*, set the contour level attributes in `contours`.'\n        ].join(' ')\n    },\n    ncontours: {\n        valType: 'integer',\n        dflt: 15,\n        min: 1,\n        role: 'style',\n        description: [\n            'Sets the maximum number of contour levels. The actual number',\n            'of contours will be chosen automatically to be less than or',\n            'equal to the value of `ncontours`.',\n            'Has an effect only if `autocontour` is *true* or if',\n            '`contours.size` is missing.'\n        ].join(' ')\n    },\n\n    contours: {\n        type: {\n            valType: 'enumerated',\n            values: ['levels', 'constraint'],\n            dflt: 'levels',\n            role: 'info',\n            description: [\n                'If `levels`, the data is represented as a contour plot with multiple',\n                'levels displayed. If `constraint`, the data is represented as constraints',\n                'with the invalid region shaded as specified by the `operation` and',\n                '`value` parameters.'\n            ].join(' ')\n        },\n        start: {\n            valType: 'number',\n            dflt: null,\n            role: 'style',\n            description: [\n                'Sets the starting contour level value.',\n                'Must be less than `contours.end`'\n            ].join(' ')\n        },\n        end: {\n            valType: 'number',\n            dflt: null,\n            role: 'style',\n            description: [\n                'Sets the end contour level value.',\n                'Must be more than `contours.start`'\n            ].join(' ')\n        },\n        size: {\n            valType: 'number',\n            dflt: null,\n            min: 0,\n            role: 'style',\n            description: [\n                'Sets the step between each contour level.',\n                'Must be positive.'\n            ].join(' ')\n        },\n        coloring: {\n            valType: 'enumerated',\n            values: ['fill', 'lines', 'none'],\n            dflt: 'fill',\n            role: 'style',\n            description: [\n                'Determines the coloring method showing the contour values.',\n                'If *fill*, coloring is done evenly between each contour level',\n                'If *lines*, coloring is done on the contour lines.',\n                'If *none*, no coloring is applied on this trace.'\n            ].join(' ')\n        },\n        showlines: {\n            valType: 'boolean',\n            dflt: true,\n            role: 'style',\n            description: [\n                'Determines whether or not the contour lines are drawn.',\n                'Has only an effect if `contours.coloring` is set to *fill*.'\n            ].join(' ')\n        },\n        operation: {\n            valType: 'enumerated',\n            values: [].concat(constants.INEQUALITY_OPS).concat(constants.INTERVAL_OPS).concat(constants.SET_OPS),\n            role: 'info',\n            dflt: '=',\n            description: [\n                'Sets the filter operation.',\n\n                '*=* keeps items equal to `value`',\n\n                '*<* keeps items less than `value`',\n                '*<=* keeps items less than or equal to `value`',\n\n                '*>* keeps items greater than `value`',\n                '*>=* keeps items greater than or equal to `value`',\n\n                '*[]* keeps items inside `value[0]` to value[1]` including both bounds`',\n                '*()* keeps items inside `value[0]` to value[1]` excluding both bounds`',\n                '*[)* keeps items inside `value[0]` to value[1]` including `value[0]` but excluding `value[1]',\n                '*(]* keeps items inside `value[0]` to value[1]` excluding `value[0]` but including `value[1]',\n\n                '*][* keeps items outside `value[0]` to value[1]` and equal to both bounds`',\n                '*)(* keeps items outside `value[0]` to value[1]`',\n                '*](* keeps items outside `value[0]` to value[1]` and equal to `value[0]`',\n                '*)[* keeps items outside `value[0]` to value[1]` and equal to `value[1]`'\n            ].join(' ')\n        },\n        value: {\n            valType: 'any',\n            dflt: 0,\n            role: 'info',\n            description: [\n                'Sets the value or values by which to filter by.',\n\n                'Values are expected to be in the same type as the data linked',\n                'to *target*.',\n\n                'When `operation` is set to one of the inequality values',\n                '(' + constants.INEQUALITY_OPS + ')',\n                '*value* is expected to be a number or a string.',\n\n                'When `operation` is set to one of the interval value',\n                '(' + constants.INTERVAL_OPS + ')',\n                '*value* is expected to be 2-item array where the first item',\n                'is the lower bound and the second item is the upper bound.',\n\n                'When `operation`, is set to one of the set value',\n                '(' + constants.SET_OPS + ')',\n                '*value* is expected to be an array with as many items as',\n                'the desired set elements.'\n            ].join(' ')\n        }\n    },\n\n    line: {\n        color: extendFlat({}, scatterLineAttrs.color, {\n            description: [\n                'Sets the color of the contour level.',\n                'Has no if `contours.coloring` is set to *lines*.'\n            ].join(' ')\n        }),\n        width: scatterLineAttrs.width,\n        dash: scatterLineAttrs.dash,\n        smoothing: extendFlat({}, scatterLineAttrs.smoothing, {\n            description: [\n                'Sets the amount of smoothing for the contour lines,',\n                'where *0* corresponds to no smoothing.'\n            ].join(' ')\n        })\n    }\n},\n    colorscaleAttrs,\n    { autocolorscale: extendFlat({}, colorscaleAttrs.autocolorscale, {dflt: false}) },\n    { colorbar: colorbarAttrs }\n);\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/heatmap/attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar scatterAttrs = require('../scatter/attributes');\nvar colorscaleAttrs = require('../../components/colorscale/attributes');\nvar colorbarAttrs = require('../../components/colorbar/attributes');\n\nvar extendFlat = require('../../lib/extend').extendFlat;\n\nmodule.exports = extendFlat({}, {\n    z: {\n        valType: 'data_array',\n        description: 'Sets the z data.'\n    },\n    x: scatterAttrs.x,\n    x0: scatterAttrs.x0,\n    dx: scatterAttrs.dx,\n    y: scatterAttrs.y,\n    y0: scatterAttrs.y0,\n    dy: scatterAttrs.dy,\n\n    text: {\n        valType: 'data_array',\n        description: 'Sets the text elements associated with each z value.'\n    },\n    transpose: {\n        valType: 'boolean',\n        dflt: false,\n        role: 'info',\n        description: 'Transposes the z data.'\n    },\n    xtype: {\n        valType: 'enumerated',\n        values: ['array', 'scaled'],\n        role: 'info',\n        description: [\n            'If *array*, the heatmap\\'s x coordinates are given by *x*',\n            '(the default behavior when `x` is provided).',\n            'If *scaled*, the heatmap\\'s x coordinates are given by *x0* and *dx*',\n            '(the default behavior when `x` is not provided).'\n        ].join(' ')\n    },\n    ytype: {\n        valType: 'enumerated',\n        values: ['array', 'scaled'],\n        role: 'info',\n        description: [\n            'If *array*, the heatmap\\'s y coordinates are given by *y*',\n            '(the default behavior when `y` is provided)',\n            'If *scaled*, the heatmap\\'s y coordinates are given by *y0* and *dy*',\n            '(the default behavior when `y` is not provided)'\n        ].join(' ')\n    },\n    zsmooth: {\n        valType: 'enumerated',\n        values: ['fast', 'best', false],\n        dflt: false,\n        role: 'style',\n        description: [\n            'Picks a smoothing algorithm use to smooth `z` data.'\n        ].join(' ')\n    },\n    connectgaps: {\n        valType: 'boolean',\n        dflt: false,\n        role: 'info',\n        description: [\n            'Determines whether or not gaps',\n            '(i.e. {nan} or missing values)',\n            'in the `z` data are filled in.'\n        ].join(' ')\n    },\n    xgap: {\n        valType: 'number',\n        dflt: 0,\n        min: 0,\n        role: 'style',\n        description: 'Sets the horizontal gap (in pixels) between bricks.'\n    },\n    ygap: {\n        valType: 'number',\n        dflt: 0,\n        min: 0,\n        role: 'style',\n        description: 'Sets the vertical gap (in pixels) between bricks.'\n    },\n},\n    colorscaleAttrs,\n    { autocolorscale: extendFlat({}, colorscaleAttrs.autocolorscale, {dflt: false}) },\n    { colorbar: colorbarAttrs }\n);\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/lib/contourgl.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = require('../src/traces/contourgl');\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/contourgl/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar ContourGl = {};\n\nContourGl.attributes = require('../contour/attributes');\nContourGl.supplyDefaults = require('../contour/defaults');\nContourGl.colorbar = require('../contour/colorbar');\n\nContourGl.calc = require('../contour/calc');\nContourGl.plot = require('./convert');\n\nContourGl.moduleType = 'trace';\nContourGl.name = 'contourgl';\nContourGl.basePlotModule = require('../../plots/gl2d');\nContourGl.categories = ['gl2d', '2dMap'];\nContourGl.meta = {\n    description: [\n        'WebGL contour (beta)'\n    ].join(' ')\n};\n\nmodule.exports = ContourGl;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/contour/attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar heatmapAttrs = require('../heatmap/attributes');\nvar scatterAttrs = require('../scatter/attributes');\nvar colorscaleAttrs = require('../../components/colorscale/attributes');\nvar colorbarAttrs = require('../../components/colorbar/attributes');\nvar dash = require('../../components/drawing/attributes').dash;\nvar extendFlat = require('../../lib/extend').extendFlat;\n\nvar scatterLineAttrs = scatterAttrs.line;\n\nmodule.exports = extendFlat({}, {\n    z: heatmapAttrs.z,\n    x: heatmapAttrs.x,\n    x0: heatmapAttrs.x0,\n    dx: heatmapAttrs.dx,\n    y: heatmapAttrs.y,\n    y0: heatmapAttrs.y0,\n    dy: heatmapAttrs.dy,\n    text: heatmapAttrs.text,\n    transpose: heatmapAttrs.transpose,\n    xtype: heatmapAttrs.xtype,\n    ytype: heatmapAttrs.ytype,\n\n    connectgaps: heatmapAttrs.connectgaps,\n\n    autocontour: {\n        valType: 'boolean',\n        dflt: true,\n        role: 'style',\n        description: [\n            'Determines whether or not the contour level attributes are',\n            'picked by an algorithm.',\n            'If *true*, the number of contour levels can be set in `ncontours`.',\n            'If *false*, set the contour level attributes in `contours`.'\n        ].join(' ')\n    },\n    ncontours: {\n        valType: 'integer',\n        dflt: 15,\n        min: 1,\n        role: 'style',\n        description: [\n            'Sets the maximum number of contour levels. The actual number',\n            'of contours will be chosen automatically to be less than or',\n            'equal to the value of `ncontours`.',\n            'Has an effect only if `autocontour` is *true* or if',\n            '`contours.size` is missing.'\n        ].join(' ')\n    },\n\n    contours: {\n        start: {\n            valType: 'number',\n            dflt: null,\n            role: 'style',\n            description: [\n                'Sets the starting contour level value.',\n                'Must be less than `contours.end`'\n            ].join(' ')\n        },\n        end: {\n            valType: 'number',\n            dflt: null,\n            role: 'style',\n            description: [\n                'Sets the end contour level value.',\n                'Must be more than `contours.start`'\n            ].join(' ')\n        },\n        size: {\n            valType: 'number',\n            dflt: null,\n            min: 0,\n            role: 'style',\n            description: [\n                'Sets the step between each contour level.',\n                'Must be positive.'\n            ].join(' ')\n        },\n        coloring: {\n            valType: 'enumerated',\n            values: ['fill', 'heatmap', 'lines', 'none'],\n            dflt: 'fill',\n            role: 'style',\n            description: [\n                'Determines the coloring method showing the contour values.',\n                'If *fill*, coloring is done evenly between each contour level',\n                'If *heatmap*, a heatmap gradient coloring is applied',\n                'between each contour level.',\n                'If *lines*, coloring is done on the contour lines.',\n                'If *none*, no coloring is applied on this trace.'\n            ].join(' ')\n        },\n        showlines: {\n            valType: 'boolean',\n            dflt: true,\n            role: 'style',\n            description: [\n                'Determines whether or not the contour lines are drawn.',\n                'Has only an effect if `contours.coloring` is set to *fill*.'\n            ].join(' ')\n        }\n    },\n\n    line: {\n        color: extendFlat({}, scatterLineAttrs.color, {\n            description: [\n                'Sets the color of the contour level.',\n                'Has no if `contours.coloring` is set to *lines*.'\n            ].join(' ')\n        }),\n        width: scatterLineAttrs.width,\n        dash: dash,\n        smoothing: extendFlat({}, scatterLineAttrs.smoothing, {\n            description: [\n                'Sets the amount of smoothing for the contour lines,',\n                'where *0* corresponds to no smoothing.'\n            ].join(' ')\n        })\n    }\n},\n    colorscaleAttrs,\n    { autocolorscale: extendFlat({}, colorscaleAttrs.autocolorscale, {dflt: false}) },\n    { colorbar: colorbarAttrs }\n);\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/lib/contour.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = require('../src/traces/contour');\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/contour/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Contour = {};\n\nContour.attributes = require('./attributes');\nContour.supplyDefaults = require('./defaults');\nContour.calc = require('./calc');\nContour.plot = require('./plot');\nContour.style = require('./style');\nContour.colorbar = require('./colorbar');\nContour.hoverPoints = require('./hover');\n\nContour.moduleType = 'trace';\nContour.name = 'contour';\nContour.basePlotModule = require('../../plots/cartesian');\nContour.categories = ['cartesian', '2dMap', 'contour'];\nContour.meta = {\n    description: [\n        'The data from which contour lines are computed is set in `z`.',\n        'Data in `z` must be a {2D array} of numbers.',\n\n        'Say that `z` has N rows and M columns, then by default,',\n        'these N rows correspond to N y coordinates',\n        '(set in `y` or auto-generated) and the M columns',\n        'correspond to M x coordinates (set in `x` or auto-generated).',\n        'By setting `transpose` to *true*, the above behavior is flipped.'\n    ].join(' ')\n};\n\nmodule.exports = Contour;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/lib/filter.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = require('../src/transforms/filter');\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/transforms/filter.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../lib');\nvar Registry = require('../registry');\nvar PlotSchema = require('../plot_api/plot_schema');\nvar axisIds = require('../plots/cartesian/axis_ids');\nvar autoType = require('../plots/cartesian/axis_autotype');\nvar setConvert = require('../plots/cartesian/set_convert');\n\nvar INEQUALITY_OPS = ['=', '<', '>=', '>', '<='];\nvar INTERVAL_OPS = ['[]', '()', '[)', '(]', '][', ')(', '](', ')['];\nvar SET_OPS = ['{}', '}{'];\n\nexports.moduleType = 'transform';\n\nexports.name = 'filter';\n\nexports.attributes = {\n    enabled: {\n        valType: 'boolean',\n        dflt: true,\n        description: [\n            'Determines whether this filter transform is enabled or disabled.'\n        ].join(' ')\n    },\n    target: {\n        valType: 'string',\n        strict: true,\n        noBlank: true,\n        arrayOk: true,\n        dflt: 'x',\n        description: [\n            'Sets the filter target by which the filter is applied.',\n\n            'If a string, *target* is assumed to be a reference to a data array',\n            'in the parent trace object.',\n            'To filter about nested variables, use *.* to access them.',\n            'For example, set `target` to *marker.color* to filter',\n            'about the marker color array.',\n\n            'If an array, *target* is then the data array by which the filter is applied.'\n        ].join(' ')\n    },\n    operation: {\n        valType: 'enumerated',\n        values: [].concat(INEQUALITY_OPS).concat(INTERVAL_OPS).concat(SET_OPS),\n        dflt: '=',\n        description: [\n            'Sets the filter operation.',\n\n            '*=* keeps items equal to `value`',\n\n            '*<* keeps items less than `value`',\n            '*<=* keeps items less than or equal to `value`',\n\n            '*>* keeps items greater than `value`',\n            '*>=* keeps items greater than or equal to `value`',\n\n            '*[]* keeps items inside `value[0]` to value[1]` including both bounds`',\n            '*()* keeps items inside `value[0]` to value[1]` excluding both bounds`',\n            '*[)* keeps items inside `value[0]` to value[1]` including `value[0]` but excluding `value[1]',\n            '*(]* keeps items inside `value[0]` to value[1]` excluding `value[0]` but including `value[1]',\n\n            '*][* keeps items outside `value[0]` to value[1]` and equal to both bounds`',\n            '*)(* keeps items outside `value[0]` to value[1]`',\n            '*](* keeps items outside `value[0]` to value[1]` and equal to `value[0]`',\n            '*)[* keeps items outside `value[0]` to value[1]` and equal to `value[1]`',\n\n            '*{}* keeps items present in a set of values',\n            '*}{* keeps items not present in a set of values'\n        ].join(' ')\n    },\n    value: {\n        valType: 'any',\n        dflt: 0,\n        description: [\n            'Sets the value or values by which to filter by.',\n\n            'Values are expected to be in the same type as the data linked',\n            'to *target*.',\n\n            'When `operation` is set to one of the inequality values',\n            '(' + INEQUALITY_OPS + ')',\n            '*value* is expected to be a number or a string.',\n\n            'When `operation` is set to one of the interval value',\n            '(' + INTERVAL_OPS + ')',\n            '*value* is expected to be 2-item array where the first item',\n            'is the lower bound and the second item is the upper bound.',\n\n            'When `operation`, is set to one of the set value',\n            '(' + SET_OPS + ')',\n            '*value* is expected to be an array with as many items as',\n            'the desired set elements.'\n        ].join(' ')\n    }\n};\n\nexports.supplyDefaults = function(transformIn) {\n    var transformOut = {};\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(transformIn, transformOut, exports.attributes, attr, dflt);\n    }\n\n    var enabled = coerce('enabled');\n\n    if(enabled) {\n        coerce('operation');\n        coerce('value');\n        coerce('target');\n\n        var handleCalendarDefaults = Registry.getComponentMethod('calendars', 'handleDefaults');\n        handleCalendarDefaults(transformIn, transformOut, 'valuecalendar', null);\n        handleCalendarDefaults(transformIn, transformOut, 'targetcalendar', null);\n    }\n\n    return transformOut;\n};\n\nexports.calcTransform = function(gd, trace, opts) {\n    if(!opts.enabled) return;\n\n    var target = opts.target,\n        filterArray = getFilterArray(trace, target),\n        len = filterArray.length;\n\n    if(!len) return;\n\n    var targetCalendar = opts.targetcalendar;\n\n    // even if you provide targetcalendar, if target is a string and there\n    // is a calendar attribute matching target it will get used instead.\n    if(typeof target === 'string') {\n        var attrTargetCalendar = Lib.nestedProperty(trace, target + 'calendar').get();\n        if(attrTargetCalendar) targetCalendar = attrTargetCalendar;\n    }\n\n    // if target points to an axis, use the type we already have for that\n    // axis to find the data type. Otherwise use the values to autotype.\n    var d2cTarget = (target === 'x' || target === 'y' || target === 'z') ?\n        target : filterArray;\n\n    var dataToCoord = getDataToCoordFunc(gd, trace, d2cTarget),\n        filterFunc = getFilterFunc(opts, dataToCoord, targetCalendar),\n        arrayAttrs = PlotSchema.findArrayAttributes(trace),\n        originalArrays = {};\n\n    // copy all original array attribute values,\n    // and clear arrays in trace\n    for(var k = 0; k < arrayAttrs.length; k++) {\n        var attr = arrayAttrs[k],\n            np = Lib.nestedProperty(trace, attr);\n\n        originalArrays[attr] = Lib.extendDeep([], np.get());\n        np.set([]);\n    }\n\n    function fill(attr, i) {\n        var oldArr = originalArrays[attr],\n            newArr = Lib.nestedProperty(trace, attr).get();\n\n        newArr.push(oldArr[i]);\n    }\n\n    for(var i = 0; i < len; i++) {\n        var v = filterArray[i];\n\n        if(!filterFunc(v)) continue;\n\n        for(var j = 0; j < arrayAttrs.length; j++) {\n            fill(arrayAttrs[j], i);\n        }\n    }\n};\n\nfunction getFilterArray(trace, target) {\n    if(typeof target === 'string' && target) {\n        var array = Lib.nestedProperty(trace, target).get();\n\n        return Array.isArray(array) ? array : [];\n    }\n    else if(Array.isArray(target)) return target.slice();\n\n    return false;\n}\n\nfunction getDataToCoordFunc(gd, trace, target) {\n    var ax;\n\n    // In the case of an array target, make a mock data array\n    // and call supplyDefaults to the data type and\n    // setup the data-to-calc method.\n    if(Array.isArray(target)) {\n        ax = {\n            type: autoType(target),\n            _categories: []\n        };\n\n        setConvert(ax);\n\n        if(ax.type === 'category') {\n            // build up ax._categories (usually done during ax.makeCalcdata()\n            for(var i = 0; i < target.length; i++) {\n                ax.d2c(target[i]);\n            }\n        }\n    }\n    else {\n        ax = axisIds.getFromTrace(gd, trace, target);\n    }\n\n    // if 'target' has corresponding axis\n    // -> use setConvert method\n    if(ax) return ax.d2c;\n\n    // special case for 'ids'\n    // -> cast to String\n    if(target === 'ids') return function(v) { return String(v); };\n\n    // otherwise (e.g. numeric-array of 'marker.color' or 'marker.size')\n    // -> cast to Number\n    return function(v) { return +v; };\n}\n\nfunction getFilterFunc(opts, d2c, targetCalendar) {\n    var operation = opts.operation,\n        value = opts.value,\n        hasArrayValue = Array.isArray(value);\n\n    function isOperationIn(array) {\n        return array.indexOf(operation) !== -1;\n    }\n\n    var d2cValue = function(v) { return d2c(v, 0, opts.valuecalendar); },\n        d2cTarget = function(v) { return d2c(v, 0, targetCalendar); };\n\n    var coercedValue;\n\n    if(isOperationIn(INEQUALITY_OPS)) {\n        coercedValue = hasArrayValue ? d2cValue(value[0]) : d2cValue(value);\n    }\n    else if(isOperationIn(INTERVAL_OPS)) {\n        coercedValue = hasArrayValue ?\n            [d2cValue(value[0]), d2cValue(value[1])] :\n            [d2cValue(value), d2cValue(value)];\n    }\n    else if(isOperationIn(SET_OPS)) {\n        coercedValue = hasArrayValue ? value.map(d2cValue) : [d2cValue(value)];\n    }\n\n    switch(operation) {\n\n        case '=':\n            return function(v) { return d2cTarget(v) === coercedValue; };\n\n        case '<':\n            return function(v) { return d2cTarget(v) < coercedValue; };\n\n        case '<=':\n            return function(v) { return d2cTarget(v) <= coercedValue; };\n\n        case '>':\n            return function(v) { return d2cTarget(v) > coercedValue; };\n\n        case '>=':\n            return function(v) { return d2cTarget(v) >= coercedValue; };\n\n        case '[]':\n            return function(v) {\n                var cv = d2cTarget(v);\n                return cv >= coercedValue[0] && cv <= coercedValue[1];\n            };\n\n        case '()':\n            return function(v) {\n                var cv = d2cTarget(v);\n                return cv > coercedValue[0] && cv < coercedValue[1];\n            };\n\n        case '[)':\n            return function(v) {\n                var cv = d2cTarget(v);\n                return cv >= coercedValue[0] && cv < coercedValue[1];\n            };\n\n        case '(]':\n            return function(v) {\n                var cv = d2cTarget(v);\n                return cv > coercedValue[0] && cv <= coercedValue[1];\n            };\n\n        case '][':\n            return function(v) {\n                var cv = d2cTarget(v);\n                return cv <= coercedValue[0] || cv >= coercedValue[1];\n            };\n\n        case ')(':\n            return function(v) {\n                var cv = d2cTarget(v);\n                return cv < coercedValue[0] || cv > coercedValue[1];\n            };\n\n        case '](':\n            return function(v) {\n                var cv = d2cTarget(v);\n                return cv <= coercedValue[0] || cv > coercedValue[1];\n            };\n\n        case ')[':\n            return function(v) {\n                var cv = d2cTarget(v);\n                return cv < coercedValue[0] || cv >= coercedValue[1];\n            };\n\n        case '{}':\n            return function(v) {\n                return coercedValue.indexOf(d2cTarget(v)) !== -1;\n            };\n\n        case '}{':\n            return function(v) {\n                return coercedValue.indexOf(d2cTarget(v)) === -1;\n            };\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plot_api/plot_schema.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Registry = require('../registry');\nvar Lib = require('../lib');\n\nvar baseAttributes = require('../plots/attributes');\nvar baseLayoutAttributes = require('../plots/layout_attributes');\nvar frameAttributes = require('../plots/frame_attributes');\nvar animationAttributes = require('../plots/animation_attributes');\n\n// polar attributes are not part of the Registry yet\nvar polarAreaAttrs = require('../plots/polar/area_attributes');\nvar polarAxisAttrs = require('../plots/polar/axis_attributes');\n\nvar extendFlat = Lib.extendFlat;\nvar extendDeep = Lib.extendDeep;\n\nvar IS_SUBPLOT_OBJ = '_isSubplotObj';\nvar IS_LINKED_TO_ARRAY = '_isLinkedToArray';\nvar ARRAY_ATTR_REGEXPS = '_arrayAttrRegexps';\nvar DEPRECATED = '_deprecated';\nvar UNDERSCORE_ATTRS = [IS_SUBPLOT_OBJ, IS_LINKED_TO_ARRAY, ARRAY_ATTR_REGEXPS, DEPRECATED];\n\nexports.IS_SUBPLOT_OBJ = IS_SUBPLOT_OBJ;\nexports.IS_LINKED_TO_ARRAY = IS_LINKED_TO_ARRAY;\nexports.DEPRECATED = DEPRECATED;\nexports.UNDERSCORE_ATTRS = UNDERSCORE_ATTRS;\n\n/** Outputs the full plotly.js plot schema\n *\n * @return {object}\n *  - defs\n *  - traces\n *  - layout\n *  - transforms\n *  - frames\n *  - animations\n *  - config (coming soon ...)\n */\nexports.get = function() {\n    var traces = {};\n\n    Registry.allTypes.concat('area').forEach(function(type) {\n        traces[type] = getTraceAttributes(type);\n    });\n\n    var transforms = {};\n\n    Object.keys(Registry.transformsRegistry).forEach(function(type) {\n        transforms[type] = getTransformAttributes(type);\n    });\n\n    return {\n        defs: {\n            valObjects: Lib.valObjects,\n            metaKeys: UNDERSCORE_ATTRS.concat(['description', 'role'])\n        },\n\n        traces: traces,\n        layout: getLayoutAttributes(),\n\n        transforms: transforms,\n\n        frames: getFramesAttributes(),\n        animation: formatAttributes(animationAttributes)\n    };\n};\n\n/**\n * Crawl the attribute tree, recursively calling a callback function\n *\n * @param {object} attrs\n *  The node of the attribute tree (e.g. the root) from which recursion originates\n * @param {Function} callback\n *  A callback function with the signature:\n *          @callback callback\n *          @param {object} attr an attribute\n *          @param {String} attrName name string\n *          @param {object[]} attrs all the attributes\n *          @param {Number} level the recursion level, 0 at the root\n * @param {Number} [specifiedLevel]\n *  The level in the tree, in order to let the callback function detect descend or backtrack,\n *  typically unsupplied (implied 0), just used by the self-recursive call.\n *  The necessity arises because the tree traversal is not controlled by callback return values.\n *  The decision to not use callback return values for controlling tree pruning arose from\n *  the goal of keeping the crawler backwards compatible. Observe that one of the pruning conditions\n *  precedes the callback call.\n *\n * @return {object} transformOut\n *  copy of transformIn that contains attribute defaults\n */\nexports.crawl = function(attrs, callback, specifiedLevel) {\n    var level = specifiedLevel || 0;\n\n    Object.keys(attrs).forEach(function(attrName) {\n        var attr = attrs[attrName];\n\n        if(UNDERSCORE_ATTRS.indexOf(attrName) !== -1) return;\n\n        callback(attr, attrName, attrs, level);\n\n        if(exports.isValObject(attr)) return;\n\n        if(Lib.isPlainObject(attr)) exports.crawl(attr, callback, level + 1);\n    });\n};\n\n/** Is object a value object (or a container object)?\n *\n * @param {object} obj\n * @return {boolean}\n *  returns true for a valid value object and\n *  false for tree nodes in the attribute hierarchy\n */\nexports.isValObject = function(obj) {\n    return obj && obj.valType !== undefined;\n};\n\n/**\n * Find all data array attributes in a given trace object - including\n * `arrayOk` attributes.\n *\n * @param {object} trace\n *  full trace object that contains a reference to `_module.attributes`\n *\n * @return {array} arrayAttributes\n *  list of array attributes for the given trace\n */\nexports.findArrayAttributes = function(trace) {\n    var arrayAttributes = [],\n        stack = [];\n\n    function callback(attr, attrName, attrs, level) {\n        stack = stack.slice(0, level).concat([attrName]);\n\n        var splittableAttr = attr && (attr.valType === 'data_array' || attr.arrayOk === true);\n        if(!splittableAttr) return;\n\n        var astr = toAttrString(stack);\n        var val = Lib.nestedProperty(trace, astr).get();\n        if(!Array.isArray(val)) return;\n\n        arrayAttributes.push(astr);\n    }\n\n    function toAttrString(stack) {\n        return stack.join('.');\n    }\n\n    exports.crawl(trace._module.attributes, callback);\n\n    if(trace.transforms) {\n        var transforms = trace.transforms;\n\n        for(var i = 0; i < transforms.length; i++) {\n            var transform = transforms[i];\n\n            stack = ['transforms[' + i + ']'];\n\n            exports.crawl(transform._module.attributes, callback, 1);\n        }\n    }\n\n    // Look into the fullInput module attributes for array attributes\n    // to make sure that 'custom' array attributes are detected.\n    //\n    // At the moment, we need this block to make sure that\n    // ohlc and candlestick 'open', 'high', 'low', 'close' can be\n    // used with filter ang groupby transforms.\n    if(trace._fullInput) {\n        exports.crawl(trace._fullInput._module.attributes, callback);\n\n        arrayAttributes = Lib.filterUnique(arrayAttributes);\n    }\n\n    return arrayAttributes;\n};\n\nfunction getTraceAttributes(type) {\n    var _module, basePlotModule;\n\n    if(type === 'area') {\n        _module = { attributes: polarAreaAttrs };\n        basePlotModule = {};\n    }\n    else {\n        _module = Registry.modules[type]._module,\n        basePlotModule = _module.basePlotModule;\n    }\n\n    var attributes = {};\n\n    // make 'type' the first attribute in the object\n    attributes.type = null;\n\n    // base attributes (same for all trace types)\n    extendDeep(attributes, baseAttributes);\n\n    // module attributes\n    extendDeep(attributes, _module.attributes);\n\n    // subplot attributes\n    if(basePlotModule.attributes) {\n        extendDeep(attributes, basePlotModule.attributes);\n    }\n\n    // add registered components trace attributes\n    Object.keys(Registry.componentsRegistry).forEach(function(k) {\n        var _module = Registry.componentsRegistry[k];\n\n        if(_module.schema && _module.schema.traces && _module.schema.traces[type]) {\n            Object.keys(_module.schema.traces[type]).forEach(function(v) {\n                insertAttrs(attributes, _module.schema.traces[type][v], v);\n            });\n        }\n    });\n\n    // 'type' gets overwritten by baseAttributes; reset it here\n    attributes.type = type;\n\n    var out = {\n        meta: _module.meta || {},\n        attributes: formatAttributes(attributes),\n    };\n\n    // trace-specific layout attributes\n    if(_module.layoutAttributes) {\n        var layoutAttributes = {};\n\n        extendDeep(layoutAttributes, _module.layoutAttributes);\n        out.layoutAttributes = formatAttributes(layoutAttributes);\n    }\n\n    return out;\n}\n\nfunction getLayoutAttributes() {\n    var layoutAttributes = {};\n\n    // global layout attributes\n    extendDeep(layoutAttributes, baseLayoutAttributes);\n\n    // add base plot module layout attributes\n    Object.keys(Registry.subplotsRegistry).forEach(function(k) {\n        var _module = Registry.subplotsRegistry[k];\n\n        if(!_module.layoutAttributes) return;\n\n        if(_module.name === 'cartesian') {\n            handleBasePlotModule(layoutAttributes, _module, 'xaxis');\n            handleBasePlotModule(layoutAttributes, _module, 'yaxis');\n        }\n        else {\n            var astr = _module.attr === 'subplot' ? _module.name : _module.attr;\n\n            handleBasePlotModule(layoutAttributes, _module, astr);\n        }\n    });\n\n    // polar layout attributes\n    layoutAttributes = assignPolarLayoutAttrs(layoutAttributes);\n\n    // add registered components layout attributes\n    Object.keys(Registry.componentsRegistry).forEach(function(k) {\n        var _module = Registry.componentsRegistry[k];\n\n        if(!_module.layoutAttributes) return;\n\n        if(_module.schema && _module.schema.layout) {\n            Object.keys(_module.schema.layout).forEach(function(v) {\n                insertAttrs(layoutAttributes, _module.schema.layout[v], v);\n            });\n        }\n        else {\n            insertAttrs(layoutAttributes, _module.layoutAttributes, _module.name);\n        }\n    });\n\n    return {\n        layoutAttributes: formatAttributes(layoutAttributes)\n    };\n}\n\nfunction getTransformAttributes(type) {\n    var _module = Registry.transformsRegistry[type];\n    var attributes = extendDeep({}, _module.attributes);\n\n    // add registered components transform attributes\n    Object.keys(Registry.componentsRegistry).forEach(function(k) {\n        var _module = Registry.componentsRegistry[k];\n\n        if(_module.schema && _module.schema.transforms && _module.schema.transforms[type]) {\n            Object.keys(_module.schema.transforms[type]).forEach(function(v) {\n                insertAttrs(attributes, _module.schema.transforms[type][v], v);\n            });\n        }\n    });\n\n    return {\n        attributes: formatAttributes(attributes)\n    };\n}\n\nfunction getFramesAttributes() {\n    var attrs = {\n        frames: Lib.extendDeep({}, frameAttributes)\n    };\n\n    formatAttributes(attrs);\n\n    return attrs.frames;\n}\n\nfunction formatAttributes(attrs) {\n    mergeValTypeAndRole(attrs);\n    formatArrayContainers(attrs);\n\n    return attrs;\n}\n\nfunction mergeValTypeAndRole(attrs) {\n\n    function makeSrcAttr(attrName) {\n        return {\n            valType: 'string',\n            role: 'info',\n            description: [\n                'Sets the source reference on plot.ly for ',\n                attrName, '.'\n            ].join(' ')\n        };\n    }\n\n    function callback(attr, attrName, attrs) {\n        if(exports.isValObject(attr)) {\n            if(attr.valType === 'data_array') {\n                // all 'data_array' attrs have role 'data'\n                attr.role = 'data';\n                // all 'data_array' attrs have a corresponding 'src' attr\n                attrs[attrName + 'src'] = makeSrcAttr(attrName);\n            }\n            else if(attr.arrayOk === true) {\n                // all 'arrayOk' attrs have a corresponding 'src' attr\n                attrs[attrName + 'src'] = makeSrcAttr(attrName);\n            }\n        }\n        else if(Lib.isPlainObject(attr)) {\n            // all attrs container objects get role 'object'\n            attr.role = 'object';\n        }\n    }\n\n    exports.crawl(attrs, callback);\n}\n\nfunction formatArrayContainers(attrs) {\n\n    function callback(attr, attrName, attrs) {\n        if(!attr) return;\n\n        var itemName = attr[IS_LINKED_TO_ARRAY];\n\n        if(!itemName) return;\n\n        delete attr[IS_LINKED_TO_ARRAY];\n\n        attrs[attrName] = { items: {} };\n        attrs[attrName].items[itemName] = attr;\n        attrs[attrName].role = 'object';\n    }\n\n    exports.crawl(attrs, callback);\n}\n\nfunction assignPolarLayoutAttrs(layoutAttributes) {\n    extendFlat(layoutAttributes, {\n        radialaxis: polarAxisAttrs.radialaxis,\n        angularaxis: polarAxisAttrs.angularaxis\n    });\n\n    extendFlat(layoutAttributes, polarAxisAttrs.layout);\n\n    return layoutAttributes;\n}\n\nfunction handleBasePlotModule(layoutAttributes, _module, astr) {\n    var np = Lib.nestedProperty(layoutAttributes, astr),\n        attrs = extendDeep({}, _module.layoutAttributes);\n\n    attrs[IS_SUBPLOT_OBJ] = true;\n    np.set(attrs);\n}\n\nfunction insertAttrs(baseAttrs, newAttrs, astr) {\n    var np = Lib.nestedProperty(baseAttrs, astr);\n\n    np.set(extendDeep(np.get() || {}, newAttrs));\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/polar/area_attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar scatterAttrs = require('../../traces/scatter/attributes');\nvar scatterMarkerAttrs = scatterAttrs.marker;\n\nmodule.exports = {\n    r: scatterAttrs.r,\n    t: scatterAttrs.t,\n    marker: {\n        color: scatterMarkerAttrs.color,\n        size: scatterMarkerAttrs.size,\n        symbol: scatterMarkerAttrs.symbol,\n        opacity: scatterMarkerAttrs.opacity\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/lib/groupby.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = require('../src/transforms/groupby');\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/transforms/groupby.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../lib');\nvar PlotSchema = require('../plot_api/plot_schema');\n\nexports.moduleType = 'transform';\n\nexports.name = 'groupby';\n\nexports.attributes = {\n    enabled: {\n        valType: 'boolean',\n        dflt: true,\n        description: [\n            'Determines whether this group-by transform is enabled or disabled.'\n        ].join(' ')\n    },\n    groups: {\n        valType: 'data_array',\n        dflt: [],\n        description: [\n            'Sets the groups in which the trace data will be split.',\n            'For example, with `x` set to *[1, 2, 3, 4]* and',\n            '`groups` set to *[\\'a\\', \\'b\\', \\'a\\', \\'b\\']*,',\n            'the groupby transform with split in one trace',\n            'with `x` [1, 3] and one trace with `x` [2, 4].'\n        ].join(' ')\n    },\n    style: {\n        valType: 'any',\n        dflt: {},\n        description: [\n            'Sets each group style.',\n            'For example, with `groups` set to *[\\'a\\', \\'b\\', \\'a\\', \\'b\\']*',\n            'and `style` set to *{ a: { marker: { color: \\'red\\' } }}',\n            'marker points in group *\\'a\\'* will be drawn in red.'\n        ].join(' ')\n    }\n};\n\n/**\n * Supply transform attributes defaults\n *\n * @param {object} transformIn\n *  object linked to trace.transforms[i] with 'type' set to exports.name\n * @param {object} fullData\n *  the plot's full data\n * @param {object} layout\n *  the plot's (not-so-full) layout\n *\n * @return {object} transformOut\n *  copy of transformIn that contains attribute defaults\n */\nexports.supplyDefaults = function(transformIn) {\n    var transformOut = {};\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(transformIn, transformOut, exports.attributes, attr, dflt);\n    }\n\n    var enabled = coerce('enabled');\n\n    if(!enabled) return transformOut;\n\n    coerce('groups');\n    coerce('style');\n\n    return transformOut;\n};\n\n/**\n * Apply transform !!!\n *\n * @param {array} data\n *  array of transformed traces (is [fullTrace] upon first transform)\n *\n * @param {object} state\n *  state object which includes:\n *      - transform {object} full transform attributes\n *      - fullTrace {object} full trace object which is being transformed\n *      - fullData {array} full pre-transform(s) data array\n *      - layout {object} the plot's (not-so-full) layout\n *\n * @return {object} newData\n *  array of transformed traces\n */\nexports.transform = function(data, state) {\n    var newData = [];\n\n    for(var i = 0; i < data.length; i++) {\n        newData = newData.concat(transformOne(data[i], state));\n    }\n\n    return newData;\n};\n\nfunction initializeArray(newTrace, a) {\n    Lib.nestedProperty(newTrace, a).set([]);\n}\n\nfunction pasteArray(newTrace, trace, j, a) {\n    Lib.nestedProperty(newTrace, a).set(\n        Lib.nestedProperty(newTrace, a).get().concat([\n            Lib.nestedProperty(trace, a).get()[j]\n        ])\n    );\n}\n\nfunction transformOne(trace, state) {\n    var opts = state.transform;\n    var groups = trace.transforms[state.transformIndex].groups;\n\n    if(!(Array.isArray(groups)) || groups.length === 0) {\n        return trace;\n    }\n\n    var groupNames = Lib.filterUnique(groups),\n        newData = new Array(groupNames.length),\n        len = groups.length;\n\n    var arrayAttrs = PlotSchema.findArrayAttributes(trace);\n\n    var style = opts.style || {};\n\n    for(var i = 0; i < groupNames.length; i++) {\n        var groupName = groupNames[i];\n\n        var newTrace = newData[i] = Lib.extendDeepNoArrays({}, trace);\n\n        arrayAttrs.forEach(initializeArray.bind(null, newTrace));\n\n        for(var j = 0; j < len; j++) {\n            if(groups[j] !== groupName) continue;\n\n            arrayAttrs.forEach(pasteArray.bind(0, newTrace, trace, j));\n        }\n\n        newTrace.name = groupName;\n\n        // there's no need to coerce style[groupName] here\n        // as another round of supplyDefaults is done on the transformed traces\n        newTrace = Lib.extendDeepNoArrays(newTrace, style[groupName] || {});\n    }\n\n    return newData;\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/lib/heatmapgl.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = require('../src/traces/heatmapgl');\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/heatmapgl/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar HeatmapGl = {};\n\nHeatmapGl.attributes = require('./attributes');\nHeatmapGl.supplyDefaults = require('../heatmap/defaults');\nHeatmapGl.colorbar = require('../heatmap/colorbar');\n\nHeatmapGl.calc = require('../heatmap/calc');\nHeatmapGl.plot = require('./convert');\n\nHeatmapGl.moduleType = 'trace';\nHeatmapGl.name = 'heatmapgl';\nHeatmapGl.basePlotModule = require('../../plots/gl2d');\nHeatmapGl.categories = ['gl2d', '2dMap'];\nHeatmapGl.meta = {\n    description: [\n        'WebGL version of the heatmap trace type.'\n    ].join(' ')\n};\n\nmodule.exports = HeatmapGl;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/heatmapgl/attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n\nvar heatmapAttrs = require('../heatmap/attributes');\nvar colorscaleAttrs = require('../../components/colorscale/attributes');\nvar colorbarAttrs = require('../../components/colorbar/attributes');\n\nvar extendFlat = require('../../lib/extend').extendFlat;\n\nvar commonList = [\n    'z',\n    'x', 'x0', 'dx',\n    'y', 'y0', 'dy',\n    'text', 'transpose',\n    'xtype', 'ytype'\n];\n\nvar attrs = {};\n\nfor(var i = 0; i < commonList.length; i++) {\n    var k = commonList[i];\n    attrs[k] = heatmapAttrs[k];\n}\n\nextendFlat(\n    attrs,\n    colorscaleAttrs,\n    { autocolorscale: extendFlat({}, colorscaleAttrs.autocolorscale, {dflt: false}) },\n    { colorbar: colorbarAttrs }\n);\n\nmodule.exports = attrs;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/lib/heatmap.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = require('../src/traces/heatmap');\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/heatmap/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Heatmap = {};\n\nHeatmap.attributes = require('./attributes');\nHeatmap.supplyDefaults = require('./defaults');\nHeatmap.calc = require('./calc');\nHeatmap.plot = require('./plot');\nHeatmap.colorbar = require('./colorbar');\nHeatmap.style = require('./style');\nHeatmap.hoverPoints = require('./hover');\n\nHeatmap.moduleType = 'trace';\nHeatmap.name = 'heatmap';\nHeatmap.basePlotModule = require('../../plots/cartesian');\nHeatmap.categories = ['cartesian', '2dMap'];\nHeatmap.meta = {\n    description: [\n        'The data that describes the heatmap value-to-color mapping',\n        'is set in `z`.',\n        'Data in `z` can either be a {2D array} of values (ragged or not)',\n        'or a 1D array of values.',\n\n        'In the case where `z` is a {2D array},',\n        'say that `z` has N rows and M columns.',\n        'Then, by default, the resulting heatmap will have N partitions along',\n        'the y axis and M partitions along the x axis.',\n        'In other words, the i-th row/ j-th column cell in `z`',\n        'is mapped to the i-th partition of the y axis',\n        '(starting from the bottom of the plot) and the j-th partition',\n        'of the x-axis (starting from the left of the plot).',\n        'This behavior can be flipped by using `transpose`.',\n        'Moreover, `x` (`y`) can be provided with M or M+1 (N or N+1) elements.',\n        'If M (N), then the coordinates correspond to the center of the',\n        'heatmap cells and the cells have equal width.',\n        'If M+1 (N+1), then the coordinates correspond to the edges of the',\n        'heatmap cells.',\n\n        'In the case where `z` is a 1D {array}, the x and y coordinates must be',\n        'provided in `x` and `y` respectively to form data triplets.'\n    ].join(' ')\n};\n\nmodule.exports = Heatmap;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/lib/histogram2dcontour.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = require('../src/traces/histogram2dcontour');\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/histogram2dcontour/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Histogram2dContour = {};\n\nHistogram2dContour.attributes = require('./attributes');\nHistogram2dContour.supplyDefaults = require('./defaults');\nHistogram2dContour.calc = require('../contour/calc');\nHistogram2dContour.plot = require('../contour/plot');\nHistogram2dContour.style = require('../contour/style');\nHistogram2dContour.colorbar = require('../contour/colorbar');\nHistogram2dContour.hoverPoints = require('../contour/hover');\n\nHistogram2dContour.moduleType = 'trace';\nHistogram2dContour.name = 'histogram2dcontour';\nHistogram2dContour.basePlotModule = require('../../plots/cartesian');\nHistogram2dContour.categories = ['cartesian', '2dMap', 'contour', 'histogram'];\nHistogram2dContour.meta = {\n    hrName: 'histogram_2d_contour',\n    description: [\n        'The sample data from which statistics are computed is set in `x`',\n        'and `y` (where `x` and `y` represent marginal distributions,',\n        'binning is set in `xbins` and `ybins` in this case)',\n        'or `z` (where `z` represent the 2D distribution and binning set,',\n        'binning is set by `x` and `y` in this case).',\n        'The resulting distribution is visualized as a contour plot.'\n    ].join(' ')\n};\n\nmodule.exports = Histogram2dContour;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/histogram2dcontour/attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar histogram2dAttrs = require('../histogram2d/attributes');\nvar contourAttrs = require('../contour/attributes');\nvar colorscaleAttrs = require('../../components/colorscale/attributes');\nvar colorbarAttrs = require('../../components/colorbar/attributes');\n\nvar extendFlat = require('../../lib/extend').extendFlat;\n\nmodule.exports = extendFlat({}, {\n    x: histogram2dAttrs.x,\n    y: histogram2dAttrs.y,\n    z: histogram2dAttrs.z,\n    marker: histogram2dAttrs.marker,\n\n    histnorm: histogram2dAttrs.histnorm,\n    histfunc: histogram2dAttrs.histfunc,\n    autobinx: histogram2dAttrs.autobinx,\n    nbinsx: histogram2dAttrs.nbinsx,\n    xbins: histogram2dAttrs.xbins,\n    autobiny: histogram2dAttrs.autobiny,\n    nbinsy: histogram2dAttrs.nbinsy,\n    ybins: histogram2dAttrs.ybins,\n\n    autocontour: contourAttrs.autocontour,\n    ncontours: contourAttrs.ncontours,\n    contours: contourAttrs.contours,\n    line: contourAttrs.line\n},\n    colorscaleAttrs,\n    { colorbar: colorbarAttrs }\n);\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/histogram2d/attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar histogramAttrs = require('../histogram/attributes');\nvar heatmapAttrs = require('../heatmap/attributes');\nvar colorscaleAttrs = require('../../components/colorscale/attributes');\nvar colorbarAttrs = require('../../components/colorbar/attributes');\n\nvar extendFlat = require('../../lib/extend').extendFlat;\n\nmodule.exports = extendFlat({},\n    {\n        x: histogramAttrs.x,\n        y: histogramAttrs.y,\n\n        z: {\n            valType: 'data_array',\n            description: 'Sets the aggregation data.'\n        },\n        marker: {\n            color: {\n                valType: 'data_array',\n                description: 'Sets the aggregation data.'\n            }\n        },\n\n        histnorm: histogramAttrs.histnorm,\n        histfunc: histogramAttrs.histfunc,\n        autobinx: histogramAttrs.autobinx,\n        nbinsx: histogramAttrs.nbinsx,\n        xbins: histogramAttrs.xbins,\n        autobiny: histogramAttrs.autobiny,\n        nbinsy: histogramAttrs.nbinsy,\n        ybins: histogramAttrs.ybins,\n\n        xgap: heatmapAttrs.xgap,\n        ygap: heatmapAttrs.ygap,\n        zsmooth: heatmapAttrs.zsmooth\n    },\n    colorscaleAttrs,\n    { autocolorscale: extendFlat({}, colorscaleAttrs.autocolorscale, {dflt: false}) },\n    { colorbar: colorbarAttrs }\n);\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/histogram/attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar barAttrs = require('../bar/attributes');\n\n\nmodule.exports = {\n    x: {\n        valType: 'data_array',\n        description: [\n            'Sets the sample data to be binned on the x axis.'\n        ].join(' ')\n    },\n    y: {\n        valType: 'data_array',\n        description: [\n            'Sets the sample data to be binned on the y axis.'\n        ].join(' ')\n    },\n\n    text: barAttrs.text,\n    orientation: barAttrs.orientation,\n\n    histfunc: {\n        valType: 'enumerated',\n        values: ['count', 'sum', 'avg', 'min', 'max'],\n        role: 'style',\n        dflt: 'count',\n        description: [\n            'Specifies the binning function used for this histogram trace.',\n\n            'If *count*, the histogram values are computed by counting the',\n            'number of values lying inside each bin.',\n\n            'If *sum*, *avg*, *min*, *max*,',\n            'the histogram values are computed using',\n            'the sum, the average, the minimum or the maximum',\n            'of the values lying inside each bin respectively.'\n        ].join(' ')\n    },\n    histnorm: {\n        valType: 'enumerated',\n        values: ['', 'percent', 'probability', 'density', 'probability density'],\n        dflt: '',\n        role: 'style',\n        description: [\n            'Specifies the type of normalization used for this histogram trace.',\n\n            'If **, the span of each bar corresponds to the number of',\n            'occurrences (i.e. the number of data points lying inside the bins).',\n\n            'If *percent* / *probability*, the span of each bar corresponds to',\n            'the percentage / fraction of occurrences with respect to the total',\n            'number of sample points',\n            '(here, the sum of all bin HEIGHTS equals 100% / 1).',\n\n            'If *density*, the span of each bar corresponds to the number of',\n            'occurrences in a bin divided by the size of the bin interval',\n            '(here, the sum of all bin AREAS equals the',\n            'total number of sample points).',\n\n            'If *probability density*, the area of each bar corresponds to the',\n            'probability that an event will fall into the corresponding bin',\n            '(here, the sum of all bin AREAS equals 1).'\n        ].join(' ')\n    },\n\n    cumulative: {\n        enabled: {\n            valType: 'boolean',\n            dflt: false,\n            role: 'info',\n            description: [\n                'If true, display the cumulative distribution by summing the',\n                'binned values. Use the `direction` and `centralbin` attributes',\n                'to tune the accumulation method.',\n                'Note: in this mode, the *density* `histnorm` settings behave',\n                'the same as their equivalents without *density*:',\n                '** and *density* both rise to the number of data points, and',\n                '*probability* and *probability density* both rise to the',\n                'number of sample points.'\n            ].join(' ')\n        },\n\n        direction: {\n            valType: 'enumerated',\n            values: ['increasing', 'decreasing'],\n            dflt: 'increasing',\n            role: 'info',\n            description: [\n                'Only applies if cumulative is enabled.',\n                'If *increasing* (default) we sum all prior bins, so the result',\n                'increases from left to right. If *decreasing* we sum later bins',\n                'so the result decreases from left to right.'\n            ].join(' ')\n        },\n\n        currentbin: {\n            valType: 'enumerated',\n            values: ['include', 'exclude', 'half'],\n            dflt: 'include',\n            role: 'info',\n            description: [\n                'Only applies if cumulative is enabled.',\n                'Sets whether the current bin is included, excluded, or has half',\n                'of its value included in the current cumulative value.',\n                '*include* is the default for compatibility with various other',\n                'tools, however it introduces a half-bin bias to the results.',\n                '*exclude* makes the opposite half-bin bias, and *half* removes',\n                'it.'\n            ].join(' ')\n        }\n    },\n\n    autobinx: {\n        valType: 'boolean',\n        dflt: null,\n        role: 'style',\n        description: [\n            'Determines whether or not the x axis bin attributes are picked',\n            'by an algorithm. Note that this should be set to false if you',\n            'want to manually set the number of bins using the attributes in',\n            'xbins.'\n        ].join(' ')\n    },\n    nbinsx: {\n        valType: 'integer',\n        min: 0,\n        dflt: 0,\n        role: 'style',\n        description: [\n            'Specifies the maximum number of desired bins. This value will be used',\n            'in an algorithm that will decide the optimal bin size such that the',\n            'histogram best visualizes the distribution of the data.'\n        ].join(' ')\n    },\n    xbins: makeBinsAttr('x'),\n\n    autobiny: {\n        valType: 'boolean',\n        dflt: null,\n        role: 'style',\n        description: [\n            'Determines whether or not the y axis bin attributes are picked',\n            'by an algorithm. Note that this should be set to false if you',\n            'want to manually set the number of bins using the attributes in',\n            'ybins.'\n        ].join(' ')\n    },\n    nbinsy: {\n        valType: 'integer',\n        min: 0,\n        dflt: 0,\n        role: 'style',\n        description: [\n            'Specifies the maximum number of desired bins. This value will be used',\n            'in an algorithm that will decide the optimal bin size such that the',\n            'histogram best visualizes the distribution of the data.'\n        ].join(' ')\n    },\n    ybins: makeBinsAttr('y'),\n\n    marker: barAttrs.marker,\n\n    error_y: barAttrs.error_y,\n    error_x: barAttrs.error_x,\n\n    _deprecated: {\n        bardir: barAttrs._deprecated.bardir\n    }\n};\n\nfunction makeBinsAttr(axLetter) {\n    return {\n        start: {\n            valType: 'any', // for date axes\n            dflt: null,\n            role: 'style',\n            description: [\n                'Sets the starting value for the', axLetter,\n                'axis bins.'\n            ].join(' ')\n        },\n        end: {\n            valType: 'any', // for date axes\n            dflt: null,\n            role: 'style',\n            description: [\n                'Sets the end value for the', axLetter,\n                'axis bins.'\n            ].join(' ')\n        },\n        size: {\n            valType: 'any', // for date axes\n            dflt: null,\n            role: 'style',\n            description: [\n                'Sets the step in-between value each', axLetter,\n                'axis bin.'\n            ].join(' ')\n        }\n    };\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/lib/histogram2d.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = require('../src/traces/histogram2d');\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/histogram2d/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Histogram2D = {};\n\nHistogram2D.attributes = require('./attributes');\nHistogram2D.supplyDefaults = require('./defaults');\nHistogram2D.calc = require('../heatmap/calc');\nHistogram2D.plot = require('../heatmap/plot');\nHistogram2D.colorbar = require('../heatmap/colorbar');\nHistogram2D.style = require('../heatmap/style');\nHistogram2D.hoverPoints = require('../heatmap/hover');\n\nHistogram2D.moduleType = 'trace';\nHistogram2D.name = 'histogram2d';\nHistogram2D.basePlotModule = require('../../plots/cartesian');\nHistogram2D.categories = ['cartesian', '2dMap', 'histogram'];\nHistogram2D.meta = {\n    hrName: 'histogram_2d',\n    description: [\n        'The sample data from which statistics are computed is set in `x`',\n        'and `y` (where `x` and `y` represent marginal distributions,',\n        'binning is set in `xbins` and `ybins` in this case)',\n        'or `z` (where `z` represent the 2D distribution and binning set,',\n        'binning is set by `x` and `y` in this case).',\n        'The resulting distribution is visualized as a heatmap.'\n    ].join(' ')\n};\n\nmodule.exports = Histogram2D;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/lib/histogram.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = require('../src/traces/histogram');\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/histogram/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\n/**\n * Histogram has its own attribute, defaults and calc steps,\n * but uses bar's plot to display\n * and bar's setPositions for stacking and grouping\n */\n\n/**\n * histogram errorBarsOK is debatable, but it's put in for backward compat.\n * there are use cases for it - sqrt for a simple histogram works right now,\n * constant and % work but they're not so meaningful. I guess it could be cool\n * to allow quadrature combination of errors in summed histograms...\n */\n\n\nvar Histogram = {};\n\nHistogram.attributes = require('./attributes');\nHistogram.layoutAttributes = require('../bar/layout_attributes');\nHistogram.supplyDefaults = require('./defaults');\nHistogram.supplyLayoutDefaults = require('../bar/layout_defaults');\nHistogram.calc = require('./calc');\nHistogram.setPositions = require('../bar/set_positions');\nHistogram.plot = require('../bar/plot');\nHistogram.style = require('../bar/style');\nHistogram.colorbar = require('../scatter/colorbar');\nHistogram.hoverPoints = require('../bar/hover');\n\nHistogram.moduleType = 'trace';\nHistogram.name = 'histogram';\nHistogram.basePlotModule = require('../../plots/cartesian');\nHistogram.categories = ['cartesian', 'bar', 'histogram', 'oriented', 'errorBarsOK', 'showLegend'];\nHistogram.meta = {\n    description: [\n        'The sample data from which statistics are computed is set in `x`',\n        'for vertically spanning histograms and',\n        'in `y` for horizontally spanning histograms.',\n        'Binning options are set `xbins` and `ybins` respectively',\n        'if no aggregation data is provided.'\n    ].join(' ')\n};\n\nmodule.exports = Histogram;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/lib/index-basic.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Plotly = require('./core');\n\nPlotly.register([\n    require('./bar'),\n    require('./pie')\n]);\n\nmodule.exports = Plotly;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/lib/index-cartesian.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Plotly = require('./core');\n\nPlotly.register([\n    require('./bar'),\n    require('./box'),\n    require('./heatmap'),\n    require('./histogram'),\n    require('./histogram2d'),\n    require('./histogram2dcontour'),\n    require('./pie'),\n    require('./contour'),\n    require('./scatterternary')\n]);\n\nmodule.exports = Plotly;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/lib/index-finance.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Plotly = require('./core');\n\nPlotly.register([\n    require('./bar'),\n    require('./histogram'),\n    require('./pie'),\n    require('./ohlc'),\n    require('./candlestick')\n]);\n\nmodule.exports = Plotly;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/lib/index-geo.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Plotly = require('./core');\n\nPlotly.register([\n    require('./scattergeo'),\n    require('./choropleth')\n]);\n\nmodule.exports = Plotly;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/lib/index-gl2d.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Plotly = require('./core');\n\nPlotly.register([\n    require('./scattergl'),\n    require('./pointcloud'),\n    require('./heatmapgl'),\n    require('./contourgl'),\n    require('./parcoords')\n]);\n\nmodule.exports = Plotly;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/lib/index-gl3d.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Plotly = require('./core');\n\nPlotly.register([\n    require('./scatter3d'),\n    require('./surface'),\n    require('./mesh3d')\n]);\n\nmodule.exports = Plotly;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/lib/index-mapbox.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Plotly = require('./core');\n\nPlotly.register([\n    require('./scattermapbox')\n]);\n\nmodule.exports = Plotly;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/lib/mesh3d.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = require('../src/traces/mesh3d');\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/mesh3d/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Mesh3D = {};\n\nMesh3D.attributes = require('./attributes');\nMesh3D.supplyDefaults = require('./defaults');\nMesh3D.colorbar = require('../heatmap/colorbar');\nMesh3D.plot = require('./convert');\n\nMesh3D.moduleType = 'trace';\nMesh3D.name = 'mesh3d',\nMesh3D.basePlotModule = require('../../plots/gl3d');\nMesh3D.categories = ['gl3d'];\nMesh3D.meta = {\n    description: [\n        'Draws sets of triangles with coordinates given by',\n        'three 1-dimensional arrays in `x`, `y`, `z` and',\n        '(1) a sets of `i`, `j`, `k` indices',\n        '(2) Delaunay triangulation or',\n        '(3) the Alpha-shape algorithm or',\n        '(4) the Convex-hull algorithm'\n    ].join(' ')\n};\n\nmodule.exports = Mesh3D;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/mesh3d/attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar colorscaleAttrs = require('../../components/colorscale/attributes');\nvar colorbarAttrs = require('../../components/colorbar/attributes');\nvar surfaceAtts = require('../surface/attributes');\n\nvar extendFlat = require('../../lib/extend').extendFlat;\n\n\nmodule.exports = {\n    x: {\n        valType: 'data_array',\n        description: [\n            'Sets the X coordinates of the vertices. The nth element of vectors `x`, `y` and `z`',\n            'jointly represent the X, Y and Z coordinates of the nth vertex.'\n        ].join(' ')\n    },\n    y: {\n        valType: 'data_array',\n        description: [\n            'Sets the Y coordinates of the vertices. The nth element of vectors `x`, `y` and `z`',\n            'jointly represent the X, Y and Z coordinates of the nth vertex.'\n        ].join(' ')\n    },\n    z: {\n        valType: 'data_array',\n        description: [\n            'Sets the Z coordinates of the vertices. The nth element of vectors `x`, `y` and `z`',\n            'jointly represent the X, Y and Z coordinates of the nth vertex.'\n        ].join(' ')\n    },\n\n    i: {\n        valType: 'data_array',\n        description: [\n            'A vector of vertex indices, i.e. integer values between 0 and the length of the vertex',\n            'vectors, representing the *first* vertex of a triangle. For example, `{i[m], j[m], k[m]}`',\n            'together represent face m (triangle m) in the mesh, where `i[m] = n` points to the triplet',\n            '`{x[n], y[n], z[n]}` in the vertex arrays. Therefore, each element in `i` represents a',\n            'point in space, which is the first vertex of a triangle.'\n        ].join(' ')\n    },\n    j: {\n        valType: 'data_array',\n        description: [\n            'A vector of vertex indices, i.e. integer values between 0 and the length of the vertex',\n            'vectors, representing the *second* vertex of a triangle. For example, `{i[m], j[m], k[m]}` ',\n            'together represent face m (triangle m) in the mesh, where `j[m] = n` points to the triplet',\n            '`{x[n], y[n], z[n]}` in the vertex arrays. Therefore, each element in `j` represents a',\n            'point in space, which is the second vertex of a triangle.'\n        ].join(' ')\n\n    },\n    k: {\n        valType: 'data_array',\n        description: [\n            'A vector of vertex indices, i.e. integer values between 0 and the length of the vertex',\n            'vectors, representing the *third* vertex of a triangle. For example, `{i[m], j[m], k[m]}`',\n            'together represent face m (triangle m) in the mesh, where `k[m] = n` points to the triplet ',\n            '`{x[n], y[n], z[n]}` in the vertex arrays. Therefore, each element in `k` represents a',\n            'point in space, which is the third vertex of a triangle.'\n        ].join(' ')\n\n    },\n\n    delaunayaxis: {\n        valType: 'enumerated',\n        role: 'info',\n        values: [ 'x', 'y', 'z' ],\n        dflt: 'z',\n        description: [\n            'Sets the Delaunay axis, which is the axis that is perpendicular to the surface of the',\n            'Delaunay triangulation.',\n            'It has an effect if `i`, `j`, `k` are not provided and `alphahull` is set to indicate',\n            'Delaunay triangulation.'\n        ].join(' ')\n    },\n\n    alphahull: {\n        valType: 'number',\n        role: 'style',\n        dflt: -1,\n        description: [\n            'Determines how the mesh surface triangles are derived from the set of',\n            'vertices (points) represented by the `x`, `y` and `z` arrays, if',\n            'the `i`, `j`, `k` arrays are not supplied.',\n            'For general use of `mesh3d` it is preferred that `i`, `j`, `k` are',\n            'supplied.',\n\n            'If *-1*, Delaunay triangulation is used, which is mainly suitable if the',\n            'mesh is a single, more or less layer surface that is perpendicular to `delaunayaxis`.',\n            'In case the `delaunayaxis` intersects the mesh surface at more than one point',\n            'it will result triangles that are very long in the dimension of `delaunayaxis`.',\n\n            'If *>0*, the alpha-shape algorithm is used. In this case, the positive `alphahull` value',\n            'signals the use of the alpha-shape algorithm, _and_ its value',\n            'acts as the parameter for the mesh fitting.',\n\n            'If *0*,  the convex-hull algorithm is used. It is suitable for convex bodies',\n            'or if the intention is to enclose the `x`, `y` and `z` point set into a convex',\n            'hull.'\n        ].join(' ')\n    },\n\n    intensity: {\n        valType: 'data_array',\n        description: [\n            'Sets the vertex intensity values,',\n            'used for plotting fields on meshes'\n        ].join(' ')\n    },\n\n    // Color field\n    color: {\n        valType: 'color',\n        role: 'style',\n        description: 'Sets the color of the whole mesh'\n    },\n    vertexcolor: {\n        valType: 'data_array',  // FIXME: this should be a color array\n        role: 'style',\n        description: [\n            'Sets the color of each vertex',\n            'Overrides *color*.'\n        ].join(' ')\n    },\n    facecolor: {\n        valType: 'data_array',\n        role: 'style',\n        description: [\n            'Sets the color of each face',\n            'Overrides *color* and *vertexcolor*.'\n        ].join(' ')\n    },\n\n    // Opacity\n    opacity: extendFlat({}, surfaceAtts.opacity),\n\n    // Flat shaded mode\n    flatshading: {\n        valType: 'boolean',\n        role: 'style',\n        dflt: false,\n        description: [\n            'Determines whether or not normal smoothing is applied to the meshes,',\n            'creating meshes with an angular, low-poly look via flat reflections.'\n        ].join(' ')\n    },\n\n    contour: {\n        show: extendFlat({}, surfaceAtts.contours.x.show, {\n            description: [\n                'Sets whether or not dynamic contours are shown on hover'\n            ].join(' ')\n        }),\n        color: extendFlat({}, surfaceAtts.contours.x.color),\n        width: extendFlat({}, surfaceAtts.contours.x.width)\n    },\n\n    colorscale: colorscaleAttrs.colorscale,\n    reversescale: colorscaleAttrs.reversescale,\n    showscale: colorscaleAttrs.showscale,\n    colorbar: colorbarAttrs,\n\n    lightposition: {\n        'x': extendFlat({}, surfaceAtts.lightposition.x, {dflt: 1e5}),\n        'y': extendFlat({}, surfaceAtts.lightposition.y, {dflt: 1e5}),\n        'z': extendFlat({}, surfaceAtts.lightposition.z, {dflt: 0})\n    },\n    lighting: extendFlat({}, {\n        vertexnormalsepsilon: {\n            valType: 'number',\n            role: 'style',\n            min: 0.00,\n            max: 1,\n            dflt: 1e-12, // otherwise finely tessellated things eg. the brain will have no specular light reflection\n            description: 'Epsilon for vertex normals calculation avoids math issues arising from degenerate geometry.'\n        },\n        facenormalsepsilon: {\n            valType: 'number',\n            role: 'style',\n            min: 0.00,\n            max: 1,\n            dflt: 1e-6, // even the brain model doesn't appear to need finer than this\n            description: 'Epsilon for face normals calculation avoids math issues arising from degenerate geometry.'\n        }\n    }, surfaceAtts.lighting)\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/surface/attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Color = require('../../components/color');\nvar colorscaleAttrs = require('../../components/colorscale/attributes');\nvar colorbarAttrs = require('../../components/colorbar/attributes');\n\nvar extendFlat = require('../../lib/extend').extendFlat;\n\nfunction makeContourProjAttr(axLetter) {\n    return {\n        valType: 'boolean',\n        role: 'info',\n        dflt: false,\n        description: [\n            'Determines whether or not these contour lines are projected',\n            'on the', axLetter, 'plane.',\n            'If `highlight` is set to *true* (the default), the projected',\n            'lines are shown on hover.',\n            'If `show` is set to *true*, the projected lines are shown',\n            'in permanence.'\n        ].join(' ')\n    };\n}\n\nfunction makeContourAttr(axLetter) {\n    return {\n        show: {\n            valType: 'boolean',\n            role: 'info',\n            dflt: false,\n            description: [\n                'Determines whether or not contour lines about the', axLetter,\n                'dimension are drawn.'\n            ].join(' ')\n        },\n        project: {\n            x: makeContourProjAttr('x'),\n            y: makeContourProjAttr('y'),\n            z: makeContourProjAttr('z')\n        },\n        color: {\n            valType: 'color',\n            role: 'style',\n            dflt: Color.defaultLine,\n            description: 'Sets the color of the contour lines.'\n        },\n        usecolormap: {\n            valType: 'boolean',\n            role: 'info',\n            dflt: false,\n            description: [\n                'An alternate to *color*.',\n                'Determines whether or not the contour lines are colored using',\n                'the trace *colorscale*.'\n            ].join(' ')\n        },\n        width: {\n            valType: 'number',\n            role: 'style',\n            min: 1,\n            max: 16,\n            dflt: 2,\n            description: 'Sets the width of the contour lines.'\n        },\n        highlight: {\n            valType: 'boolean',\n            role: 'info',\n            dflt: true,\n            description: [\n                'Determines whether or not contour lines about the', axLetter,\n                'dimension are highlighted on hover.'\n            ].join(' ')\n        },\n        highlightcolor: {\n            valType: 'color',\n            role: 'style',\n            dflt: Color.defaultLine,\n            description: 'Sets the color of the highlighted contour lines.'\n        },\n        highlightwidth: {\n            valType: 'number',\n            role: 'style',\n            min: 1,\n            max: 16,\n            dflt: 2,\n            description: 'Sets the width of the highlighted contour lines.'\n        }\n    };\n}\n\nmodule.exports = {\n    z: {\n        valType: 'data_array',\n        description: 'Sets the z coordinates.'\n    },\n    x: {\n        valType: 'data_array',\n        description: 'Sets the x coordinates.'\n    },\n    y: {\n        valType: 'data_array',\n        description: 'Sets the y coordinates.'\n    },\n\n    text: {\n        valType: 'data_array',\n        description: 'Sets the text elements associated with each z value.'\n    },\n    surfacecolor: {\n        valType: 'data_array',\n        description: [\n            'Sets the surface color values,',\n            'used for setting a color scale independent of `z`.'\n        ].join(' ')\n    },\n\n    // Todo this block has a structure of colorscale/attributes.js but with colorscale/color_attributes.js names\n    cauto: colorscaleAttrs.zauto,\n    cmin: colorscaleAttrs.zmin,\n    cmax: colorscaleAttrs.zmax,\n    colorscale: colorscaleAttrs.colorscale,\n    autocolorscale: extendFlat({}, colorscaleAttrs.autocolorscale,\n        {dflt: false}),\n    reversescale: colorscaleAttrs.reversescale,\n    showscale: colorscaleAttrs.showscale,\n    colorbar: colorbarAttrs,\n\n    contours: {\n        x: makeContourAttr('x'),\n        y: makeContourAttr('y'),\n        z: makeContourAttr('z')\n    },\n    hidesurface: {\n        valType: 'boolean',\n        role: 'info',\n        dflt: false,\n        description: [\n            'Determines whether or not a surface is drawn.',\n            'For example, set `hidesurface` to *false*',\n            '`contours.x.show` to *true* and',\n            '`contours.y.show` to *true* to draw a wire frame plot.'\n        ].join(' ')\n    },\n\n    lightposition: {\n        x: {\n            valType: 'number',\n            role: 'style',\n            min: -1e5,\n            max: 1e5,\n            dflt: 10,\n            description: 'Numeric vector, representing the X coordinate for each vertex.'\n        },\n        y: {\n            valType: 'number',\n            role: 'style',\n            min: -1e5,\n            max: 1e5,\n            dflt: 1e4,\n            description: 'Numeric vector, representing the Y coordinate for each vertex.'\n        },\n        z: {\n            valType: 'number',\n            role: 'style',\n            min: -1e5,\n            max: 1e5,\n            dflt: 0,\n            description: 'Numeric vector, representing the Z coordinate for each vertex.'\n        }\n    },\n\n    lighting: {\n        ambient: {\n            valType: 'number',\n            role: 'style',\n            min: 0.00,\n            max: 1.0,\n            dflt: 0.8,\n            description: 'Ambient light increases overall color visibility but can wash out the image.'\n        },\n        diffuse: {\n            valType: 'number',\n            role: 'style',\n            min: 0.00,\n            max: 1.00,\n            dflt: 0.8,\n            description: 'Represents the extent that incident rays are reflected in a range of angles.'\n        },\n        specular: {\n            valType: 'number',\n            role: 'style',\n            min: 0.00,\n            max: 2.00,\n            dflt: 0.05,\n            description: 'Represents the level that incident rays are reflected in a single direction, causing shine.'\n        },\n        roughness: {\n            valType: 'number',\n            role: 'style',\n            min: 0.00,\n            max: 1.00,\n            dflt: 0.5,\n            description: 'Alters specular reflection; the rougher the surface, the wider and less contrasty the shine.'\n        },\n        fresnel: {\n            valType: 'number',\n            role: 'style',\n            min: 0.00,\n            max: 5.00,\n            dflt: 0.2,\n            description: [\n                'Represents the reflectance as a dependency of the viewing angle; e.g. paper is reflective',\n                'when viewing it from the edge of the paper (almost 90 degrees), causing shine.'\n            ].join(' ')\n        }\n    },\n\n    opacity: {\n        valType: 'number',\n        role: 'style',\n        min: 0,\n        max: 1,\n        dflt: 1,\n        description: 'Sets the opacity of the surface.'\n    },\n\n    _deprecated: {\n        zauto: extendFlat({}, colorscaleAttrs.zauto, {\n            description: 'Obsolete. Use `cauto` instead.'\n        }),\n        zmin: extendFlat({}, colorscaleAttrs.zmin, {\n            description: 'Obsolete. Use `cmin` instead.'\n        }),\n        zmax: extendFlat({}, colorscaleAttrs.zmax, {\n            description: 'Obsolete. Use `cmax` instead.'\n        })\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/mesh3d/defaults.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar colorbarDefaults = require('../../components/colorbar/defaults');\nvar attributes = require('./attributes');\n\n\nmodule.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {\n    function coerce(attr, dflt) {\n        return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);\n    }\n\n    // read in face/vertex properties\n    function readComponents(array) {\n        var ret = array.map(function(attr) {\n            var result = coerce(attr);\n\n            if(result && Array.isArray(result)) return result;\n            return null;\n        });\n\n        return ret.every(function(x) {\n            return x && x.length === ret[0].length;\n        }) && ret;\n    }\n\n    var coords = readComponents(['x', 'y', 'z']);\n    var indices = readComponents(['i', 'j', 'k']);\n\n    if(!coords) {\n        traceOut.visible = false;\n        return;\n    }\n\n    if(indices) {\n        // otherwise, convert all face indices to ints\n        indices.forEach(function(index) {\n            for(var i = 0; i < index.length; ++i) index[i] |= 0;\n        });\n    }\n\n    var handleCalendarDefaults = Registry.getComponentMethod('calendars', 'handleTraceDefaults');\n    handleCalendarDefaults(traceIn, traceOut, ['x', 'y', 'z'], layout);\n\n    // Coerce remaining properties\n    [\n        'lighting.ambient',\n        'lighting.diffuse',\n        'lighting.specular',\n        'lighting.roughness',\n        'lighting.fresnel',\n        'lighting.vertexnormalsepsilon',\n        'lighting.facenormalsepsilon',\n        'lightposition.x',\n        'lightposition.y',\n        'lightposition.z',\n        'contour.show',\n        'contour.color',\n        'contour.width',\n        'colorscale',\n        'reversescale',\n        'flatshading',\n        'alphahull',\n        'delaunayaxis',\n        'opacity'\n    ].forEach(function(x) { coerce(x); });\n\n    if('intensity' in traceIn) {\n        coerce('intensity');\n        coerce('showscale', true);\n    }\n    else {\n        traceOut.showscale = false;\n\n        if('vertexcolor' in traceIn) coerce('vertexcolor');\n        else if('facecolor' in traceIn) coerce('facecolor');\n        else coerce('color', defaultColor);\n    }\n\n    if(traceOut.reversescale) {\n        traceOut.colorscale = traceOut.colorscale.map(function(si) {\n            return [1 - si[0], si[1]];\n        }).reverse();\n    }\n\n    if(traceOut.showscale) {\n        colorbarDefaults(traceIn, traceOut, layout);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/heatmap/colorbar.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\nvar Plots = require('../../plots/plots');\nvar Colorscale = require('../../components/colorscale');\nvar drawColorbar = require('../../components/colorbar/draw');\n\n\nmodule.exports = function colorbar(gd, cd) {\n    var trace = cd[0].trace,\n        cbId = 'cb' + trace.uid,\n        zmin = trace.zmin,\n        zmax = trace.zmax;\n\n    if(!isNumeric(zmin)) zmin = Lib.aggNums(Math.min, null, trace.z);\n    if(!isNumeric(zmax)) zmax = Lib.aggNums(Math.max, null, trace.z);\n\n    gd._fullLayout._infolayer.selectAll('.' + cbId).remove();\n\n    if(!trace.showscale) {\n        Plots.autoMargin(gd, cbId);\n        return;\n    }\n\n    var cb = cd[0].t.cb = drawColorbar(gd, cbId);\n    var sclFunc = Colorscale.makeColorScaleFunc(\n        Colorscale.extractScale(\n            trace.colorscale,\n            zmin,\n            zmax\n        ),\n        { noNumericCheck: true }\n    );\n\n    cb.fillcolor(sclFunc)\n        .filllevels({start: zmin, end: zmax, size: (zmax - zmin) / 254})\n        .options(trace.colorbar)();\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/colorbar/draw.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\nvar tinycolor = require('tinycolor2');\n\nvar Plotly = require('../../plotly');\nvar Plots = require('../../plots/plots');\nvar Registry = require('../../registry');\nvar Axes = require('../../plots/cartesian/axes');\nvar dragElement = require('../dragelement');\nvar Lib = require('../../lib');\nvar extendFlat = require('../../lib/extend').extendFlat;\nvar setCursor = require('../../lib/setcursor');\nvar Drawing = require('../drawing');\nvar Color = require('../color');\nvar Titles = require('../titles');\n\nvar handleAxisDefaults = require('../../plots/cartesian/axis_defaults');\nvar handleAxisPositionDefaults = require('../../plots/cartesian/position_defaults');\nvar axisLayoutAttrs = require('../../plots/cartesian/layout_attributes');\n\nvar attributes = require('./attributes');\n\n\nmodule.exports = function draw(gd, id) {\n    // opts: options object, containing everything from attributes\n    // plus a few others that are the equivalent of the colorbar \"data\"\n    var opts = {};\n    Object.keys(attributes).forEach(function(k) {\n        opts[k] = null;\n    });\n    // fillcolor can be a d3 scale, domain is z values, range is colors\n    // or leave it out for no fill,\n    // or set to a string constant for single-color fill\n    opts.fillcolor = null;\n    // line.color has the same options as fillcolor\n    opts.line = {color: null, width: null, dash: null};\n    // levels of lines to draw.\n    // note that this DOES NOT determine the extent of the bar\n    // that's given by the domain of fillcolor\n    // (or line.color if no fillcolor domain)\n    opts.levels = {start: null, end: null, size: null};\n    // separate fill levels (for example, heatmap coloring of a\n    // contour map) if this is omitted, fillcolors will be\n    // evaluated halfway between levels\n    opts.filllevels = null;\n\n    function component() {\n        var fullLayout = gd._fullLayout,\n            gs = fullLayout._size;\n        if((typeof opts.fillcolor !== 'function') &&\n                (typeof opts.line.color !== 'function')) {\n            fullLayout._infolayer.selectAll('g.' + id).remove();\n            return;\n        }\n        var zrange = d3.extent(((typeof opts.fillcolor === 'function') ?\n                opts.fillcolor : opts.line.color).domain()),\n            linelevels = [],\n            filllevels = [],\n            l,\n            linecolormap = typeof opts.line.color === 'function' ?\n                opts.line.color : function() { return opts.line.color; },\n            fillcolormap = typeof opts.fillcolor === 'function' ?\n                opts.fillcolor : function() { return opts.fillcolor; };\n\n        var l0 = opts.levels.end + opts.levels.size / 100,\n            ls = opts.levels.size,\n            zr0 = (1.001 * zrange[0] - 0.001 * zrange[1]),\n            zr1 = (1.001 * zrange[1] - 0.001 * zrange[0]);\n        for(l = opts.levels.start; (l - l0) * ls < 0; l += ls) {\n            if(l > zr0 && l < zr1) linelevels.push(l);\n        }\n\n        if(typeof opts.fillcolor === 'function') {\n            if(opts.filllevels) {\n                l0 = opts.filllevels.end + opts.filllevels.size / 100;\n                ls = opts.filllevels.size;\n                for(l = opts.filllevels.start; (l - l0) * ls < 0; l += ls) {\n                    if(l > zrange[0] && l < zrange[1]) filllevels.push(l);\n                }\n            }\n            else {\n                filllevels = linelevels.map(function(v) {\n                    return v - opts.levels.size / 2;\n                });\n                filllevels.push(filllevels[filllevels.length - 1] +\n                    opts.levels.size);\n            }\n        }\n        else if(opts.fillcolor && typeof opts.fillcolor === 'string') {\n            // doesn't matter what this value is, with a single value\n            // we'll make a single fill rect covering the whole bar\n            filllevels = [0];\n        }\n\n        if(opts.levels.size < 0) {\n            linelevels.reverse();\n            filllevels.reverse();\n        }\n\n        // now make a Plotly Axes object to scale with and draw ticks\n        // TODO: does not support orientation other than right\n\n        // we calculate pixel sizes based on the specified graph size,\n        // not the actual (in case something pushed the margins around)\n        // which is a little odd but avoids an odd iterative effect\n        // when the colorbar itself is pushing the margins.\n        // but then the fractional size is calculated based on the\n        // actual graph size, so that the axes will size correctly.\n        var originalPlotHeight = fullLayout.height - fullLayout.margin.t - fullLayout.margin.b,\n            originalPlotWidth = fullLayout.width - fullLayout.margin.l - fullLayout.margin.r,\n            thickPx = Math.round(opts.thickness *\n                (opts.thicknessmode === 'fraction' ? originalPlotWidth : 1)),\n            thickFrac = thickPx / gs.w,\n            lenPx = Math.round(opts.len *\n                (opts.lenmode === 'fraction' ? originalPlotHeight : 1)),\n            lenFrac = lenPx / gs.h,\n            xpadFrac = opts.xpad / gs.w,\n            yExtraPx = (opts.borderwidth + opts.outlinewidth) / 2,\n            ypadFrac = opts.ypad / gs.h,\n\n            // x positioning: do it initially just for left anchor,\n            // then fix at the end (since we don't know the width yet)\n            xLeft = Math.round(opts.x * gs.w + opts.xpad),\n            // for dragging... this is getting a little muddled...\n            xLeftFrac = opts.x - thickFrac *\n                ({middle: 0.5, right: 1}[opts.xanchor]||0),\n\n            // y positioning we can do correctly from the start\n            yBottomFrac = opts.y + lenFrac *\n                (({top: -0.5, bottom: 0.5}[opts.yanchor] || 0) - 0.5),\n            yBottomPx = Math.round(gs.h * (1 - yBottomFrac)),\n            yTopPx = yBottomPx - lenPx,\n            titleEl,\n            cbAxisIn = {\n                type: 'linear',\n                range: zrange,\n                tickmode: opts.tickmode,\n                nticks: opts.nticks,\n                tick0: opts.tick0,\n                dtick: opts.dtick,\n                tickvals: opts.tickvals,\n                ticktext: opts.ticktext,\n                ticks: opts.ticks,\n                ticklen: opts.ticklen,\n                tickwidth: opts.tickwidth,\n                tickcolor: opts.tickcolor,\n                showticklabels: opts.showticklabels,\n                tickfont: opts.tickfont,\n                tickangle: opts.tickangle,\n                tickformat: opts.tickformat,\n                exponentformat: opts.exponentformat,\n                separatethousands: opts.separatethousands,\n                showexponent: opts.showexponent,\n                showtickprefix: opts.showtickprefix,\n                tickprefix: opts.tickprefix,\n                showticksuffix: opts.showticksuffix,\n                ticksuffix: opts.ticksuffix,\n                title: opts.title,\n                titlefont: opts.titlefont,\n                anchor: 'free',\n                position: 1\n            },\n            cbAxisOut = {\n                type: 'linear',\n                _id: 'y' + id\n            },\n            axisOptions = {\n                letter: 'y',\n                font: fullLayout.font,\n                noHover: true,\n                calendar: fullLayout.calendar  // not really necessary (yet?)\n            };\n\n        // Coerce w.r.t. Axes layoutAttributes:\n        // re-use axes.js logic without updating _fullData\n        function coerce(attr, dflt) {\n            return Lib.coerce(cbAxisIn, cbAxisOut, axisLayoutAttrs, attr, dflt);\n        }\n\n        // Prepare the Plotly axis object\n        handleAxisDefaults(cbAxisIn, cbAxisOut, coerce, axisOptions, fullLayout);\n        handleAxisPositionDefaults(cbAxisIn, cbAxisOut, coerce, axisOptions);\n\n        // position can't go in through supplyDefaults\n        // because that restricts it to [0,1]\n        cbAxisOut.position = opts.x + xpadFrac + thickFrac;\n\n        // save for other callers to access this axis\n        component.axis = cbAxisOut;\n\n        if(['top', 'bottom'].indexOf(opts.titleside) !== -1) {\n            cbAxisOut.titleside = opts.titleside;\n            cbAxisOut.titlex = opts.x + xpadFrac;\n            cbAxisOut.titley = yBottomFrac +\n                (opts.titleside === 'top' ? lenFrac - ypadFrac : ypadFrac);\n        }\n\n        if(opts.line.color && opts.tickmode === 'auto') {\n            cbAxisOut.tickmode = 'linear';\n            cbAxisOut.tick0 = opts.levels.start;\n            var dtick = opts.levels.size;\n            // expand if too many contours, so we don't get too many ticks\n            var autoNtick = Lib.constrain(\n                    (yBottomPx - yTopPx) / 50, 4, 15) + 1,\n                dtFactor = (zrange[1] - zrange[0]) /\n                    ((opts.nticks || autoNtick) * dtick);\n            if(dtFactor > 1) {\n                var dtexp = Math.pow(10, Math.floor(\n                    Math.log(dtFactor) / Math.LN10));\n                dtick *= dtexp * Lib.roundUp(dtFactor / dtexp, [2, 5, 10]);\n                // if the contours are at round multiples, reset tick0\n                // so they're still at round multiples. Otherwise,\n                // keep the first label on the first contour level\n                if((Math.abs(opts.levels.start) /\n                        opts.levels.size + 1e-6) % 1 < 2e-6) {\n                    cbAxisOut.tick0 = 0;\n                }\n            }\n            cbAxisOut.dtick = dtick;\n        }\n\n        // set domain after init, because we may want to\n        // allow it outside [0,1]\n        cbAxisOut.domain = [\n            yBottomFrac + ypadFrac,\n            yBottomFrac + lenFrac - ypadFrac\n        ];\n        cbAxisOut.setScale();\n\n        // now draw the elements\n        var container = fullLayout._infolayer.selectAll('g.' + id).data([0]);\n        container.enter().append('g').classed(id, true)\n            .each(function() {\n                var s = d3.select(this);\n                s.append('rect').classed('cbbg', true);\n                s.append('g').classed('cbfills', true);\n                s.append('g').classed('cblines', true);\n                s.append('g').classed('cbaxis', true).classed('crisp', true);\n                s.append('g').classed('cbtitleunshift', true)\n                    .append('g').classed('cbtitle', true);\n                s.append('rect').classed('cboutline', true);\n                s.select('.cbtitle').datum(0);\n            });\n        container.attr('transform', 'translate(' + Math.round(gs.l) +\n            ',' + Math.round(gs.t) + ')');\n        // TODO: this opposite transform is a hack until we make it\n        // more rational which items get this offset\n        var titleCont = container.select('.cbtitleunshift')\n            .attr('transform', 'translate(-' +\n                Math.round(gs.l) + ',-' +\n                Math.round(gs.t) + ')');\n\n        cbAxisOut._axislayer = container.select('.cbaxis');\n        var titleHeight = 0;\n        if(['top', 'bottom'].indexOf(opts.titleside) !== -1) {\n            // draw the title so we know how much room it needs\n            // when we squish the axis. This one only applies to\n            // top or bottom titles, not right side.\n            var x = gs.l + (opts.x + xpadFrac) * gs.w,\n                fontSize = cbAxisOut.titlefont.size,\n                y;\n\n            if(opts.titleside === 'top') {\n                y = (1 - (yBottomFrac + lenFrac - ypadFrac)) * gs.h +\n                    gs.t + 3 + fontSize * 0.75;\n            }\n            else {\n                y = (1 - (yBottomFrac + ypadFrac)) * gs.h +\n                    gs.t - 3 - fontSize * 0.25;\n            }\n            drawTitle(cbAxisOut._id + 'title', {\n                attributes: {x: x, y: y, 'text-anchor': 'start'}\n            });\n        }\n\n        function drawAxis() {\n            if(['top', 'bottom'].indexOf(opts.titleside) !== -1) {\n                // squish the axis top to make room for the title\n                var titleGroup = container.select('.cbtitle'),\n                    titleText = titleGroup.select('text'),\n                    titleTrans =\n                        [-opts.outlinewidth / 2, opts.outlinewidth / 2],\n                    mathJaxNode = titleGroup\n                        .select('.h' + cbAxisOut._id + 'title-math-group')\n                        .node(),\n                    lineSize = 15.6;\n                if(titleText.node()) {\n                    lineSize =\n                        parseInt(titleText.style('font-size'), 10) * 1.3;\n                }\n                if(mathJaxNode) {\n                    titleHeight = Drawing.bBox(mathJaxNode).height;\n                    if(titleHeight > lineSize) {\n                        // not entirely sure how mathjax is doing\n                        // vertical alignment, but this seems to work.\n                        titleTrans[1] -= (titleHeight - lineSize) / 2;\n                    }\n                }\n                else if(titleText.node() &&\n                        !titleText.classed('js-placeholder')) {\n                    titleHeight = Drawing.bBox(\n                        titleGroup.node()).height;\n                }\n                if(titleHeight) {\n                    // buffer btwn colorbar and title\n                    // TODO: configurable\n                    titleHeight += 5;\n\n                    if(opts.titleside === 'top') {\n                        cbAxisOut.domain[1] -= titleHeight / gs.h;\n                        titleTrans[1] *= -1;\n                    }\n                    else {\n                        cbAxisOut.domain[0] += titleHeight / gs.h;\n                        var nlines = Math.max(1,\n                            titleText.selectAll('tspan.line').size());\n                        titleTrans[1] += (1 - nlines) * lineSize;\n                    }\n\n                    titleGroup.attr('transform',\n                        'translate(' + titleTrans + ')');\n\n                    cbAxisOut.setScale();\n                }\n            }\n\n            container.selectAll('.cbfills,.cblines,.cbaxis')\n                .attr('transform', 'translate(0,' +\n                    Math.round(gs.h * (1 - cbAxisOut.domain[1])) + ')');\n\n            var fills = container.select('.cbfills')\n                .selectAll('rect.cbfill')\n                    .data(filllevels);\n            fills.enter().append('rect')\n                .classed('cbfill', true)\n                .style('stroke', 'none');\n            fills.exit().remove();\n            fills.each(function(d, i) {\n                var z = [\n                    (i === 0) ? zrange[0] :\n                        (filllevels[i] + filllevels[i - 1]) / 2,\n                    (i === filllevels.length - 1) ? zrange[1] :\n                        (filllevels[i] + filllevels[i + 1]) / 2\n                ]\n                .map(cbAxisOut.c2p)\n                .map(Math.round);\n\n                // offset the side adjoining the next rectangle so they\n                // overlap, to prevent antialiasing gaps\n                if(i !== filllevels.length - 1) {\n                    z[1] += (z[1] > z[0]) ? 1 : -1;\n                }\n\n\n                // Tinycolor can't handle exponents and\n                // at this scale, removing it makes no difference.\n                var colorString = fillcolormap(d).replace('e-', ''),\n                    opaqueColor = tinycolor(colorString).toHexString();\n\n                // Colorbar cannot currently support opacities so we\n                // use an opaque fill even when alpha channels present\n                d3.select(this).attr({\n                    x: xLeft,\n                    width: Math.max(thickPx, 2),\n                    y: d3.min(z),\n                    height: Math.max(d3.max(z) - d3.min(z), 2),\n                    fill: opaqueColor\n                });\n            });\n\n            var lines = container.select('.cblines')\n                .selectAll('path.cbline')\n                    .data(opts.line.color && opts.line.width ?\n                        linelevels : []);\n            lines.enter().append('path')\n                .classed('cbline', true);\n            lines.exit().remove();\n            lines.each(function(d) {\n                d3.select(this)\n                    .attr('d', 'M' + xLeft + ',' +\n                        (Math.round(cbAxisOut.c2p(d)) + (opts.line.width / 2) % 1) +\n                        'h' + thickPx)\n                    .call(Drawing.lineGroupStyle,\n                        opts.line.width, linecolormap(d), opts.line.dash);\n            });\n\n            // force full redraw of labels and ticks\n            cbAxisOut._axislayer.selectAll('g.' + cbAxisOut._id + 'tick,path')\n                .remove();\n\n            cbAxisOut._pos = xLeft + thickPx +\n                (opts.outlinewidth||0) / 2 - (opts.ticks === 'outside' ? 1 : 0);\n            cbAxisOut.side = 'right';\n\n            // separate out axis and title drawing,\n            // so we don't need such complicated logic in Titles.draw\n            // if title is on the top or bottom, we've already drawn it\n            // this title call only handles side=right\n            return Lib.syncOrAsync([\n                function() {\n                    return Axes.doTicks(gd, cbAxisOut, true);\n                },\n                function() {\n                    if(['top', 'bottom'].indexOf(opts.titleside) === -1) {\n                        var fontSize = cbAxisOut.titlefont.size,\n                            y = cbAxisOut._offset + cbAxisOut._length / 2,\n                            x = gs.l + (cbAxisOut.position || 0) * gs.w + ((cbAxisOut.side === 'right') ?\n                                10 + fontSize * ((cbAxisOut.showticklabels ? 1 : 0.5)) :\n                                -10 - fontSize * ((cbAxisOut.showticklabels ? 0.5 : 0)));\n\n                        // the 'h' + is a hack to get around the fact that\n                        // convertToTspans rotates any 'y...' class by 90 degrees.\n                        // TODO: find a better way to control this.\n                        drawTitle('h' + cbAxisOut._id + 'title', {\n                            avoid: {\n                                selection: d3.select(gd).selectAll('g.' + cbAxisOut._id + 'tick'),\n                                side: opts.titleside,\n                                offsetLeft: gs.l,\n                                offsetTop: gs.t,\n                                maxShift: fullLayout.width\n                            },\n                            attributes: {x: x, y: y, 'text-anchor': 'middle'},\n                            transform: {rotate: '-90', offset: 0}\n                        });\n                    }\n                }]);\n        }\n\n        function drawTitle(titleClass, titleOpts) {\n            var trace = getTrace(),\n                propName;\n            if(Registry.traceIs(trace, 'markerColorscale')) {\n                propName = 'marker.colorbar.title';\n            }\n            else propName = 'colorbar.title';\n\n            var dfltTitleOpts = {\n                propContainer: cbAxisOut,\n                propName: propName,\n                traceIndex: trace.index,\n                dfltName: 'colorscale',\n                containerGroup: container.select('.cbtitle')\n            };\n\n            // this class-to-rotate thing with convertToTspans is\n            // getting hackier and hackier... delete groups with the\n            // wrong class (in case earlier the colorbar was drawn on\n            // a different side, I think?)\n            var otherClass = titleClass.charAt(0) === 'h' ?\n                titleClass.substr(1) : ('h' + titleClass);\n            container.selectAll('.' + otherClass + ',.' + otherClass + '-math-group')\n                .remove();\n\n            Titles.draw(gd, titleClass,\n                extendFlat(dfltTitleOpts, titleOpts || {}));\n        }\n\n        function positionCB() {\n            // wait for the axis & title to finish rendering before\n            // continuing positioning\n            // TODO: why are we redrawing multiple times now with this?\n            // I guess autoMargin doesn't like being post-promise?\n            var innerWidth = thickPx + opts.outlinewidth / 2 +\n                    Drawing.bBox(cbAxisOut._axislayer.node()).width;\n            titleEl = titleCont.select('text');\n            if(titleEl.node() && !titleEl.classed('js-placeholder')) {\n                var mathJaxNode = titleCont\n                        .select('.h' + cbAxisOut._id + 'title-math-group')\n                        .node(),\n                    titleWidth;\n                if(mathJaxNode &&\n                        ['top', 'bottom'].indexOf(opts.titleside) !== -1) {\n                    titleWidth = Drawing.bBox(mathJaxNode).width;\n                }\n                else {\n                    // note: the formula below works for all titlesides,\n                    // (except for top/bottom mathjax, above)\n                    // but the weird gs.l is because the titleunshift\n                    // transform gets removed by Drawing.bBox\n                    titleWidth =\n                        Drawing.bBox(titleCont.node()).right -\n                        xLeft - gs.l;\n                }\n                innerWidth = Math.max(innerWidth, titleWidth);\n            }\n\n            var outerwidth = 2 * opts.xpad + innerWidth +\n                    opts.borderwidth + opts.outlinewidth / 2,\n                outerheight = yBottomPx - yTopPx;\n\n            container.select('.cbbg').attr({\n                x: xLeft - opts.xpad -\n                    (opts.borderwidth + opts.outlinewidth) / 2,\n                y: yTopPx - yExtraPx,\n                width: Math.max(outerwidth, 2),\n                height: Math.max(outerheight + 2 * yExtraPx, 2)\n            })\n            .call(Color.fill, opts.bgcolor)\n            .call(Color.stroke, opts.bordercolor)\n            .style({'stroke-width': opts.borderwidth});\n\n            container.selectAll('.cboutline').attr({\n                x: xLeft,\n                y: yTopPx + opts.ypad +\n                    (opts.titleside === 'top' ? titleHeight : 0),\n                width: Math.max(thickPx, 2),\n                height: Math.max(outerheight - 2 * opts.ypad - titleHeight, 2)\n            })\n            .call(Color.stroke, opts.outlinecolor)\n            .style({\n                fill: 'None',\n                'stroke-width': opts.outlinewidth\n            });\n\n            // fix positioning for xanchor!='left'\n            var xoffset = ({center: 0.5, right: 1}[opts.xanchor] || 0) *\n                outerwidth;\n            container.attr('transform',\n                'translate(' + (gs.l - xoffset) + ',' + gs.t + ')');\n\n            // auto margin adjustment\n            Plots.autoMargin(gd, id, {\n                x: opts.x,\n                y: opts.y,\n                l: outerwidth * ({right: 1, center: 0.5}[opts.xanchor] || 0),\n                r: outerwidth * ({left: 1, center: 0.5}[opts.xanchor] || 0),\n                t: outerheight * ({bottom: 1, middle: 0.5}[opts.yanchor] || 0),\n                b: outerheight * ({top: 1, middle: 0.5}[opts.yanchor] || 0)\n            });\n        }\n\n        var cbDone = Lib.syncOrAsync([\n            Plots.previousPromises,\n            drawAxis,\n            Plots.previousPromises,\n            positionCB\n        ], gd);\n\n        if(cbDone && cbDone.then) (gd._promises || []).push(cbDone);\n\n        // dragging...\n        if(gd._context.editable) {\n            var t0,\n                xf,\n                yf;\n\n            dragElement.init({\n                element: container.node(),\n                prepFn: function() {\n                    t0 = container.attr('transform');\n                    setCursor(container);\n                },\n                moveFn: function(dx, dy) {\n                    container.attr('transform',\n                        t0 + ' ' + 'translate(' + dx + ',' + dy + ')');\n\n                    xf = dragElement.align(xLeftFrac + (dx / gs.w), thickFrac,\n                        0, 1, opts.xanchor);\n                    yf = dragElement.align(yBottomFrac - (dy / gs.h), lenFrac,\n                        0, 1, opts.yanchor);\n\n                    var csr = dragElement.getCursor(xf, yf,\n                        opts.xanchor, opts.yanchor);\n                    setCursor(container, csr);\n                },\n                doneFn: function(dragged) {\n                    setCursor(container);\n\n                    if(dragged && xf !== undefined && yf !== undefined) {\n                        Plotly.restyle(gd,\n                            {'colorbar.x': xf, 'colorbar.y': yf},\n                            getTrace().index);\n                    }\n                }\n            });\n        }\n        return cbDone;\n    }\n\n    function getTrace() {\n        var idNum = id.substr(2),\n            i,\n            trace;\n        for(i = 0; i < gd._fullData.length; i++) {\n            trace = gd._fullData[i];\n            if(trace.uid === idNum) return trace;\n        }\n    }\n\n    // setter/getters for every item defined in opts\n    Object.keys(opts).forEach(function(name) {\n        component[name] = function(v) {\n            // getter\n            if(!arguments.length) return opts[name];\n\n            // setter - for multi-part properties,\n            // set only the parts that are provided\n            opts[name] = Lib.isPlainObject(opts[name]) ?\n                 Lib.extendFlat(opts[name], v) :\n                 v;\n\n            return component;\n        };\n    });\n\n    // or use .options to set multiple options at once via a dictionary\n    component.options = function(o) {\n        Object.keys(o).forEach(function(name) {\n            // in case something random comes through\n            // that's not an option, ignore it\n            if(typeof component[name] === 'function') {\n                component[name](o[name]);\n            }\n        });\n        return component;\n    };\n\n    component._opts = opts;\n\n    return component;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/mesh3d/convert.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar createMesh = require('gl-mesh3d');\nvar tinycolor = require('tinycolor2');\nvar triangulate = require('delaunay-triangulate');\nvar alphaShape = require('alpha-shape');\nvar convexHull = require('convex-hull');\n\nvar str2RgbaArray = require('../../lib/str2rgbarray');\n\n\nfunction Mesh3DTrace(scene, mesh, uid) {\n    this.scene = scene;\n    this.uid = uid;\n    this.mesh = mesh;\n    this.name = '';\n    this.color = '#fff';\n    this.data = null;\n    this.showContour = false;\n}\n\nvar proto = Mesh3DTrace.prototype;\n\nproto.handlePick = function(selection) {\n    if(selection.object === this.mesh) {\n        var selectIndex = selection.data.index;\n\n        selection.traceCoordinate = [\n            this.data.x[selectIndex],\n            this.data.y[selectIndex],\n            this.data.z[selectIndex]\n        ];\n\n        return true;\n    }\n};\n\nfunction parseColorScale(colorscale) {\n    return colorscale.map(function(elem) {\n        var index = elem[0];\n        var color = tinycolor(elem[1]);\n        var rgb = color.toRgb();\n        return {\n            index: index,\n            rgb: [rgb.r, rgb.g, rgb.b, 1]\n        };\n    });\n}\n\nfunction parseColorArray(colors) {\n    return colors.map(str2RgbaArray);\n}\n\nfunction zip3(x, y, z) {\n    var result = new Array(x.length);\n    for(var i = 0; i < x.length; ++i) {\n        result[i] = [x[i], y[i], z[i]];\n    }\n    return result;\n}\n\nproto.update = function(data) {\n    var scene = this.scene,\n        layout = scene.fullSceneLayout;\n\n    this.data = data;\n\n    // Unpack position data\n    function toDataCoords(axis, coord, scale, calendar) {\n        return coord.map(function(x) {\n            return axis.d2l(x, 0, calendar) * scale;\n        });\n    }\n\n    var positions = zip3(\n        toDataCoords(layout.xaxis, data.x, scene.dataScale[0], data.xcalendar),\n        toDataCoords(layout.yaxis, data.y, scene.dataScale[1], data.ycalendar),\n        toDataCoords(layout.zaxis, data.z, scene.dataScale[2], data.zcalendar));\n\n    var cells;\n    if(data.i && data.j && data.k) {\n        cells = zip3(data.i, data.j, data.k);\n    }\n    else if(data.alphahull === 0) {\n        cells = convexHull(positions);\n    }\n    else if(data.alphahull > 0) {\n        cells = alphaShape(data.alphahull, positions);\n    }\n    else {\n        var d = ['x', 'y', 'z'].indexOf(data.delaunayaxis);\n        cells = triangulate(positions.map(function(c) {\n            return [c[(d + 1) % 3], c[(d + 2) % 3]];\n        }));\n    }\n\n    var config = {\n        positions: positions,\n        cells: cells,\n        lightPosition: [data.lightposition.x, data.lightposition.y, data.lightposition.z],\n        ambient: data.lighting.ambient,\n        diffuse: data.lighting.diffuse,\n        specular: data.lighting.specular,\n        roughness: data.lighting.roughness,\n        fresnel: data.lighting.fresnel,\n        vertexNormalsEpsilon: data.lighting.vertexnormalsepsilon,\n        faceNormalsEpsilon: data.lighting.facenormalsepsilon,\n        opacity: data.opacity,\n        contourEnable: data.contour.show,\n        contourColor: str2RgbaArray(data.contour.color).slice(0, 3),\n        contourWidth: data.contour.width,\n        useFacetNormals: data.flatshading\n    };\n\n    if(data.intensity) {\n        this.color = '#fff';\n        config.vertexIntensity = data.intensity;\n        config.colormap = parseColorScale(data.colorscale);\n    }\n    else if(data.vertexcolor) {\n        this.color = data.vertexcolors[0];\n        config.vertexColors = parseColorArray(data.vertexcolor);\n    }\n    else if(data.facecolor) {\n        this.color = data.facecolor[0];\n        config.cellColors = parseColorArray(data.facecolor);\n    }\n    else {\n        this.color = data.color;\n        config.meshColor = str2RgbaArray(data.color);\n    }\n\n    // Update mesh\n    this.mesh.update(config);\n};\n\nproto.dispose = function() {\n    this.scene.glplot.remove(this.mesh);\n    this.mesh.dispose();\n};\n\nfunction createMesh3DTrace(scene, data) {\n    var gl = scene.glplot.gl;\n    var mesh = createMesh({gl: gl});\n    var result = new Mesh3DTrace(scene, mesh, data.uid);\n    mesh._trace = result;\n    result.update(data);\n    scene.glplot.add(mesh);\n    return result;\n}\n\nmodule.exports = createMesh3DTrace;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/lib/str2rgbarray.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar rgba = require('color-rgba');\n\nfunction str2RgbaArray(color) {\n    var colorOut = rgba(color);\n    return colorOut.length ? colorOut : [0, 0, 0, 1];\n}\n\nmodule.exports = str2RgbaArray;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/gl3d/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Scene = require('./scene');\nvar Plots = require('../plots');\nvar Lib = require('../../lib');\nvar xmlnsNamespaces = require('../../constants/xmlns_namespaces');\n\nexports.name = 'gl3d';\n\nexports.attr = 'scene';\n\nexports.idRoot = 'scene';\n\nexports.idRegex = /^scene([2-9]|[1-9][0-9]+)?$/;\n\nexports.attrRegex = /^scene([2-9]|[1-9][0-9]+)?$/;\n\nexports.attributes = require('./layout/attributes');\n\nexports.layoutAttributes = require('./layout/layout_attributes');\n\nexports.supplyLayoutDefaults = require('./layout/defaults');\n\nexports.plot = function plotGl3d(gd) {\n    var fullLayout = gd._fullLayout,\n        fullData = gd._fullData,\n        sceneIds = Plots.getSubplotIds(fullLayout, 'gl3d');\n\n    for(var i = 0; i < sceneIds.length; i++) {\n        var sceneId = sceneIds[i],\n            fullSceneData = Plots.getSubplotData(fullData, 'gl3d', sceneId),\n            sceneLayout = fullLayout[sceneId],\n            scene = sceneLayout._scene;\n\n        if(!scene) {\n            scene = new Scene({\n                id: sceneId,\n                graphDiv: gd,\n                container: gd.querySelector('.gl-container'),\n                staticPlot: gd._context.staticPlot,\n                plotGlPixelRatio: gd._context.plotGlPixelRatio\n            },\n                fullLayout\n            );\n\n            // set ref to Scene instance\n            sceneLayout._scene = scene;\n        }\n\n        // save 'initial' camera settings for modebar button\n        if(!scene.cameraInitial) {\n            scene.cameraInitial = Lib.extendDeep({}, sceneLayout.camera);\n        }\n\n        scene.plot(fullSceneData, fullLayout, gd.layout);\n    }\n};\n\nexports.clean = function(newFullData, newFullLayout, oldFullData, oldFullLayout) {\n    var oldSceneKeys = Plots.getSubplotIds(oldFullLayout, 'gl3d');\n\n    for(var i = 0; i < oldSceneKeys.length; i++) {\n        var oldSceneKey = oldSceneKeys[i];\n\n        if(!newFullLayout[oldSceneKey] && !!oldFullLayout[oldSceneKey]._scene) {\n            oldFullLayout[oldSceneKey]._scene.destroy();\n        }\n    }\n};\n\nexports.toSVG = function(gd) {\n    var fullLayout = gd._fullLayout,\n        sceneIds = Plots.getSubplotIds(fullLayout, 'gl3d'),\n        size = fullLayout._size;\n\n    for(var i = 0; i < sceneIds.length; i++) {\n        var sceneLayout = fullLayout[sceneIds[i]],\n            domain = sceneLayout.domain,\n            scene = sceneLayout._scene;\n\n        var imageData = scene.toImage('png');\n        var image = fullLayout._glimages.append('svg:image');\n\n        image.attr({\n            xmlns: xmlnsNamespaces.svg,\n            'xlink:href': imageData,\n            x: size.l + size.w * domain.x[0],\n            y: size.t + size.h * (1 - domain.y[1]),\n            width: size.w * (domain.x[1] - domain.x[0]),\n            height: size.h * (domain.y[1] - domain.y[0]),\n            preserveAspectRatio: 'none'\n        });\n\n        scene.destroy();\n    }\n};\n\n// clean scene ids, 'scene1' -> 'scene'\nexports.cleanId = function cleanId(id) {\n    if(!id.match(/^scene[0-9]*$/)) return;\n\n    var sceneNum = id.substr(5);\n    if(sceneNum === '1') sceneNum = '';\n\n    return 'scene' + sceneNum;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/gl3d/scene.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar createPlot = require('gl-plot3d');\nvar getContext = require('webgl-context');\n\nvar Lib = require('../../lib');\n\nvar Axes = require('../../plots/cartesian/axes');\nvar Fx = require('../../plots/cartesian/graph_interact');\n\nvar str2RGBAarray = require('../../lib/str2rgbarray');\nvar showNoWebGlMsg = require('../../lib/show_no_webgl_msg');\n\nvar createCamera = require('./camera');\nvar project = require('./project');\nvar createAxesOptions = require('./layout/convert');\nvar createSpikeOptions = require('./layout/spikes');\nvar computeTickMarks = require('./layout/tick_marks');\n\nvar STATIC_CANVAS, STATIC_CONTEXT;\n\nfunction render(scene) {\n\n    var trace;\n\n    // update size of svg container\n    var svgContainer = scene.svgContainer;\n    var clientRect = scene.container.getBoundingClientRect();\n    var width = clientRect.width, height = clientRect.height;\n    svgContainer.setAttributeNS(null, 'viewBox', '0 0 ' + width + ' ' + height);\n    svgContainer.setAttributeNS(null, 'width', width);\n    svgContainer.setAttributeNS(null, 'height', height);\n\n    computeTickMarks(scene);\n    scene.glplot.axes.update(scene.axesOptions);\n\n    // check if pick has changed\n    var keys = Object.keys(scene.traces);\n    var lastPicked = null;\n    var selection = scene.glplot.selection;\n    for(var i = 0; i < keys.length; ++i) {\n        trace = scene.traces[keys[i]];\n        if(trace.data.hoverinfo !== 'skip' && trace.handlePick(selection)) {\n            lastPicked = trace;\n        }\n\n        if(trace.setContourLevels) trace.setContourLevels();\n    }\n\n    function formatter(axisName, val) {\n        var axis = scene.fullSceneLayout[axisName];\n\n        return Axes.tickText(axis, axis.d2l(val), 'hover').text;\n    }\n\n    var oldEventData;\n\n    if(lastPicked !== null) {\n        var pdata = project(scene.glplot.cameraParams, selection.dataCoordinate);\n        trace = lastPicked.data;\n        var hoverinfo = trace.hoverinfo;\n\n        var xVal = formatter('xaxis', selection.traceCoordinate[0]),\n            yVal = formatter('yaxis', selection.traceCoordinate[1]),\n            zVal = formatter('zaxis', selection.traceCoordinate[2]);\n\n        if(hoverinfo !== 'all') {\n            var hoverinfoParts = hoverinfo.split('+');\n            if(hoverinfoParts.indexOf('x') === -1) xVal = undefined;\n            if(hoverinfoParts.indexOf('y') === -1) yVal = undefined;\n            if(hoverinfoParts.indexOf('z') === -1) zVal = undefined;\n            if(hoverinfoParts.indexOf('text') === -1) selection.textLabel = undefined;\n            if(hoverinfoParts.indexOf('name') === -1) lastPicked.name = undefined;\n        }\n\n        if(scene.fullSceneLayout.hovermode) {\n            Fx.loneHover({\n                x: (0.5 + 0.5 * pdata[0] / pdata[3]) * width,\n                y: (0.5 - 0.5 * pdata[1] / pdata[3]) * height,\n                xLabel: xVal,\n                yLabel: yVal,\n                zLabel: zVal,\n                text: selection.textLabel,\n                name: lastPicked.name,\n                color: lastPicked.color\n            }, {\n                container: svgContainer\n            });\n        }\n\n        var eventData = {\n            points: [{\n                x: xVal,\n                y: yVal,\n                z: zVal,\n                data: trace._input,\n                fullData: trace,\n                curveNumber: trace.index,\n                pointNumber: selection.data.index\n            }]\n        };\n\n        if(selection.buttons && selection.distance < 5) {\n            scene.graphDiv.emit('plotly_click', eventData);\n        }\n        else {\n            scene.graphDiv.emit('plotly_hover', eventData);\n        }\n\n        oldEventData = eventData;\n    }\n    else {\n        Fx.loneUnhover(svgContainer);\n        scene.graphDiv.emit('plotly_unhover', oldEventData);\n    }\n}\n\nfunction initializeGLPlot(scene, fullLayout, canvas, gl) {\n    var glplotOptions = {\n        canvas: canvas,\n        gl: gl,\n        container: scene.container,\n        axes: scene.axesOptions,\n        spikes: scene.spikeOptions,\n        pickRadius: 10,\n        snapToData: true,\n        autoScale: true,\n        autoBounds: false\n    };\n\n    // for static plots, we reuse the WebGL context\n    //  as WebKit doesn't collect them reliably\n    if(scene.staticMode) {\n        if(!STATIC_CONTEXT) {\n            STATIC_CANVAS = document.createElement('canvas');\n            STATIC_CONTEXT = getContext({\n                canvas: STATIC_CANVAS,\n                preserveDrawingBuffer: true,\n                premultipliedAlpha: true,\n                antialias: true\n            });\n            if(!STATIC_CONTEXT) {\n                throw new Error('error creating static canvas/context for image server');\n            }\n        }\n        glplotOptions.pixelRatio = scene.pixelRatio;\n        glplotOptions.gl = STATIC_CONTEXT;\n        glplotOptions.canvas = STATIC_CANVAS;\n    }\n\n    try {\n        scene.glplot = createPlot(glplotOptions);\n    }\n    catch(e) {\n        /*\n        * createPlot will throw when webgl is not enabled in the client.\n        * Lets return an instance of the module with all functions noop'd.\n        * The destroy method - which will remove the container from the DOM\n        * is overridden with a function that removes the container only.\n        */\n        showNoWebGlMsg(scene);\n    }\n\n    var relayoutCallback = function(scene) {\n        if(scene.fullSceneLayout.dragmode === false) return;\n\n        var update = {};\n        update[scene.id] = getLayoutCamera(scene.camera);\n        scene.saveCamera(scene.graphDiv.layout);\n        scene.graphDiv.emit('plotly_relayout', update);\n    };\n\n    scene.glplot.canvas.addEventListener('mouseup', relayoutCallback.bind(null, scene));\n    scene.glplot.canvas.addEventListener('wheel', relayoutCallback.bind(null, scene));\n\n    if(!scene.staticMode) {\n        scene.glplot.canvas.addEventListener('webglcontextlost', function(ev) {\n            Lib.warn('Lost WebGL context.');\n            ev.preventDefault();\n        });\n    }\n\n    if(!scene.camera) {\n        var cameraData = scene.fullSceneLayout.camera;\n        scene.camera = createCamera(scene.container, {\n            center: [cameraData.center.x, cameraData.center.y, cameraData.center.z],\n            eye: [cameraData.eye.x, cameraData.eye.y, cameraData.eye.z],\n            up: [cameraData.up.x, cameraData.up.y, cameraData.up.z],\n            zoomMin: 0.1,\n            zoomMax: 100,\n            mode: 'orbit'\n        });\n    }\n\n    scene.glplot.camera = scene.camera;\n\n    scene.glplot.oncontextloss = function() {\n        scene.recoverContext();\n    };\n\n    scene.glplot.onrender = render.bind(null, scene);\n\n    // List of scene objects\n    scene.traces = {};\n\n    return true;\n}\n\nfunction Scene(options, fullLayout) {\n\n    // create sub container for plot\n    var sceneContainer = document.createElement('div');\n    var plotContainer = options.container;\n\n    // keep a ref to the graph div to fire hover+click events\n    this.graphDiv = options.graphDiv;\n\n    // create SVG container for hover text\n    var svgContainer = document.createElementNS(\n        'http://www.w3.org/2000/svg',\n        'svg');\n    svgContainer.style.position = 'absolute';\n    svgContainer.style.top = svgContainer.style.left = '0px';\n    svgContainer.style.width = svgContainer.style.height = '100%';\n    svgContainer.style['z-index'] = 20;\n    svgContainer.style['pointer-events'] = 'none';\n    sceneContainer.appendChild(svgContainer);\n    this.svgContainer = svgContainer;\n\n    // Tag the container with the sceneID\n    sceneContainer.id = options.id;\n    sceneContainer.style.position = 'absolute';\n    sceneContainer.style.top = sceneContainer.style.left = '0px';\n    sceneContainer.style.width = sceneContainer.style.height = '100%';\n    plotContainer.appendChild(sceneContainer);\n\n    this.fullLayout = fullLayout;\n    this.id = options.id || 'scene';\n    this.fullSceneLayout = fullLayout[this.id];\n\n    // Saved from last call to plot()\n    this.plotArgs = [ [], {}, {} ];\n\n    /*\n     * Move this to calc step? Why does it work here?\n     */\n    this.axesOptions = createAxesOptions(fullLayout[this.id]);\n    this.spikeOptions = createSpikeOptions(fullLayout[this.id]);\n    this.container = sceneContainer;\n    this.staticMode = !!options.staticPlot;\n    this.pixelRatio = options.plotGlPixelRatio || 2;\n\n    // Coordinate rescaling\n    this.dataScale = [1, 1, 1];\n\n    this.contourLevels = [ [], [], [] ];\n\n    if(!initializeGLPlot(this, fullLayout)) return; // todo check the necessity for this line\n}\n\nvar proto = Scene.prototype;\n\nproto.recoverContext = function() {\n    var scene = this;\n    var gl = this.glplot.gl;\n    var canvas = this.glplot.canvas;\n    this.glplot.dispose();\n\n    function tryRecover() {\n        if(gl.isContextLost()) {\n            requestAnimationFrame(tryRecover);\n            return;\n        }\n        if(!initializeGLPlot(scene, scene.fullLayout, canvas, gl)) {\n            Lib.error('Catastrophic and unrecoverable WebGL error. Context lost.');\n            return;\n        }\n        scene.plot.apply(scene, scene.plotArgs);\n    }\n    requestAnimationFrame(tryRecover);\n};\n\nvar axisProperties = [ 'xaxis', 'yaxis', 'zaxis' ];\n\nfunction coordinateBound(axis, coord, d, bounds, calendar) {\n    var x;\n    for(var i = 0; i < coord.length; ++i) {\n        if(Array.isArray(coord[i])) {\n            for(var j = 0; j < coord[i].length; ++j) {\n                x = axis.d2l(coord[i][j], 0, calendar);\n                if(!isNaN(x) && isFinite(x)) {\n                    bounds[0][d] = Math.min(bounds[0][d], x);\n                    bounds[1][d] = Math.max(bounds[1][d], x);\n                }\n            }\n        }\n        else {\n            x = axis.d2l(coord[i], 0, calendar);\n            if(!isNaN(x) && isFinite(x)) {\n                bounds[0][d] = Math.min(bounds[0][d], x);\n                bounds[1][d] = Math.max(bounds[1][d], x);\n            }\n        }\n    }\n}\n\nfunction computeTraceBounds(scene, trace, bounds) {\n    var sceneLayout = scene.fullSceneLayout;\n    coordinateBound(sceneLayout.xaxis, trace.x, 0, bounds, trace.xcalendar);\n    coordinateBound(sceneLayout.yaxis, trace.y, 1, bounds, trace.ycalendar);\n    coordinateBound(sceneLayout.zaxis, trace.z, 2, bounds, trace.zcalendar);\n}\n\nproto.plot = function(sceneData, fullLayout, layout) {\n\n    // Save parameters\n    this.plotArgs = [sceneData, fullLayout, layout];\n\n    if(this.glplot.contextLost) return;\n\n    var data, trace;\n    var i, j, axis, axisType;\n    var fullSceneLayout = fullLayout[this.id];\n    var sceneLayout = layout[this.id];\n\n    if(fullSceneLayout.bgcolor) this.glplot.clearColor = str2RGBAarray(fullSceneLayout.bgcolor);\n    else this.glplot.clearColor = [0, 0, 0, 0];\n\n    this.glplot.snapToData = true;\n\n    // Update layout\n    this.fullLayout = fullLayout;\n    this.fullSceneLayout = fullSceneLayout;\n\n    this.glplotLayout = fullSceneLayout;\n    this.axesOptions.merge(fullSceneLayout);\n    this.spikeOptions.merge(fullSceneLayout);\n\n    // Update camera and camera mode\n    this.setCamera(fullSceneLayout.camera);\n    this.updateFx(fullSceneLayout.dragmode, fullSceneLayout.hovermode);\n\n    // Update scene\n    this.glplot.update({});\n\n    // Update axes functions BEFORE updating traces\n    this.setConvert(axis);\n\n    // Convert scene data\n    if(!sceneData) sceneData = [];\n    else if(!Array.isArray(sceneData)) sceneData = [sceneData];\n\n    // Compute trace bounding box\n    var dataBounds = [\n        [Infinity, Infinity, Infinity],\n        [-Infinity, -Infinity, -Infinity]\n    ];\n    for(i = 0; i < sceneData.length; ++i) {\n        data = sceneData[i];\n        if(data.visible !== true) continue;\n\n        computeTraceBounds(this, data, dataBounds);\n    }\n    var dataScale = [1, 1, 1];\n    for(j = 0; j < 3; ++j) {\n        if(dataBounds[0][j] > dataBounds[1][j]) {\n            dataScale[j] = 1.0;\n        }\n        else {\n            if(dataBounds[1][j] === dataBounds[0][j]) {\n                dataScale[j] = 1.0;\n            }\n            else {\n                dataScale[j] = 1.0 / (dataBounds[1][j] - dataBounds[0][j]);\n            }\n        }\n    }\n\n    // Save scale\n    this.dataScale = dataScale;\n\n    // Update traces\n    for(i = 0; i < sceneData.length; ++i) {\n        data = sceneData[i];\n        if(data.visible !== true) {\n            continue;\n        }\n        trace = this.traces[data.uid];\n        if(trace) {\n            trace.update(data);\n        } else {\n            trace = data._module.plot(this, data);\n            this.traces[data.uid] = trace;\n        }\n        trace.name = data.name;\n    }\n\n    // Remove empty traces\n    var traceIds = Object.keys(this.traces);\n\n    trace_id_loop:\n    for(i = 0; i < traceIds.length; ++i) {\n        for(j = 0; j < sceneData.length; ++j) {\n            if(sceneData[j].uid === traceIds[i] && sceneData[j].visible === true) {\n                continue trace_id_loop;\n            }\n        }\n        trace = this.traces[traceIds[i]];\n        trace.dispose();\n        delete this.traces[traceIds[i]];\n    }\n\n    // order object per trace index\n    this.glplot.objects.sort(function(a, b) {\n        return a._trace.data.index - b._trace.data.index;\n    });\n\n    // Update ranges (needs to be called *after* objects are added due to updates)\n    var sceneBounds = [[0, 0, 0], [0, 0, 0]],\n        axisDataRange = [],\n        axisTypeRatios = {};\n\n    for(i = 0; i < 3; ++i) {\n        axis = fullSceneLayout[axisProperties[i]];\n        axisType = axis.type;\n\n        if(axisType in axisTypeRatios) {\n            axisTypeRatios[axisType].acc *= dataScale[i];\n            axisTypeRatios[axisType].count += 1;\n        }\n        else {\n            axisTypeRatios[axisType] = {\n                acc: dataScale[i],\n                count: 1\n            };\n        }\n\n        if(axis.autorange) {\n            sceneBounds[0][i] = Infinity;\n            sceneBounds[1][i] = -Infinity;\n            for(j = 0; j < this.glplot.objects.length; ++j) {\n                var objBounds = this.glplot.objects[j].bounds;\n                sceneBounds[0][i] = Math.min(sceneBounds[0][i],\n                  objBounds[0][i] / dataScale[i]);\n                sceneBounds[1][i] = Math.max(sceneBounds[1][i],\n                  objBounds[1][i] / dataScale[i]);\n            }\n            if('rangemode' in axis && axis.rangemode === 'tozero') {\n                sceneBounds[0][i] = Math.min(sceneBounds[0][i], 0);\n                sceneBounds[1][i] = Math.max(sceneBounds[1][i], 0);\n            }\n            if(sceneBounds[0][i] > sceneBounds[1][i]) {\n                sceneBounds[0][i] = -1;\n                sceneBounds[1][i] = 1;\n            } else {\n                var d = sceneBounds[1][i] - sceneBounds[0][i];\n                sceneBounds[0][i] -= d / 32.0;\n                sceneBounds[1][i] += d / 32.0;\n            }\n        } else {\n            var range = fullSceneLayout[axisProperties[i]].range;\n            sceneBounds[0][i] = range[0];\n            sceneBounds[1][i] = range[1];\n        }\n        if(sceneBounds[0][i] === sceneBounds[1][i]) {\n            sceneBounds[0][i] -= 1;\n            sceneBounds[1][i] += 1;\n        }\n        axisDataRange[i] = sceneBounds[1][i] - sceneBounds[0][i];\n\n        // Update plot bounds\n        this.glplot.bounds[0][i] = sceneBounds[0][i] * dataScale[i];\n        this.glplot.bounds[1][i] = sceneBounds[1][i] * dataScale[i];\n    }\n\n    var axesScaleRatio = [1, 1, 1];\n\n    // Compute axis scale per category\n    for(i = 0; i < 3; ++i) {\n        axis = fullSceneLayout[axisProperties[i]];\n        axisType = axis.type;\n        var axisRatio = axisTypeRatios[axisType];\n        axesScaleRatio[i] = Math.pow(axisRatio.acc, 1.0 / axisRatio.count) / dataScale[i];\n    }\n\n    /*\n     * Dynamically set the aspect ratio depending on the users aspect settings\n     */\n    var axisAutoScaleFactor = 4;\n    var aspectRatio;\n\n    if(fullSceneLayout.aspectmode === 'auto') {\n\n        if(Math.max.apply(null, axesScaleRatio) / Math.min.apply(null, axesScaleRatio) <= axisAutoScaleFactor) {\n\n            /*\n             * USE DATA MODE WHEN AXIS RANGE DIMENSIONS ARE RELATIVELY EQUAL\n             */\n\n            aspectRatio = axesScaleRatio;\n        } else {\n\n            /*\n             * USE EQUAL MODE WHEN AXIS RANGE DIMENSIONS ARE HIGHLY UNEQUAL\n             */\n            aspectRatio = [1, 1, 1];\n        }\n\n    } else if(fullSceneLayout.aspectmode === 'cube') {\n        aspectRatio = [1, 1, 1];\n\n    } else if(fullSceneLayout.aspectmode === 'data') {\n        aspectRatio = axesScaleRatio;\n\n    } else if(fullSceneLayout.aspectmode === 'manual') {\n        var userRatio = fullSceneLayout.aspectratio;\n        aspectRatio = [userRatio.x, userRatio.y, userRatio.z];\n\n    } else {\n        throw new Error('scene.js aspectRatio was not one of the enumerated types');\n    }\n\n    /*\n     * Write aspect Ratio back to user data and fullLayout so that it is modifies as user\n     * manipulates the aspectmode settings and the fullLayout is up-to-date.\n     */\n    fullSceneLayout.aspectratio.x = sceneLayout.aspectratio.x = aspectRatio[0];\n    fullSceneLayout.aspectratio.y = sceneLayout.aspectratio.y = aspectRatio[1];\n    fullSceneLayout.aspectratio.z = sceneLayout.aspectratio.z = aspectRatio[2];\n\n    /*\n     * Finally assign the computed aspecratio to the glplot module. This will have an effect\n     * on the next render cycle.\n     */\n    this.glplot.aspect = aspectRatio;\n\n\n    // Update frame position for multi plots\n    var domain = fullSceneLayout.domain || null,\n        size = fullLayout._size || null;\n\n    if(domain && size) {\n        var containerStyle = this.container.style;\n        containerStyle.position = 'absolute';\n        containerStyle.left = (size.l + domain.x[0] * size.w) + 'px';\n        containerStyle.top = (size.t + (1 - domain.y[1]) * size.h) + 'px';\n        containerStyle.width = (size.w * (domain.x[1] - domain.x[0])) + 'px';\n        containerStyle.height = (size.h * (domain.y[1] - domain.y[0])) + 'px';\n    }\n\n    // force redraw so that promise is returned when rendering is completed\n    this.glplot.redraw();\n};\n\nproto.destroy = function() {\n    this.glplot.dispose();\n    this.container.parentNode.removeChild(this.container);\n\n    // Remove reference to glplot\n    this.glplot = null;\n};\n\n// getOrbitCamera :: plotly_coords -> orbit_camera_coords\n// inverse of getLayoutCamera\nfunction getOrbitCamera(camera) {\n    return [\n        [camera.eye.x, camera.eye.y, camera.eye.z],\n        [camera.center.x, camera.center.y, camera.center.z],\n        [camera.up.x, camera.up.y, camera.up.z]\n    ];\n}\n\n// getLayoutCamera :: orbit_camera_coords -> plotly_coords\n// inverse of getOrbitCamera\nfunction getLayoutCamera(camera) {\n    return {\n        up: {x: camera.up[0], y: camera.up[1], z: camera.up[2]},\n        center: {x: camera.center[0], y: camera.center[1], z: camera.center[2]},\n        eye: {x: camera.eye[0], y: camera.eye[1], z: camera.eye[2]}\n    };\n}\n\n// get camera position in plotly coords from 'orbit-camera' coords\nproto.getCamera = function getCamera() {\n    this.glplot.camera.view.recalcMatrix(this.camera.view.lastT());\n    return getLayoutCamera(this.glplot.camera);\n};\n\n// set camera position with a set of plotly coords\nproto.setCamera = function setCamera(cameraData) {\n    this.glplot.camera.lookAt.apply(this, getOrbitCamera(cameraData));\n};\n\n// save camera to user layout (i.e. gd.layout)\nproto.saveCamera = function saveCamera(layout) {\n    var cameraData = this.getCamera(),\n        cameraNestedProp = Lib.nestedProperty(layout, this.id + '.camera'),\n        cameraDataLastSave = cameraNestedProp.get(),\n        hasChanged = false;\n\n    function same(x, y, i, j) {\n        var vectors = ['up', 'center', 'eye'],\n            components = ['x', 'y', 'z'];\n        return y[vectors[i]] && (x[vectors[i]][components[j]] === y[vectors[i]][components[j]]);\n    }\n\n    if(cameraDataLastSave === undefined) hasChanged = true;\n    else {\n        for(var i = 0; i < 3; i++) {\n            for(var j = 0; j < 3; j++) {\n                if(!same(cameraData, cameraDataLastSave, i, j)) {\n                    hasChanged = true;\n                    break;\n                }\n            }\n        }\n    }\n\n    if(hasChanged) cameraNestedProp.set(cameraData);\n\n    return hasChanged;\n};\n\nproto.updateFx = function(dragmode, hovermode) {\n    var camera = this.camera;\n\n    if(camera) {\n        // rotate and orbital are synonymous\n        if(dragmode === 'orbit') {\n            camera.mode = 'orbit';\n            camera.keyBindingMode = 'rotate';\n\n        } else if(dragmode === 'turntable') {\n            camera.up = [0, 0, 1];\n            camera.mode = 'turntable';\n            camera.keyBindingMode = 'rotate';\n\n        } else {\n\n            // none rotation modes [pan or zoom]\n            camera.keyBindingMode = dragmode;\n        }\n    }\n\n    // to put dragmode and hovermode on the same grounds from relayout\n    this.fullSceneLayout.hovermode = hovermode;\n};\n\nproto.toImage = function(format) {\n    if(!format) format = 'png';\n\n    if(this.staticMode) this.container.appendChild(STATIC_CANVAS);\n\n    // Force redraw\n    this.glplot.redraw();\n\n    // Grab context and yank out pixels\n    var gl = this.glplot.gl;\n    var w = gl.drawingBufferWidth;\n    var h = gl.drawingBufferHeight;\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n    var pixels = new Uint8Array(w * h * 4);\n    gl.readPixels(0, 0, w, h, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n\n    // Flip pixels\n    for(var j = 0, k = h - 1; j < k; ++j, --k) {\n        for(var i = 0; i < w; ++i) {\n            for(var l = 0; l < 4; ++l) {\n                var tmp = pixels[4 * (w * j + i) + l];\n                pixels[4 * (w * j + i) + l] = pixels[4 * (w * k + i) + l];\n                pixels[4 * (w * k + i) + l] = tmp;\n            }\n        }\n    }\n\n    var canvas = document.createElement('canvas');\n    canvas.width = w;\n    canvas.height = h;\n    var context = canvas.getContext('2d');\n    var imageData = context.createImageData(w, h);\n    imageData.data.set(pixels);\n    context.putImageData(imageData, 0, 0);\n\n    var dataURL;\n\n    switch(format) {\n        case 'jpeg':\n            dataURL = canvas.toDataURL('image/jpeg');\n            break;\n        case 'webp':\n            dataURL = canvas.toDataURL('image/webp');\n            break;\n        default:\n            dataURL = canvas.toDataURL('image/png');\n    }\n\n    if(this.staticMode) this.container.removeChild(STATIC_CANVAS);\n\n    return dataURL;\n};\n\nproto.setConvert = function() {\n    for(var i = 0; i < 3; ++i) {\n        var ax = this.fullSceneLayout[axisProperties[i]];\n        Axes.setConvert(ax, this.fullLayout);\n        ax.setScale = Lib.noop;\n    }\n};\n\nmodule.exports = Scene;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/lib/ohlc.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = require('../src/traces/ohlc');\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/ohlc/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar register = require('../../plot_api/register');\n\nmodule.exports = {\n    moduleType: 'trace',\n    name: 'ohlc',\n    basePlotModule: require('../../plots/cartesian'),\n    categories: ['cartesian', 'showLegend'],\n    meta: {\n        description: [\n            'The ohlc (short for Open-High-Low-Close) is a style of financial chart describing',\n            'open, high, low and close for a given `x` coordinate (most likely time).',\n\n            'The tip of the lines represent the `low` and `high` values and',\n            'the horizontal segments represent the `open` and `close` values.',\n\n            'Sample points where the close value is higher (lower) then the open',\n            'value are called increasing (decreasing).',\n\n            'By default, increasing candles are drawn in green whereas',\n            'decreasing are drawn in red.'\n        ].join(' ')\n    },\n\n    attributes: require('./attributes'),\n    supplyDefaults: require('./defaults'),\n};\n\nregister(require('../scatter'));\nregister(require('./transform'));\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/lib/parcoords.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = require('../src/traces/parcoords');\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/parcoords/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Parcoords = {};\n\nParcoords.attributes = require('./attributes');\nParcoords.supplyDefaults = require('./defaults');\nParcoords.calc = require('./calc');\nParcoords.plot = require('./plot');\nParcoords.colorbar = require('./colorbar');\n\nParcoords.moduleType = 'trace';\nParcoords.name = 'parcoords';\nParcoords.basePlotModule = require('./base_plot');\nParcoords.categories = ['gl', 'noOpacity'];\nParcoords.meta = {\n    description: [\n        'Parallel coordinates for multidimensional exploratory data analysis.',\n        'The samples are specified in `dimensions`.',\n        'The colors are set in `line.color`.'\n    ].join(' ')\n};\n\nmodule.exports = Parcoords;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/parcoords/attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar colorAttributes = require('../../components/colorscale/color_attributes');\nvar colorbarAttrs = require('../../components/colorbar/attributes');\nvar colorscales = require('../../components/colorscale/scales');\nvar axesAttrs = require('../../plots/cartesian/layout_attributes');\n\nvar extendDeep = require('../../lib/extend').extendDeep;\nvar extendFlat = require('../../lib/extend').extendFlat;\n\nmodule.exports = {\n\n    domain: {\n        x: {\n            valType: 'info_array',\n            role: 'info',\n            items: [\n                {valType: 'number', min: 0, max: 1},\n                {valType: 'number', min: 0, max: 1}\n            ],\n            dflt: [0, 1],\n            description: [\n                'Sets the horizontal domain of this `parcoords` trace',\n                '(in plot fraction).'\n            ].join(' ')\n        },\n        y: {\n            valType: 'info_array',\n            role: 'info',\n            items: [\n                {valType: 'number', min: 0, max: 1},\n                {valType: 'number', min: 0, max: 1}\n            ],\n            dflt: [0, 1],\n            description: [\n                'Sets the vertical domain of this `parcoords` trace',\n                '(in plot fraction).'\n            ].join(' ')\n        }\n    },\n\n    dimensions: {\n        _isLinkedToArray: 'dimension',\n        label: {\n            valType: 'string',\n            role: 'info',\n            description: 'The shown name of the dimension.'\n        },\n        tickvals: axesAttrs.tickvals,\n        ticktext: axesAttrs.ticktext,\n        tickformat: {\n            valType: 'string',\n            dflt: '3s',\n            role: 'style',\n            description: [\n                'Sets the tick label formatting rule using d3 formatting mini-language',\n                'which is similar to those of Python. See',\n                'https://github.com/d3/d3-format/blob/master/README.md#locale_format'\n            ].join(' ')\n        },\n        visible: {\n            valType: 'boolean',\n            dflt: true,\n            role: 'info',\n            description: 'Shows the dimension when set to `true` (the default). Hides the dimension for `false`.'\n        },\n        range: {\n            valType: 'info_array',\n            role: 'info',\n            items: [\n                {valType: 'number'},\n                {valType: 'number'}\n            ],\n            description: [\n                'The domain range that represents the full, shown axis extent. Defaults to the `values` extent.',\n                'Must be an array of `[fromValue, toValue]` with finite numbers as elements.'\n            ].join(' ')\n        },\n        constraintrange: {\n            valType: 'info_array',\n            role: 'info',\n            items: [\n                {valType: 'number'},\n                {valType: 'number'}\n            ],\n            description: [\n                'The domain range to which the filter on the dimension is constrained. Must be an array',\n                'of `[fromValue, toValue]` with finite numbers as elements.'\n            ].join(' ')\n        },\n        values: {\n            valType: 'data_array',\n            role: 'info',\n            dflt: [],\n            description: [\n                'Dimension values. `values[n]` represents the value of the `n`th point in the dataset,',\n                'therefore the `values` vector for all dimensions must be the same (longer vectors',\n                'will be truncated). Each value must be a finite number.'\n            ].join(' ')\n        },\n        description: 'The dimensions (variables) of the parallel coordinates chart. 2..60 dimensions are supported.'\n    },\n\n    line: extendFlat({},\n\n        // the default autocolorscale isn't quite usable for parcoords due to context ambiguity around 0 (grey, off-white)\n        // autocolorscale therefore defaults to false too, to avoid being overridden by the  blue-white-red autocolor palette\n        extendDeep(\n            {},\n            colorAttributes('line'),\n            {\n                colorscale: extendDeep(\n                    {},\n                    colorAttributes('line').colorscale,\n                    {dflt: colorscales.Viridis}\n                ),\n                autocolorscale: extendDeep(\n                    {},\n                    colorAttributes('line').autocolorscale,\n                    {\n                        dflt: false,\n                        description: [\n                            'Has an effect only if line.color` is set to a numerical array.',\n                            'Determines whether the colorscale is a default palette (`autocolorscale: true`)',\n                            'or the palette determined by `line.colorscale`.',\n                            'In case `colorscale` is unspecified or `autocolorscale` is true, the default ',\n                            'palette will be chosen according to whether numbers in the `color` array are',\n                            'all positive, all negative or mixed.',\n                            'The default value is false, so that `parcoords` colorscale can default to `Viridis`.'\n                        ].join(' ')\n                    }\n                )\n\n            }\n        ),\n\n        {\n            showscale: {\n                valType: 'boolean',\n                role: 'info',\n                dflt: false,\n                description: [\n                    'Has an effect only if `line.color` is set to a numerical array.',\n                    'Determines whether or not a colorbar is displayed.'\n                ].join(' ')\n            },\n            colorbar: colorbarAttrs\n        }\n    )\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/lib/pie.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = require('../src/traces/pie');\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/pie/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Pie = {};\n\nPie.attributes = require('./attributes');\nPie.supplyDefaults = require('./defaults');\nPie.supplyLayoutDefaults = require('./layout_defaults');\nPie.layoutAttributes = require('./layout_attributes');\nPie.calc = require('./calc');\nPie.plot = require('./plot');\nPie.style = require('./style');\nPie.styleOne = require('./style_one');\n\nPie.moduleType = 'trace';\nPie.name = 'pie';\nPie.basePlotModule = require('./base_plot');\nPie.categories = ['pie', 'showLegend'];\nPie.meta = {\n    description: [\n        'A data visualized by the sectors of the pie is set in `values`.',\n        'The sector labels are set in `labels`.',\n        'The sector colors are set in `marker.colors`'\n    ].join(' ')\n};\n\nmodule.exports = Pie;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/pie/attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar colorAttrs = require('../../components/color/attributes');\nvar fontAttrs = require('../../plots/font_attributes');\nvar plotAttrs = require('../../plots/attributes');\n\nvar extendFlat = require('../../lib/extend').extendFlat;\n\n\nmodule.exports = {\n    labels: {\n        valType: 'data_array',\n        description: 'Sets the sector labels.'\n    },\n    // equivalent of x0 and dx, if label is missing\n    label0: {\n        valType: 'number',\n        role: 'info',\n        dflt: 0,\n        description: [\n            'Alternate to `labels`.',\n            'Builds a numeric set of labels.',\n            'Use with `dlabel`',\n            'where `label0` is the starting label and `dlabel` the step.'\n        ].join(' ')\n    },\n    dlabel: {\n        valType: 'number',\n        role: 'info',\n        dflt: 1,\n        description: 'Sets the label step. See `label0` for more info.'\n    },\n\n    values: {\n        valType: 'data_array',\n        description: 'Sets the values of the sectors of this pie chart.'\n    },\n\n    marker: {\n        colors: {\n            valType: 'data_array',  // TODO 'color_array' ?\n            description: [\n                'Sets the color of each sector of this pie chart.',\n                'If not specified, the default trace color set is used',\n                'to pick the sector colors.'\n            ].join(' ')\n        },\n\n        line: {\n            color: {\n                valType: 'color',\n                role: 'style',\n                dflt: colorAttrs.defaultLine,\n                arrayOk: true,\n                description: [\n                    'Sets the color of the line enclosing each sector.'\n                ].join(' ')\n            },\n            width: {\n                valType: 'number',\n                role: 'style',\n                min: 0,\n                dflt: 0,\n                arrayOk: true,\n                description: [\n                    'Sets the width (in px) of the line enclosing each sector.'\n                ].join(' ')\n            }\n        }\n    },\n\n    text: {\n        valType: 'data_array',\n        description: [\n            'Sets text elements associated with each sector.',\n            'If trace `textinfo` contains a *text* flag, these elements will seen',\n            'on the chart.',\n            'If trace `hoverinfo` contains a *text* flag and *hovertext* is not set,',\n            'these elements will be seen in the hover labels.'\n        ].join(' ')\n    },\n    hovertext: {\n        valType: 'string',\n        role: 'info',\n        dflt: '',\n        arrayOk: true,\n        description: [\n            'Sets hover text elements associated with each sector.',\n            'If a single string, the same string appears for',\n            'all data points.',\n            'If an array of string, the items are mapped in order of',\n            'this trace\\'s sectors.',\n            'To be seen, trace `hoverinfo` must contain a *text* flag.'\n        ].join(' ')\n    },\n\n// 'see eg:'\n// 'https://www.e-education.psu.edu/natureofgeoinfo/sites/www.e-education.psu.edu.natureofgeoinfo/files/image/hisp_pies.gif',\n// '(this example involves a map too - may someday be a whole trace type',\n// 'of its own. but the point is the size of the whole pie is important.)'\n    scalegroup: {\n        valType: 'string',\n        role: 'info',\n        dflt: '',\n        description: [\n            'If there are multiple pies that should be sized according to',\n            'their totals, link them by providing a non-empty group id here',\n            'shared by every trace in the same group.'\n        ].join(' ')\n    },\n\n    // labels (legend is handled by plots.attributes.showlegend and layout.hiddenlabels)\n    textinfo: {\n        valType: 'flaglist',\n        role: 'info',\n        flags: ['label', 'text', 'value', 'percent'],\n        extras: ['none'],\n        description: [\n            'Determines which trace information appear on the graph.'\n        ].join(' ')\n    },\n    hoverinfo: extendFlat({}, plotAttrs.hoverinfo, {\n        flags: ['label', 'text', 'value', 'percent', 'name']\n    }),\n    textposition: {\n        valType: 'enumerated',\n        role: 'info',\n        values: ['inside', 'outside', 'auto', 'none'],\n        dflt: 'auto',\n        arrayOk: true,\n        description: [\n            'Specifies the location of the `textinfo`.'\n        ].join(' ')\n    },\n    // TODO make those arrayOk?\n    textfont: extendFlat({}, fontAttrs, {\n        description: 'Sets the font used for `textinfo`.'\n    }),\n    insidetextfont: extendFlat({}, fontAttrs, {\n        description: 'Sets the font used for `textinfo` lying inside the pie.'\n    }),\n    outsidetextfont: extendFlat({}, fontAttrs, {\n        description: 'Sets the font used for `textinfo` lying outside the pie.'\n    }),\n\n    // position and shape\n    domain: {\n        x: {\n            valType: 'info_array',\n            role: 'info',\n            items: [\n                {valType: 'number', min: 0, max: 1},\n                {valType: 'number', min: 0, max: 1}\n            ],\n            dflt: [0, 1],\n            description: [\n                'Sets the horizontal domain of this pie trace',\n                '(in plot fraction).'\n            ].join(' ')\n        },\n        y: {\n            valType: 'info_array',\n            role: 'info',\n            items: [\n                {valType: 'number', min: 0, max: 1},\n                {valType: 'number', min: 0, max: 1}\n            ],\n            dflt: [0, 1],\n            description: [\n                'Sets the vertical domain of this pie trace',\n                '(in plot fraction).'\n            ].join(' ')\n        }\n    },\n    hole: {\n        valType: 'number',\n        role: 'style',\n        min: 0,\n        max: 1,\n        dflt: 0,\n        description: [\n            'Sets the fraction of the radius to cut out of the pie.',\n            'Use this to make a donut chart.'\n        ].join(' ')\n    },\n\n    // ordering and direction\n    sort: {\n        valType: 'boolean',\n        role: 'style',\n        dflt: true,\n        description: [\n            'Determines whether or not the sectors are reordered',\n            'from largest to smallest.'\n        ].join(' ')\n    },\n    direction: {\n        /**\n         * there are two common conventions, both of which place the first\n         * (largest, if sorted) slice with its left edge at 12 o'clock but\n         * succeeding slices follow either cw or ccw from there.\n         *\n         * see http://visage.co/data-visualization-101-pie-charts/\n         */\n        valType: 'enumerated',\n        values: ['clockwise', 'counterclockwise'],\n        role: 'style',\n        dflt: 'counterclockwise',\n        description: [\n            'Specifies the direction at which succeeding sectors follow',\n            'one another.'\n        ].join(' ')\n    },\n    rotation: {\n        valType: 'number',\n        role: 'style',\n        min: -360,\n        max: 360,\n        dflt: 0,\n        description: [\n            'Instead of the first slice starting at 12 o\\'clock,',\n            'rotate to some other angle.'\n        ].join(' ')\n    },\n\n    pull: {\n        valType: 'number',\n        role: 'style',\n        min: 0,\n        max: 1,\n        dflt: 0,\n        arrayOk: true,\n        description: [\n            'Sets the fraction of larger radius to pull the sectors',\n            'out from the center. This can be a constant',\n            'to pull all slices apart from each other equally',\n            'or an array to highlight one or more slices.'\n        ].join(' ')\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/pie/defaults.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar attributes = require('./attributes');\n\nmodule.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {\n    function coerce(attr, dflt) {\n        return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);\n    }\n\n    var coerceFont = Lib.coerceFont;\n\n    var vals = coerce('values');\n    if(!Array.isArray(vals) || !vals.length) {\n        traceOut.visible = false;\n        return;\n    }\n\n    var labels = coerce('labels');\n    if(!Array.isArray(labels)) {\n        coerce('label0');\n        coerce('dlabel');\n    }\n\n    var lineWidth = coerce('marker.line.width');\n    if(lineWidth) coerce('marker.line.color');\n\n    var colors = coerce('marker.colors');\n    if(!Array.isArray(colors)) traceOut.marker.colors = []; // later this will get padded with default colors\n\n    coerce('scalegroup');\n    // TODO: tilt, depth, and hole all need to be coerced to the same values within a scaleegroup\n    // (ideally actually, depth would get set the same *after* scaling, ie the same absolute depth)\n    // and if colors aren't specified we should match these up - potentially even if separate pies\n    // are NOT in the same sharegroup\n\n\n    var textData = coerce('text');\n    var textInfo = coerce('textinfo', Array.isArray(textData) ? 'text+percent' : 'percent');\n    coerce('hovertext');\n\n    coerce('hoverinfo', (layout._dataLength === 1) ? 'label+text+value+percent' : undefined);\n\n    if(textInfo && textInfo !== 'none') {\n        var textPosition = coerce('textposition'),\n            hasBoth = Array.isArray(textPosition) || textPosition === 'auto',\n            hasInside = hasBoth || textPosition === 'inside',\n            hasOutside = hasBoth || textPosition === 'outside';\n\n        if(hasInside || hasOutside) {\n            var dfltFont = coerceFont(coerce, 'textfont', layout.font);\n            if(hasInside) coerceFont(coerce, 'insidetextfont', dfltFont);\n            if(hasOutside) coerceFont(coerce, 'outsidetextfont', dfltFont);\n        }\n    }\n\n    coerce('domain.x');\n    coerce('domain.y');\n\n    // 3D attributes commented out until I finish them in a later PR\n    // var tilt = coerce('tilt');\n    // if(tilt) {\n    //     coerce('tiltaxis');\n    //     coerce('depth');\n    //     coerce('shading');\n    // }\n\n    coerce('hole');\n\n    coerce('sort');\n    coerce('direction');\n    coerce('rotation');\n\n    coerce('pull');\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/pie/layout_defaults.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\n\nvar layoutAttributes = require('./layout_attributes');\n\nmodule.exports = function supplyLayoutDefaults(layoutIn, layoutOut) {\n    function coerce(attr, dflt) {\n        return Lib.coerce(layoutIn, layoutOut, layoutAttributes, attr, dflt);\n    }\n    coerce('hiddenlabels');\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/pie/layout_attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = {\n    /**\n     * hiddenlabels is the pie chart analog of visible:'legendonly'\n     * but it can contain many labels, and can hide slices\n     * from several pies simultaneously\n     */\n    hiddenlabels: {valType: 'data_array'}\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/pie/calc.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar tinycolor = require('tinycolor2');\n\nvar Color = require('../../components/color');\nvar helpers = require('./helpers');\n\nmodule.exports = function calc(gd, trace) {\n    var vals = trace.values,\n        labels = trace.labels,\n        cd = [],\n        fullLayout = gd._fullLayout,\n        colorMap = fullLayout._piecolormap,\n        allThisTraceLabels = {},\n        needDefaults = false,\n        vTotal = 0,\n        hiddenLabels = fullLayout.hiddenlabels || [],\n        i,\n        v,\n        label,\n        color,\n        hidden,\n        pt;\n\n    if(trace.dlabel) {\n        labels = new Array(vals.length);\n        for(i = 0; i < vals.length; i++) {\n            labels[i] = String(trace.label0 + i * trace.dlabel);\n        }\n    }\n\n    for(i = 0; i < vals.length; i++) {\n        v = vals[i];\n        if(!isNumeric(v)) continue;\n        v = +v;\n        if(v < 0) continue;\n\n        label = labels[i];\n        if(label === undefined || label === '') label = i;\n        label = String(label);\n        // only take the first occurrence of any given label.\n        // TODO: perhaps (optionally?) sum values for a repeated label?\n        if(allThisTraceLabels[label] === undefined) allThisTraceLabels[label] = true;\n        else continue;\n\n        color = tinycolor(trace.marker.colors[i]);\n        if(color.isValid()) {\n            color = Color.addOpacity(color, color.getAlpha());\n            if(!colorMap[label]) {\n                colorMap[label] = color;\n            }\n        }\n        // have we seen this label and assigned a color to it in a previous trace?\n        else if(colorMap[label]) color = colorMap[label];\n        // color needs a default - mark it false, come back after sorting\n        else {\n            color = false;\n            needDefaults = true;\n        }\n\n        hidden = hiddenLabels.indexOf(label) !== -1;\n\n        if(!hidden) vTotal += v;\n\n        cd.push({\n            v: v,\n            label: label,\n            color: color,\n            i: i,\n            hidden: hidden\n        });\n    }\n\n    if(trace.sort) cd.sort(function(a, b) { return b.v - a.v; });\n\n    /**\n     * now go back and fill in colors we're still missing\n     * this is done after sorting, so we pick defaults\n     * in the order slices will be displayed\n     */\n\n    if(needDefaults) {\n        for(i = 0; i < cd.length; i++) {\n            pt = cd[i];\n            if(pt.color === false) {\n                colorMap[pt.label] = pt.color = nextDefaultColor(fullLayout._piedefaultcolorcount);\n                fullLayout._piedefaultcolorcount++;\n            }\n        }\n    }\n\n    // include the sum of all values in the first point\n    if(cd[0]) cd[0].vTotal = vTotal;\n\n    // now insert text\n    if(trace.textinfo && trace.textinfo !== 'none') {\n        var hasLabel = trace.textinfo.indexOf('label') !== -1,\n            hasText = trace.textinfo.indexOf('text') !== -1,\n            hasValue = trace.textinfo.indexOf('value') !== -1,\n            hasPercent = trace.textinfo.indexOf('percent') !== -1,\n            separators = fullLayout.separators,\n            thisText;\n\n        for(i = 0; i < cd.length; i++) {\n            pt = cd[i];\n            thisText = hasLabel ? [pt.label] : [];\n            if(hasText && trace.text[pt.i]) thisText.push(trace.text[pt.i]);\n            if(hasValue) thisText.push(helpers.formatPieValue(pt.v, separators));\n            if(hasPercent) thisText.push(helpers.formatPiePercent(pt.v / vTotal, separators));\n            pt.text = thisText.join('<br>');\n        }\n    }\n\n    return cd;\n};\n\n/**\n * pick a default color from the main default set, augmented by\n * itself lighter then darker before repeating\n */\nvar pieDefaultColors;\n\nfunction nextDefaultColor(index) {\n    if(!pieDefaultColors) {\n        // generate this default set on demand (but then it gets saved in the module)\n        var mainDefaults = Color.defaults;\n        pieDefaultColors = mainDefaults.slice();\n\n        var i;\n\n        for(i = 0; i < mainDefaults.length; i++) {\n            pieDefaultColors.push(tinycolor(mainDefaults[i]).lighten(20).toHexString());\n        }\n\n        for(i = 0; i < Color.defaults.length; i++) {\n            pieDefaultColors.push(tinycolor(mainDefaults[i]).darken(20).toHexString());\n        }\n    }\n\n    return pieDefaultColors[index % pieDefaultColors.length];\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/pie/helpers.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\n\nexports.formatPiePercent = function formatPiePercent(v, separators) {\n    var vRounded = (v * 100).toPrecision(3);\n    if(vRounded.lastIndexOf('.') !== -1) {\n        vRounded = vRounded.replace(/[.]?0+$/, '');\n    }\n    return Lib.numSeparate(vRounded, separators) + '%';\n};\n\nexports.formatPieValue = function formatPieValue(v, separators) {\n    var vRounded = v.toPrecision(10);\n    if(vRounded.lastIndexOf('.') !== -1) {\n        vRounded = vRounded.replace(/[.]?0+$/, '');\n    }\n    return Lib.numSeparate(vRounded, separators);\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/pie/plot.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\n\nvar Fx = require('../../plots/cartesian/graph_interact');\nvar Color = require('../../components/color');\nvar Drawing = require('../../components/drawing');\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar helpers = require('./helpers');\n\nmodule.exports = function plot(gd, cdpie) {\n    var fullLayout = gd._fullLayout;\n\n    scalePies(cdpie, fullLayout._size);\n\n    var pieGroups = fullLayout._pielayer.selectAll('g.trace').data(cdpie);\n\n    pieGroups.enter().append('g')\n        .attr({\n            'stroke-linejoin': 'round', // TODO: miter might look better but can sometimes cause problems\n                                        // maybe miter with a small-ish stroke-miterlimit?\n            'class': 'trace'\n        });\n    pieGroups.exit().remove();\n    pieGroups.order();\n\n    pieGroups.each(function(cd) {\n        var pieGroup = d3.select(this),\n            cd0 = cd[0],\n            trace = cd0.trace,\n            tiltRads = 0, // trace.tilt * Math.PI / 180,\n            depthLength = (trace.depth||0) * cd0.r * Math.sin(tiltRads) / 2,\n            tiltAxis = trace.tiltaxis || 0,\n            tiltAxisRads = tiltAxis * Math.PI / 180,\n            depthVector = [\n                depthLength * Math.sin(tiltAxisRads),\n                depthLength * Math.cos(tiltAxisRads)\n            ],\n            rSmall = cd0.r * Math.cos(tiltRads);\n\n        var pieParts = pieGroup.selectAll('g.part')\n            .data(trace.tilt ? ['top', 'sides'] : ['top']);\n\n        pieParts.enter().append('g').attr('class', function(d) {\n            return d + ' part';\n        });\n        pieParts.exit().remove();\n        pieParts.order();\n\n        setCoords(cd);\n\n        pieGroup.selectAll('.top').each(function() {\n            var slices = d3.select(this).selectAll('g.slice').data(cd);\n\n            slices.enter().append('g')\n                .classed('slice', true);\n            slices.exit().remove();\n\n            var quadrants = [\n                    [[], []], // y<0: x<0, x>=0\n                    [[], []] // y>=0: x<0, x>=0\n                ],\n                hasOutsideText = false;\n\n            slices.each(function(pt) {\n                if(pt.hidden) {\n                    d3.select(this).selectAll('path,g').remove();\n                    return;\n                }\n\n                quadrants[pt.pxmid[1] < 0 ? 0 : 1][pt.pxmid[0] < 0 ? 0 : 1].push(pt);\n\n                var cx = cd0.cx + depthVector[0],\n                    cy = cd0.cy + depthVector[1],\n                    sliceTop = d3.select(this),\n                    slicePath = sliceTop.selectAll('path.surface').data([pt]),\n                    hasHoverData = false;\n\n                function handleMouseOver(evt) {\n                    evt.originalEvent = d3.event;\n\n                    // in case fullLayout or fullData has changed without a replot\n                    var fullLayout2 = gd._fullLayout,\n                        trace2 = gd._fullData[trace.index],\n                        hoverinfo = trace2.hoverinfo;\n\n                    if(hoverinfo === 'all') hoverinfo = 'label+text+value+percent+name';\n\n                    // in case we dragged over the pie from another subplot,\n                    // or if hover is turned off\n                    if(gd._dragging || fullLayout2.hovermode === false ||\n                            hoverinfo === 'none' || hoverinfo === 'skip' || !hoverinfo) {\n                        Fx.hover(gd, evt, 'pie');\n                        return;\n                    }\n\n                    var rInscribed = getInscribedRadiusFraction(pt, cd0),\n                        hoverCenterX = cx + pt.pxmid[0] * (1 - rInscribed),\n                        hoverCenterY = cy + pt.pxmid[1] * (1 - rInscribed),\n                        separators = fullLayout.separators,\n                        thisText = [];\n\n                    if(hoverinfo.indexOf('label') !== -1) thisText.push(pt.label);\n                    if(hoverinfo.indexOf('text') !== -1) {\n                        if(trace2.hovertext) {\n                            thisText.push(\n                                Array.isArray(trace2.hovertext) ?\n                                    trace2.hovertext[pt.i] :\n                                    trace2.hovertext\n                            );\n                        } else if(trace2.text && trace2.text[pt.i]) {\n                            thisText.push(trace2.text[pt.i]);\n                        }\n                    }\n                    if(hoverinfo.indexOf('value') !== -1) thisText.push(helpers.formatPieValue(pt.v, separators));\n                    if(hoverinfo.indexOf('percent') !== -1) thisText.push(helpers.formatPiePercent(pt.v / cd0.vTotal, separators));\n\n                    Fx.loneHover({\n                        x0: hoverCenterX - rInscribed * cd0.r,\n                        x1: hoverCenterX + rInscribed * cd0.r,\n                        y: hoverCenterY,\n                        text: thisText.join('<br>'),\n                        name: hoverinfo.indexOf('name') !== -1 ? trace2.name : undefined,\n                        color: pt.color,\n                        idealAlign: pt.pxmid[0] < 0 ? 'left' : 'right'\n                    }, {\n                        container: fullLayout2._hoverlayer.node(),\n                        outerContainer: fullLayout2._paper.node()\n                    });\n\n                    Fx.hover(gd, evt, 'pie');\n\n                    hasHoverData = true;\n                }\n\n                function handleMouseOut(evt) {\n                    evt.originalEvent = d3.event;\n                    gd.emit('plotly_unhover', {\n                        event: d3.event,\n                        points: [evt]\n                    });\n\n                    if(hasHoverData) {\n                        Fx.loneUnhover(fullLayout._hoverlayer.node());\n                        hasHoverData = false;\n                    }\n                }\n\n                function handleClick() {\n                    gd._hoverdata = [pt];\n                    gd._hoverdata.trace = cd0.trace;\n                    Fx.click(gd, d3.event);\n                }\n\n                slicePath.enter().append('path')\n                    .classed('surface', true)\n                    .style({'pointer-events': 'all'});\n\n                sliceTop.select('path.textline').remove();\n\n                sliceTop\n                    .on('mouseover', handleMouseOver)\n                    .on('mouseout', handleMouseOut)\n                    .on('click', handleClick);\n\n                if(trace.pull) {\n                    var pull = +(Array.isArray(trace.pull) ? trace.pull[pt.i] : trace.pull) || 0;\n                    if(pull > 0) {\n                        cx += pull * pt.pxmid[0];\n                        cy += pull * pt.pxmid[1];\n                    }\n                }\n\n                pt.cxFinal = cx;\n                pt.cyFinal = cy;\n\n                function arc(start, finish, cw, scale) {\n                    return 'a' + (scale * cd0.r) + ',' + (scale * rSmall) + ' ' + tiltAxis + ' ' +\n                        pt.largeArc + (cw ? ' 1 ' : ' 0 ') +\n                        (scale * (finish[0] - start[0])) + ',' + (scale * (finish[1] - start[1]));\n                }\n\n                var hole = trace.hole;\n                if(pt.v === cd0.vTotal) { // 100% fails bcs arc start and end are identical\n                    var outerCircle = 'M' + (cx + pt.px0[0]) + ',' + (cy + pt.px0[1]) +\n                        arc(pt.px0, pt.pxmid, true, 1) +\n                        arc(pt.pxmid, pt.px0, true, 1) + 'Z';\n                    if(hole) {\n                        slicePath.attr('d',\n                            'M' + (cx + hole * pt.px0[0]) + ',' + (cy + hole * pt.px0[1]) +\n                            arc(pt.px0, pt.pxmid, false, hole) +\n                            arc(pt.pxmid, pt.px0, false, hole) +\n                            'Z' + outerCircle);\n                    }\n                    else slicePath.attr('d', outerCircle);\n                } else {\n\n                    var outerArc = arc(pt.px0, pt.px1, true, 1);\n\n                    if(hole) {\n                        var rim = 1 - hole;\n                        slicePath.attr('d',\n                            'M' + (cx + hole * pt.px1[0]) + ',' + (cy + hole * pt.px1[1]) +\n                            arc(pt.px1, pt.px0, false, hole) +\n                            'l' + (rim * pt.px0[0]) + ',' + (rim * pt.px0[1]) +\n                            outerArc +\n                            'Z');\n                    } else {\n                        slicePath.attr('d',\n                            'M' + cx + ',' + cy +\n                            'l' + pt.px0[0] + ',' + pt.px0[1] +\n                            outerArc +\n                            'Z');\n                    }\n                }\n\n                // add text\n                var textPosition = Array.isArray(trace.textposition) ?\n                        trace.textposition[pt.i] : trace.textposition,\n                    sliceTextGroup = sliceTop.selectAll('g.slicetext')\n                    .data(pt.text && (textPosition !== 'none') ? [0] : []);\n\n                sliceTextGroup.enter().append('g')\n                    .classed('slicetext', true);\n                sliceTextGroup.exit().remove();\n\n                sliceTextGroup.each(function() {\n                    var sliceText = d3.select(this).selectAll('text').data([0]);\n\n                    sliceText.enter().append('text')\n                        // prohibit tex interpretation until we can handle\n                        // tex and regular text together\n                        .attr('data-notex', 1);\n                    sliceText.exit().remove();\n\n                    sliceText.text(pt.text)\n                        .attr({\n                            'class': 'slicetext',\n                            transform: '',\n                            'data-bb': '',\n                            'text-anchor': 'middle',\n                            x: 0,\n                            y: 0\n                        })\n                        .call(Drawing.font, textPosition === 'outside' ?\n                            trace.outsidetextfont : trace.insidetextfont)\n                        .call(svgTextUtils.convertToTspans);\n                    sliceText.selectAll('tspan.line').attr({x: 0, y: 0});\n\n                    // position the text relative to the slice\n                    // TODO: so far this only accounts for flat\n                    var textBB = Drawing.bBox(sliceText.node()),\n                        transform;\n\n                    if(textPosition === 'outside') {\n                        transform = transformOutsideText(textBB, pt);\n                    } else {\n                        transform = transformInsideText(textBB, pt, cd0);\n                        if(textPosition === 'auto' && transform.scale < 1) {\n                            sliceText.call(Drawing.font, trace.outsidetextfont);\n                            if(trace.outsidetextfont.family !== trace.insidetextfont.family ||\n                                    trace.outsidetextfont.size !== trace.insidetextfont.size) {\n                                sliceText.attr({'data-bb': ''});\n                                textBB = Drawing.bBox(sliceText.node());\n                            }\n                            transform = transformOutsideText(textBB, pt);\n                        }\n                    }\n\n                    var translateX = cx + pt.pxmid[0] * transform.rCenter + (transform.x || 0),\n                        translateY = cy + pt.pxmid[1] * transform.rCenter + (transform.y || 0);\n\n                    // save some stuff to use later ensure no labels overlap\n                    if(transform.outside) {\n                        pt.yLabelMin = translateY - textBB.height / 2;\n                        pt.yLabelMid = translateY;\n                        pt.yLabelMax = translateY + textBB.height / 2;\n                        pt.labelExtraX = 0;\n                        pt.labelExtraY = 0;\n                        hasOutsideText = true;\n                    }\n\n                    sliceText.attr('transform',\n                        'translate(' + translateX + ',' + translateY + ')' +\n                        (transform.scale < 1 ? ('scale(' + transform.scale + ')') : '') +\n                        (transform.rotate ? ('rotate(' + transform.rotate + ')') : '') +\n                        'translate(' +\n                            (-(textBB.left + textBB.right) / 2) + ',' +\n                            (-(textBB.top + textBB.bottom) / 2) +\n                        ')');\n                });\n            });\n\n            // now make sure no labels overlap (at least within one pie)\n            if(hasOutsideText) scootLabels(quadrants, trace);\n            slices.each(function(pt) {\n                if(pt.labelExtraX || pt.labelExtraY) {\n                    // first move the text to its new location\n                    var sliceTop = d3.select(this),\n                        sliceText = sliceTop.select('g.slicetext text');\n\n                    sliceText.attr('transform', 'translate(' + pt.labelExtraX + ',' + pt.labelExtraY + ')' +\n                        sliceText.attr('transform'));\n\n                    // then add a line to the new location\n                    var lineStartX = pt.cxFinal + pt.pxmid[0],\n                        lineStartY = pt.cyFinal + pt.pxmid[1],\n                        textLinePath = 'M' + lineStartX + ',' + lineStartY,\n                        finalX = (pt.yLabelMax - pt.yLabelMin) * (pt.pxmid[0] < 0 ? -1 : 1) / 4;\n                    if(pt.labelExtraX) {\n                        var yFromX = pt.labelExtraX * pt.pxmid[1] / pt.pxmid[0],\n                            yNet = pt.yLabelMid + pt.labelExtraY - (pt.cyFinal + pt.pxmid[1]);\n\n                        if(Math.abs(yFromX) > Math.abs(yNet)) {\n                            textLinePath +=\n                                'l' + (yNet * pt.pxmid[0] / pt.pxmid[1]) + ',' + yNet +\n                                'H' + (lineStartX + pt.labelExtraX + finalX);\n                        } else {\n                            textLinePath += 'l' + pt.labelExtraX + ',' + yFromX +\n                                'v' + (yNet - yFromX) +\n                                'h' + finalX;\n                        }\n                    } else {\n                        textLinePath +=\n                            'V' + (pt.yLabelMid + pt.labelExtraY) +\n                            'h' + finalX;\n                    }\n\n                    sliceTop.append('path')\n                        .classed('textline', true)\n                        .call(Color.stroke, trace.outsidetextfont.color)\n                        .attr({\n                            'stroke-width': Math.min(2, trace.outsidetextfont.size / 8),\n                            d: textLinePath,\n                            fill: 'none'\n                        });\n                }\n            });\n        });\n    });\n\n    // This is for a bug in Chrome (as of 2015-07-22, and does not affect FF)\n    // if insidetextfont and outsidetextfont are different sizes, sometimes the size\n    // of an \"em\" gets taken from the wrong element at first so lines are\n    // spaced wrong. You just have to tell it to try again later and it gets fixed.\n    // I have no idea why we haven't seen this in other contexts. Also, sometimes\n    // it gets the initial draw correct but on redraw it gets confused.\n    setTimeout(function() {\n        pieGroups.selectAll('tspan').each(function() {\n            var s = d3.select(this);\n            if(s.attr('dy')) s.attr('dy', s.attr('dy'));\n        });\n    }, 0);\n};\n\n\nfunction transformInsideText(textBB, pt, cd0) {\n    var textDiameter = Math.sqrt(textBB.width * textBB.width + textBB.height * textBB.height),\n        textAspect = textBB.width / textBB.height,\n        halfAngle = Math.PI * Math.min(pt.v / cd0.vTotal, 0.5),\n        ring = 1 - cd0.trace.hole,\n        rInscribed = getInscribedRadiusFraction(pt, cd0),\n\n        // max size text can be inserted inside without rotating it\n        // this inscribes the text rectangle in a circle, which is then inscribed\n        // in the slice, so it will be an underestimate, which some day we may want\n        // to improve so this case can get more use\n        transform = {\n            scale: rInscribed * cd0.r * 2 / textDiameter,\n\n            // and the center position and rotation in this case\n            rCenter: 1 - rInscribed,\n            rotate: 0\n        };\n\n    if(transform.scale >= 1) return transform;\n\n        // max size if text is rotated radially\n    var Qr = textAspect + 1 / (2 * Math.tan(halfAngle)),\n        maxHalfHeightRotRadial = cd0.r * Math.min(\n            1 / (Math.sqrt(Qr * Qr + 0.5) + Qr),\n            ring / (Math.sqrt(textAspect * textAspect + ring / 2) + textAspect)\n        ),\n        radialTransform = {\n            scale: maxHalfHeightRotRadial * 2 / textBB.height,\n            rCenter: Math.cos(maxHalfHeightRotRadial / cd0.r) -\n                maxHalfHeightRotRadial * textAspect / cd0.r,\n            rotate: (180 / Math.PI * pt.midangle + 720) % 180 - 90\n        },\n\n        // max size if text is rotated tangentially\n        aspectInv = 1 / textAspect,\n        Qt = aspectInv + 1 / (2 * Math.tan(halfAngle)),\n        maxHalfWidthTangential = cd0.r * Math.min(\n            1 / (Math.sqrt(Qt * Qt + 0.5) + Qt),\n            ring / (Math.sqrt(aspectInv * aspectInv + ring / 2) + aspectInv)\n        ),\n        tangentialTransform = {\n            scale: maxHalfWidthTangential * 2 / textBB.width,\n            rCenter: Math.cos(maxHalfWidthTangential / cd0.r) -\n                maxHalfWidthTangential / textAspect / cd0.r,\n            rotate: (180 / Math.PI * pt.midangle + 810) % 180 - 90\n        },\n        // if we need a rotated transform, pick the biggest one\n        // even if both are bigger than 1\n        rotatedTransform = tangentialTransform.scale > radialTransform.scale ?\n            tangentialTransform : radialTransform;\n\n    if(transform.scale < 1 && rotatedTransform.scale > transform.scale) return rotatedTransform;\n    return transform;\n}\n\nfunction getInscribedRadiusFraction(pt, cd0) {\n    if(pt.v === cd0.vTotal && !cd0.trace.hole) return 1;// special case of 100% with no hole\n\n    var halfAngle = Math.PI * Math.min(pt.v / cd0.vTotal, 0.5);\n    return Math.min(1 / (1 + 1 / Math.sin(halfAngle)), (1 - cd0.trace.hole) / 2);\n}\n\nfunction transformOutsideText(textBB, pt) {\n    var x = pt.pxmid[0],\n        y = pt.pxmid[1],\n        dx = textBB.width / 2,\n        dy = textBB.height / 2;\n\n    if(x < 0) dx *= -1;\n    if(y < 0) dy *= -1;\n\n    return {\n        scale: 1,\n        rCenter: 1,\n        rotate: 0,\n        x: dx + Math.abs(dy) * (dx > 0 ? 1 : -1) / 2,\n        y: dy / (1 + x * x / (y * y)),\n        outside: true\n    };\n}\n\nfunction scootLabels(quadrants, trace) {\n    var xHalf,\n        yHalf,\n        equatorFirst,\n        farthestX,\n        farthestY,\n        xDiffSign,\n        yDiffSign,\n        thisQuad,\n        oppositeQuad,\n        wholeSide,\n        i,\n        thisQuadOutside,\n        firstOppositeOutsidePt;\n\n    function topFirst(a, b) { return a.pxmid[1] - b.pxmid[1]; }\n    function bottomFirst(a, b) { return b.pxmid[1] - a.pxmid[1]; }\n\n    function scootOneLabel(thisPt, prevPt) {\n        if(!prevPt) prevPt = {};\n\n        var prevOuterY = prevPt.labelExtraY + (yHalf ? prevPt.yLabelMax : prevPt.yLabelMin),\n            thisInnerY = yHalf ? thisPt.yLabelMin : thisPt.yLabelMax,\n            thisOuterY = yHalf ? thisPt.yLabelMax : thisPt.yLabelMin,\n            thisSliceOuterY = thisPt.cyFinal + farthestY(thisPt.px0[1], thisPt.px1[1]),\n            newExtraY = prevOuterY - thisInnerY,\n            xBuffer,\n            i,\n            otherPt,\n            otherOuterY,\n            otherOuterX,\n            newExtraX;\n        // make sure this label doesn't overlap other labels\n        // this *only* has us move these labels vertically\n        if(newExtraY * yDiffSign > 0) thisPt.labelExtraY = newExtraY;\n\n        // make sure this label doesn't overlap any slices\n        if(!Array.isArray(trace.pull)) return; // this can only happen with array pulls\n\n        for(i = 0; i < wholeSide.length; i++) {\n            otherPt = wholeSide[i];\n\n            // overlap can only happen if the other point is pulled more than this one\n            if(otherPt === thisPt || ((trace.pull[thisPt.i] || 0) >= trace.pull[otherPt.i] || 0)) continue;\n\n            if((thisPt.pxmid[1] - otherPt.pxmid[1]) * yDiffSign > 0) {\n                // closer to the equator - by construction all of these happen first\n                // move the text vertically to get away from these slices\n                otherOuterY = otherPt.cyFinal + farthestY(otherPt.px0[1], otherPt.px1[1]);\n                newExtraY = otherOuterY - thisInnerY - thisPt.labelExtraY;\n\n                if(newExtraY * yDiffSign > 0) thisPt.labelExtraY += newExtraY;\n\n            } else if((thisOuterY + thisPt.labelExtraY - thisSliceOuterY) * yDiffSign > 0) {\n                // farther from the equator - happens after we've done all the\n                // vertical moving we're going to do\n                // move horizontally to get away from these more polar slices\n\n                // if we're moving horz. based on a slice that's several slices away from this one\n                // then we need some extra space for the lines to labels between them\n                xBuffer = 3 * xDiffSign * Math.abs(i - wholeSide.indexOf(thisPt));\n\n                otherOuterX = otherPt.cxFinal + farthestX(otherPt.px0[0], otherPt.px1[0]);\n                newExtraX = otherOuterX + xBuffer - (thisPt.cxFinal + thisPt.pxmid[0]) - thisPt.labelExtraX;\n\n                if(newExtraX * xDiffSign > 0) thisPt.labelExtraX += newExtraX;\n            }\n        }\n    }\n\n    for(yHalf = 0; yHalf < 2; yHalf++) {\n        equatorFirst = yHalf ? topFirst : bottomFirst;\n        farthestY = yHalf ? Math.max : Math.min;\n        yDiffSign = yHalf ? 1 : -1;\n\n        for(xHalf = 0; xHalf < 2; xHalf++) {\n            farthestX = xHalf ? Math.max : Math.min;\n            xDiffSign = xHalf ? 1 : -1;\n\n            // first sort the array\n            // note this is a copy of cd, so cd itself doesn't get sorted\n            // but we can still modify points in place.\n            thisQuad = quadrants[yHalf][xHalf];\n            thisQuad.sort(equatorFirst);\n\n            oppositeQuad = quadrants[1 - yHalf][xHalf];\n            wholeSide = oppositeQuad.concat(thisQuad);\n\n            thisQuadOutside = [];\n            for(i = 0; i < thisQuad.length; i++) {\n                if(thisQuad[i].yLabelMid !== undefined) thisQuadOutside.push(thisQuad[i]);\n            }\n\n            firstOppositeOutsidePt = false;\n            for(i = 0; yHalf && i < oppositeQuad.length; i++) {\n                if(oppositeQuad[i].yLabelMid !== undefined) {\n                    firstOppositeOutsidePt = oppositeQuad[i];\n                    break;\n                }\n            }\n\n            // each needs to avoid the previous\n            for(i = 0; i < thisQuadOutside.length; i++) {\n                var prevPt = i && thisQuadOutside[i - 1];\n                // bottom half needs to avoid the first label of the top half\n                // top half we still need to call scootOneLabel on the first slice\n                // so we can avoid other slices, but we don't pass a prevPt\n                if(firstOppositeOutsidePt && !i) prevPt = firstOppositeOutsidePt;\n                scootOneLabel(thisQuadOutside[i], prevPt);\n            }\n        }\n    }\n}\n\nfunction scalePies(cdpie, plotSize) {\n    var pieBoxWidth,\n        pieBoxHeight,\n        i,\n        j,\n        cd0,\n        trace,\n        tiltAxisRads,\n        maxPull,\n        scaleGroups = [],\n        scaleGroup,\n        minPxPerValUnit;\n\n    // first figure out the center and maximum radius for each pie\n    for(i = 0; i < cdpie.length; i++) {\n        cd0 = cdpie[i][0];\n        trace = cd0.trace;\n        pieBoxWidth = plotSize.w * (trace.domain.x[1] - trace.domain.x[0]);\n        pieBoxHeight = plotSize.h * (trace.domain.y[1] - trace.domain.y[0]);\n        tiltAxisRads = trace.tiltaxis * Math.PI / 180;\n\n        maxPull = trace.pull;\n        if(Array.isArray(maxPull)) {\n            maxPull = 0;\n            for(j = 0; j < trace.pull.length; j++) {\n                if(trace.pull[j] > maxPull) maxPull = trace.pull[j];\n            }\n        }\n\n        cd0.r = Math.min(\n                pieBoxWidth / maxExtent(trace.tilt, Math.sin(tiltAxisRads), trace.depth),\n                pieBoxHeight / maxExtent(trace.tilt, Math.cos(tiltAxisRads), trace.depth)\n            ) / (2 + 2 * maxPull);\n\n        cd0.cx = plotSize.l + plotSize.w * (trace.domain.x[1] + trace.domain.x[0]) / 2;\n        cd0.cy = plotSize.t + plotSize.h * (2 - trace.domain.y[1] - trace.domain.y[0]) / 2;\n\n        if(trace.scalegroup && scaleGroups.indexOf(trace.scalegroup) === -1) {\n            scaleGroups.push(trace.scalegroup);\n        }\n    }\n\n    // Then scale any pies that are grouped\n    for(j = 0; j < scaleGroups.length; j++) {\n        minPxPerValUnit = Infinity;\n        scaleGroup = scaleGroups[j];\n\n        for(i = 0; i < cdpie.length; i++) {\n            cd0 = cdpie[i][0];\n            if(cd0.trace.scalegroup === scaleGroup) {\n                minPxPerValUnit = Math.min(minPxPerValUnit,\n                    cd0.r * cd0.r / cd0.vTotal);\n            }\n        }\n\n        for(i = 0; i < cdpie.length; i++) {\n            cd0 = cdpie[i][0];\n            if(cd0.trace.scalegroup === scaleGroup) {\n                cd0.r = Math.sqrt(minPxPerValUnit * cd0.vTotal);\n            }\n        }\n    }\n\n}\n\nfunction setCoords(cd) {\n    var cd0 = cd[0],\n        trace = cd0.trace,\n        tilt = trace.tilt,\n        tiltAxisRads,\n        tiltAxisSin,\n        tiltAxisCos,\n        tiltRads,\n        crossTilt,\n        inPlane,\n        currentAngle = trace.rotation * Math.PI / 180,\n        angleFactor = 2 * Math.PI / cd0.vTotal,\n        firstPt = 'px0',\n        lastPt = 'px1',\n        i,\n        cdi,\n        currentCoords;\n\n    if(trace.direction === 'counterclockwise') {\n        for(i = 0; i < cd.length; i++) {\n            if(!cd[i].hidden) break; // find the first non-hidden slice\n        }\n        if(i === cd.length) return; // all slices hidden\n\n        currentAngle += angleFactor * cd[i].v;\n        angleFactor *= -1;\n        firstPt = 'px1';\n        lastPt = 'px0';\n    }\n\n    if(tilt) {\n        tiltRads = tilt * Math.PI / 180;\n        tiltAxisRads = trace.tiltaxis * Math.PI / 180;\n        crossTilt = Math.sin(tiltAxisRads) * Math.cos(tiltAxisRads);\n        inPlane = 1 - Math.cos(tiltRads);\n        tiltAxisSin = Math.sin(tiltAxisRads);\n        tiltAxisCos = Math.cos(tiltAxisRads);\n    }\n\n    function getCoords(angle) {\n        var xFlat = cd0.r * Math.sin(angle),\n            yFlat = -cd0.r * Math.cos(angle);\n\n        if(!tilt) return [xFlat, yFlat];\n\n        return [\n            xFlat * (1 - inPlane * tiltAxisSin * tiltAxisSin) + yFlat * crossTilt * inPlane,\n            xFlat * crossTilt * inPlane + yFlat * (1 - inPlane * tiltAxisCos * tiltAxisCos),\n            Math.sin(tiltRads) * (yFlat * tiltAxisCos - xFlat * tiltAxisSin)\n        ];\n    }\n\n    currentCoords = getCoords(currentAngle);\n\n    for(i = 0; i < cd.length; i++) {\n        cdi = cd[i];\n        if(cdi.hidden) continue;\n\n        cdi[firstPt] = currentCoords;\n\n        currentAngle += angleFactor * cdi.v / 2;\n        cdi.pxmid = getCoords(currentAngle);\n        cdi.midangle = currentAngle;\n\n        currentAngle += angleFactor * cdi.v / 2;\n        currentCoords = getCoords(currentAngle);\n\n        cdi[lastPt] = currentCoords;\n\n        cdi.largeArc = (cdi.v > cd0.vTotal / 2) ? 1 : 0;\n    }\n}\n\nfunction maxExtent(tilt, tiltAxisFraction, depth) {\n    if(!tilt) return 1;\n    var sinTilt = Math.sin(tilt * Math.PI / 180);\n    return Math.max(0.01, // don't let it go crazy if you tilt the pie totally on its side\n        depth * sinTilt * Math.abs(tiltAxisFraction) +\n        2 * Math.sqrt(1 - sinTilt * sinTilt * tiltAxisFraction * tiltAxisFraction));\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/pie/style.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\n\nvar styleOne = require('./style_one');\n\nmodule.exports = function style(gd) {\n    gd._fullLayout._pielayer.selectAll('.trace').each(function(cd) {\n        var cd0 = cd[0],\n            trace = cd0.trace,\n            traceSelection = d3.select(this);\n\n        traceSelection.style({opacity: trace.opacity});\n\n        traceSelection.selectAll('.top path.surface').each(function(pt) {\n            d3.select(this).call(styleOne, pt, trace);\n        });\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/pie/style_one.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Color = require('../../components/color');\n\nmodule.exports = function styleOne(s, pt, trace) {\n    var lineColor = trace.marker.line.color;\n    if(Array.isArray(lineColor)) lineColor = lineColor[pt.i] || Color.defaultLine;\n\n    var lineWidth = trace.marker.line.width || 0;\n    if(Array.isArray(lineWidth)) lineWidth = lineWidth[pt.i] || 0;\n\n    s.style({'stroke-width': lineWidth})\n    .call(Color.fill, pt.color)\n    .call(Color.stroke, lineColor);\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/pie/base_plot.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Registry = require('../../registry');\n\n\nexports.name = 'pie';\n\nexports.plot = function(gd) {\n    var Pie = Registry.getModule('pie');\n    var cdPie = getCdModule(gd.calcdata, Pie);\n\n    if(cdPie.length) Pie.plot(gd, cdPie);\n};\n\nexports.clean = function(newFullData, newFullLayout, oldFullData, oldFullLayout) {\n    var hadPie = (oldFullLayout._has && oldFullLayout._has('pie'));\n    var hasPie = (newFullLayout._has && newFullLayout._has('pie'));\n\n    if(hadPie && !hasPie) {\n        oldFullLayout._pielayer.selectAll('g.trace').remove();\n    }\n};\n\nfunction getCdModule(calcdata, _module) {\n    var cdModule = [];\n\n    for(var i = 0; i < calcdata.length; i++) {\n        var cd = calcdata[i];\n        var trace = cd[0].trace;\n\n        if((trace._module === _module) && (trace.visible === true)) {\n            cdModule.push(cd);\n        }\n    }\n\n    return cdModule;\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/lib/pointcloud.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = require('../src/traces/pointcloud');\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/pointcloud/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar pointcloud = {};\n\npointcloud.attributes = require('./attributes');\npointcloud.supplyDefaults = require('./defaults');\n\n// reuse the Scatter3D 'dummy' calc step so that legends know what to do\npointcloud.calc = require('../scatter3d/calc');\npointcloud.plot = require('./convert');\n\npointcloud.moduleType = 'trace';\npointcloud.name = 'pointcloud';\npointcloud.basePlotModule = require('../../plots/gl2d');\npointcloud.categories = ['gl2d', 'showLegend'];\npointcloud.meta = {\n    description: [\n        'The data visualized as a point cloud set in `x` and `y`',\n        'using the WebGl plotting engine.'\n    ].join(' ')\n};\n\nmodule.exports = pointcloud;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/pointcloud/attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar scatterglAttrs = require('../scattergl/attributes');\n\nmodule.exports = {\n    x: scatterglAttrs.x,\n    y: scatterglAttrs.y,\n    xy: {\n        valType: 'data_array',\n        description: [\n            'Faster alternative to specifying `x` and `y` separately.',\n            'If supplied, it must be a typed `Float32Array` array that',\n            'represents points such that `xy[i * 2] = x[i]` and `xy[i * 2 + 1] = y[i]`'\n        ].join(' ')\n    },\n    indices: {\n        valType: 'data_array',\n        description: [\n            'A sequential value, 0..n, supply it to avoid creating this array inside plotting.',\n            'If specified, it must be a typed `Int32Array` array.',\n            'Its length must be equal to or greater than the number of points.',\n            'For the best performance and memory use, create one large `indices` typed array',\n            'that is guaranteed to be at least as long as the largest number of points during',\n            'use, and reuse it on each `Plotly.restyle()` call.'\n        ].join(' ')\n    },\n    xbounds: {\n        valType: 'data_array',\n        description: [\n            'Specify `xbounds` in the shape of `[xMin, xMax] to avoid looping through',\n            'the `xy` typed array. Use it in conjunction with `xy` and `ybounds` for the performance benefits.'\n        ].join(' ')\n    },\n    ybounds: {\n        valType: 'data_array',\n        description: [\n            'Specify `ybounds` in the shape of `[yMin, yMax] to avoid looping through',\n            'the `xy` typed array. Use it in conjunction with `xy` and `xbounds` for the performance benefits.'\n        ].join(' ')\n    },\n    text: scatterglAttrs.text,\n    marker: {\n        color: {\n            valType: 'color',\n            arrayOk: false,\n            role: 'style',\n            description: [\n                'Sets the marker fill color. It accepts a specific color.',\n                'If the color is not fully opaque and there are hundreds of thousands',\n                'of points, it may cause slower zooming and panning.'\n            ].join('')\n        },\n        opacity: {\n            valType: 'number',\n            min: 0,\n            max: 1,\n            dflt: 1,\n            arrayOk: false,\n            role: 'style',\n            description: [\n                'Sets the marker opacity. The default value is `1` (fully opaque).',\n                'If the markers are not fully opaque and there are hundreds of thousands',\n                'of points, it may cause slower zooming and panning.',\n                'Opacity fades the color even if `blend` is left on `false` even if there',\n                'is no translucency effect in that case.'\n            ].join(' ')\n        },\n        blend: {\n            valType: 'boolean',\n            dflt: null,\n            role: 'style',\n            description: [\n                'Determines if colors are blended together for a translucency effect',\n                'in case `opacity` is specified as a value less then `1`.',\n                'Setting `blend` to `true` reduces zoom/pan',\n                'speed if used with large numbers of points.'\n            ].join(' ')\n        },\n        sizemin: {\n            valType: 'number',\n            min: 0.1,\n            max: 2,\n            dflt: 0.5,\n            role: 'style',\n            description: [\n                'Sets the minimum size (in px) of the rendered marker points, effective when',\n                'the `pointcloud` shows a million or more points.'\n            ].join(' ')\n        },\n        sizemax: {\n            valType: 'number',\n            min: 0.1,\n            dflt: 20,\n            role: 'style',\n            description: [\n                'Sets the maximum size (in px) of the rendered marker points.',\n                'Effective when the `pointcloud` shows only few points.'\n            ].join(' ')\n        },\n        border: {\n            color: {\n                valType: 'color',\n                arrayOk: false,\n                role: 'style',\n                description: [\n                    'Sets the stroke color. It accepts a specific color.',\n                    'If the color is not fully opaque and there are hundreds of thousands',\n                    'of points, it may cause slower zooming and panning.'\n                ].join(' ')\n            },\n            arearatio: {\n                valType: 'number',\n                min: 0,\n                max: 1,\n                dflt: 0,\n                role: 'style',\n                description: [\n                    'Specifies what fraction of the marker area is covered with the',\n                    'border.'\n                ].join(' ')\n            }\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/scattergl/attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar scatterAttrs = require('../scatter/attributes');\nvar colorAttributes = require('../../components/colorscale/color_attributes');\n\nvar DASHES = require('../../constants/gl2d_dashes');\nvar MARKERS = require('../../constants/gl_markers');\nvar extendFlat = require('../../lib/extend').extendFlat;\nvar extendDeep = require('../../lib/extend').extendDeep;\n\nvar scatterLineAttrs = scatterAttrs.line,\n    scatterMarkerAttrs = scatterAttrs.marker,\n    scatterMarkerLineAttrs = scatterMarkerAttrs.line;\n\nmodule.exports = {\n    x: scatterAttrs.x,\n    x0: scatterAttrs.x0,\n    dx: scatterAttrs.dx,\n    y: scatterAttrs.y,\n    y0: scatterAttrs.y0,\n    dy: scatterAttrs.dy,\n\n    text: extendFlat({}, scatterAttrs.text, {\n        description: [\n            'Sets text elements associated with each (x,y) pair to appear on hover.',\n            'If a single string, the same string appears over',\n            'all the data points.',\n            'If an array of string, the items are mapped in order to the',\n            'this trace\\'s (x,y) coordinates.'\n        ].join(' ')\n    }),\n    mode: {\n        valType: 'flaglist',\n        flags: ['lines', 'markers'],\n        extras: ['none'],\n        role: 'info',\n        description: [\n            'Determines the drawing mode for this scatter trace.'\n        ].join(' ')\n    },\n    line: {\n        color: scatterLineAttrs.color,\n        width: scatterLineAttrs.width,\n        dash: {\n            valType: 'enumerated',\n            values: Object.keys(DASHES),\n            dflt: 'solid',\n            role: 'style',\n            description: 'Sets the style of the lines.'\n        }\n    },\n    marker: extendDeep({}, colorAttributes('marker'), {\n        symbol: {\n            valType: 'enumerated',\n            values: Object.keys(MARKERS),\n            dflt: 'circle',\n            arrayOk: true,\n            role: 'style',\n            description: 'Sets the marker symbol type.'\n        },\n        size: scatterMarkerAttrs.size,\n        sizeref: scatterMarkerAttrs.sizeref,\n        sizemin: scatterMarkerAttrs.sizemin,\n        sizemode: scatterMarkerAttrs.sizemode,\n        opacity: scatterMarkerAttrs.opacity,\n        showscale: scatterMarkerAttrs.showscale,\n        colorbar: scatterMarkerAttrs.colorbar,\n        line: extendDeep({}, colorAttributes('marker.line'), {\n            width: scatterMarkerLineAttrs.width\n        })\n    }),\n    connectgaps: scatterAttrs.connectgaps,\n    fill: extendFlat({}, scatterAttrs.fill, {\n        values: ['none', 'tozeroy', 'tozerox']\n    }),\n    fillcolor: scatterAttrs.fillcolor,\n\n    error_y: scatterAttrs.error_y,\n    error_x: scatterAttrs.error_x\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/lib/scatter3d.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = require('../src/traces/scatter3d');\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/scatter3d/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Scatter3D = {};\n\nScatter3D.plot = require('./convert');\nScatter3D.attributes = require('./attributes');\nScatter3D.markerSymbols = require('../../constants/gl_markers');\nScatter3D.supplyDefaults = require('./defaults');\nScatter3D.colorbar = require('../scatter/colorbar');\nScatter3D.calc = require('./calc');\n\nScatter3D.moduleType = 'trace';\nScatter3D.name = 'scatter3d';\nScatter3D.basePlotModule = require('../../plots/gl3d');\nScatter3D.categories = ['gl3d', 'symbols', 'markerColorscale', 'showLegend'];\nScatter3D.meta = {\n    hrName: 'scatter_3d',\n    description: [\n        'The data visualized as scatter point or lines in 3D dimension',\n        'is set in `x`, `y`, `z`.',\n        'Text (appearing either on the chart or on hover only) is via `text`.',\n        'Bubble charts are achieved by setting `marker.size` and/or `marker.color`',\n        'Projections are achieved via `projection`.',\n        'Surface fills are achieved via `surfaceaxis`.'\n    ].join(' ')\n};\n\nmodule.exports = Scatter3D;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/scatter3d/convert.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar createLinePlot = require('gl-line3d');\nvar createScatterPlot = require('gl-scatter3d');\nvar createErrorBars = require('gl-error3d');\nvar createMesh = require('gl-mesh3d');\nvar triangulate = require('delaunay-triangulate');\n\nvar Lib = require('../../lib');\nvar str2RgbaArray = require('../../lib/str2rgbarray');\nvar formatColor = require('../../lib/gl_format_color');\nvar makeBubbleSizeFn = require('../scatter/make_bubble_size_func');\nvar DASH_PATTERNS = require('../../constants/gl3d_dashes');\nvar MARKER_SYMBOLS = require('../../constants/gl_markers');\n\nvar calculateError = require('./calc_errors');\n\nfunction LineWithMarkers(scene, uid) {\n    this.scene = scene;\n    this.uid = uid;\n    this.linePlot = null;\n    this.scatterPlot = null;\n    this.errorBars = null;\n    this.textMarkers = null;\n    this.delaunayMesh = null;\n    this.color = null;\n    this.mode = '';\n    this.dataPoints = [];\n    this.axesBounds = [\n        [-Infinity, -Infinity, -Infinity],\n        [Infinity, Infinity, Infinity]\n    ];\n    this.textLabels = null;\n    this.data = null;\n}\n\nvar proto = LineWithMarkers.prototype;\n\nproto.handlePick = function(selection) {\n    if(selection.object &&\n        (selection.object === this.linePlot ||\n         selection.object === this.delaunayMesh ||\n         selection.object === this.textMarkers ||\n         selection.object === this.scatterPlot)) {\n        if(selection.object.highlight) {\n            selection.object.highlight(null);\n        }\n        if(this.scatterPlot) {\n            selection.object = this.scatterPlot;\n            this.scatterPlot.highlight(selection.data);\n        }\n        if(this.textLabels) {\n            if(this.textLabels[selection.data.index] !== undefined) {\n                selection.textLabel = this.textLabels[selection.data.index];\n            } else {\n                selection.textLabel = this.textLabels;\n            }\n        }\n        else selection.textLabel = '';\n\n        var selectIndex = selection.data.index;\n        selection.traceCoordinate = [\n            this.data.x[selectIndex],\n            this.data.y[selectIndex],\n            this.data.z[selectIndex]\n        ];\n\n        return true;\n    }\n};\n\nfunction constructDelaunay(points, color, axis) {\n    var u = (axis + 1) % 3;\n    var v = (axis + 2) % 3;\n    var filteredPoints = [];\n    var filteredIds = [];\n    var i;\n\n    for(i = 0; i < points.length; ++i) {\n        var p = points[i];\n        if(isNaN(p[u]) || !isFinite(p[u]) ||\n           isNaN(p[v]) || !isFinite(p[v])) {\n            continue;\n        }\n        filteredPoints.push([p[u], p[v]]);\n        filteredIds.push(i);\n    }\n    var cells = triangulate(filteredPoints);\n    for(i = 0; i < cells.length; ++i) {\n        var c = cells[i];\n        for(var j = 0; j < c.length; ++j) {\n            c[j] = filteredIds[c[j]];\n        }\n    }\n    return {\n        positions: points,\n        cells: cells,\n        meshColor: color\n    };\n}\n\nfunction calculateErrorParams(errors) {\n    var capSize = [0.0, 0.0, 0.0],\n        color = [[0, 0, 0], [0, 0, 0], [0, 0, 0]],\n        lineWidth = [0.0, 0.0, 0.0];\n\n    for(var i = 0; i < 3; i++) {\n        var e = errors[i];\n\n        if(e && e.copy_zstyle !== false) e = errors[2];\n        if(!e) continue;\n\n        capSize[i] = e.width / 2;  // ballpark rescaling\n        color[i] = str2RgbaArray(e.color);\n        lineWidth = e.thickness;\n\n    }\n\n    return {capSize: capSize, color: color, lineWidth: lineWidth};\n}\n\nfunction calculateTextOffset(tp) {\n    // Read out text properties\n    var textOffset = [0, 0];\n    if(Array.isArray(tp)) return [0, -1];\n    if(tp.indexOf('bottom') >= 0) textOffset[1] += 1;\n    if(tp.indexOf('top') >= 0) textOffset[1] -= 1;\n    if(tp.indexOf('left') >= 0) textOffset[0] -= 1;\n    if(tp.indexOf('right') >= 0) textOffset[0] += 1;\n    return textOffset;\n}\n\n\nfunction calculateSize(sizeIn, sizeFn) {\n    // rough parity with Plotly 2D markers\n    return sizeFn(sizeIn * 4);\n}\n\nfunction calculateSymbol(symbolIn) {\n    return MARKER_SYMBOLS[symbolIn];\n}\n\nfunction formatParam(paramIn, len, calculate, dflt, extraFn) {\n    var paramOut = null;\n\n    if(Array.isArray(paramIn)) {\n        paramOut = [];\n\n        for(var i = 0; i < len; i++) {\n            if(paramIn[i] === undefined) paramOut[i] = dflt;\n            else paramOut[i] = calculate(paramIn[i], extraFn);\n        }\n\n    }\n    else paramOut = calculate(paramIn, Lib.identity);\n\n    return paramOut;\n}\n\n\nfunction convertPlotlyOptions(scene, data) {\n    var params, i,\n        points = [],\n        sceneLayout = scene.fullSceneLayout,\n        scaleFactor = scene.dataScale,\n        xaxis = sceneLayout.xaxis,\n        yaxis = sceneLayout.yaxis,\n        zaxis = sceneLayout.zaxis,\n        marker = data.marker,\n        line = data.line,\n        xc, x = data.x || [],\n        yc, y = data.y || [],\n        zc, z = data.z || [],\n        len = x.length,\n        xcalendar = data.xcalendar,\n        ycalendar = data.ycalendar,\n        zcalendar = data.zcalendar,\n        text;\n\n    // Convert points\n    for(i = 0; i < len; i++) {\n        // sanitize numbers and apply transforms based on axes.type\n        xc = xaxis.d2l(x[i], 0, xcalendar) * scaleFactor[0];\n        yc = yaxis.d2l(y[i], 0, ycalendar) * scaleFactor[1];\n        zc = zaxis.d2l(z[i], 0, zcalendar) * scaleFactor[2];\n\n        points[i] = [xc, yc, zc];\n    }\n\n    // convert text\n    if(Array.isArray(data.text)) text = data.text;\n    else if(data.text !== undefined) {\n        text = new Array(len);\n        for(i = 0; i < len; i++) text[i] = data.text;\n    }\n\n    // Build object parameters\n    params = {\n        position: points,\n        mode: data.mode,\n        text: text\n    };\n\n    if('line' in data) {\n        params.lineColor = formatColor(line, 1, len);\n        params.lineWidth = line.width;\n        params.lineDashes = line.dash;\n    }\n\n    if('marker' in data) {\n        var sizeFn = makeBubbleSizeFn(data);\n\n        params.scatterColor = formatColor(marker, 1, len);\n        params.scatterSize = formatParam(marker.size, len, calculateSize, 20, sizeFn);\n        params.scatterMarker = formatParam(marker.symbol, len, calculateSymbol, '');\n        params.scatterLineWidth = marker.line.width;  // arrayOk === false\n        params.scatterLineColor = formatColor(marker.line, 1, len);\n        params.scatterAngle = 0;\n    }\n\n    if('textposition' in data) {\n        params.textOffset = calculateTextOffset(data.textposition);  // arrayOk === false\n        params.textColor = formatColor(data.textfont, 1, len);\n        params.textSize = formatParam(data.textfont.size, len, Lib.identity, 12);\n        params.textFont = data.textfont.family;  // arrayOk === false\n        params.textAngle = 0;\n    }\n\n    var dims = ['x', 'y', 'z'];\n    params.project = [false, false, false];\n    params.projectScale = [1, 1, 1];\n    params.projectOpacity = [1, 1, 1];\n    for(i = 0; i < 3; ++i) {\n        var projection = data.projection[dims[i]];\n        if((params.project[i] = projection.show)) {\n            params.projectOpacity[i] = projection.opacity;\n            params.projectScale[i] = projection.scale;\n        }\n    }\n\n    params.errorBounds = calculateError(data, scaleFactor);\n\n    var errorParams = calculateErrorParams([data.error_x, data.error_y, data.error_z]);\n    params.errorColor = errorParams.color;\n    params.errorLineWidth = errorParams.lineWidth;\n    params.errorCapSize = errorParams.capSize;\n\n    params.delaunayAxis = data.surfaceaxis;\n    params.delaunayColor = str2RgbaArray(data.surfacecolor);\n\n    return params;\n}\n\nfunction arrayToColor(color) {\n    if(Array.isArray(color)) {\n        var c = color[0];\n\n        if(Array.isArray(c)) color = c;\n\n        return 'rgb(' + color.slice(0, 3).map(function(x) {\n            return Math.round(x * 255);\n        }) + ')';\n    }\n\n    return null;\n}\n\nproto.update = function(data) {\n    var gl = this.scene.glplot.gl,\n        lineOptions,\n        scatterOptions,\n        errorOptions,\n        textOptions,\n        dashPattern = DASH_PATTERNS.solid;\n\n    // Save data\n    this.data = data;\n\n    // Run data conversion\n    var options = convertPlotlyOptions(this.scene, data);\n\n    if('mode' in options) {\n        this.mode = options.mode;\n    }\n    if('lineDashes' in options) {\n        if(options.lineDashes in DASH_PATTERNS) {\n            dashPattern = DASH_PATTERNS[options.lineDashes];\n        }\n    }\n\n    this.color = arrayToColor(options.scatterColor) ||\n                 arrayToColor(options.lineColor);\n\n    // Save data points\n    this.dataPoints = options.position;\n\n    lineOptions = {\n        gl: gl,\n        position: options.position,\n        color: options.lineColor,\n        lineWidth: options.lineWidth || 1,\n        dashes: dashPattern[0],\n        dashScale: dashPattern[1],\n        opacity: data.opacity,\n        connectGaps: data.connectgaps\n    };\n\n    if(this.mode.indexOf('lines') !== -1) {\n        if(this.linePlot) this.linePlot.update(lineOptions);\n        else {\n            this.linePlot = createLinePlot(lineOptions);\n            this.linePlot._trace = this;\n            this.scene.glplot.add(this.linePlot);\n        }\n    } else if(this.linePlot) {\n        this.scene.glplot.remove(this.linePlot);\n        this.linePlot.dispose();\n        this.linePlot = null;\n    }\n\n    // N.B. marker.opacity must be a scalar for performance\n    var scatterOpacity = data.opacity;\n    if(data.marker && data.marker.opacity) scatterOpacity *= data.marker.opacity;\n\n    scatterOptions = {\n        gl: gl,\n        position: options.position,\n        color: options.scatterColor,\n        size: options.scatterSize,\n        glyph: options.scatterMarker,\n        opacity: scatterOpacity,\n        orthographic: true,\n        lineWidth: options.scatterLineWidth,\n        lineColor: options.scatterLineColor,\n        project: options.project,\n        projectScale: options.projectScale,\n        projectOpacity: options.projectOpacity\n    };\n\n    if(this.mode.indexOf('markers') !== -1) {\n        if(this.scatterPlot) this.scatterPlot.update(scatterOptions);\n        else {\n            this.scatterPlot = createScatterPlot(scatterOptions);\n            this.scatterPlot._trace = this;\n            this.scatterPlot.highlightScale = 1;\n            this.scene.glplot.add(this.scatterPlot);\n        }\n    } else if(this.scatterPlot) {\n        this.scene.glplot.remove(this.scatterPlot);\n        this.scatterPlot.dispose();\n        this.scatterPlot = null;\n    }\n\n    textOptions = {\n        gl: gl,\n        position: options.position,\n        glyph: options.text,\n        color: options.textColor,\n        size: options.textSize,\n        angle: options.textAngle,\n        alignment: options.textOffset,\n        font: options.textFont,\n        orthographic: true,\n        lineWidth: 0,\n        project: false,\n        opacity: data.opacity\n    };\n\n    this.textLabels = data.hovertext || data.text;\n\n    if(this.mode.indexOf('text') !== -1) {\n        if(this.textMarkers) this.textMarkers.update(textOptions);\n        else {\n            this.textMarkers = createScatterPlot(textOptions);\n            this.textMarkers._trace = this;\n            this.textMarkers.highlightScale = 1;\n            this.scene.glplot.add(this.textMarkers);\n        }\n    } else if(this.textMarkers) {\n        this.scene.glplot.remove(this.textMarkers);\n        this.textMarkers.dispose();\n        this.textMarkers = null;\n    }\n\n    errorOptions = {\n        gl: gl,\n        position: options.position,\n        color: options.errorColor,\n        error: options.errorBounds,\n        lineWidth: options.errorLineWidth,\n        capSize: options.errorCapSize,\n        opacity: data.opacity\n    };\n    if(this.errorBars) {\n        if(options.errorBounds) {\n            this.errorBars.update(errorOptions);\n        } else {\n            this.scene.glplot.remove(this.errorBars);\n            this.errorBars.dispose();\n            this.errorBars = null;\n        }\n    } else if(options.errorBounds) {\n        this.errorBars = createErrorBars(errorOptions);\n        this.errorBars._trace = this;\n        this.scene.glplot.add(this.errorBars);\n    }\n\n    if(options.delaunayAxis >= 0) {\n        var delaunayOptions = constructDelaunay(\n            options.position,\n            options.delaunayColor,\n            options.delaunayAxis\n        );\n        delaunayOptions.opacity = data.opacity;\n\n        if(this.delaunayMesh) {\n            this.delaunayMesh.update(delaunayOptions);\n        } else {\n            delaunayOptions.gl = gl;\n            this.delaunayMesh = createMesh(delaunayOptions);\n            this.delaunayMesh._trace = this;\n            this.scene.glplot.add(this.delaunayMesh);\n        }\n    } else if(this.delaunayMesh) {\n        this.scene.glplot.remove(this.delaunayMesh);\n        this.delaunayMesh.dispose();\n        this.delaunayMesh = null;\n    }\n};\n\nproto.dispose = function() {\n    if(this.linePlot) {\n        this.scene.glplot.remove(this.linePlot);\n        this.linePlot.dispose();\n    }\n    if(this.scatterPlot) {\n        this.scene.glplot.remove(this.scatterPlot);\n        this.scatterPlot.dispose();\n    }\n    if(this.errorBars) {\n        this.scene.glplot.remove(this.errorBars);\n        this.errorBars.dispose();\n    }\n    if(this.textMarkers) {\n        this.scene.glplot.remove(this.textMarkers);\n        this.textMarkers.dispose();\n    }\n    if(this.delaunayMesh) {\n        this.scene.glplot.remove(this.delaunayMesh);\n        this.delaunayMesh.dispose();\n    }\n};\n\nfunction createLineWithMarkers(scene, data) {\n    var plot = new LineWithMarkers(scene, data.uid);\n    plot.update(data);\n    return plot;\n}\n\nmodule.exports = createLineWithMarkers;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/lib/gl_format_color.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar rgba = require('color-rgba');\n\nvar Colorscale = require('../components/colorscale');\nvar colorDflt = require('../components/color/attributes').defaultLine;\n\nvar colorDfltRgba = rgba(colorDflt);\nvar opacityDflt = 1;\n\nfunction calculateColor(colorIn, opacityIn) {\n    var colorOut = colorIn;\n    colorOut[3] *= opacityIn;\n    return colorOut;\n}\n\nfunction validateColor(colorIn) {\n    if(isNumeric(colorIn)) return colorDfltRgba;\n\n    var colorOut = rgba(colorIn);\n\n    return colorOut.length ? colorOut : colorDfltRgba;\n}\n\nfunction validateOpacity(opacityIn) {\n    return isNumeric(opacityIn) ? opacityIn : opacityDflt;\n}\n\nfunction formatColor(containerIn, opacityIn, len) {\n    var colorIn = containerIn.color,\n        isArrayColorIn = Array.isArray(colorIn),\n        isArrayOpacityIn = Array.isArray(opacityIn),\n        colorOut = [];\n\n    var sclFunc, getColor, getOpacity, colori, opacityi;\n\n    if(containerIn.colorscale !== undefined) {\n        sclFunc = Colorscale.makeColorScaleFunc(\n            Colorscale.extractScale(\n                containerIn.colorscale,\n                containerIn.cmin,\n                containerIn.cmax\n            )\n        );\n    }\n    else {\n        sclFunc = validateColor;\n    }\n\n    if(isArrayColorIn) {\n        getColor = function(c, i) {\n            return c[i] === undefined ? colorDfltRgba : rgba(sclFunc(c[i]));\n        };\n    }\n    else getColor = validateColor;\n\n    if(isArrayOpacityIn) {\n        getOpacity = function(o, i) {\n            return o[i] === undefined ? opacityDflt : validateOpacity(o[i]);\n        };\n    }\n    else getOpacity = validateOpacity;\n\n    if(isArrayColorIn || isArrayOpacityIn) {\n        for(var i = 0; i < len; i++) {\n            colori = getColor(colorIn, i);\n            opacityi = getOpacity(opacityIn, i);\n            colorOut[i] = calculateColor(colori, opacityi);\n        }\n    }\n    else colorOut = calculateColor(rgba(colorIn), opacityIn);\n\n    return colorOut;\n}\n\nmodule.exports = formatColor;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/constants/gl3d_dashes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nmodule.exports = {\n    solid: [[], 0],\n    dot: [[0.5, 1], 200],\n    dash: [[0.5, 1], 50],\n    longdash: [[0.5, 1], 10],\n    dashdot: [[0.5, 0.625, 0.875, 1], 50],\n    longdashdot: [[0.5, 0.7, 0.8, 1], 10]\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/constants/gl_markers.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nmodule.exports = {\n    circle: '',\n    'circle-open': '',\n    square: '',\n    'square-open': '',\n    diamond: '',\n    'diamond-open': '',\n    cross: '+',\n    x: ''\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/scatter3d/calc_errors.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar makeComputeError = require('../../components/errorbars/compute_error');\n\n\nfunction calculateAxisErrors(data, params, scaleFactor) {\n    if(!params || !params.visible) return null;\n\n    var computeError = makeComputeError(params);\n    var result = new Array(data.length);\n\n    for(var i = 0; i < data.length; i++) {\n        var errors = computeError(+data[i], i);\n\n        result[i] = [\n            -errors[0] * scaleFactor,\n            errors[1] * scaleFactor\n        ];\n    }\n\n    return result;\n}\n\nfunction dataLength(array) {\n    for(var i = 0; i < array.length; i++) {\n        if(array[i]) return array[i].length;\n    }\n    return 0;\n}\n\nfunction calculateErrors(data, scaleFactor) {\n    var errors = [\n        calculateAxisErrors(data.x, data.error_x, scaleFactor[0]),\n        calculateAxisErrors(data.y, data.error_y, scaleFactor[1]),\n        calculateAxisErrors(data.z, data.error_z, scaleFactor[2])\n    ];\n\n    var n = dataLength(errors);\n    if(n === 0) return null;\n\n    var errorBounds = new Array(n);\n\n    for(var i = 0; i < n; i++) {\n        var bound = [[0, 0, 0], [0, 0, 0]];\n\n        for(var j = 0; j < 3; j++) {\n            if(errors[j]) {\n                for(var k = 0; k < 2; k++) {\n                    bound[k][j] = errors[j][i][k];\n                }\n            }\n        }\n\n        errorBounds[i] = bound;\n    }\n\n    return errorBounds;\n}\n\nmodule.exports = calculateErrors;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/scatter3d/attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar scatterAttrs = require('../scatter/attributes');\nvar colorAttributes = require('../../components/colorscale/color_attributes');\nvar errorBarAttrs = require('../../components/errorbars/attributes');\nvar DASHES = require('../../constants/gl3d_dashes');\n\nvar MARKER_SYMBOLS = require('../../constants/gl_markers');\nvar extendFlat = require('../../lib/extend').extendFlat;\n\nvar scatterLineAttrs = scatterAttrs.line,\n    scatterMarkerAttrs = scatterAttrs.marker,\n    scatterMarkerLineAttrs = scatterMarkerAttrs.line;\n\nfunction makeProjectionAttr(axLetter) {\n    return {\n        show: {\n            valType: 'boolean',\n            role: 'info',\n            dflt: false,\n            description: [\n                'Sets whether or not projections are shown along the',\n                axLetter, 'axis.'\n            ].join(' ')\n        },\n        opacity: {\n            valType: 'number',\n            role: 'style',\n            min: 0,\n            max: 1,\n            dflt: 1,\n            description: 'Sets the projection color.'\n        },\n        scale: {\n            valType: 'number',\n            role: 'style',\n            min: 0,\n            max: 10,\n            dflt: 2 / 3,\n            description: [\n                'Sets the scale factor determining the size of the',\n                'projection marker points.'\n            ].join(' ')\n        }\n    };\n}\n\nmodule.exports = {\n    x: {\n        valType: 'data_array',\n        description: 'Sets the x coordinates.'\n    },\n    y: {\n        valType: 'data_array',\n        description: 'Sets the y coordinates.'\n    },\n    z: {\n        valType: 'data_array',\n        description: 'Sets the z coordinates.'\n    },\n\n    text: extendFlat({}, scatterAttrs.text, {\n        description: [\n            'Sets text elements associated with each (x,y,z) triplet.',\n            'If a single string, the same string appears over',\n            'all the data points.',\n            'If an array of string, the items are mapped in order to the',\n            'this trace\\'s (x,y,z) coordinates.',\n            'If trace `hoverinfo` contains a *text* flag and *hovertext* is not set,',\n            'these elements will be seen in the hover labels.'\n        ].join(' ')\n    }),\n    hovertext: extendFlat({}, scatterAttrs.hovertext, {\n        description: [\n            'Sets text elements associated with each (x,y,z) triplet.',\n            'If a single string, the same string appears over',\n            'all the data points.',\n            'If an array of string, the items are mapped in order to the',\n            'this trace\\'s (x,y,z) coordinates.',\n            'To be seen, trace `hoverinfo` must contain a *text* flag.'\n        ].join(' ')\n    }),\n\n    mode: extendFlat({}, scatterAttrs.mode,  // shouldn't this be on-par with 2D?\n        {dflt: 'lines+markers'}),\n    surfaceaxis: {\n        valType: 'enumerated',\n        role: 'info',\n        values: [-1, 0, 1, 2],\n        dflt: -1,\n        description: [\n            'If *-1*, the scatter points are not fill with a surface',\n            'If *0*, *1*, *2*, the scatter points are filled with',\n            'a Delaunay surface about the x, y, z respectively.'\n        ].join(' ')\n    },\n    surfacecolor: {\n        valType: 'color',\n        role: 'style',\n        description: 'Sets the surface fill color.'\n    },\n    projection: {\n        x: makeProjectionAttr('x'),\n        y: makeProjectionAttr('y'),\n        z: makeProjectionAttr('z')\n    },\n    connectgaps: scatterAttrs.connectgaps,\n    line: extendFlat({}, {\n        width: scatterLineAttrs.width,\n        dash: {\n            valType: 'enumerated',\n            values: Object.keys(DASHES),\n            dflt: 'solid',\n            role: 'style',\n            description: 'Sets the dash style of the lines.'\n        },\n        showscale: {\n            valType: 'boolean',\n            role: 'info',\n            dflt: false,\n            description: [\n                'Has an effect only if `line.color` is set to a numerical array.',\n                'Determines whether or not a colorbar is displayed.'\n            ].join(' ')\n        }\n    },\n        colorAttributes('line')\n    ),\n    marker: extendFlat({}, {  // Parity with scatter.js?\n        symbol: {\n            valType: 'enumerated',\n            values: Object.keys(MARKER_SYMBOLS),\n            role: 'style',\n            dflt: 'circle',\n            arrayOk: true,\n            description: 'Sets the marker symbol type.'\n        },\n        size: extendFlat({}, scatterMarkerAttrs.size, {dflt: 8}),\n        sizeref: scatterMarkerAttrs.sizeref,\n        sizemin: scatterMarkerAttrs.sizemin,\n        sizemode: scatterMarkerAttrs.sizemode,\n        opacity: extendFlat({}, scatterMarkerAttrs.opacity, {\n            arrayOk: false,\n            description: [\n                'Sets the marker opacity.',\n                'Note that the marker opacity for scatter3d traces',\n                'must be a scalar value for performance reasons.',\n                'To set a blending opacity value',\n                '(i.e. which is not transparent), set *marker.color*',\n                'to an rgba color and use its alpha channel.'\n            ].join(' ')\n        }),\n        showscale: scatterMarkerAttrs.showscale,\n        colorbar: scatterMarkerAttrs.colorbar,\n\n        line: extendFlat({},\n            {width: extendFlat({}, scatterMarkerLineAttrs.width, {arrayOk: false})},\n            colorAttributes('marker.line')\n        )\n    },\n        colorAttributes('marker')\n    ),\n\n    textposition: extendFlat({}, scatterAttrs.textposition, {dflt: 'top center'}),\n    textfont: scatterAttrs.textfont,\n\n    error_x: errorBarAttrs,\n    error_y: errorBarAttrs,\n    error_z: errorBarAttrs,\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/lib/scattercarpet.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = require('../src/traces/scattercarpet');\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/scattercarpet/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar ScatterCarpet = {};\n\nScatterCarpet.attributes = require('./attributes');\nScatterCarpet.supplyDefaults = require('./defaults');\nScatterCarpet.colorbar = require('../scatter/colorbar');\nScatterCarpet.calc = require('./calc');\nScatterCarpet.plot = require('./plot');\nScatterCarpet.style = require('./style');\nScatterCarpet.hoverPoints = require('./hover');\nScatterCarpet.selectPoints = require('./select');\n\nScatterCarpet.moduleType = 'trace';\nScatterCarpet.name = 'scattercarpet';\nScatterCarpet.basePlotModule = require('../../plots/cartesian');\nScatterCarpet.categories = ['carpet', 'symbols', 'markerColorscale', 'showLegend', 'carpetDependent'];\nScatterCarpet.meta = {\n    hrName: 'scatter_carpet',\n    description: [\n        'Plots a scatter trace on either the first carpet axis or the',\n        'carpet axis with a matching `carpet` attribute.'\n    ].join(' ')\n};\n\nmodule.exports = ScatterCarpet;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/scattercarpet/attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar scatterAttrs = require('../scatter/attributes');\nvar plotAttrs = require('../../plots/attributes');\nvar colorAttributes = require('../../components/colorscale/color_attributes');\nvar colorbarAttrs = require('../../components/colorbar/attributes');\n\nvar extendFlat = require('../../lib/extend').extendFlat;\n\nvar scatterMarkerAttrs = scatterAttrs.marker,\n    scatterLineAttrs = scatterAttrs.line,\n    scatterMarkerLineAttrs = scatterMarkerAttrs.line;\n\nmodule.exports = {\n    carpet: {\n        valType: 'string',\n        role: 'info',\n        description: [\n            'An identifier for this carpet, so that `scattercarpet` and',\n            '`scattercontour` traces can specify a carpet plot on which',\n            'they lie'\n        ].join(' ')\n    },\n    a: {\n        valType: 'data_array',\n        description: [\n            'Sets the quantity of component `a` in each data point.',\n            'If `a`, `b`, and `c` are all provided, they need not be',\n            'normalized, only the relative values matter. If only two',\n            'arrays are provided they must be normalized to match',\n            '`ternary<i>.sum`.'\n        ].join(' ')\n    },\n    b: {\n        valType: 'data_array',\n        description: [\n            'Sets the quantity of component `a` in each data point.',\n            'If `a`, `b`, and `c` are all provided, they need not be',\n            'normalized, only the relative values matter. If only two',\n            'arrays are provided they must be normalized to match',\n            '`ternary<i>.sum`.'\n        ].join(' ')\n    },\n    sum: {\n        valType: 'number',\n        role: 'info',\n        dflt: 0,\n        min: 0,\n        description: [\n            'The number each triplet should sum to,',\n            'if only two of `a`, `b`, and `c` are provided.',\n            'This overrides `ternary<i>.sum` to normalize this specific',\n            'trace, but does not affect the values displayed on the axes.',\n            '0 (or missing) means to use ternary<i>.sum'\n        ].join(' ')\n    },\n    mode: extendFlat({}, scatterAttrs.mode, {dflt: 'markers'}),\n    text: extendFlat({}, scatterAttrs.text, {\n        description: [\n            'Sets text elements associated with each (a,b,c) point.',\n            'If a single string, the same string appears over',\n            'all the data points.',\n            'If an array of strings, the items are mapped in order to the',\n            'the data points in (a,b,c).'\n        ].join(' ')\n    }),\n    line: {\n        color: scatterLineAttrs.color,\n        width: scatterLineAttrs.width,\n        dash: scatterLineAttrs.dash,\n        shape: extendFlat({}, scatterLineAttrs.shape,\n            {values: ['linear', 'spline']}),\n        smoothing: scatterLineAttrs.smoothing\n    },\n    connectgaps: scatterAttrs.connectgaps,\n    fill: extendFlat({}, scatterAttrs.fill, {\n        values: ['none', 'toself', 'tonext'],\n        description: [\n            'Sets the area to fill with a solid color.',\n            'Use with `fillcolor` if not *none*.',\n            'scatterternary has a subset of the options available to scatter.',\n            '*toself* connects the endpoints of the trace (or each segment',\n            'of the trace if it has gaps) into a closed shape.',\n            '*tonext* fills the space between two traces if one completely',\n            'encloses the other (eg consecutive contour lines), and behaves like',\n            '*toself* if there is no trace before it. *tonext* should not be',\n            'used if one trace does not enclose the other.'\n        ].join(' ')\n    }),\n    fillcolor: scatterAttrs.fillcolor,\n    marker: extendFlat({}, {\n        symbol: scatterMarkerAttrs.symbol,\n        opacity: scatterMarkerAttrs.opacity,\n        maxdisplayed: scatterMarkerAttrs.maxdisplayed,\n        size: scatterMarkerAttrs.size,\n        sizeref: scatterMarkerAttrs.sizeref,\n        sizemin: scatterMarkerAttrs.sizemin,\n        sizemode: scatterMarkerAttrs.sizemode,\n        line: extendFlat({},\n            {width: scatterMarkerLineAttrs.width},\n            colorAttributes('marker'.line)\n        )\n    }, colorAttributes('marker'), {\n        showscale: scatterMarkerAttrs.showscale,\n        colorbar: colorbarAttrs\n    }),\n\n    textfont: scatterAttrs.textfont,\n    textposition: scatterAttrs.textposition,\n    hoverinfo: extendFlat({}, plotAttrs.hoverinfo, {\n        flags: ['a', 'b', 'c', 'text', 'name']\n    }),\n    hoveron: scatterAttrs.hoveron,\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/lib/scattergeo.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = require('../src/traces/scattergeo');\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/scattergeo/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar ScatterGeo = {};\n\nScatterGeo.attributes = require('./attributes');\nScatterGeo.supplyDefaults = require('./defaults');\nScatterGeo.colorbar = require('../scatter/colorbar');\nScatterGeo.calc = require('./calc');\nScatterGeo.plot = require('./plot');\nScatterGeo.hoverPoints = require('./hover');\nScatterGeo.eventData = require('./event_data');\n\nScatterGeo.moduleType = 'trace';\nScatterGeo.name = 'scattergeo';\nScatterGeo.basePlotModule = require('../../plots/geo');\nScatterGeo.categories = ['geo', 'symbols', 'markerColorscale', 'showLegend'];\nScatterGeo.meta = {\n    hrName: 'scatter_geo',\n    description: [\n        'The data visualized as scatter point or lines on a geographic map',\n        'is provided either by longitude/latitude pairs in `lon` and `lat`',\n        'respectively or by geographic location IDs or names in `locations`.'\n    ].join(' ')\n};\n\nmodule.exports = ScatterGeo;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/lib/scattergl.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = require('../src/traces/scattergl');\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/scattergl/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar ScatterGl = {};\n\nScatterGl.attributes = require('./attributes');\nScatterGl.supplyDefaults = require('./defaults');\nScatterGl.colorbar = require('../scatter/colorbar');\n\n// reuse the Scatter3D 'dummy' calc step so that legends know what to do\nScatterGl.calc = require('../scatter3d/calc');\nScatterGl.plot = require('./convert');\n\nScatterGl.moduleType = 'trace';\nScatterGl.name = 'scattergl';\nScatterGl.basePlotModule = require('../../plots/gl2d');\nScatterGl.categories = ['gl2d', 'symbols', 'errorBarsOK', 'markerColorscale', 'showLegend'];\nScatterGl.meta = {\n    description: [\n        'The data visualized as scatter point or lines is set in `x` and `y`',\n        'using the WebGl plotting engine.',\n        'Bubble charts are achieved by setting `marker.size` and/or `marker.color`',\n        'to a numerical arrays.'\n    ].join(' ')\n};\n\nmodule.exports = ScatterGl;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/lib/scatter.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = require('../src/traces/scatter');\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/scatter/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Scatter = {};\n\nvar subtypes = require('./subtypes');\nScatter.hasLines = subtypes.hasLines;\nScatter.hasMarkers = subtypes.hasMarkers;\nScatter.hasText = subtypes.hasText;\nScatter.isBubble = subtypes.isBubble;\n\n// traces with < this many points are by default shown\n// with points and lines, > just get lines\nScatter.attributes = require('./attributes');\nScatter.supplyDefaults = require('./defaults');\nScatter.cleanData = require('./clean_data');\nScatter.calc = require('./calc');\nScatter.arraysToCalcdata = require('./arrays_to_calcdata');\nScatter.plot = require('./plot');\nScatter.colorbar = require('./colorbar');\nScatter.style = require('./style');\nScatter.hoverPoints = require('./hover');\nScatter.selectPoints = require('./select');\nScatter.animatable = true;\n\nScatter.moduleType = 'trace';\nScatter.name = 'scatter';\nScatter.basePlotModule = require('../../plots/cartesian');\nScatter.categories = ['cartesian', 'symbols', 'markerColorscale', 'errorBarsOK', 'showLegend'];\nScatter.meta = {\n    description: [\n        'The scatter trace type encompasses line charts, scatter charts, text charts, and bubble charts.',\n        'The data visualized as scatter point or lines is set in `x` and `y`.',\n        'Text (appearing either on the chart or on hover only) is via `text`.',\n        'Bubble charts are achieved by setting `marker.size` and/or `marker.color`',\n        'to numerical arrays.'\n    ].join(' ')\n};\n\nmodule.exports = Scatter;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/lib/scattermapbox.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = require('../src/traces/scattermapbox');\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/scattermapbox/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n\nvar ScatterMapbox = {};\n\nScatterMapbox.attributes = require('./attributes');\nScatterMapbox.supplyDefaults = require('./defaults');\nScatterMapbox.colorbar = require('../scatter/colorbar');\nScatterMapbox.calc = require('../scattergeo/calc');\nScatterMapbox.hoverPoints = require('./hover');\nScatterMapbox.eventData = require('./event_data');\nScatterMapbox.plot = require('./plot');\n\nScatterMapbox.moduleType = 'trace';\nScatterMapbox.name = 'scattermapbox';\nScatterMapbox.basePlotModule = require('../../plots/mapbox');\nScatterMapbox.categories = ['mapbox', 'gl', 'symbols', 'markerColorscale', 'showLegend'];\nScatterMapbox.meta = {\n    hrName: 'scatter_mapbox',\n    description: [\n        'The data visualized as scatter point, lines or marker symbols',\n        'on a Mapbox GL geographic map',\n        'is provided by longitude/latitude pairs in `lon` and `lat`.'\n    ].join(' ')\n};\n\nmodule.exports = ScatterMapbox;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/scattermapbox/attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar scatterGeoAttrs = require('../scattergeo/attributes');\nvar scatterAttrs = require('../scatter/attributes');\nvar mapboxAttrs = require('../../plots/mapbox/layout_attributes');\nvar plotAttrs = require('../../plots/attributes');\nvar colorbarAttrs = require('../../components/colorbar/attributes');\n\nvar extendFlat = require('../../lib/extend').extendFlat;\n\nvar lineAttrs = scatterGeoAttrs.line;\nvar markerAttrs = scatterGeoAttrs.marker;\n\n\nmodule.exports = {\n    lon: scatterGeoAttrs.lon,\n    lat: scatterGeoAttrs.lat,\n\n    // locations\n    // locationmode\n\n    mode: extendFlat({}, scatterAttrs.mode, {\n        dflt: 'markers',\n        description: [\n            'Determines the drawing mode for this scatter trace.',\n            'If the provided `mode` includes *text* then the `text` elements',\n            'appear at the coordinates. Otherwise, the `text` elements',\n            'appear on hover.'\n        ].join(' ')\n    }),\n\n    text: extendFlat({}, scatterAttrs.text, {\n        description: [\n            'Sets text elements associated with each (lon,lat) pair',\n            'If a single string, the same string appears over',\n            'all the data points.',\n            'If an array of string, the items are mapped in order to the',\n            'this trace\\'s (lon,lat) coordinates.',\n            'If trace `hoverinfo` contains a *text* flag and *hovertext* is not set,',\n            'these elements will be seen in the hover labels.'\n        ].join(' ')\n    }),\n    hovertext: extendFlat({}, scatterAttrs.hovertext, {\n        description: [\n            'Sets hover text elements associated with each (lon,lat) pair',\n            'If a single string, the same string appears over',\n            'all the data points.',\n            'If an array of string, the items are mapped in order to the',\n            'this trace\\'s (lon,lat) coordinates.',\n            'To be seen, trace `hoverinfo` must contain a *text* flag.'\n        ].join(' ')\n    }),\n\n    line: {\n        color: lineAttrs.color,\n        width: lineAttrs.width\n\n        // TODO\n        // dash: dash\n    },\n\n    connectgaps: scatterAttrs.connectgaps,\n\n    marker: {\n        symbol: {\n            valType: 'string',\n            dflt: 'circle',\n            role: 'style',\n            arrayOk: true,\n            description: [\n                'Sets the marker symbol.',\n                'Full list: https://www.mapbox.com/maki-icons/',\n                'Note that the array `marker.color` and `marker.size`',\n                'are only available for *circle* symbols.'\n            ].join(' ')\n        },\n        opacity: extendFlat({}, markerAttrs.opacity, {\n            arrayOk: false\n        }),\n        size: markerAttrs.size,\n        sizeref: markerAttrs.sizeref,\n        sizemin: markerAttrs.sizemin,\n        sizemode: markerAttrs.sizemode,\n        color: markerAttrs.color,\n        colorscale: markerAttrs.colorscale,\n        cauto: markerAttrs.cauto,\n        cmax: markerAttrs.cmax,\n        cmin: markerAttrs.cmin,\n        autocolorscale: markerAttrs.autocolorscale,\n        reversescale: markerAttrs.reversescale,\n        showscale: markerAttrs.showscale,\n        colorbar: colorbarAttrs\n\n        // line\n    },\n\n    fill: scatterGeoAttrs.fill,\n    fillcolor: scatterAttrs.fillcolor,\n\n    textfont: mapboxAttrs.layers.symbol.textfont,\n    textposition: mapboxAttrs.layers.symbol.textposition,\n\n    hoverinfo: extendFlat({}, plotAttrs.hoverinfo, {\n        flags: ['lon', 'lat', 'text', 'name']\n    }),\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/lib/scatterternary.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = require('../src/traces/scatterternary');\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/scatterternary/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar ScatterTernary = {};\n\nScatterTernary.attributes = require('./attributes');\nScatterTernary.supplyDefaults = require('./defaults');\nScatterTernary.colorbar = require('../scatter/colorbar');\nScatterTernary.calc = require('./calc');\nScatterTernary.plot = require('./plot');\nScatterTernary.style = require('./style');\nScatterTernary.hoverPoints = require('./hover');\nScatterTernary.selectPoints = require('./select');\n\nScatterTernary.moduleType = 'trace';\nScatterTernary.name = 'scatterternary';\nScatterTernary.basePlotModule = require('../../plots/ternary');\nScatterTernary.categories = ['ternary', 'symbols', 'markerColorscale', 'showLegend'];\nScatterTernary.meta = {\n    hrName: 'scatter_ternary',\n    description: [\n        'Provides similar functionality to the *scatter* type but on a ternary phase diagram.',\n        'The data is provided by at least two arrays out of `a`, `b`, `c` triplets.'\n    ].join(' ')\n};\n\nmodule.exports = ScatterTernary;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/scatterternary/attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar scatterAttrs = require('../scatter/attributes');\nvar plotAttrs = require('../../plots/attributes');\nvar colorAttributes = require('../../components/colorscale/color_attributes');\nvar colorbarAttrs = require('../../components/colorbar/attributes');\nvar dash = require('../../components/drawing/attributes').dash;\n\nvar extendFlat = require('../../lib/extend').extendFlat;\n\nvar scatterMarkerAttrs = scatterAttrs.marker,\n    scatterLineAttrs = scatterAttrs.line,\n    scatterMarkerLineAttrs = scatterMarkerAttrs.line;\n\nmodule.exports = {\n    a: {\n        valType: 'data_array',\n        description: [\n            'Sets the quantity of component `a` in each data point.',\n            'If `a`, `b`, and `c` are all provided, they need not be',\n            'normalized, only the relative values matter. If only two',\n            'arrays are provided they must be normalized to match',\n            '`ternary<i>.sum`.'\n        ].join(' ')\n    },\n    b: {\n        valType: 'data_array',\n        description: [\n            'Sets the quantity of component `a` in each data point.',\n            'If `a`, `b`, and `c` are all provided, they need not be',\n            'normalized, only the relative values matter. If only two',\n            'arrays are provided they must be normalized to match',\n            '`ternary<i>.sum`.'\n        ].join(' ')\n    },\n    c: {\n        valType: 'data_array',\n        description: [\n            'Sets the quantity of component `a` in each data point.',\n            'If `a`, `b`, and `c` are all provided, they need not be',\n            'normalized, only the relative values matter. If only two',\n            'arrays are provided they must be normalized to match',\n            '`ternary<i>.sum`.'\n        ].join(' ')\n    },\n    sum: {\n        valType: 'number',\n        role: 'info',\n        dflt: 0,\n        min: 0,\n        description: [\n            'The number each triplet should sum to,',\n            'if only two of `a`, `b`, and `c` are provided.',\n            'This overrides `ternary<i>.sum` to normalize this specific',\n            'trace, but does not affect the values displayed on the axes.',\n            '0 (or missing) means to use ternary<i>.sum'\n        ].join(' ')\n    },\n    mode: extendFlat({}, scatterAttrs.mode, {dflt: 'markers'}),\n    text: extendFlat({}, scatterAttrs.text, {\n        description: [\n            'Sets text elements associated with each (a,b,c) point.',\n            'If a single string, the same string appears over',\n            'all the data points.',\n            'If an array of strings, the items are mapped in order to the',\n            'the data points in (a,b,c).',\n            'If trace `hoverinfo` contains a *text* flag and *hovertext* is not set,',\n            'these elements will be seen in the hover labels.'\n        ].join(' ')\n    }),\n    hovertext: extendFlat({}, scatterAttrs.hovertext, {\n        description: [\n            'Sets hover text elements associated with each (a,b,c) point.',\n            'If a single string, the same string appears over',\n            'all the data points.',\n            'If an array of strings, the items are mapped in order to the',\n            'the data points in (a,b,c).',\n            'To be seen, trace `hoverinfo` must contain a *text* flag.'\n        ].join(' ')\n    }),\n    line: {\n        color: scatterLineAttrs.color,\n        width: scatterLineAttrs.width,\n        dash: dash,\n        shape: extendFlat({}, scatterLineAttrs.shape,\n            {values: ['linear', 'spline']}),\n        smoothing: scatterLineAttrs.smoothing\n    },\n    connectgaps: scatterAttrs.connectgaps,\n    fill: extendFlat({}, scatterAttrs.fill, {\n        values: ['none', 'toself', 'tonext'],\n        description: [\n            'Sets the area to fill with a solid color.',\n            'Use with `fillcolor` if not *none*.',\n            'scatterternary has a subset of the options available to scatter.',\n            '*toself* connects the endpoints of the trace (or each segment',\n            'of the trace if it has gaps) into a closed shape.',\n            '*tonext* fills the space between two traces if one completely',\n            'encloses the other (eg consecutive contour lines), and behaves like',\n            '*toself* if there is no trace before it. *tonext* should not be',\n            'used if one trace does not enclose the other.'\n        ].join(' ')\n    }),\n    fillcolor: scatterAttrs.fillcolor,\n    marker: extendFlat({}, {\n        symbol: scatterMarkerAttrs.symbol,\n        opacity: scatterMarkerAttrs.opacity,\n        maxdisplayed: scatterMarkerAttrs.maxdisplayed,\n        size: scatterMarkerAttrs.size,\n        sizeref: scatterMarkerAttrs.sizeref,\n        sizemin: scatterMarkerAttrs.sizemin,\n        sizemode: scatterMarkerAttrs.sizemode,\n        line: extendFlat({},\n            {width: scatterMarkerLineAttrs.width},\n            colorAttributes('marker'.line)\n        )\n    }, colorAttributes('marker'), {\n        showscale: scatterMarkerAttrs.showscale,\n        colorbar: colorbarAttrs\n    }),\n\n    textfont: scatterAttrs.textfont,\n    textposition: scatterAttrs.textposition,\n    hoverinfo: extendFlat({}, plotAttrs.hoverinfo, {\n        flags: ['a', 'b', 'c', 'text', 'name']\n    }),\n    hoveron: scatterAttrs.hoveron,\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/lib/surface.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = require('../src/traces/surface');\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/surface/index.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Surface = {};\n\nSurface.attributes = require('./attributes');\nSurface.supplyDefaults = require('./defaults');\nSurface.colorbar = require('./colorbar');\nSurface.calc = require('./calc');\nSurface.plot = require('./convert');\n\nSurface.moduleType = 'trace';\nSurface.name = 'surface';\nSurface.basePlotModule = require('../../plots/gl3d');\nSurface.categories = ['gl3d', 'noOpacity'];\nSurface.meta = {\n    description: [\n        'The data the describes the coordinates of the surface is set in `z`.',\n        'Data in `z` should be a {2D array}.',\n\n        'Coordinates in `x` and `y` can either be 1D {arrays}',\n        'or {2D arrays} (e.g. to graph parametric surfaces).',\n\n        'If not provided in `x` and `y`, the x and y coordinates are assumed',\n        'to be linear starting at 0 with a unit step.',\n\n        'The color scale corresponds to the `z` values by default.',\n        'For custom color scales, use `surfacecolor` which should be a {2D array},',\n        'where its bounds can be controlled using `cmin` and `cmax`.'\n    ].join(' ')\n};\n\nmodule.exports = Surface;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/surface/defaults.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\n\nvar colorscaleDefaults = require('../../components/colorscale/defaults');\nvar attributes = require('./attributes');\n\n\nmodule.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {\n    var i, j;\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);\n    }\n\n    var z = coerce('z');\n    if(!z) {\n        traceOut.visible = false;\n        return;\n    }\n\n    var xlen = z[0].length;\n    var ylen = z.length;\n\n    coerce('x');\n    coerce('y');\n\n    var handleCalendarDefaults = Registry.getComponentMethod('calendars', 'handleTraceDefaults');\n    handleCalendarDefaults(traceIn, traceOut, ['x', 'y', 'z'], layout);\n\n    if(!Array.isArray(traceOut.x)) {\n        // build a linearly scaled x\n        traceOut.x = [];\n        for(i = 0; i < xlen; ++i) {\n            traceOut.x[i] = i;\n        }\n    }\n\n    coerce('text');\n    if(!Array.isArray(traceOut.y)) {\n        traceOut.y = [];\n        for(i = 0; i < ylen; ++i) {\n            traceOut.y[i] = i;\n        }\n    }\n\n    // Coerce remaining properties\n    [\n        'lighting.ambient',\n        'lighting.diffuse',\n        'lighting.specular',\n        'lighting.roughness',\n        'lighting.fresnel',\n        'lightposition.x',\n        'lightposition.y',\n        'lightposition.z',\n        'hidesurface',\n        'opacity'\n    ].forEach(function(x) { coerce(x); });\n\n    var surfaceColor = coerce('surfacecolor');\n\n    coerce('colorscale');\n\n    var dims = ['x', 'y', 'z'];\n    for(i = 0; i < 3; ++i) {\n\n        var contourDim = 'contours.' + dims[i];\n        var show = coerce(contourDim + '.show');\n        var highlight = coerce(contourDim + '.highlight');\n\n        if(show || highlight) {\n            for(j = 0; j < 3; ++j) {\n                coerce(contourDim + '.project.' + dims[j]);\n            }\n        }\n\n        if(show) {\n            coerce(contourDim + '.color');\n            coerce(contourDim + '.width');\n            coerce(contourDim + '.usecolormap');\n        }\n\n        if(highlight) {\n            coerce(contourDim + '.highlightcolor');\n            coerce(contourDim + '.highlightwidth');\n        }\n    }\n\n    // backward compatibility block\n    if(!surfaceColor) {\n        mapLegacy(traceIn, 'zmin', 'cmin');\n        mapLegacy(traceIn, 'zmax', 'cmax');\n        mapLegacy(traceIn, 'zauto', 'cauto');\n    }\n\n    // TODO if contours.?.usecolormap are false and hidesurface is true\n    // the colorbar shouldn't be shown by default\n\n    colorscaleDefaults(\n        traceIn, traceOut, layout, coerce, {prefix: '', cLetter: 'c'}\n    );\n};\n\nfunction mapLegacy(traceIn, oldAttr, newAttr) {\n    if(oldAttr in traceIn && !(newAttr in traceIn)) {\n        traceIn[newAttr] = traceIn[oldAttr];\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/surface/colorbar.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\nvar Plots = require('../../plots/plots');\nvar Colorscale = require('../../components/colorscale');\nvar drawColorbar = require('../../components/colorbar/draw');\n\n\nmodule.exports = function colorbar(gd, cd) {\n    var trace = cd[0].trace,\n        cbId = 'cb' + trace.uid,\n        cmin = trace.cmin,\n        cmax = trace.cmax,\n        vals = trace.surfacecolor || trace.z;\n\n    if(!isNumeric(cmin)) cmin = Lib.aggNums(Math.min, null, vals);\n    if(!isNumeric(cmax)) cmax = Lib.aggNums(Math.max, null, vals);\n\n    gd._fullLayout._infolayer.selectAll('.' + cbId).remove();\n\n    if(!trace.showscale) {\n        Plots.autoMargin(gd, cbId);\n        return;\n    }\n\n    var cb = cd[0].t.cb = drawColorbar(gd, cbId);\n    var sclFunc = Colorscale.makeColorScaleFunc(\n        Colorscale.extractScale(\n            trace.colorscale,\n            cmin,\n            cmax\n        ),\n        { noNumericCheck: true }\n    );\n\n    cb.fillcolor(sclFunc)\n        .filllevels({start: cmin, end: cmax, size: (cmax - cmin) / 254})\n        .options(trace.colorbar)();\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/surface/calc.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar colorscaleCalc = require('../../components/colorscale/calc');\n\n\n// Compute auto-z and autocolorscale if applicable\nmodule.exports = function calc(gd, trace) {\n    if(trace.surfacecolor) {\n        colorscaleCalc(trace, trace.surfacecolor, '', 'c');\n    } else {\n        colorscaleCalc(trace, trace.z, '', 'c');\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/surface/convert.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar createSurface = require('gl-surface3d');\nvar ndarray = require('ndarray');\nvar homography = require('ndarray-homography');\nvar fill = require('ndarray-fill');\nvar ops = require('ndarray-ops');\nvar tinycolor = require('tinycolor2');\n\nvar str2RgbaArray = require('../../lib/str2rgbarray');\n\nvar MIN_RESOLUTION = 128;\n\nfunction SurfaceTrace(scene, surface, uid) {\n    this.scene = scene;\n    this.uid = uid;\n    this.surface = surface;\n    this.data = null;\n    this.showContour = [false, false, false];\n    this.dataScale = 1.0;\n}\n\nvar proto = SurfaceTrace.prototype;\n\nproto.handlePick = function(selection) {\n    if(selection.object === this.surface) {\n        var selectIndex = [\n            Math.min(\n                Math.round(selection.data.index[0] / this.dataScale - 1)|0,\n                this.data.z[0].length - 1\n            ),\n            Math.min(\n                Math.round(selection.data.index[1] / this.dataScale - 1)|0,\n                this.data.z.length - 1\n            )\n        ];\n        var traceCoordinate = [0, 0, 0];\n\n        if(Array.isArray(this.data.x[0])) {\n            traceCoordinate[0] = this.data.x[selectIndex[1]][selectIndex[0]];\n        } else {\n            traceCoordinate[0] = this.data.x[selectIndex[0]];\n        }\n        if(Array.isArray(this.data.y[0])) {\n            traceCoordinate[1] = this.data.y[selectIndex[1]][selectIndex[0]];\n        } else {\n            traceCoordinate[1] = this.data.y[selectIndex[1]];\n        }\n\n        traceCoordinate[2] = this.data.z[selectIndex[1]][selectIndex[0]];\n        selection.traceCoordinate = traceCoordinate;\n\n        var sceneLayout = this.scene.fullSceneLayout;\n        selection.dataCoordinate = [\n            sceneLayout.xaxis.d2l(traceCoordinate[0], 0, this.data.xcalendar) * this.scene.dataScale[0],\n            sceneLayout.yaxis.d2l(traceCoordinate[1], 0, this.data.ycalendar) * this.scene.dataScale[1],\n            sceneLayout.zaxis.d2l(traceCoordinate[2], 0, this.data.zcalendar) * this.scene.dataScale[2]\n        ];\n\n        var text = this.data.text;\n        if(text && text[selectIndex[1]] && text[selectIndex[1]][selectIndex[0]] !== undefined) {\n            selection.textLabel = text[selectIndex[1]][selectIndex[0]];\n        }\n        else selection.textLabel = '';\n\n        selection.data.dataCoordinate = selection.dataCoordinate.slice();\n\n        this.surface.highlight(selection.data);\n\n        // Snap spikes to data coordinate\n        this.scene.glplot.spikes.position = selection.dataCoordinate;\n\n        return true;\n    }\n};\n\nfunction parseColorScale(colorscale, alpha) {\n    if(alpha === undefined) alpha = 1;\n\n    return colorscale.map(function(elem) {\n        var index = elem[0];\n        var color = tinycolor(elem[1]);\n        var rgb = color.toRgb();\n        return {\n            index: index,\n            rgb: [rgb.r, rgb.g, rgb.b, alpha]\n        };\n    });\n}\n\nfunction isColormapCircular(colormap) {\n    var first = colormap[0].rgb,\n        last = colormap[colormap.length - 1].rgb;\n\n    return (\n        first[0] === last[0] &&\n        first[1] === last[1] &&\n        first[2] === last[2] &&\n        first[3] === last[3]\n    );\n}\n\n// Pad coords by +1\nfunction padField(field) {\n    var shape = field.shape;\n    var nshape = [shape[0] + 2, shape[1] + 2];\n    var nfield = ndarray(new Float32Array(nshape[0] * nshape[1]), nshape);\n\n    // Center\n    ops.assign(nfield.lo(1, 1).hi(shape[0], shape[1]), field);\n\n    // Edges\n    ops.assign(nfield.lo(1).hi(shape[0], 1),\n                field.hi(shape[0], 1));\n    ops.assign(nfield.lo(1, nshape[1] - 1).hi(shape[0], 1),\n                field.lo(0, shape[1] - 1).hi(shape[0], 1));\n    ops.assign(nfield.lo(0, 1).hi(1, shape[1]),\n                field.hi(1));\n    ops.assign(nfield.lo(nshape[0] - 1, 1).hi(1, shape[1]),\n                field.lo(shape[0] - 1));\n\n    // Corners\n    nfield.set(0, 0, field.get(0, 0));\n    nfield.set(0, nshape[1] - 1, field.get(0, shape[1] - 1));\n    nfield.set(nshape[0] - 1, 0, field.get(shape[0] - 1, 0));\n    nfield.set(nshape[0] - 1, nshape[1] - 1, field.get(shape[0] - 1, shape[1] - 1));\n\n    return nfield;\n}\n\nfunction refine(coords) {\n    var minScale = Math.max(coords[0].shape[0], coords[0].shape[1]);\n\n    if(minScale < MIN_RESOLUTION) {\n        var scaleF = MIN_RESOLUTION / minScale;\n        var nshape = [\n            Math.floor((coords[0].shape[0]) * scaleF + 1)|0,\n            Math.floor((coords[0].shape[1]) * scaleF + 1)|0 ];\n        var nsize = nshape[0] * nshape[1];\n\n        for(var i = 0; i < coords.length; ++i) {\n            var padImg = padField(coords[i]);\n            var scaledImg = ndarray(new Float32Array(nsize), nshape);\n            homography(scaledImg, padImg, [scaleF, 0, 0,\n                0, scaleF, 0,\n                0, 0, 1]);\n            coords[i] = scaledImg;\n        }\n\n        return scaleF;\n    }\n\n    return 1.0;\n}\n\nproto.setContourLevels = function() {\n    var nlevels = [[], [], []];\n    var needsUpdate = false;\n\n    for(var i = 0; i < 3; ++i) {\n        if(this.showContour[i]) {\n            needsUpdate = true;\n            nlevels[i] = this.scene.contourLevels[i];\n        }\n    }\n\n    if(needsUpdate) {\n        this.surface.update({ levels: nlevels });\n    }\n};\n\nproto.update = function(data) {\n    var i,\n        scene = this.scene,\n        sceneLayout = scene.fullSceneLayout,\n        surface = this.surface,\n        alpha = data.opacity,\n        colormap = parseColorScale(data.colorscale, alpha),\n        z = data.z,\n        x = data.x,\n        y = data.y,\n        xaxis = sceneLayout.xaxis,\n        yaxis = sceneLayout.yaxis,\n        zaxis = sceneLayout.zaxis,\n        scaleFactor = scene.dataScale,\n        xlen = z[0].length,\n        ylen = z.length,\n        coords = [\n            ndarray(new Float32Array(xlen * ylen), [xlen, ylen]),\n            ndarray(new Float32Array(xlen * ylen), [xlen, ylen]),\n            ndarray(new Float32Array(xlen * ylen), [xlen, ylen])\n        ],\n        xc = coords[0],\n        yc = coords[1],\n        contourLevels = scene.contourLevels;\n\n    // Save data\n    this.data = data;\n\n    /*\n     * Fill and transpose zdata.\n     * Consistent with 'heatmap' and 'contour', plotly 'surface'\n     * 'z' are such that sub-arrays correspond to y-coords\n     * and that the sub-array entries correspond to a x-coords,\n     * which is the transpose of 'gl-surface-plot'.\n     */\n\n    var xcalendar = data.xcalendar,\n        ycalendar = data.ycalendar,\n        zcalendar = data.zcalendar;\n\n    fill(coords[2], function(row, col) {\n        return zaxis.d2l(z[col][row], 0, zcalendar) * scaleFactor[2];\n    });\n\n    // coords x\n    if(Array.isArray(x[0])) {\n        fill(xc, function(row, col) {\n            return xaxis.d2l(x[col][row], 0, xcalendar) * scaleFactor[0];\n        });\n    } else {\n        // ticks x\n        fill(xc, function(row) {\n            return xaxis.d2l(x[row], 0, xcalendar) * scaleFactor[0];\n        });\n    }\n\n    // coords y\n    if(Array.isArray(y[0])) {\n        fill(yc, function(row, col) {\n            return yaxis.d2l(y[col][row], 0, ycalendar) * scaleFactor[1];\n        });\n    } else {\n        // ticks y\n        fill(yc, function(row, col) {\n            return yaxis.d2l(y[col], 0, ycalendar) * scaleFactor[1];\n        });\n    }\n\n    var params = {\n        colormap: colormap,\n        levels: [[], [], []],\n        showContour: [true, true, true],\n        showSurface: !data.hidesurface,\n        contourProject: [\n            [false, false, false],\n            [false, false, false],\n            [false, false, false]\n        ],\n        contourWidth: [1, 1, 1],\n        contourColor: [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\n        contourTint: [1, 1, 1],\n        dynamicColor: [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\n        dynamicWidth: [1, 1, 1],\n        dynamicTint: [1, 1, 1],\n        opacity: data.opacity\n    };\n\n    params.intensityBounds = [data.cmin, data.cmax];\n\n    // Refine if necessary\n    if(data.surfacecolor) {\n        var intensity = ndarray(new Float32Array(xlen * ylen), [xlen, ylen]);\n\n        fill(intensity, function(row, col) {\n            return data.surfacecolor[col][row];\n        });\n\n        coords.push(intensity);\n    }\n    else {\n        // when 'z' is used as 'intensity',\n        // we must scale its value\n        params.intensityBounds[0] *= scaleFactor[2];\n        params.intensityBounds[1] *= scaleFactor[2];\n    }\n\n    this.dataScale = refine(coords);\n\n    if(data.surfacecolor) {\n        params.intensity = coords.pop();\n    }\n\n    var highlightEnable = [true, true, true];\n    var axis = ['x', 'y', 'z'];\n\n    for(i = 0; i < 3; ++i) {\n        var contourParams = data.contours[axis[i]];\n        highlightEnable[i] = contourParams.highlight;\n\n        params.showContour[i] = contourParams.show || contourParams.highlight;\n        if(!params.showContour[i]) continue;\n\n        params.contourProject[i] = [\n            contourParams.project.x,\n            contourParams.project.y,\n            contourParams.project.z\n        ];\n\n        if(contourParams.show) {\n            this.showContour[i] = true;\n            params.levels[i] = contourLevels[i];\n            surface.highlightColor[i] = params.contourColor[i] = str2RgbaArray(contourParams.color);\n\n            if(contourParams.usecolormap) {\n                surface.highlightTint[i] = params.contourTint[i] = 0;\n            }\n            else {\n                surface.highlightTint[i] = params.contourTint[i] = 1;\n            }\n            params.contourWidth[i] = contourParams.width;\n        } else {\n            this.showContour[i] = false;\n        }\n\n        if(contourParams.highlight) {\n            params.dynamicColor[i] = str2RgbaArray(contourParams.highlightcolor);\n            params.dynamicWidth[i] = contourParams.highlightwidth;\n        }\n    }\n\n    // see https://github.com/plotly/plotly.js/issues/940\n    if(isColormapCircular(colormap)) {\n        params.vertexColor = true;\n    }\n\n    params.coords = coords;\n\n    surface.update(params);\n\n    surface.visible = data.visible;\n    surface.enableDynamic = highlightEnable;\n\n    surface.snapToData = true;\n\n    if('lighting' in data) {\n        surface.ambientLight = data.lighting.ambient;\n        surface.diffuseLight = data.lighting.diffuse;\n        surface.specularLight = data.lighting.specular;\n        surface.roughness = data.lighting.roughness;\n        surface.fresnel = data.lighting.fresnel;\n    }\n\n    if('lightposition' in data) {\n        surface.lightPosition = [data.lightposition.x, data.lightposition.y, data.lightposition.z];\n    }\n\n    if(alpha && alpha < 1) {\n        surface.supportsTransparency = true;\n    }\n};\n\nproto.dispose = function() {\n    this.scene.glplot.remove(this.surface);\n    this.surface.dispose();\n};\n\nfunction createSurfaceTrace(scene, data) {\n    var gl = scene.glplot.gl;\n    var surface = createSurface({ gl: gl });\n    var result = new SurfaceTrace(scene, surface, data.uid);\n    surface._trace = result;\n    result.update(data);\n    scene.glplot.add(surface);\n    return result;\n}\n\nmodule.exports = createSurfaceTrace;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/tasks/baseline.js":"var constants = require('./util/constants');\nvar common = require('./util/common');\nvar containerCommands = require('./util/container_commands');\n\nvar msg = [\n    'Generating baseline image(s) using build/plotly.js from',\n    common.getTimeLastModified(constants.pathToPlotlyBuild),\n    '\\n'\n].join(' ');\n\nvar cmd = containerCommands.getRunCmd(\n    process.env.CIRCLECI,\n    'node test/image/make_baseline.js ' + process.argv.slice(2).join(' ')\n);\n\nconsole.log(msg);\ncommon.execCmd(cmd);\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/tasks/util/constants.js":"var path = require('path');\nvar pkg = require('../../package.json');\n\nvar pathToRoot = path.join(__dirname, '../../');\nvar pathToSrc = path.join(pathToRoot, 'src/');\nvar pathToLib = path.join(pathToRoot, 'lib/');\nvar pathToImageTest = path.join(pathToRoot, 'test/image');\nvar pathToDist = path.join(pathToRoot, 'dist/');\nvar pathToBuild = path.join(pathToRoot, 'build/');\n\nvar pathToTopojsonSrc = path.join(\n    path.dirname(require.resolve('sane-topojson')), 'dist/'\n);\n\nvar partialBundleNames = [\n    'basic', 'cartesian', 'geo', 'gl3d', 'gl2d', 'mapbox', 'finance'\n];\n\nvar partialBundlePaths = partialBundleNames.map(function(name) {\n    return {\n        name: name,\n        index: path.join(pathToLib, 'index-' + name + '.js'),\n        dist: path.join(pathToDist, 'plotly-' + name + '.js'),\n        distMin: path.join(pathToDist, 'plotly-' + name + '.min.js')\n    };\n});\n\nvar year = (new Date()).getFullYear();\n\nmodule.exports = {\n    pathToRoot: pathToRoot,\n    pathToSrc: pathToSrc,\n    pathToLib: pathToLib,\n    pathToBuild: pathToBuild,\n    pathToDist: pathToDist,\n\n    pathToPlotlyIndex: path.join(pathToLib, 'index.js'),\n    pathToPlotlyCore: path.join(pathToSrc, 'core.js'),\n    pathToPlotlyBuild: path.join(pathToBuild, 'plotly.js'),\n    pathToPlotlyDist: path.join(pathToDist, 'plotly.js'),\n    pathToPlotlyDistMin: path.join(pathToDist, 'plotly.min.js'),\n    pathToPlotlyDistWithMeta: path.join(pathToDist, 'plotly-with-meta.js'),\n\n    partialBundleNames: partialBundleNames,\n    partialBundlePaths: partialBundlePaths,\n\n    pathToTopojsonSrc: pathToTopojsonSrc,\n    pathToTopojsonDist: path.join(pathToDist, 'topojson/'),\n    pathToPlotlyGeoAssetsSrc: path.join(pathToSrc, 'assets/geo_assets.js'),\n    pathToPlotlyGeoAssetsDist: path.join(pathToDist, 'plotly-geo-assets.js'),\n\n    pathToFontSVG: path.join(pathToSrc, 'fonts/ploticon/ploticon.svg'),\n    pathToFontSVGBuild: path.join(pathToBuild, 'ploticon.js'),\n\n    pathToSCSS: path.join(pathToSrc, 'css/style.scss'),\n    pathToCSSBuild: path.join(pathToBuild, 'plotcss.js'),\n\n    pathToTestDashboardBundle: path.join(pathToBuild, 'test_dashboard-bundle.js'),\n    pathToImageViewerBundle: path.join(pathToBuild, 'image_viewer-bundle.js'),\n\n    pathToTestImageMocks: path.join(pathToImageTest, 'mocks/'),\n    pathToTestImageBaselines: path.join(pathToImageTest, 'baselines/'),\n    pathToTestImages: path.join(pathToBuild, 'test_images/'),\n    pathToTestImagesDiff: path.join(pathToBuild, 'test_images_diff/'),\n    pathToTestImagesDiffList: path.join(pathToBuild, 'list_of_incorrect_images.txt'),\n\n    pathToJasmineTests: path.join(pathToRoot, 'test/jasmine/tests'),\n    pathToJasmineBundleTests: path.join(pathToRoot, 'test/jasmine/bundle_tests'),\n    pathToRequireJS: path.join(pathToRoot, 'node_modules', 'requirejs', 'require.js'),\n    pathToRequireJSFixture: path.join(pathToBuild, 'requirejs_fixture.js'),\n\n    // this mapbox access token is 'public', no need to hide it\n    // more info: https://www.mapbox.com/help/define-access-token/\n    mapboxAccessToken: 'pk.eyJ1IjoiZXRwaW5hcmQiLCJhIjoiY2luMHIzdHE0MGFxNXVubTRxczZ2YmUxaCJ9.hwWZful0U2CQxit4ItNsiQ',\n    pathToCredentials: path.join(pathToBuild, 'credentials.json'),\n\n    testContainerImage: 'plotly/testbed:latest',\n    testContainerName: process.env.PLOTLYJS_TEST_CONTAINER_NAME || 'imagetest',\n    testContainerPort: '9010',\n    testContainerUrl: 'http://localhost:9010/',\n    testContainerHome: '/var/www/streambed/image_server/plotly.js',\n\n    uglifyOptions: {\n        fromString: true,\n        mangle: true,\n        compress: {\n            warnings: false,\n            screw_ie8: true\n        },\n        output: {\n            beautify: false,\n            ascii_only: true\n        }\n    },\n\n    licenseDist: [\n        '/**',\n        '* plotly.js v' + pkg.version,\n        '* Copyright 2012-' + year + ', Plotly, Inc.',\n        '* All rights reserved.',\n        '* Licensed under the MIT license',\n        '*/'\n    ].join('\\n'),\n\n    licenseSrc: [\n        '/**',\n        '* Copyright 2012-' + year + ', Plotly, Inc.',\n        '* All rights reserved.',\n        '*',\n        '* This source code is licensed under the MIT license found in the',\n        '* LICENSE file in the root directory of this source tree.',\n        '*/'\n    ].join('\\n')\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/tasks/util/common.js":"var fs = require('fs');\nvar exec = require('child_process').exec;\n\nexports.execCmd = function(cmd, cb, errorCb) {\n    cb = cb ? cb : function() {};\n    errorCb = errorCb ? errorCb : function(err) { if(err) throw err; };\n\n    exec(cmd, function(err) {\n        errorCb(err);\n        cb();\n    })\n    .stdout.pipe(process.stdout);\n};\n\nexports.writeFile = function(filePath, content, cb) {\n    fs.writeFile(filePath, content, function(err) {\n        if(err) throw err;\n        if(cb) cb();\n    });\n};\n\nexports.doesDirExist = function(dirPath) {\n    try {\n        if(fs.statSync(dirPath).isDirectory()) return true;\n    }\n    catch(e) {\n        return false;\n    }\n\n    return false;\n};\n\nexports.doesFileExist = function(filePath) {\n    try {\n        if(fs.statSync(filePath).isFile()) return true;\n    }\n    catch(e) {\n        return false;\n    }\n\n    return false;\n};\n\nexports.formatTime = function(date) {\n    return [\n        date.toLocaleDateString(),\n        date.toLocaleTimeString(),\n        date.toString().match(/\\(([A-Za-z\\s].*)\\)/)[1]\n    ].join(' ');\n};\n\nexports.getTimeLastModified = function(filePath) {\n    if(!exports.doesFileExist(filePath)) {\n        throw new Error(filePath + ' does not exist');\n    }\n\n    var stats = fs.statSync(filePath),\n        formattedTime = exports.formatTime(stats.mtime);\n\n    return formattedTime;\n};\n\nexports.touch = function(filePath) {\n    fs.closeSync(fs.openSync(filePath, 'w'));\n};\n\nexports.throwOnError = function(err) {\n    if(err) throw err;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/tasks/util/container_commands.js":"var constants = require('./constants');\n\nvar containerCommands = {\n    cdHome: 'cd ' + constants.testContainerHome,\n    cpIndex: 'cp -f test/image/index.html ../server_app/index.html',\n    injectEnv: [\n        'sed -i',\n        's/process.env.PLOTLY_MAPBOX_DEFAULT_ACCESS_TOKEN/\\\\\\'' + constants.mapboxAccessToken + '\\\\\\'/',\n        '../server_app/main.js'\n    ].join(' '),\n    restart: 'supervisorctl restart nw1'\n};\n\ncontainerCommands.ping = [\n    'wget',\n    '--server-response --spider --tries=20 --retry-connrefused',\n    constants.testContainerUrl + 'ping'\n].join(' ');\n\ncontainerCommands.setup = [\n    containerCommands.cpIndex,\n    containerCommands.injectEnv,\n    containerCommands.restart,\n    'sleep 1',\n].join(' && ');\n\ncontainerCommands.dockerRun = [\n    'docker run -d',\n    '--name', constants.testContainerName,\n    '-v', constants.pathToRoot + ':' + constants.testContainerHome,\n    '-p', constants.testContainerPort + ':' + constants.testContainerPort,\n    constants.testContainerImage\n].join(' ');\n\ncontainerCommands.getRunCmd = function(isCI, commands) {\n    var _commands = Array.isArray(commands) ? commands.slice() : [commands];\n\n    if(isCI) return getRunCI(_commands);\n\n    // add setup commands locally\n    _commands = [containerCommands.setup].concat(_commands);\n    return getRunLocal(_commands);\n};\n\nfunction getRunLocal(commands) {\n    commands = [containerCommands.cdHome].concat(commands);\n\n    var commandsJoined = '\"' + commands.join(' && ') + '\"';\n\n    return [\n        'docker exec -i',\n        constants.testContainerName,\n        '/bin/bash -c',\n        commandsJoined\n    ].join(' ');\n}\n\nfunction getRunCI(commands) {\n    commands = ['export CIRCLECI=1', containerCommands.cdHome].concat(commands);\n\n    var commandsJoined = '\"' + commands.join(' && ') + '\"';\n\n    return [\n        'sudo',\n        'lxc-attach -n',\n        '$(docker inspect --format \\'{{.Id}}\\' ' + constants.testContainerName + ')',\n        '-- bash -c',\n        commandsJoined\n    ].join(' ');\n}\n\nmodule.exports = containerCommands;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/tasks/bundle.js":"var constants = require('./util/constants');\nvar common = require('./util/common');\nvar _bundle = require('./util/browserify_wrapper');\n\n/*\n * This script takes one argument\n *\n * Run `npm run build -- dev` or `npm run build -- --dev`\n * to include source map in the plotly.js bundle\n *\n * N.B. This script is meant for dist builds; the output bundles are placed\n *      in plotly.js/dist/.\n *      Use `npm run watch` for dev builds.\n */\n\nvar arg = process.argv[2];\nvar DEV = (arg === 'dev') || (arg === '--dev');\n\n\n// Check if style and font build files are there\nvar doesFileExist = common.doesFileExist;\nif(!doesFileExist(constants.pathToCSSBuild) || !doesFileExist(constants.pathToFontSVG)) {\n    throw new Error([\n        'build/ is missing one or more files',\n        'Please run `npm run preprocess` first'\n    ].join('\\n'));\n}\n\n// Browserify plotly.js\n_bundle(constants.pathToPlotlyIndex, constants.pathToPlotlyDist, {\n    standalone: 'Plotly',\n    debug: DEV,\n    pathToMinBundle: constants.pathToPlotlyDistMin\n});\n\n// Browserify the geo assets\n_bundle(constants.pathToPlotlyGeoAssetsSrc, constants.pathToPlotlyGeoAssetsDist, {\n    standalone: 'PlotlyGeoAssets'\n});\n\n// Browserify the plotly.js with meta\n_bundle(constants.pathToPlotlyIndex, constants.pathToPlotlyDistWithMeta, {\n    standalone: 'Plotly',\n    debug: DEV\n});\n\n// Browserify the plotly.js partial bundles\nconstants.partialBundlePaths.forEach(function(pathObj) {\n    _bundle(pathObj.index, pathObj.dist, {\n        standalone: 'Plotly',\n        debug: DEV,\n        pathToMinBundle: pathObj.distMin\n    });\n});\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/tasks/util/browserify_wrapper.js":"var fs = require('fs');\nvar path = require('path');\n\nvar browserify = require('browserify');\nvar UglifyJS = require('uglify-js');\n\nvar constants = require('./constants');\nvar compressAttributes = require('./compress_attributes');\nvar patchMinified = require('./patch_minified');\n\n/** Convenience browserify wrapper\n *\n * @param {string} pathToIndex path to index file to bundle\n * @param {string} pathToBunlde path to destination bundle\n *\n * @param {object} opts\n *\n *  Browserify options:\n *  - standalone {string}\n *  - debug {boolean} [optional]\n *\n *  Additional option:\n *  - pathToMinBundle {string} path to destination minified bundle\n *\n * Outputs one bundle (un-minified) file if opts.pathToMinBundle is omitted\n * or opts.debug is true. Otherwise outputs two file: one un-minified bundle and\n * one minified bundle.\n *\n * Logs basename of bundle when completed.\n */\nmodule.exports = function _bundle(pathToIndex, pathToBundle, opts) {\n    opts = opts || {};\n\n    // do we output a minified file?\n    var pathToMinBundle = opts.pathToMinBundle,\n        outputMinified = !!pathToMinBundle && !opts.debug;\n\n    var browserifyOpts = {};\n    browserifyOpts.standalone = opts.standalone;\n    browserifyOpts.debug = opts.debug;\n    browserifyOpts.transform = outputMinified ? [compressAttributes] : [];\n\n    var b = browserify(pathToIndex, browserifyOpts),\n        bundleWriteStream = fs.createWriteStream(pathToBundle);\n\n    bundleWriteStream.on('finish', function() {\n        logger(pathToBundle);\n    });\n\n    b.bundle(function(err, buf) {\n        if(err) throw err;\n\n        if(outputMinified) {\n            var minifiedCode = UglifyJS.minify(buf.toString(), constants.uglifyOptions).code;\n            minifiedCode = patchMinified(minifiedCode);\n\n            fs.writeFile(pathToMinBundle, minifiedCode, function(err) {\n                if(err) throw err;\n\n                logger(pathToMinBundle);\n            });\n        }\n    })\n    .pipe(bundleWriteStream);\n};\n\nfunction logger(pathToOutput) {\n    var log = 'ok ' + path.basename(pathToOutput);\n\n    console.log(log);\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/tasks/cibundle.js":"var constants = require('./util/constants');\nvar _bundle = require('./util/browserify_wrapper');\n\n/*\n * Trimmed down version of ./bundle.js for CI testing\n *\n * Outputs:\n *\n *  - plotly.js bundle in build/\n *  - plotly-geo-assets.js bundle in dist/ (in accordance with test/image/index.html)\n *  - plotly.min.js bundle in dist/ (for requirejs test)\n */\n\n\n// Browserify plotly.js and plotly.min.js\n_bundle(constants.pathToPlotlyIndex, constants.pathToPlotlyBuild, {\n    standalone: 'Plotly',\n    pathToMinBundle: constants.pathToPlotlyDistMin,\n});\n\n// Browserify the geo assets\n_bundle(constants.pathToPlotlyGeoAssetsSrc, constants.pathToPlotlyGeoAssetsDist, {\n    standalone: 'PlotlyGeoAssets'\n});\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/tasks/docker.js":"var constants = require('./util/constants');\nvar common = require('./util/common');\nvar containerCommands = require('./util/container_commands');\n\nvar isCI = process.env.CIRCLECI;\nvar arg = process.argv[2];\n\nvar msg, cmd, cb, errorCb;\n\nswitch(arg) {\n\n    case 'pull':\n        msg = 'Pulling latest docker image';\n        cmd = 'docker pull ' + constants.testContainerImage;\n        break;\n\n    case 'run':\n        msg = 'Booting up ' + constants.testContainerName + ' docker container';\n        cmd = containerCommands.dockerRun;\n\n        // if docker-run fails, try docker-start.\n        errorCb = function(err) {\n            if(err) common.execCmd('docker start ' + constants.testContainerName);\n        };\n\n        break;\n\n    case 'setup':\n        msg = 'Setting up ' + constants.testContainerName + ' docker container for testing';\n        cmd = containerCommands.getRunCmd(isCI, containerCommands.setup);\n        break;\n\n    case 'stop':\n        msg = 'Stopping ' + constants.testContainerName + ' docker container';\n        cmd = 'docker stop ' + constants.testContainerName;\n        break;\n\n    case 'remove':\n        msg = 'Removing ' + constants.testContainerName + ' docker container';\n        cmd = 'docker rm ' + constants.testContainerName;\n        break;\n\n    default:\n        console.log('Usage: pull, run, setup, stop, remove');\n        process.exit(0);\n        break;\n}\n\nconsole.log(msg);\ncommon.execCmd(cmd, cb, errorCb);\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/tasks/header.js":"var path = require('path');\nvar fs = require('fs');\n\nvar prependFile = require('prepend-file');\nvar falafel = require('falafel');\nvar glob = require('glob');\n\nvar constants = require('./util/constants');\nvar common = require('./util/common');\n\n// main\naddHeadersInDistFiles();\nupdateHeadersInSrcFiles();\n\n// add headers to dist files\nfunction addHeadersInDistFiles() {\n    function _prepend(path, header) {\n        prependFile(path, header + '\\n', common.throwOnError);\n    }\n\n    // add header to main dist bundles\n    var pathsDist = [\n        constants.pathToPlotlyDistMin,\n        constants.pathToPlotlyDist,\n        constants.pathToPlotlyDistWithMeta,\n        constants.pathToPlotlyGeoAssetsDist\n    ];\n    pathsDist.forEach(function(path) {\n        _prepend(path, constants.licenseDist);\n    });\n\n    // add header and bundle name to partial bundle\n    constants.partialBundlePaths.forEach(function(pathObj) {\n        var headerDist = constants.licenseDist\n            .replace('plotly.js', 'plotly.js (' + pathObj.name + ')');\n        _prepend(pathObj.dist, headerDist);\n\n        var headerDistMin = constants.licenseDist\n            .replace('plotly.js', 'plotly.js (' + pathObj.name + ' - minified)');\n        _prepend(pathObj.distMin, headerDistMin);\n    });\n}\n\n// add or update header to src/ lib/ files\nfunction updateHeadersInSrcFiles() {\n    var srcGlob = path.join(constants.pathToSrc, '**/*.js');\n    var libGlob = path.join(constants.pathToLib, '**/*.js');\n\n    // remove leading '/*' and trailing '*/' for comparison with falafel output\n    var licenseSrc = constants.licenseSrc;\n    var licenseStr = licenseSrc.substring(2, licenseSrc.length - 2);\n\n    glob('{' + srcGlob + ',' + libGlob + '}', function(err, files) {\n        files.forEach(function(file) {\n            fs.readFile(file, 'utf-8', function(err, code) {\n\n                // parse through code string while keeping track of comments\n                var comments = [];\n                falafel(code, {onComment: comments, locations: true}, function() {});\n\n                var header = comments[0];\n\n                // error out if no header is found\n                if(!header || header.loc.start.line > 1) {\n                    throw new Error(file + ' : has no header information.');\n                }\n\n                // if header and license are the same, do nothing\n                if(isCorrect(header)) return;\n\n                // if header and license only differ by date, update header\n                else if(hasWrongDate(header)) {\n                    var codeLines = code.split('\\n');\n\n                    codeLines.splice(header.loc.start.line - 1, header.loc.end.line);\n\n                    var newCode = licenseSrc + '\\n' + codeLines.join('\\n');\n\n                    common.writeFile(file, newCode);\n                }\n                else {\n                    // otherwise, throw an error\n                    throw new Error(file + ' : has wrong header information.');\n                }\n            });\n        });\n    });\n\n    function isCorrect(header) {\n        return (header.value === licenseStr);\n    }\n\n    function hasWrongDate(header) {\n        var regex = /Copyright 20[0-9][0-9]-20[0-9][0-9]/g;\n\n        return (header.value.replace(regex, '') === licenseStr.replace(regex, ''));\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/tasks/preprocess.js":"var fs = require('fs-extra');\nvar sass = require('node-sass');\n\nvar constants = require('./util/constants');\nvar common = require('./util/common');\nvar pullCSS = require('./util/pull_css');\nvar pullFontSVG = require('./util/pull_font_svg');\nvar updateVersion = require('./util/update_version');\n\n// main\nmakeBuildCSS();\nmakeBuildFontSVG();\ncopyTopojsonFiles();\nupdateVersion(constants.pathToPlotlyCore);\nupdateVersion(constants.pathToPlotlyGeoAssetsSrc);\n\n// convert scss to css to js\nfunction makeBuildCSS() {\n    sass.render({\n        file: constants.pathToSCSS,\n        outputStyle: 'compressed'\n    }, function(err, result) {\n        if(err) throw err;\n\n        // css to js\n        pullCSS(String(result.css), constants.pathToCSSBuild);\n    });\n}\n\n// convert font svg into js\nfunction makeBuildFontSVG() {\n    fs.readFile(constants.pathToFontSVG, function(err, data) {\n        if(err) throw err;\n\n        pullFontSVG(data.toString(), constants.pathToFontSVGBuild);\n    });\n}\n\n// copy topojson files from sane-topojson to dist/\nfunction copyTopojsonFiles() {\n    fs.copy(\n        constants.pathToTopojsonSrc,\n        constants.pathToTopojsonDist,\n        { clobber: true },\n        common.throwOnError\n    );\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/tasks/pretest.js":"var fs = require('fs');\n\nvar constants = require('./util/constants');\nvar common = require('./util/common');\n\n// main\nmakeCredentialsFile();\nmakeTestImageFolders();\nmakeRequireJSFixture();\n\n// Create a credentials json file,\n// to be required in jasmine test suites and test dashboard\nfunction makeCredentialsFile() {\n    var credentials = JSON.stringify({\n        MAPBOX_ACCESS_TOKEN: constants.mapboxAccessToken\n    }, null, 2);\n\n    common.writeFile(constants.pathToCredentials, credentials);\n    logger('make build/credentials.json');\n}\n\n// Make artifact folders for image tests\nfunction makeTestImageFolders() {\n\n    function makeOne(folderPath, info) {\n        if(!common.doesDirExist(folderPath)) {\n            fs.mkdirSync(folderPath);\n            logger('initialize ' + info);\n        }\n        else logger(info + ' is present');\n    }\n\n    makeOne(constants.pathToTestImages, 'test image folder');\n    makeOne(constants.pathToTestImagesDiff, 'test image diff folder');\n}\n\n// Make script file that define plotly in a RequireJS context\nfunction makeRequireJSFixture() {\n    var bundle = fs.readFileSync(constants.pathToPlotlyDistMin, 'utf-8');\n\n    var index = [\n        'define(\\'plotly\\', function(require, exports, module) {',\n        bundle,\n        '});'\n    ].join('');\n\n    common.writeFile(constants.pathToRequireJSFixture, index);\n    logger('make build/requirejs_fixture.js');\n}\n\nfunction logger(task) {\n    console.log('ok ' + task);\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/tasks/stats.js":"var path = require('path');\nvar fs = require('fs');\nvar spawn = require('child_process').spawn;\n\nvar falafel = require('falafel');\nvar gzipSize = require('gzip-size');\nvar prettySize = require('prettysize');\n\nvar common = require('./util/common');\nvar constants = require('./util/constants');\nvar pkg = require('../package.json');\n\nvar pathDistREADME = path.join(constants.pathToDist, 'README.md');\nvar pathDistNpmLs = path.join(constants.pathToDist, 'npm-ls.json');\nvar cdnRoot = 'https://cdn.plot.ly/plotly-';\nvar coreModules = ['scatter'];\n\nvar ENC = 'utf-8';\nvar JS = '.js';\nvar MINJS = '.min.js';\n\n// main\nwriteNpmLs();\ncommon.writeFile(pathDistREADME, getReadMeContent());\n\nfunction writeNpmLs() {\n    if(common.doesFileExist(pathDistNpmLs)) fs.unlinkSync(pathDistNpmLs);\n\n    var ws = fs.createWriteStream(pathDistNpmLs, { flags: 'a' });\n    var proc = spawn('npm', ['ls', '--json', '--only', 'prod']);\n\n    proc.stdout.pipe(ws);\n}\n\nfunction getReadMeContent() {\n    return []\n        .concat(getInfoContent())\n        .concat(getMainBundleInfo())\n        .concat(getPartialBundleInfo())\n        .concat(getFooter())\n        .join('\\n');\n}\n\n// general info about distributed files\nfunction getInfoContent() {\n    return [\n        '# Using distributed files',\n        '',\n        'All plotly.js dist bundles inject an object `Plotly` into the global scope.',\n        '',\n        'Import plotly.js as:',\n        '',\n        '```html',\n        '<script type=\"text/javascript\" src=\"plotly.min.js\"></script>',\n        '```',\n        '',\n        'or the un-minified version as:',\n        '',\n        '```html',\n        '<script type=\"text/javascript\" src=\"plotly.js\" charset=\"utf-8\"></script>',\n        '```',\n        '',\n        'To support IE9, put:',\n        '',\n        '```html',\n        '<script>if(typeof window.Int16Array !== \\'function\\')document.write(\"<scri\"+\"pt src=\\'extras/typedarray.min.js\\'></scr\"+\"ipt>\");</script>',\n        '<script>document.write(\"<scri\"+\"pt src=\\'extras/request_animation_frame.js\\'></scr\"+\"ipt>\");</script>',\n        '```',\n        '',\n        'before the plotly.js script tag.',\n        '',\n        'To add MathJax, put',\n        '',\n        '```html',\n        '<script type=\"text/javascript\" src=\"mathjax/MathJax.js?config=TeX-AMS-MML_SVG\"></script>',\n        '```',\n        '',\n        'before the plotly.js script tag. You can grab the relevant MathJax files in `./dist/extras/mathjax/`.',\n        ''\n    ];\n}\n\n// info about main bundle\nfunction getMainBundleInfo() {\n    var mainSizes = findSizes({\n        dist: constants.pathToPlotlyDist,\n        distMin: constants.pathToPlotlyDistMin,\n        withMeta: constants.pathToPlotlyDistWithMeta\n    });\n\n    return [\n        '# Bundle information',\n        '',\n        'The main plotly.js bundle includes all the official (non-beta) trace modules.',\n        '',\n        'It be can imported as minified javascript',\n        '- using dist file `dist/plotly.min.js`',\n        '- using CDN URL ' + cdnRoot + 'latest' + MINJS + ' OR ' + cdnRoot + pkg.version + MINJS,\n        '',\n        'or as raw javascript:',\n        '- using dist file `dist/plotly.js`',\n        '- using CDN URL ' + cdnRoot + 'latest' + JS + ' OR ' + cdnRoot + pkg.version + JS,\n        '- using CommonJS with `require(\\'plotly.js\\')`',\n        '',\n        'If you would like to have access to the attribute meta information ' +\n        '(including attribute descriptions as on the [schema reference page](https://plot.ly/javascript/reference/)), ' +\n        'use dist file `dist/plotly-with-meta.js`',\n        '',\n        'The main plotly.js bundle weights in at:',\n        '',\n        '| plotly.js | plotly.min.js | plotly.min.js + gzip | plotly-with-meta.js |',\n        '|-----------|---------------|----------------------|---------------------|',\n        '| ' + mainSizes.raw + ' | ' + mainSizes.minified + ' | ' + mainSizes.gzipped + ' | ' + mainSizes.withMeta + ' |',\n        '',\n        '## Partial bundles',\n        '',\n        'Starting in `v1.15.0`, plotly.js also ships with several _partial_ bundles:',\n        '',\n        constants.partialBundlePaths.map(makeBundleHeaderInfo).join('\\n'),\n        ''\n    ];\n}\n\n// info about partial bundles\nfunction getPartialBundleInfo() {\n    return constants.partialBundlePaths.map(makeBundleInfo);\n}\n\n// footer info\nfunction getFooter() {\n    return [\n        '----------------',\n        '',\n        '_This file is auto-generated by `npm run stats`. ' +\n        'Please do not edit this file directly._'\n    ];\n}\n\nfunction makeBundleHeaderInfo(pathObj) {\n    var name = pathObj.name;\n    return '- [' + name + '](#plotlyjs-' + name + ')';\n}\n\nfunction makeBundleInfo(pathObj) {\n    var name = pathObj.name;\n    var sizes = findSizes(pathObj);\n    var moduleList = coreModules.concat(scrapeContent(pathObj));\n\n    return [\n        '### plotly.js ' + name,\n        '',\n        formatBundleInfo(name, moduleList),\n        '',\n        '| Way to import | Location |',\n        '|---------------|----------|',\n        '| dist bundle | ' + '`dist/plotly-' + name + JS + '` |',\n        '| dist bundle (minified) | ' + '`dist/plotly-' + name + MINJS + '` |',\n        '| CDN URL (latest) | ' + cdnRoot + name + '-latest' + JS + ' |',\n        '| CDN URL (latest minified) | ' + cdnRoot + name + '-latest' + MINJS + ' |',\n        '| CDN URL (tagged) | ' + cdnRoot + name + '-' + pkg.version + JS + ' |',\n        '| CDN URL (tagged minified) | ' + cdnRoot + name + '-' + pkg.version + MINJS + ' |',\n        '| CommonJS | ' + '`require(\\'plotly.js/lib/' + 'index-' + name + '\\')`' + ' |',\n        '',\n        '| Raw size | Minified size | Minified + gzip size |',\n        '|------|-----------------|------------------------|',\n        '| ' + sizes.raw + ' | ' + sizes.minified + ' | ' + sizes.gzipped + ' |',\n        ''\n    ].join('\\n');\n}\n\nfunction findSizes(pathObj) {\n    var codeDist = fs.readFileSync(pathObj.dist, ENC),\n        codeDistMin = fs.readFileSync(pathObj.distMin, ENC);\n\n    var sizes = {\n        raw: prettySize(codeDist.length),\n        minified: prettySize(codeDistMin.length),\n        gzipped: prettySize(gzipSize.sync(codeDistMin))\n    };\n\n    if(pathObj.withMeta) {\n        var codeWithMeta = fs.readFileSync(pathObj.withMeta, ENC);\n        sizes.withMeta = prettySize(codeWithMeta.length);\n    }\n\n    return sizes;\n}\n\nfunction scrapeContent(pathObj) {\n    var code = fs.readFileSync(pathObj.index, ENC);\n    var moduleList = [];\n\n    falafel(code, function(node) {\n        if(isModuleNode(node)) {\n            var moduleName = node.value.replace('./', '');\n            moduleList.push(moduleName);\n        }\n    });\n\n    return moduleList;\n}\n\nfunction isModuleNode(node) {\n    return (\n        node.type === 'Literal' &&\n        node.parent &&\n        node.parent.type === 'CallExpression' &&\n        node.parent.callee &&\n        node.parent.callee.type === 'Identifier' &&\n        node.parent.callee.name === 'require' &&\n        node.parent.parent &&\n        node.parent.parent.type === 'ArrayExpression'\n    );\n}\n\nfunction formatBundleInfo(bundleName, moduleList) {\n    var enumeration = moduleList.map(function(moduleName, i) {\n        var len = moduleList.length,\n            ending;\n\n        if(i === len - 2) ending = ' and';\n        else if(i < len - 1) ending = ',';\n        else ending = '';\n\n        return '`' + moduleName + '`' + ending;\n    });\n\n    return [\n        'The', '`' + bundleName + '`',\n        'partial bundle contains the',\n        enumeration.join(' '),\n        'trace modules.'\n    ].join(' ');\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/tasks/watch.js":"var makeWatchifiedBundle = require('./util/watchified_bundle');\nvar noop = function() {};\n\n// make a watchified bundle for plotly.js and run it!\nvar watchifiedBundle = makeWatchifiedBundle(noop);\nwatchifiedBundle();\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/tasks/util/watchified_bundle.js":"var fs = require('fs');\n\nvar browserify = require('browserify');\nvar watchify = require('watchify');\nvar prettySize = require('prettysize');\n\nvar constants = require('./constants');\nvar common = require('./common');\nvar compressAttributes = require('./compress_attributes');\n\n/**\n * Make a plotly.js browserify bundle function watched by watchify.\n *\n * N.B. This module is meant for dev builds; the output bundle is placed\n *      in plotly.js/build/\n *      Use `npm run build` for dist builds.\n *\n * @param {function} onFirstBundleCallback executed when first bundle is completed\n *\n */\nmodule.exports = function makeWatchifiedBundle(onFirstBundleCallback) {\n    var b = browserify(constants.pathToPlotlyIndex, {\n        debug: true,\n        standalone: 'Plotly',\n        transform: [compressAttributes],\n        cache: {},\n        packageCache: {},\n        plugin: [watchify]\n    });\n\n    var firstBundle = true;\n\n    if(firstBundle) {\n        console.log([\n            '***',\n            'Building the first bundle, this should take ~10 seconds',\n            '***\\n'\n        ].join(' '));\n    }\n\n    b.on('update', bundle);\n    formatBundleMsg(b, 'plotly.js');\n\n    function bundle() {\n        b.bundle(function(err) {\n            if(err) console.error(JSON.stringify(String(err)));\n\n            if(firstBundle) {\n                onFirstBundleCallback();\n                firstBundle = false;\n            }\n        })\n        .pipe(\n            fs.createWriteStream(constants.pathToPlotlyBuild)\n        );\n    }\n\n    return bundle;\n};\n\nfunction formatBundleMsg(b, bundleName) {\n    var msgParts = [\n        bundleName, ':', '',\n        'written', 'in', '', 'sec',\n        '[', '', ']'\n    ];\n\n    b.on('bytes', function(bytes) {\n        msgParts[2] = prettySize(bytes, true);\n    });\n\n    b.on('time', function(time) {\n        msgParts[5] = (time / 1000).toFixed(2);\n    });\n\n    b.on('log', function() {\n        var formattedTime = common.formatTime(new Date());\n\n        msgParts[msgParts.length - 2] = formattedTime;\n\n        console.log(msgParts.join(' '));\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/constants/gl2d_dashes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nmodule.exports = {\n    solid: [1],\n    dot: [1, 1],\n    dash: [4, 1],\n    longdash: [8, 1],\n    dashdot: [4, 1, 1, 1],\n    longdashdot: [8, 1, 1, 1]\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/fonts/mathjax_config.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n/* global MathJax:false */\n\n/**\n * Check and configure MathJax\n */\nif(typeof MathJax !== 'undefined') {\n    exports.MathJax = true;\n\n    MathJax.Hub.Config({\n        messageStyle: 'none',\n        skipStartupTypeset: true,\n        displayAlign: 'left',\n        tex2jax: {\n            inlineMath: [['$', '$'], ['\\\\(', '\\\\)']]\n        }\n    });\n\n    MathJax.Hub.Configured();\n} else {\n    exports.MathJax = false;\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/lib/array_to_calc_item.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\n// similar to Lib.mergeArray, but using inside a loop\nmodule.exports = function arrayToCalcItem(traceAttr, calcItem, calcAttr, i) {\n    if(Array.isArray(traceAttr)) calcItem[calcAttr] = traceAttr[i];\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/lib/geojson_utils.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar BADNUM = require('../constants/numerical').BADNUM;\n\n/**\n * Convert calcTrace to GeoJSON 'MultiLineString' coordinate arrays\n *\n * @param {object} calcTrace\n *  gd.calcdata item.\n *  Note that calcTrace[i].lonlat is assumed to be defined\n *\n * @return {array}\n *  return line coords array (or array of arrays)\n *\n */\nexports.calcTraceToLineCoords = function(calcTrace) {\n    var trace = calcTrace[0].trace;\n    var connectgaps = trace.connectgaps;\n\n    var coords = [];\n    var lineString = [];\n\n    for(var i = 0; i < calcTrace.length; i++) {\n        var calcPt = calcTrace[i];\n        var lonlat = calcPt.lonlat;\n\n        if(lonlat[0] !== BADNUM) {\n            lineString.push(lonlat);\n        } else if(!connectgaps && lineString.length > 0) {\n            coords.push(lineString);\n            lineString = [];\n        }\n    }\n\n    if(lineString.length > 0) {\n        coords.push(lineString);\n    }\n\n    return coords;\n};\n\n\n/**\n * Make line ('LineString' or 'MultiLineString') GeoJSON\n *\n * @param {array} coords\n *  results form calcTraceToLineCoords\n * @param {object} trace\n *  (optional) full trace object to be added on to output\n *\n * @return {object} out\n *  GeoJSON object\n *\n */\nexports.makeLine = function(coords, trace) {\n    var out = {};\n\n    if(coords.length === 1) {\n        out = {\n            type: 'LineString',\n            coordinates: coords[0]\n        };\n    }\n    else {\n        out = {\n            type: 'MultiLineString',\n            coordinates: coords\n        };\n    }\n\n    if(trace) out.trace = trace;\n\n    return out;\n};\n\n/**\n * Make polygon ('Polygon' or 'MultiPolygon') GeoJSON\n *\n * @param {array} coords\n *  results form calcTraceToLineCoords\n * @param {object} trace\n *  (optional) full trace object to be added on to output\n *\n * @return {object} out\n *  GeoJSON object\n */\nexports.makePolygon = function(coords, trace) {\n    var out = {};\n\n    if(coords.length === 1) {\n        out = {\n            type: 'Polygon',\n            coordinates: coords\n        };\n    }\n    else {\n        var _coords = new Array(coords.length);\n\n        for(var i = 0; i < coords.length; i++) {\n            _coords[i] = [coords[i]];\n        }\n\n        out = {\n            type: 'MultiPolygon',\n            coordinates: _coords\n        };\n    }\n\n    if(trace) out.trace = trace;\n\n    return out;\n};\n\n/**\n * Make blank GeoJSON\n *\n * @return {object}\n *  Blank GeoJSON object\n *\n */\nexports.makeBlank = function() {\n    return {\n        type: 'Point',\n        coordinates: []\n    };\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/lib/geo_location_utils.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar countryRegex = require('country-regex');\nvar Lib = require('../lib');\n\n\n// make list of all country iso3 ids from at runtime\nvar countryIds = Object.keys(countryRegex);\n\nvar locationmodeToIdFinder = {\n    'ISO-3': Lib.identity,\n    'USA-states': Lib.identity,\n    'country names': countryNameToISO3\n};\n\nexports.locationToFeature = function(locationmode, location, features) {\n    var locationId = getLocationId(locationmode, location);\n\n    if(locationId) {\n        for(var i = 0; i < features.length; i++) {\n            var feature = features[i];\n\n            if(feature.id === locationId) return feature;\n        }\n\n        Lib.warn([\n            'Location with id', locationId,\n            'does not have a matching topojson feature at this resolution.'\n        ].join(' '));\n    }\n\n    return false;\n};\n\nfunction getLocationId(locationmode, location) {\n    var idFinder = locationmodeToIdFinder[locationmode];\n    return idFinder(location);\n}\n\nfunction countryNameToISO3(countryName) {\n    for(var i = 0; i < countryIds.length; i++) {\n        var iso3 = countryIds[i],\n            regex = new RegExp(countryRegex[iso3]);\n\n        if(regex.test(countryName.trim().toLowerCase())) return iso3;\n    }\n\n    Lib.warn('Unrecognized country name: ' + countryName + '.');\n\n    return false;\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/lib/html2unicode.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar toSuperScript = require('superscript-text');\nvar stringMappings = require('../constants/string_mappings');\n\nfunction fixSuperScript(x) {\n    var idx = 0;\n\n    while((idx = x.indexOf('<sup>', idx)) >= 0) {\n        var nidx = x.indexOf('</sup>', idx);\n        if(nidx < idx) break;\n\n        x = x.slice(0, idx) + toSuperScript(x.slice(idx + 5, nidx)) + x.slice(nidx + 6);\n    }\n\n    return x;\n}\n\nfunction fixBR(x) {\n    return x.replace(/\\<br\\>/g, '\\n');\n}\n\nfunction stripTags(x) {\n    return x.replace(/\\<.*\\>/g, '');\n}\n\nfunction fixEntities(x) {\n    var entityToUnicode = stringMappings.entityToUnicode;\n    var idx = 0;\n\n    while((idx = x.indexOf('&', idx)) >= 0) {\n        var nidx = x.indexOf(';', idx);\n        if(nidx < idx) {\n            idx += 1;\n            continue;\n        }\n\n        var entity = entityToUnicode[x.slice(idx + 1, nidx)];\n        if(entity) {\n            x = x.slice(0, idx) + entity + x.slice(nidx + 1);\n        } else {\n            x = x.slice(0, idx) + x.slice(nidx + 1);\n        }\n    }\n\n    return x;\n}\n\nfunction convertHTMLToUnicode(html) {\n    return '' +\n        fixEntities(\n        stripTags(\n        fixSuperScript(\n        fixBR(\n          html))));\n}\n\nmodule.exports = convertHTMLToUnicode;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/lib/show_no_webgl_msg.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Color = require('../components/color');\n\nvar noop = function() {};\n\n\n/**\n * Prints a no webgl error message into the scene container\n * @param {scene instance} scene\n *\n * Expects 'scene' to have property 'container'\n *\n */\nmodule.exports = function showWebGlMsg(scene) {\n    for(var prop in scene) {\n        if(typeof scene[prop] === 'function') scene[prop] = noop;\n    }\n\n    scene.destroy = function() {\n        scene.container.parentNode.removeChild(scene.container);\n    };\n\n    var div = document.createElement('div');\n    div.textContent = 'Webgl is not supported by your browser - visit http://get.webgl.org for more info';\n    div.style.cursor = 'pointer';\n    div.style.fontSize = '24px';\n    div.style.color = Color.defaults[0];\n\n    scene.container.appendChild(div);\n    scene.container.style.background = '#FFFFFF';\n    scene.container.onclick = function() {\n        window.open('http://get.webgl.org');\n    };\n\n    // return before setting up camera and onrender methods\n    return false;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/lib/topojson_utils.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar topojsonUtils = module.exports = {};\n\nvar locationmodeToLayer = require('../plots/geo/constants').locationmodeToLayer;\nvar topojsonFeature = require('topojson-client').feature;\n\n\ntopojsonUtils.getTopojsonName = function(geoLayout) {\n    return [\n        geoLayout.scope.replace(/ /g, '-'), '_',\n        geoLayout.resolution.toString(), 'm'\n    ].join('');\n};\n\ntopojsonUtils.getTopojsonPath = function(topojsonURL, topojsonName) {\n    return topojsonURL + topojsonName + '.json';\n};\n\ntopojsonUtils.getTopojsonFeatures = function(trace, topojson) {\n    var layer = locationmodeToLayer[trace.locationmode],\n        obj = topojson.objects[layer];\n\n    return topojsonFeature(topojson, obj).features;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/geo/constants.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar params = module.exports = {};\n\n// projection names to d3 function name\nparams.projNames = {\n    // d3.geo.projection\n    'equirectangular': 'equirectangular',\n    'mercator': 'mercator',\n    'orthographic': 'orthographic',\n    'natural earth': 'naturalEarth',\n    'kavrayskiy7': 'kavrayskiy7',\n    'miller': 'miller',\n    'robinson': 'robinson',\n    'eckert4': 'eckert4',\n    'azimuthal equal area': 'azimuthalEqualArea',\n    'azimuthal equidistant': 'azimuthalEquidistant',\n    'conic equal area': 'conicEqualArea',\n    'conic conformal': 'conicConformal',\n    'conic equidistant': 'conicEquidistant',\n    'gnomonic': 'gnomonic',\n    'stereographic': 'stereographic',\n    'mollweide': 'mollweide',\n    'hammer': 'hammer',\n    'transverse mercator': 'transverseMercator',\n    'albers usa': 'albersUsa',\n    'winkel tripel': 'winkel3',\n    'aitoff': 'aitoff',\n    'sinusoidal': 'sinusoidal'\n};\n\n// name of the axes\nparams.axesNames = ['lonaxis', 'lataxis'];\n\n// max longitudinal angular span (EXPERIMENTAL)\nparams.lonaxisSpan = {\n    'orthographic': 180,\n    'azimuthal equal area': 360,\n    'azimuthal equidistant': 360,\n    'conic conformal': 180,\n    'gnomonic': 160,\n    'stereographic': 180,\n    'transverse mercator': 180,\n    '*': 360\n};\n\n// max latitudinal angular span (EXPERIMENTAL)\nparams.lataxisSpan = {\n    'conic conformal': 150,\n    'stereographic': 179.5,\n    '*': 180\n};\n\n// defaults for each scope\nparams.scopeDefaults = {\n    world: {\n        lonaxisRange: [-180, 180],\n        lataxisRange: [-90, 90],\n        projType: 'equirectangular',\n        projRotate: [0, 0, 0]\n    },\n    usa: {\n        lonaxisRange: [-180, -50],\n        lataxisRange: [15, 80],\n        projType: 'albers usa'\n    },\n    europe: {\n        lonaxisRange: [-30, 60],\n        lataxisRange: [30, 80],\n        projType: 'conic conformal',\n        projRotate: [15, 0, 0],\n        projParallels: [0, 60]\n    },\n    asia: {\n        lonaxisRange: [22, 160],\n        lataxisRange: [-15, 55],\n        projType: 'mercator',\n        projRotate: [0, 0, 0]\n    },\n    africa: {\n        lonaxisRange: [-30, 60],\n        lataxisRange: [-40, 40],\n        projType: 'mercator',\n        projRotate: [0, 0, 0]\n    },\n    'north america': {\n        lonaxisRange: [-180, -45],\n        lataxisRange: [5, 85],\n        projType: 'conic conformal',\n        projRotate: [-100, 0, 0],\n        projParallels: [29.5, 45.5]\n    },\n    'south america': {\n        lonaxisRange: [-100, -30],\n        lataxisRange: [-60, 15],\n        projType: 'mercator',\n        projRotate: [0, 0, 0]\n    }\n};\n\n// angular pad to avoid rounding error around clip angles\nparams.clipPad = 1e-3;\n\n// map projection precision\nparams.precision = 0.1;\n\n// default land and water fill colors\nparams.landColor = '#F0DC82';\nparams.waterColor = '#3399FF';\n\n// locationmode to layer name\nparams.locationmodeToLayer = {\n    'ISO-3': 'countries',\n    'USA-states': 'subunits',\n    'country names': 'countries'\n};\n\n// SVG element for a sphere (use to frame maps)\nparams.sphereSVG = {type: 'Sphere'};\n\n// N.B. base layer names must be the same as in the topojson files\n\n// base layer with a fill color\nparams.fillLayers = ['ocean', 'land', 'lakes'];\n\n// base layer with a only a line color\nparams.lineLayers = ['subunits', 'countries', 'coastlines', 'rivers', 'frame'];\n\n// all base layers - in order\nparams.baseLayers = [\n    'ocean', 'land', 'lakes',\n    'subunits', 'countries', 'coastlines', 'rivers',\n    'lataxis', 'lonaxis',\n    'frame'\n];\n\nparams.layerNameToAdjective = {\n    ocean: 'ocean',\n    land: 'land',\n    lakes: 'lake',\n    subunits: 'subunit',\n    countries: 'country',\n    coastlines: 'coastline',\n    rivers: 'river',\n    frame: 'frame'\n};\n\n// base layers drawn over choropleth\nparams.baseLayersOverChoropleth = ['rivers', 'lakes'];\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/lib/typed_array_truncate.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nfunction truncateFloat32(arrayIn, len) {\n    var arrayOut = new Float32Array(len);\n    for(var i = 0; i < len; i++) arrayOut[i] = arrayIn[i];\n    return arrayOut;\n}\n\nfunction truncateFloat64(arrayIn, len) {\n    var arrayOut = new Float64Array(len);\n    for(var i = 0; i < len; i++) arrayOut[i] = arrayIn[i];\n    return arrayOut;\n}\n\n/**\n * Truncate a typed array to some length.\n * For some reason, ES2015 Float32Array.prototype.slice takes\n * 2x as long, therefore we aren't checking for its existence\n */\nmodule.exports = function truncate(arrayIn, len) {\n    if(arrayIn instanceof Float32Array) return truncateFloat32(arrayIn, len);\n    if(arrayIn instanceof Float64Array) return truncateFloat64(arrayIn, len);\n    throw new Error('This array type is not yet supported by `truncate`.');\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plot_api/set_plot_config.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Plotly = require('../plotly');\nvar Lib = require('../lib');\n\n/**\n * Extends the plot config\n *\n * @param {object} configObj partial plot configuration object\n *      to extend the current plot configuration.\n *\n */\nmodule.exports = function setPlotConfig(configObj) {\n    return Lib.extendFlat(Plotly.defaultConfig, configObj);\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plot_api/validate.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\n\nvar Lib = require('../lib');\nvar Plots = require('../plots/plots');\nvar PlotSchema = require('./plot_schema');\n\nvar isPlainObject = Lib.isPlainObject;\nvar isArray = Array.isArray;\n\n\n/**\n * Validate a data array and layout object.\n *\n * @param {array} data\n * @param {object} layout\n *\n * @return {array} array of error objects each containing:\n *  - {string} code\n *      error code ('object', 'array', 'schema', 'unused', 'invisible' or 'value')\n *  - {string} container\n *      container where the error occurs ('data' or 'layout')\n *  - {number} trace\n *      trace index of the 'data' container where the error occurs\n *  - {array} path\n *      nested path to the key that causes the error\n *  - {string} astr\n *      attribute string variant of 'path' compatible with Plotly.restyle and\n *      Plotly.relayout.\n *  - {string} msg\n *      error message (shown in console in logger config argument is enable)\n */\nmodule.exports = function valiate(data, layout) {\n    var schema = PlotSchema.get(),\n        errorList = [],\n        gd = {};\n\n    var dataIn, layoutIn;\n\n    if(isArray(data)) {\n        gd.data = Lib.extendDeep([], data);\n        dataIn = data;\n    }\n    else {\n        gd.data = [];\n        dataIn = [];\n        errorList.push(format('array', 'data'));\n    }\n\n    if(isPlainObject(layout)) {\n        gd.layout = Lib.extendDeep({}, layout);\n        layoutIn = layout;\n    }\n    else {\n        gd.layout = {};\n        layoutIn = {};\n        if(arguments.length > 1) {\n            errorList.push(format('object', 'layout'));\n        }\n    }\n\n    // N.B. dataIn and layoutIn are in general not the same as\n    // gd.data and gd.layout after supplyDefaults as some attributes\n    // in gd.data and gd.layout (still) get mutated during this step.\n\n    Plots.supplyDefaults(gd);\n\n    var dataOut = gd._fullData,\n        len = dataIn.length;\n\n    for(var i = 0; i < len; i++) {\n        var traceIn = dataIn[i],\n            base = ['data', i];\n\n        if(!isPlainObject(traceIn)) {\n            errorList.push(format('object', base));\n            continue;\n        }\n\n        var traceOut = dataOut[i],\n            traceType = traceOut.type,\n            traceSchema = schema.traces[traceType].attributes;\n\n        // PlotSchema does something fancy with trace 'type', reset it here\n        // to make the trace schema compatible with Lib.validate.\n        traceSchema.type = {\n            valType: 'enumerated',\n            values: [traceType]\n        };\n\n        if(traceOut.visible === false && traceIn.visible !== false) {\n            errorList.push(format('invisible', base));\n        }\n\n        crawl(traceIn, traceOut, traceSchema, errorList, base);\n\n        var transformsIn = traceIn.transforms,\n            transformsOut = traceOut.transforms;\n\n        if(transformsIn) {\n            if(!isArray(transformsIn)) {\n                errorList.push(format('array', base, ['transforms']));\n            }\n\n            base.push('transforms');\n\n            for(var j = 0; j < transformsIn.length; j++) {\n                var path = ['transforms', j],\n                    transformType = transformsIn[j].type;\n\n                if(!isPlainObject(transformsIn[j])) {\n                    errorList.push(format('object', base, path));\n                    continue;\n                }\n\n                var transformSchema = schema.transforms[transformType] ?\n                    schema.transforms[transformType].attributes :\n                    {};\n\n                // add 'type' to transform schema to validate the transform type\n                transformSchema.type = {\n                    valType: 'enumerated',\n                    values: Object.keys(schema.transforms)\n                };\n\n                crawl(transformsIn[j], transformsOut[j], transformSchema, errorList, base, path);\n            }\n        }\n    }\n\n    var layoutOut = gd._fullLayout,\n        layoutSchema = fillLayoutSchema(schema, dataOut);\n\n    crawl(layoutIn, layoutOut, layoutSchema, errorList, 'layout');\n\n    // return undefined if no validation errors were found\n    return (errorList.length === 0) ? void(0) : errorList;\n};\n\nfunction crawl(objIn, objOut, schema, list, base, path) {\n    path = path || [];\n\n    var keys = Object.keys(objIn);\n\n    for(var i = 0; i < keys.length; i++) {\n        var k = keys[i];\n\n        // transforms are handled separately\n        if(k === 'transforms') continue;\n\n        var p = path.slice();\n        p.push(k);\n\n        var valIn = objIn[k],\n            valOut = objOut[k];\n\n        var nestedSchema = getNestedSchema(schema, k),\n            isInfoArray = (nestedSchema || {}).valType === 'info_array',\n            isColorscale = (nestedSchema || {}).valType === 'colorscale';\n\n        if(!isInSchema(schema, k)) {\n            list.push(format('schema', base, p));\n        }\n        else if(isPlainObject(valIn) && isPlainObject(valOut)) {\n            crawl(valIn, valOut, nestedSchema, list, base, p);\n        }\n        else if(nestedSchema.items && !isInfoArray && isArray(valIn)) {\n            var items = nestedSchema.items,\n                _nestedSchema = items[Object.keys(items)[0]],\n                indexList = [];\n\n            var j, _p;\n\n            // loop over valOut items while keeping track of their\n            // corresponding input container index (given by _index)\n            for(j = 0; j < valOut.length; j++) {\n                var _index = valOut[j]._index || j;\n\n                _p = p.slice();\n                _p.push(_index);\n\n                if(isPlainObject(valIn[_index]) && isPlainObject(valOut[j])) {\n                    indexList.push(_index);\n                    crawl(valIn[_index], valOut[j], _nestedSchema, list, base, _p);\n                }\n            }\n\n            // loop over valIn to determine where it went wrong for some items\n            for(j = 0; j < valIn.length; j++) {\n                _p = p.slice();\n                _p.push(j);\n\n                if(!isPlainObject(valIn[j])) {\n                    list.push(format('object', base, _p, valIn[j]));\n                }\n                else if(indexList.indexOf(j) === -1) {\n                    list.push(format('unused', base, _p));\n                }\n            }\n        }\n        else if(!isPlainObject(valIn) && isPlainObject(valOut)) {\n            list.push(format('object', base, p, valIn));\n        }\n        else if(!isArray(valIn) && isArray(valOut) && !isInfoArray && !isColorscale) {\n            list.push(format('array', base, p, valIn));\n        }\n        else if(!(k in objOut)) {\n            list.push(format('unused', base, p, valIn));\n        }\n        else if(!Lib.validate(valIn, nestedSchema)) {\n            list.push(format('value', base, p, valIn));\n        }\n    }\n\n    return list;\n}\n\n// the 'full' layout schema depends on the traces types presents\nfunction fillLayoutSchema(schema, dataOut) {\n    for(var i = 0; i < dataOut.length; i++) {\n        var traceType = dataOut[i].type,\n            traceLayoutAttr = schema.traces[traceType].layoutAttributes;\n\n        if(traceLayoutAttr) {\n            Lib.extendFlat(schema.layout.layoutAttributes, traceLayoutAttr);\n        }\n    }\n\n    return schema.layout.layoutAttributes;\n}\n\n// validation error codes\nvar code2msgFunc = {\n    object: function(base, astr) {\n        var prefix;\n\n        if(base === 'layout' && astr === '') prefix = 'The layout argument';\n        else if(base[0] === 'data' && astr === '') {\n            prefix = 'Trace ' + base[1] + ' in the data argument';\n        }\n        else prefix = inBase(base) + 'key ' + astr;\n\n        return prefix + ' must be linked to an object container';\n    },\n    array: function(base, astr) {\n        var prefix;\n\n        if(base === 'data') prefix = 'The data argument';\n        else prefix = inBase(base) + 'key ' + astr;\n\n        return prefix + ' must be linked to an array container';\n    },\n    schema: function(base, astr) {\n        return inBase(base) + 'key ' + astr + ' is not part of the schema';\n    },\n    unused: function(base, astr, valIn) {\n        var target = isPlainObject(valIn) ? 'container' : 'key';\n\n        return inBase(base) + target + ' ' + astr + ' did not get coerced';\n    },\n    invisible: function(base) {\n        return 'Trace ' + base[1] + ' got defaulted to be not visible';\n    },\n    value: function(base, astr, valIn) {\n        return [\n            inBase(base) + 'key ' + astr,\n            'is set to an invalid value (' + valIn + ')'\n        ].join(' ');\n    }\n};\n\nfunction inBase(base) {\n    if(isArray(base)) return 'In data trace ' + base[1] + ', ';\n\n    return 'In ' + base + ', ';\n}\n\nfunction format(code, base, path, valIn) {\n    path = path || '';\n\n    var container, trace;\n\n    // container is either 'data' or 'layout\n    // trace is the trace index if 'data', null otherwise\n\n    if(isArray(base)) {\n        container = base[0];\n        trace = base[1];\n    }\n    else {\n        container = base;\n        trace = null;\n    }\n\n    var astr = convertPathToAttributeString(path),\n        msg = code2msgFunc[code](base, astr, valIn);\n\n    // log to console if logger config option is enabled\n    Lib.log(msg);\n\n    return {\n        code: code,\n        container: container,\n        trace: trace,\n        path: path,\n        astr: astr,\n        msg: msg\n    };\n}\n\nfunction isInSchema(schema, key) {\n    var parts = splitKey(key),\n        keyMinusId = parts.keyMinusId,\n        id = parts.id;\n\n    if((keyMinusId in schema) && schema[keyMinusId]._isSubplotObj && id) {\n        return true;\n    }\n\n    return (key in schema);\n}\n\nfunction getNestedSchema(schema, key) {\n    var parts = splitKey(key);\n\n    return schema[parts.keyMinusId];\n}\n\nfunction splitKey(key) {\n    var idRegex = /([2-9]|[1-9][0-9]+)$/;\n\n    var keyMinusId = key.split(idRegex)[0],\n        id = key.substr(keyMinusId.length, key.length);\n\n    return {\n        keyMinusId: keyMinusId,\n        id: id\n    };\n}\n\nfunction convertPathToAttributeString(path) {\n    if(!isArray(path)) return String(path);\n\n    var astr = '';\n\n    for(var i = 0; i < path.length; i++) {\n        var p = path[i];\n\n        if(typeof p === 'number') {\n            astr = astr.substr(0, astr.length - 1) + '[' + p + ']';\n        }\n        else {\n            astr += p;\n        }\n\n        if(i < path.length - 1) astr += '.';\n    }\n\n    return astr;\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/array_container_defaults.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../lib');\n\n\n/** Convenience wrapper for making array container logic DRY and consistent\n *\n * @param {object} parentObjIn\n *  user input object where the container in question is linked\n *  (i.e. either a user trace object or the user layout object)\n *\n * @param {object} parentObjOut\n *  full object where the coerced container will be linked\n *  (i.e. either a full trace object or the full layout object)\n *\n * @param {object} opts\n *  options object:\n *   - name {string}\n *      name of the key linking the container in question\n *   - handleItemDefaults {function}\n *      defaults method to be called on each item in the array container in question\n *\n *      Its arguments are:\n *          - itemIn {object} item in user layout\n *          - itemOut {object} item in full layout\n *          - parentObj {object} (as in closure)\n *          - opts {object} (as in closure)\n *          - itemOpts {object}\n *              - itemIsNotPlainObject {boolean}\n * N.B.\n *\n *  - opts is passed to handleItemDefaults so it can also store\n *    links to supplementary data (e.g. fullData for layout components)\n *\n */\nmodule.exports = function handleArrayContainerDefaults(parentObjIn, parentObjOut, opts) {\n    var name = opts.name;\n\n    var previousContOut = parentObjOut[name];\n\n    var contIn = Lib.isArray(parentObjIn[name]) ? parentObjIn[name] : [],\n        contOut = parentObjOut[name] = [],\n        i;\n\n    for(i = 0; i < contIn.length; i++) {\n        var itemIn = contIn[i],\n            itemOut = {},\n            itemOpts = {};\n\n        if(!Lib.isPlainObject(itemIn)) {\n            itemOpts.itemIsNotPlainObject = true;\n            itemIn = {};\n        }\n\n        opts.handleItemDefaults(itemIn, itemOut, parentObjOut, opts, itemOpts);\n\n        itemOut._input = itemIn;\n        itemOut._index = i;\n\n        contOut.push(itemOut);\n    }\n\n    // in case this array gets its defaults rebuilt independent of the whole layout,\n    // relink the private keys just for this array.\n    if(Lib.isArray(previousContOut)) {\n        var len = Math.min(previousContOut.length, contOut.length);\n        for(i = 0; i < len; i++) {\n            Lib.relinkPrivateKeys(contOut[i], previousContOut[i]);\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/pad_attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = {\n    t: {\n        valType: 'number',\n        dflt: 0,\n        role: 'style',\n        description: 'The amount of padding (in px) along the top of the component.'\n    },\n    r: {\n        valType: 'number',\n        dflt: 0,\n        role: 'style',\n        description: 'The amount of padding (in px) on the right side of the component.'\n    },\n    b: {\n        valType: 'number',\n        dflt: 0,\n        role: 'style',\n        description: 'The amount of padding (in px) along the bottom of the component.'\n    },\n    l: {\n        valType: 'number',\n        dflt: 0,\n        role: 'style',\n        description: 'The amount of padding (in px) on the left side of the component.'\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/subplot_defaults.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Lib = require('../lib');\nvar Plots = require('./plots');\n\n\n/**\n * Find and supply defaults to all subplots of a given type\n * This handles subplots that are contained within one container - so\n * gl3d, geo, ternary... but not 2d axes which have separate x and y axes\n * finds subplots, coerces their `domain` attributes, then calls the\n * given handleDefaults function to fill in everything else.\n *\n * layoutIn: the complete user-supplied input layout\n * layoutOut: the complete finished layout\n * fullData: the finished data array, used only to find subplots\n * opts: {\n *  type: subplot type string\n *  attributes: subplot attributes object\n *  partition: 'x' or 'y', which direction to divide domain space by default\n *      (default 'x', ie side-by-side subplots)\n *      TODO: this option is only here because 3D and geo made opposite\n *      choices in this regard previously and I didn't want to change it.\n *      Instead we should do:\n *      - something consistent\n *      - something more square (4 cuts 2x2, 5/6 cuts 2x3, etc.)\n *      - something that includes all subplot types in one arrangement,\n *        now that we can have them together!\n *  handleDefaults: function of (subplotLayoutIn, subplotLayoutOut, coerce, opts)\n *      this opts object is passed through to handleDefaults, so attach any\n *      additional items needed by this function here as well\n * }\n */\nmodule.exports = function handleSubplotDefaults(layoutIn, layoutOut, fullData, opts) {\n    var subplotType = opts.type,\n        subplotAttributes = opts.attributes,\n        handleDefaults = opts.handleDefaults,\n        partition = opts.partition || 'x';\n\n    var ids = Plots.findSubplotIds(fullData, subplotType),\n        idsLength = ids.length;\n\n    var subplotLayoutIn, subplotLayoutOut;\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(subplotLayoutIn, subplotLayoutOut, subplotAttributes, attr, dflt);\n    }\n\n    for(var i = 0; i < idsLength; i++) {\n        var id = ids[i];\n\n        // ternary traces get a layout ternary for free!\n        if(layoutIn[id]) subplotLayoutIn = layoutIn[id];\n        else subplotLayoutIn = layoutIn[id] = {};\n\n        layoutOut[id] = subplotLayoutOut = {};\n\n        coerce('domain.' + partition, [i / idsLength, (i + 1) / idsLength]);\n        coerce('domain.' + {x: 'y', y: 'x'}[partition]);\n\n        opts.id = id;\n        handleDefaults(subplotLayoutIn, subplotLayoutOut, coerce, opts);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/snapshot/toimage.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar Plotly = require('../plotly');\nvar Lib = require('../lib');\n\nvar helpers = require('./helpers');\nvar clonePlot = require('./cloneplot');\nvar toSVG = require('./tosvg');\nvar svgToImg = require('./svgtoimg');\n\n\n/**\n * @param {object} gd figure Object\n * @param {object} opts option object\n * @param opts.format 'jpeg' | 'png' | 'webp' | 'svg'\n */\nfunction toImage(gd, opts) {\n\n    // first clone the GD so we can operate in a clean environment\n    var ev = new EventEmitter();\n\n    var clone = clonePlot(gd, {format: 'png'});\n    var clonedGd = clone.gd;\n\n    // put the cloned div somewhere off screen before attaching to DOM\n    clonedGd.style.position = 'absolute';\n    clonedGd.style.left = '-5000px';\n    document.body.appendChild(clonedGd);\n\n    function wait() {\n        var delay = helpers.getDelay(clonedGd._fullLayout);\n\n        setTimeout(function() {\n            var svg = toSVG(clonedGd);\n\n            var canvas = document.createElement('canvas');\n            canvas.id = Lib.randstr();\n\n            ev = svgToImg({\n                format: opts.format,\n                width: clonedGd._fullLayout.width,\n                height: clonedGd._fullLayout.height,\n                canvas: canvas,\n                emitter: ev,\n                svg: svg\n            });\n\n            ev.clean = function() {\n                if(clonedGd) document.body.removeChild(clonedGd);\n            };\n\n        }, delay);\n    }\n\n    var redrawFunc = helpers.getRedrawFunc(clonedGd);\n\n    Plotly.plot(clonedGd, clone.data, clone.layout, clone.config)\n        .then(redrawFunc)\n        .then(wait)\n        .catch(function(err) {\n            ev.emit('error', err);\n        });\n\n\n    return ev;\n}\n\nmodule.exports = toImage;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/tasks/util/compress_attributes.js":"var through = require('through2');\n\n/**\n * Browserify transform that strips meta attributes out\n * of the plotly.js bundles\n */\n\n\n// one line string with or without trailing comma\nfunction makeStringRegex(attr) {\n    return attr + ': \\'.*\\'' + ',?';\n}\n\n// joined array of strings with or without trailing comma\nfunction makeJoinedArrayRegex(attr) {\n    return attr + ': \\\\[[\\\\s\\\\S]*?\\\\]' + '\\\\.join\\\\(.*' + ',?';\n}\n\n// array with or without trailing comma\nfunction makeArrayRegex(attr) {\n    return attr + ': \\\\[[\\\\s\\\\S]*?\\\\]' + ',?';\n}\n\n// ref: http://www.regexr.com/3cmac\nvar regexStr = [\n    makeStringRegex('description'),\n    makeJoinedArrayRegex('description'),\n    makeArrayRegex('requiredOpts'),\n    makeArrayRegex('otherOpts'),\n    makeStringRegex('hrName'),\n    makeStringRegex('role')\n].join('|');\n\nvar regex = new RegExp(regexStr, 'g');\n\nmodule.exports = function() {\n    return through(function(buf, enc, next) {\n        this.push(\n            buf.toString('utf-8')\n               .replace(regex, '')\n        );\n        next();\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/tasks/util/patch_minified.js":"var PATTERN = /require\\(\"\\+(\\w)\\((\\w)\\)\\+\"\\)/;\nvar NEW_SUBSTR = 'require(\"+ $1($2) +\")';\n\n/* Uber hacky in-house fix to\n *\n * https://github.com/substack/webworkify/issues/29\n *\n * so that plotly.min.js loads in Jupyter NBs, more info here:\n *\n * - https://github.com/plotly/plotly.py/pull/545\n * - https://github.com/plotly/plotly.js/pull/914\n * - https://github.com/plotly/plotly.js/pull/1094\n *\n * For example, this routine replaces\n *  'require(\"+o(s)+\")' -> 'require(\"+ o(s) +\")'\n *\n * But works for any 1-letter variable that uglify-js may output.\n *\n */\nmodule.exports = function patchMinified(minifiedCode) {\n    return minifiedCode.replace(PATTERN, NEW_SUBSTR);\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/tasks/util/pull_css.js":"var fs = require('fs');\n\n\nmodule.exports = function pullCSS(data, pathOut) {\n    var rules = {};\n\n    data.split(/\\s*\\}\\s*/).forEach(function(chunk) {\n        if(!chunk) return;\n\n        var parts = chunk.split(/\\s*\\{\\s*/),\n            selectorList = parts[0],\n            rule = parts[1];\n\n        // take off \".js-plotly-plot .plotly\", which should be on every selector\n        selectorList.split(/,\\s*/).forEach(function(selector) {\n            if(!selector.match(/^([\\.]js-plotly-plot [\\.]plotly|[\\.]plotly-notifier)/)) {\n                throw new Error('all plotlyjs-style selectors must start ' +\n                    '.js-plotly-plot .plotly or .plotly-notifier\\n' +\n                    'found: ' + selectorList);\n            }\n        });\n\n        selectorList = selectorList\n            .replace(/[\\.]js-plotly-plot [\\.]plotly/g, 'X')\n            .replace(/[\\.]plotly-notifier/g, 'Y');\n\n        // take out newlines in rule, and make sure it ends in a semicolon\n        rule = rule.replace(/;\\s*/g, ';').replace(/;?\\s*$/, ';');\n\n        // omit blank rules (why do we get these occasionally?)\n        if(rule.match(/^[\\s;]*$/)) return;\n\n        rules[selectorList] = rules[selectorList] || '' + rule;\n    });\n\n    var rulesStr = JSON.stringify(rules, null, 4).replace(/\\\"(\\w+)\\\":/g, '$1:');\n\n    var outStr = [\n        '\\'use strict\\';',\n        '',\n        'var Lib = require(\\'../src/lib\\');',\n        'var rules = ' + rulesStr + ';',\n        '',\n        'for(var selector in rules) {',\n        '    var fullSelector = selector.replace(/^,/,\\' ,\\')',\n        '        .replace(/X/g, \\'.js-plotly-plot .plotly\\')',\n        '        .replace(/Y/g, \\'.plotly-notifier\\');',\n        '    Lib.addStyleRule(fullSelector, rules[selector]);',\n        '}',\n        ''\n    ].join('\\n');\n\n    fs.writeFile(pathOut, outStr, function(err) {\n        if(err) throw err;\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/tasks/util/pull_font_svg.js":"var fs = require('fs');\nvar xml2js = require('xml2js');\n\nvar parser = new xml2js.Parser();\n\n\nmodule.exports = function pullFontSVG(data, pathOut) {\n    parser.parseString(data, function(err, result) {\n        if(err) throw err;\n\n        var font_obj = result.svg.defs[0].font[0],\n            default_width = Number(font_obj.$['horiz-adv-x']),\n            ascent = Number(font_obj['font-face'][0].$.ascent),\n            descent = Number(font_obj['font-face'][0].$.descent),\n            chars = {};\n\n        font_obj.glyph.forEach(function(glyph) {\n            chars[glyph.$['glyph-name']] = {\n                width: Number(glyph.$['horiz-adv-x']) || default_width,\n                path: glyph.$.d,\n                ascent: ascent,\n                descent: descent\n            };\n        });\n\n        // turn remaining double quotes into single\n        var charStr = JSON.stringify(chars, null, 4).replace(/\\\"/g, '\\'');\n\n        var outStr = [\n            '\\'use strict\\';',\n            '',\n            'module.exports = ' + charStr + ';',\n            ''\n        ].join('\\n');\n\n        fs.writeFile(pathOut, outStr, function(err) {\n            if(err) throw err;\n        });\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/tasks/util/shortcut_paths.js":"var path = require('path');\n\nvar transformTools = require('browserify-transform-tools');\n\nvar constants = require('./constants');\n\n/**\n * Transform require paths starting with '@' to appropriate folder paths\n */\n\nvar shortcutsConfig = {\n    '@src': constants.pathToSrc,\n    '@lib': constants.pathToLib,\n    '@mocks': constants.pathToTestImageMocks,\n    '@build': constants.pathToBuild\n};\n\nmodule.exports = transformTools.makeRequireTransform('requireTransform',\n    { evaluateArguments: true, jsFilesOnly: true },\n    function(args, opts, cb) {\n        var pathIn = args[0];\n        var pathOut;\n\n        Object.keys(shortcutsConfig).forEach(function(k) {\n            if(pathIn.indexOf(k) !== -1) {\n                var tail = pathIn.split(k)[1];\n                var newPath = path.join(shortcutsConfig[k], tail).replace(/\\\\/g, '/');\n                pathOut = 'require(\\'' + newPath + '\\')';\n            }\n        });\n\n        if(pathOut) return cb(null, pathOut);\n        else return cb();\n    });\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/tasks/util/update_version.js":"var fs = require('fs');\n\nvar falafel = require('falafel');\n\nvar pkg = require('../../package.json');\n\n\nmodule.exports = function updateVersion(pathToFile) {\n    fs.readFile(pathToFile, 'utf-8', function(err, code) {\n        var out = falafel(code, function(node) {\n            if(isVersionNode(node)) node.update('\\'' + pkg.version + '\\'');\n        });\n\n        fs.writeFile(pathToFile, out, function(err) {\n            if(err) throw err;\n        });\n    });\n};\n\nfunction isVersionNode(node) {\n    return (\n        node.type === 'Literal' &&\n        node.parent &&\n        node.parent.type === 'AssignmentExpression' &&\n        node.parent.left &&\n        node.parent.left.object &&\n        node.parent.left.property &&\n        node.parent.left.property.name === 'version'\n    );\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/annotations/annotation_defaults.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar Color = require('../color');\nvar Axes = require('../../plots/cartesian/axes');\nvar constants = require('../../plots/cartesian/constants');\n\nvar attributes = require('./attributes');\n\n\nmodule.exports = function handleAnnotationDefaults(annIn, annOut, fullLayout, opts, itemOpts) {\n    opts = opts || {};\n    itemOpts = itemOpts || {};\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(annIn, annOut, attributes, attr, dflt);\n    }\n\n    var visible = coerce('visible', !itemOpts.itemIsNotPlainObject);\n    var clickToShow = coerce('clicktoshow');\n\n    if(!(visible || clickToShow)) return annOut;\n\n    coerce('opacity');\n    var bgColor = coerce('bgcolor');\n\n    var borderColor = coerce('bordercolor'),\n        borderOpacity = Color.opacity(borderColor);\n\n    coerce('borderpad');\n\n    var borderWidth = coerce('borderwidth');\n    var showArrow = coerce('showarrow');\n\n    coerce('text', showArrow ? ' ' : 'new text');\n    coerce('textangle');\n    Lib.coerceFont(coerce, 'font', fullLayout.font);\n\n    coerce('width');\n    coerce('align');\n\n    var h = coerce('height');\n    if(h) coerce('valign');\n\n    // positioning\n    var axLetters = ['x', 'y'],\n        arrowPosDflt = [-10, -30],\n        gdMock = {_fullLayout: fullLayout};\n    for(var i = 0; i < 2; i++) {\n        var axLetter = axLetters[i];\n\n        // xref, yref\n        var axRef = Axes.coerceRef(annIn, annOut, gdMock, axLetter, '', 'paper');\n\n        // x, y\n        Axes.coercePosition(annOut, gdMock, coerce, axRef, axLetter, 0.5);\n\n        if(showArrow) {\n            var arrowPosAttr = 'a' + axLetter,\n                // axref, ayref\n                aaxRef = Axes.coerceRef(annIn, annOut, gdMock, arrowPosAttr, 'pixel');\n\n            // for now the arrow can only be on the same axis or specified as pixels\n            // TODO: sometime it might be interesting to allow it to be on *any* axis\n            // but that would require updates to drawing & autorange code and maybe more\n            if(aaxRef !== 'pixel' && aaxRef !== axRef) {\n                aaxRef = annOut[arrowPosAttr] = 'pixel';\n            }\n\n            // ax, ay\n            var aDflt = (aaxRef === 'pixel') ? arrowPosDflt[i] : 0.4;\n            Axes.coercePosition(annOut, gdMock, coerce, aaxRef, arrowPosAttr, aDflt);\n        }\n\n        // xanchor, yanchor\n        coerce(axLetter + 'anchor');\n\n        // xshift, yshift\n        coerce(axLetter + 'shift');\n    }\n\n    // if you have one coordinate you should have both\n    Lib.noneOrAll(annIn, annOut, ['x', 'y']);\n\n    if(showArrow) {\n        coerce('arrowcolor', borderOpacity ? annOut.bordercolor : Color.defaultLine);\n        coerce('arrowhead');\n        coerce('arrowsize');\n        coerce('arrowwidth', ((borderOpacity && borderWidth) || 1) * 2);\n        coerce('standoff');\n\n        // if you have one part of arrow length you should have both\n        Lib.noneOrAll(annIn, annOut, ['ax', 'ay']);\n    }\n\n    if(clickToShow) {\n        var xClick = coerce('xclick');\n        var yClick = coerce('yclick');\n\n        // put the actual click data to bind to into private attributes\n        // so we don't have to do this little bit of logic on every hover event\n        annOut._xclick = (xClick === undefined) ? annOut.x : xClick;\n        annOut._yclick = (yClick === undefined) ? annOut.y : yClick;\n    }\n\n    var hoverText = coerce('hovertext');\n    if(hoverText) {\n        var hoverBG = coerce('hoverlabel.bgcolor',\n            Color.opacity(bgColor) ? Color.rgb(bgColor) : Color.defaultLine);\n        var hoverBorder = coerce('hoverlabel.bordercolor', Color.contrast(hoverBG));\n        Lib.coerceFont(coerce, 'hoverlabel.font', {\n            family: constants.HOVERFONT,\n            size: constants.HOVERFONTSIZE,\n            color: hoverBorder\n        });\n    }\n    coerce('captureevents', !!hoverText);\n\n    return annOut;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/annotations/attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar ARROWPATHS = require('./arrow_paths');\nvar fontAttrs = require('../../plots/font_attributes');\nvar cartesianConstants = require('../../plots/cartesian/constants');\nvar extendFlat = require('../../lib/extend').extendFlat;\n\n\nmodule.exports = {\n    _isLinkedToArray: 'annotation',\n\n    visible: {\n        valType: 'boolean',\n        role: 'info',\n        dflt: true,\n        description: [\n            'Determines whether or not this annotation is visible.'\n        ].join(' ')\n    },\n\n    text: {\n        valType: 'string',\n        role: 'info',\n        description: [\n            'Sets the text associated with this annotation.',\n            'Plotly uses a subset of HTML tags to do things like',\n            'newline (<br>), bold (<b></b>), italics (<i></i>),',\n            'hyperlinks (<a href=\\'...\\'></a>). Tags <em>, <sup>, <sub>',\n            '<span> are also supported.'\n        ].join(' ')\n    },\n    textangle: {\n        valType: 'angle',\n        dflt: 0,\n        role: 'style',\n        description: [\n            'Sets the angle at which the `text` is drawn',\n            'with respect to the horizontal.'\n        ].join(' ')\n    },\n    font: extendFlat({}, fontAttrs, {\n        description: 'Sets the annotation text font.'\n    }),\n    width: {\n        valType: 'number',\n        min: 1,\n        dflt: null,\n        role: 'style',\n        description: [\n            'Sets an explicit width for the text box. null (default) lets the',\n            'text set the box width. Wider text will be clipped.',\n            'There is no automatic wrapping; use <br> to start a new line.'\n        ].join(' ')\n    },\n    height: {\n        valType: 'number',\n        min: 1,\n        dflt: null,\n        role: 'style',\n        description: [\n            'Sets an explicit height for the text box. null (default) lets the',\n            'text set the box height. Taller text will be clipped.'\n        ].join(' ')\n    },\n    opacity: {\n        valType: 'number',\n        min: 0,\n        max: 1,\n        dflt: 1,\n        role: 'style',\n        description: 'Sets the opacity of the annotation (text + arrow).'\n    },\n    align: {\n        valType: 'enumerated',\n        values: ['left', 'center', 'right'],\n        dflt: 'center',\n        role: 'style',\n        description: [\n            'Sets the horizontal alignment of the `text` within the box.',\n            'Has an effect only if `text` spans more two or more lines',\n            '(i.e. `text` contains one or more <br> HTML tags) or if an',\n            'explicit width is set to override the text width.'\n        ].join(' ')\n    },\n    valign: {\n        valType: 'enumerated',\n        values: ['top', 'middle', 'bottom'],\n        dflt: 'middle',\n        role: 'style',\n        description: [\n            'Sets the vertical alignment of the `text` within the box.',\n            'Has an effect only if an explicit height is set to override',\n            'the text height.'\n        ].join(' ')\n    },\n    bgcolor: {\n        valType: 'color',\n        dflt: 'rgba(0,0,0,0)',\n        role: 'style',\n        description: 'Sets the background color of the annotation.'\n    },\n    bordercolor: {\n        valType: 'color',\n        dflt: 'rgba(0,0,0,0)',\n        role: 'style',\n        description: [\n            'Sets the color of the border enclosing the annotation `text`.'\n        ].join(' ')\n    },\n    borderpad: {\n        valType: 'number',\n        min: 0,\n        dflt: 1,\n        role: 'style',\n        description: [\n            'Sets the padding (in px) between the `text`',\n            'and the enclosing border.'\n        ].join(' ')\n    },\n    borderwidth: {\n        valType: 'number',\n        min: 0,\n        dflt: 1,\n        role: 'style',\n        description: [\n            'Sets the width (in px) of the border enclosing',\n            'the annotation `text`.'\n        ].join(' ')\n    },\n    // arrow\n    showarrow: {\n        valType: 'boolean',\n        dflt: true,\n        role: 'style',\n        description: [\n            'Determines whether or not the annotation is drawn with an arrow.',\n            'If *true*, `text` is placed near the arrow\\'s tail.',\n            'If *false*, `text` lines up with the `x` and `y` provided.'\n        ].join(' ')\n    },\n    arrowcolor: {\n        valType: 'color',\n        role: 'style',\n        description: 'Sets the color of the annotation arrow.'\n    },\n    arrowhead: {\n        valType: 'integer',\n        min: 0,\n        max: ARROWPATHS.length,\n        dflt: 1,\n        role: 'style',\n        description: 'Sets the annotation arrow head style.'\n    },\n    arrowsize: {\n        valType: 'number',\n        min: 0.3,\n        dflt: 1,\n        role: 'style',\n        description: 'Sets the size (in px) of annotation arrow head.'\n    },\n    arrowwidth: {\n        valType: 'number',\n        min: 0.1,\n        role: 'style',\n        description: 'Sets the width (in px) of annotation arrow.'\n    },\n    standoff: {\n        valType: 'number',\n        min: 0,\n        dflt: 0,\n        role: 'style',\n        description: [\n            'Sets a distance, in pixels, to move the arrowhead away from the',\n            'position it is pointing at, for example to point at the edge of',\n            'a marker independent of zoom. Note that this shortens the arrow',\n            'from the `ax` / `ay` vector, in contrast to `xshift` / `yshift`',\n            'which moves everything by this amount.'\n        ].join(' ')\n    },\n    ax: {\n        valType: 'any',\n        role: 'info',\n        description: [\n            'Sets the x component of the arrow tail about the arrow head.',\n            'If `axref` is `pixel`, a positive (negative) ',\n            'component corresponds to an arrow pointing',\n            'from right to left (left to right).',\n            'If `axref` is an axis, this is an absolute value on that axis,',\n            'like `x`, NOT a relative value.'\n        ].join(' ')\n    },\n    ay: {\n        valType: 'any',\n        role: 'info',\n        description: [\n            'Sets the y component of the arrow tail about the arrow head.',\n            'If `ayref` is `pixel`, a positive (negative) ',\n            'component corresponds to an arrow pointing',\n            'from bottom to top (top to bottom).',\n            'If `ayref` is an axis, this is an absolute value on that axis,',\n            'like `y`, NOT a relative value.'\n        ].join(' ')\n    },\n    axref: {\n        valType: 'enumerated',\n        dflt: 'pixel',\n        values: [\n            'pixel',\n            cartesianConstants.idRegex.x.toString()\n        ],\n        role: 'info',\n        description: [\n            'Indicates in what terms the tail of the annotation (ax,ay) ',\n            'is specified. If `pixel`, `ax` is a relative offset in pixels ',\n            'from `x`. If set to an x axis id (e.g. *x* or *x2*), `ax` is ',\n            'specified in the same terms as that axis. This is useful ',\n            'for trendline annotations which should continue to indicate ',\n            'the correct trend when zoomed.'\n        ].join(' ')\n    },\n    ayref: {\n        valType: 'enumerated',\n        dflt: 'pixel',\n        values: [\n            'pixel',\n            cartesianConstants.idRegex.y.toString()\n        ],\n        role: 'info',\n        description: [\n            'Indicates in what terms the tail of the annotation (ax,ay) ',\n            'is specified. If `pixel`, `ay` is a relative offset in pixels ',\n            'from `y`. If set to a y axis id (e.g. *y* or *y2*), `ay` is ',\n            'specified in the same terms as that axis. This is useful ',\n            'for trendline annotations which should continue to indicate ',\n            'the correct trend when zoomed.'\n        ].join(' ')\n    },\n    // positioning\n    xref: {\n        valType: 'enumerated',\n        values: [\n            'paper',\n            cartesianConstants.idRegex.x.toString()\n        ],\n        role: 'info',\n        description: [\n            'Sets the annotation\\'s x coordinate axis.',\n            'If set to an x axis id (e.g. *x* or *x2*), the `x` position',\n            'refers to an x coordinate',\n            'If set to *paper*, the `x` position refers to the distance from',\n            'the left side of the plotting area in normalized coordinates',\n            'where 0 (1) corresponds to the left (right) side.'\n        ].join(' ')\n    },\n    x: {\n        valType: 'any',\n        role: 'info',\n        description: [\n            'Sets the annotation\\'s x position.',\n            'If the axis `type` is *log*, then you must take the',\n            'log of your desired range.',\n            'If the axis `type` is *date*, it should be date strings,',\n            'like date data, though Date objects and unix milliseconds',\n            'will be accepted and converted to strings.',\n            'If the axis `type` is *category*, it should be numbers,',\n            'using the scale where each category is assigned a serial',\n            'number from zero in the order it appears.'\n        ].join(' ')\n    },\n    xanchor: {\n        valType: 'enumerated',\n        values: ['auto', 'left', 'center', 'right'],\n        dflt: 'auto',\n        role: 'info',\n        description: [\n            'Sets the text box\\'s horizontal position anchor',\n            'This anchor binds the `x` position to the *left*, *center*',\n            'or *right* of the annotation.',\n            'For example, if `x` is set to 1, `xref` to *paper* and',\n            '`xanchor` to *right* then the right-most portion of the',\n            'annotation lines up with the right-most edge of the',\n            'plotting area.',\n            'If *auto*, the anchor is equivalent to *center* for',\n            'data-referenced annotations or if there is an arrow,',\n            'whereas for paper-referenced with no arrow, the anchor picked',\n            'corresponds to the closest side.'\n        ].join(' ')\n    },\n    xshift: {\n        valType: 'number',\n        dflt: 0,\n        role: 'style',\n        description: [\n            'Shifts the position of the whole annotation and arrow to the',\n            'right (positive) or left (negative) by this many pixels.'\n        ].join(' ')\n    },\n    yref: {\n        valType: 'enumerated',\n        values: [\n            'paper',\n            cartesianConstants.idRegex.y.toString()\n        ],\n        role: 'info',\n        description: [\n            'Sets the annotation\\'s y coordinate axis.',\n            'If set to an y axis id (e.g. *y* or *y2*), the `y` position',\n            'refers to an y coordinate',\n            'If set to *paper*, the `y` position refers to the distance from',\n            'the bottom of the plotting area in normalized coordinates',\n            'where 0 (1) corresponds to the bottom (top).'\n        ].join(' ')\n    },\n    y: {\n        valType: 'any',\n        role: 'info',\n        description: [\n            'Sets the annotation\\'s y position.',\n            'If the axis `type` is *log*, then you must take the',\n            'log of your desired range.',\n            'If the axis `type` is *date*, it should be date strings,',\n            'like date data, though Date objects and unix milliseconds',\n            'will be accepted and converted to strings.',\n            'If the axis `type` is *category*, it should be numbers,',\n            'using the scale where each category is assigned a serial',\n            'number from zero in the order it appears.'\n        ].join(' ')\n    },\n    yanchor: {\n        valType: 'enumerated',\n        values: ['auto', 'top', 'middle', 'bottom'],\n        dflt: 'auto',\n        role: 'info',\n        description: [\n            'Sets the text box\\'s vertical position anchor',\n            'This anchor binds the `y` position to the *top*, *middle*',\n            'or *bottom* of the annotation.',\n            'For example, if `y` is set to 1, `yref` to *paper* and',\n            '`yanchor` to *top* then the top-most portion of the',\n            'annotation lines up with the top-most edge of the',\n            'plotting area.',\n            'If *auto*, the anchor is equivalent to *middle* for',\n            'data-referenced annotations or if there is an arrow,',\n            'whereas for paper-referenced with no arrow, the anchor picked',\n            'corresponds to the closest side.'\n        ].join(' ')\n    },\n    yshift: {\n        valType: 'number',\n        dflt: 0,\n        role: 'style',\n        description: [\n            'Shifts the position of the whole annotation and arrow up',\n            '(positive) or down (negative) by this many pixels.'\n        ].join(' ')\n    },\n    clicktoshow: {\n        valType: 'enumerated',\n        values: [false, 'onoff', 'onout'],\n        dflt: false,\n        role: 'style',\n        description: [\n            'Makes this annotation respond to clicks on the plot.',\n            'If you click a data point that exactly matches the `x` and `y`',\n            'values of this annotation, and it is hidden (visible: false),',\n            'it will appear. In *onoff* mode, you must click the same point',\n            'again to make it disappear, so if you click multiple points,',\n            'you can show multiple annotations. In *onout* mode, a click',\n            'anywhere else in the plot (on another data point or not) will',\n            'hide this annotation.',\n            'If you need to show/hide this annotation in response to different',\n            '`x` or `y` values, you can set `xclick` and/or `yclick`. This is',\n            'useful for example to label the side of a bar. To label markers',\n            'though, `standoff` is preferred over `xclick` and `yclick`.'\n        ].join(' ')\n    },\n    xclick: {\n        valType: 'any',\n        role: 'info',\n        description: [\n            'Toggle this annotation when clicking a data point whose `x` value',\n            'is `xclick` rather than the annotation\\'s `x` value.'\n        ].join(' ')\n    },\n    yclick: {\n        valType: 'any',\n        role: 'info',\n        description: [\n            'Toggle this annotation when clicking a data point whose `y` value',\n            'is `yclick` rather than the annotation\\'s `y` value.'\n        ].join(' ')\n    },\n    hovertext: {\n        valType: 'string',\n        role: 'info',\n        description: [\n            'Sets text to appear when hovering over this annotation.',\n            'If omitted or blank, no hover label will appear.'\n        ].join(' ')\n    },\n    hoverlabel: {\n        bgcolor: {\n            valType: 'color',\n            role: 'style',\n            description: [\n                'Sets the background color of the hover label.',\n                'By default uses the annotation\\'s `bgcolor` made opaque,',\n                'or white if it was transparent.'\n            ].join(' ')\n        },\n        bordercolor: {\n            valType: 'color',\n            role: 'style',\n            description: [\n                'Sets the border color of the hover label.',\n                'By default uses either dark grey or white, for maximum',\n                'contrast with `hoverlabel.bgcolor`.'\n            ].join(' ')\n        },\n        font: extendFlat({}, fontAttrs, {\n            description: [\n                'Sets the hover label text font.',\n                'By default uses the global hover font and size,',\n                'with color from `hoverlabel.bordercolor`.'\n            ].join(' ')\n        })\n    },\n    captureevents: {\n        valType: 'boolean',\n        role: 'info',\n        description: [\n            'Determines whether the annotation text box captures mouse move',\n            'and click events, or allows those events to pass through to data',\n            'points in the plot that may be behind the annotation. By default',\n            '`captureevents` is *false* unless `hovertext` is provided.',\n            'If you use the event `plotly_clickannotation` without `hovertext`',\n            'you must explicitly enable `captureevents`.'\n        ].join(' ')\n    },\n\n    _deprecated: {\n        ref: {\n            valType: 'string',\n            role: 'info',\n            description: [\n                'Obsolete. Set `xref` and `yref` separately instead.'\n            ].join(' ')\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/annotations/arrow_paths.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n/**\n * centerx is a center of scaling tuned for maximum scalability of\n * the arrowhead ie throughout mag=0.3..3 the head is joined smoothly\n * to the line, but the endpoint moves.\n * backoff is the distance to move the arrowhead, and the end of the\n * line, in order to end at the right place\n *\n * TODO: option to have the pointed-to  point a little in front of the\n * end of the line, as people tend to want a bit of a gap there...\n */\n\nmodule.exports = [\n    // no arrow\n    {\n        path: '',\n        backoff: 0\n    },\n    // wide with flat back\n    {\n        path: 'M-2.4,-3V3L0.6,0Z',\n        backoff: 0.6\n    },\n    // narrower with flat back\n    {\n        path: 'M-3.7,-2.5V2.5L1.3,0Z',\n        backoff: 1.3\n    },\n    // barbed\n    {\n        path: 'M-4.45,-3L-1.65,-0.2V0.2L-4.45,3L1.55,0Z',\n        backoff: 1.55\n    },\n    // wide line-drawn\n    {\n        path: 'M-2.2,-2.2L-0.2,-0.2V0.2L-2.2,2.2L-1.4,3L1.6,0L-1.4,-3Z',\n        backoff: 1.6\n    },\n    // narrower line-drawn\n    {\n        path: 'M-4.4,-2.1L-0.6,-0.2V0.2L-4.4,2.1L-4,3L2,0L-4,-3Z',\n        backoff: 2\n    },\n    // circle\n    {\n        path: 'M2,0A2,2 0 1,1 0,-2A2,2 0 0,1 2,0Z',\n        backoff: 0\n    },\n    // square\n    {\n        path: 'M2,2V-2H-2V2Z',\n        backoff: 0\n    }\n];\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/annotations/calc_autorange.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar Axes = require('../../plots/cartesian/axes');\n\nvar draw = require('./draw').draw;\n\n\nmodule.exports = function calcAutorange(gd) {\n    var fullLayout = gd._fullLayout,\n        annotationList = Lib.filterVisible(fullLayout.annotations);\n\n    if(!annotationList.length || !gd._fullData.length) return;\n\n    var annotationAxes = {};\n    annotationList.forEach(function(ann) {\n        annotationAxes[ann.xref] = true;\n        annotationAxes[ann.yref] = true;\n    });\n\n    var autorangedAnnos = Axes.list(gd).filter(function(ax) {\n        return ax.autorange && annotationAxes[ax._id];\n    });\n    if(!autorangedAnnos.length) return;\n\n    return Lib.syncOrAsync([\n        draw,\n        annAutorange\n    ], gd);\n};\n\nfunction annAutorange(gd) {\n    var fullLayout = gd._fullLayout;\n\n    // find the bounding boxes for each of these annotations'\n    // relative to their anchor points\n    // use the arrow and the text bg rectangle,\n    // as the whole anno may include hidden text in its bbox\n    Lib.filterVisible(fullLayout.annotations).forEach(function(ann) {\n        var xa = Axes.getFromId(gd, ann.xref),\n            ya = Axes.getFromId(gd, ann.yref),\n            headSize = 3 * ann.arrowsize * ann.arrowwidth || 0;\n\n        var headPlus, headMinus;\n\n        if(xa && xa.autorange) {\n            headPlus = headSize + ann.xshift;\n            headMinus = headSize - ann.xshift;\n\n            if(ann.axref === ann.xref) {\n                // expand for the arrowhead (padded by arrowhead)\n                Axes.expand(xa, [xa.r2c(ann.x)], {\n                    ppadplus: headPlus,\n                    ppadminus: headMinus\n                });\n                // again for the textbox (padded by textbox)\n                Axes.expand(xa, [xa.r2c(ann.ax)], {\n                    ppadplus: ann._xpadplus,\n                    ppadminus: ann._xpadminus\n                });\n            }\n            else {\n                Axes.expand(xa, [xa.r2c(ann.x)], {\n                    ppadplus: Math.max(ann._xpadplus, headPlus),\n                    ppadminus: Math.max(ann._xpadminus, headMinus)\n                });\n            }\n        }\n\n        if(ya && ya.autorange) {\n            headPlus = headSize - ann.yshift;\n            headMinus = headSize + ann.yshift;\n\n            if(ann.ayref === ann.yref) {\n                Axes.expand(ya, [ya.r2c(ann.y)], {\n                    ppadplus: headPlus,\n                    ppadminus: headMinus\n                });\n                Axes.expand(ya, [ya.r2c(ann.ay)], {\n                    ppadplus: ann._ypadplus,\n                    ppadminus: ann._ypadminus\n                });\n            }\n            else {\n                Axes.expand(ya, [ya.r2c(ann.y)], {\n                    ppadplus: Math.max(ann._ypadplus, headPlus),\n                    ppadminus: Math.max(ann._ypadminus, headMinus)\n                });\n            }\n        }\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/annotations/draw.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\n\nvar Plotly = require('../../plotly');\nvar Plots = require('../../plots/plots');\nvar Lib = require('../../lib');\nvar Axes = require('../../plots/cartesian/axes');\nvar Fx = require('../../plots/cartesian/graph_interact');\nvar Color = require('../color');\nvar Drawing = require('../drawing');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar setCursor = require('../../lib/setcursor');\nvar dragElement = require('../dragelement');\n\nvar drawArrowHead = require('./draw_arrow_head');\n\n\n// Annotations are stored in gd.layout.annotations, an array of objects\n// index can point to one item in this array,\n//  or non-numeric to simply add a new one\n//  or -1 to modify all existing\n// opt can be the full options object, or one key (to be set to value)\n//  or undefined to simply redraw\n// if opt is blank, val can be 'add' or a full options object to add a new\n//  annotation at that point in the array, or 'remove' to delete this one\n\nmodule.exports = {\n    draw: draw,\n    drawOne: drawOne\n};\n\n/*\n * draw: draw all annotations without any new modifications\n */\nfunction draw(gd) {\n    var fullLayout = gd._fullLayout;\n\n    fullLayout._infolayer.selectAll('.annotation').remove();\n\n    for(var i = 0; i < fullLayout.annotations.length; i++) {\n        if(fullLayout.annotations[i].visible) {\n            drawOne(gd, i);\n        }\n    }\n\n    return Plots.previousPromises(gd);\n}\n\n/*\n * drawOne: draw a single annotation, potentially with modifications\n *\n * index (int): the annotation to draw\n */\nfunction drawOne(gd, index) {\n    var layout = gd.layout,\n        fullLayout = gd._fullLayout,\n        gs = gd._fullLayout._size;\n\n    // remove the existing annotation if there is one\n    fullLayout._infolayer.selectAll('.annotation[data-index=\"' + index + '\"]').remove();\n\n    // remember a few things about what was already there,\n    var optionsIn = (layout.annotations || [])[index],\n        options = fullLayout.annotations[index];\n\n    var annClipID = 'clip' + fullLayout._uid + '_ann' + index;\n\n    // this annotation is gone - quit now after deleting it\n    // TODO: use d3 idioms instead of deleting and redrawing every time\n    if(!optionsIn || options.visible === false) {\n        d3.selectAll('#' + annClipID).remove();\n        return;\n    }\n\n    var xa = Axes.getFromId(gd, options.xref),\n        ya = Axes.getFromId(gd, options.yref),\n\n        // calculated pixel positions\n        // x & y each will get text, head, and tail as appropriate\n        annPosPx = {x: {}, y: {}},\n        textangle = +options.textangle || 0;\n\n    // create the components\n    // made a single group to contain all, so opacity can work right\n    // with border/arrow together this could handle a whole bunch of\n    // cleanup at this point, but works for now\n    var annGroup = fullLayout._infolayer.append('g')\n        .classed('annotation', true)\n        .attr('data-index', String(index))\n        .style('opacity', options.opacity);\n\n    // another group for text+background so that they can rotate together\n    var annTextGroup = annGroup.append('g')\n        .classed('annotation-text-g', true)\n        .attr('data-index', String(index));\n\n    var annTextGroupInner = annTextGroup.append('g')\n        .style('pointer-events', options.captureevents ? 'all' : null)\n        .call(setCursor, 'default')\n        .on('click', function() {\n            gd._dragging = false;\n            gd.emit('plotly_clickannotation', {\n                index: index,\n                annotation: optionsIn,\n                fullAnnotation: options\n            });\n        });\n\n    if(options.hovertext) {\n        annTextGroupInner\n        .on('mouseover', function() {\n            var hoverOptions = options.hoverlabel;\n            var hoverFont = hoverOptions.font;\n            var bBox = this.getBoundingClientRect();\n            var bBoxRef = gd.getBoundingClientRect();\n\n            Fx.loneHover({\n                x0: bBox.left - bBoxRef.left,\n                x1: bBox.right - bBoxRef.left,\n                y: (bBox.top + bBox.bottom) / 2 - bBoxRef.top,\n                text: options.hovertext,\n                color: hoverOptions.bgcolor,\n                borderColor: hoverOptions.bordercolor,\n                fontFamily: hoverFont.family,\n                fontSize: hoverFont.size,\n                fontColor: hoverFont.color\n            }, {\n                container: fullLayout._hoverlayer.node(),\n                outerContainer: fullLayout._paper.node()\n            });\n        })\n        .on('mouseout', function() {\n            Fx.loneUnhover(fullLayout._hoverlayer.node());\n        });\n    }\n\n    var borderwidth = options.borderwidth,\n        borderpad = options.borderpad,\n        borderfull = borderwidth + borderpad;\n\n    var annTextBG = annTextGroupInner.append('rect')\n        .attr('class', 'bg')\n        .style('stroke-width', borderwidth + 'px')\n        .call(Color.stroke, options.bordercolor)\n        .call(Color.fill, options.bgcolor);\n\n    var isSizeConstrained = options.width || options.height;\n\n    var annTextClip = fullLayout._defs.select('.clips')\n        .selectAll('#' + annClipID)\n        .data(isSizeConstrained ? [0] : []);\n\n    annTextClip.enter().append('clipPath')\n        .classed('annclip', true)\n        .attr('id', annClipID)\n      .append('rect');\n    annTextClip.exit().remove();\n\n    var font = options.font;\n\n    var annText = annTextGroupInner.append('text')\n        .classed('annotation', true)\n        .attr('data-unformatted', options.text)\n        .text(options.text);\n\n    function textLayout(s) {\n        s.call(Drawing.font, font)\n        .attr({\n            'text-anchor': {\n                left: 'start',\n                right: 'end'\n            }[options.align] || 'middle'\n        });\n\n        svgTextUtils.convertToTspans(s, drawGraphicalElements);\n        return s;\n    }\n\n    function drawGraphicalElements() {\n\n        // make sure lines are aligned the way they will be\n        // at the end, even if their position changes\n        annText.selectAll('tspan.line').attr({y: 0, x: 0});\n\n        var mathjaxGroup = annTextGroupInner.select('.annotation-math-group');\n        var hasMathjax = !mathjaxGroup.empty();\n        var anntextBB = Drawing.bBox(\n                (hasMathjax ? mathjaxGroup : annText).node());\n        var textWidth = anntextBB.width;\n        var textHeight = anntextBB.height;\n        var annWidth = options.width || textWidth;\n        var annHeight = options.height || textHeight;\n        var outerWidth = Math.round(annWidth + 2 * borderfull);\n        var outerHeight = Math.round(annHeight + 2 * borderfull);\n\n\n        // save size in the annotation object for use by autoscale\n        options._w = annWidth;\n        options._h = annHeight;\n\n        function shiftFraction(v, anchor) {\n            if(anchor === 'auto') {\n                if(v < 1 / 3) anchor = 'left';\n                else if(v > 2 / 3) anchor = 'right';\n                else anchor = 'center';\n            }\n            return {\n                center: 0,\n                middle: 0,\n                left: 0.5,\n                bottom: -0.5,\n                right: -0.5,\n                top: 0.5\n            }[anchor];\n        }\n\n        var annotationIsOffscreen = false;\n        ['x', 'y'].forEach(function(axLetter) {\n            var axRef = options[axLetter + 'ref'] || axLetter,\n                tailRef = options['a' + axLetter + 'ref'],\n                ax = Axes.getFromId(gd, axRef),\n                dimAngle = (textangle + (axLetter === 'x' ? 0 : -90)) * Math.PI / 180,\n                // note that these two can be either positive or negative\n                annSizeFromWidth = outerWidth * Math.cos(dimAngle),\n                annSizeFromHeight = outerHeight * Math.sin(dimAngle),\n                // but this one is the positive total size\n                annSize = Math.abs(annSizeFromWidth) + Math.abs(annSizeFromHeight),\n                anchor = options[axLetter + 'anchor'],\n                overallShift = options[axLetter + 'shift'] * (axLetter === 'x' ? 1 : -1),\n                posPx = annPosPx[axLetter],\n                basePx,\n                textPadShift,\n                alignPosition,\n                autoAlignFraction,\n                textShift;\n\n            /*\n             * calculate the *primary* pixel position\n             * which is the arrowhead if there is one,\n             * otherwise the text anchor point\n             */\n            if(ax) {\n                /*\n                 * hide the annotation if it's pointing outside the visible plot\n                 * as long as the axis isn't autoranged - then we need to draw it\n                 * anyway to get its bounding box. When we're dragging, an axis can\n                 * still look autoranged even though it won't be when the drag finishes.\n                 */\n                var posFraction = ax.r2fraction(options[axLetter]);\n                if((gd._dragging || !ax.autorange) && (posFraction < 0 || posFraction > 1)) {\n                    if(tailRef === axRef) {\n                        posFraction = ax.r2fraction(options['a' + axLetter]);\n                        if(posFraction < 0 || posFraction > 1) {\n                            annotationIsOffscreen = true;\n                        }\n                    }\n                    else {\n                        annotationIsOffscreen = true;\n                    }\n\n                    if(annotationIsOffscreen) return;\n                }\n                basePx = ax._offset + ax.r2p(options[axLetter]);\n                autoAlignFraction = 0.5;\n            }\n            else {\n                if(axLetter === 'x') {\n                    alignPosition = options[axLetter];\n                    basePx = gs.l + gs.w * alignPosition;\n                }\n                else {\n                    alignPosition = 1 - options[axLetter];\n                    basePx = gs.t + gs.h * alignPosition;\n                }\n                autoAlignFraction = options.showarrow ? 0.5 : alignPosition;\n            }\n\n            // now translate this into pixel positions of head, tail, and text\n            // as well as paddings for autorange\n            if(options.showarrow) {\n                posPx.head = basePx;\n\n                var arrowLength = options['a' + axLetter];\n\n                // with an arrow, the text rotates around the anchor point\n                textShift = annSizeFromWidth * shiftFraction(0.5, options.xanchor) -\n                    annSizeFromHeight * shiftFraction(0.5, options.yanchor);\n\n                if(tailRef === axRef) {\n                    posPx.tail = ax._offset + ax.r2p(arrowLength);\n                    // tail is data-referenced: autorange pads the text in px from the tail\n                    textPadShift = textShift;\n                }\n                else {\n                    posPx.tail = basePx + arrowLength;\n                    // tail is specified in px from head, so autorange also pads vs head\n                    textPadShift = textShift + arrowLength;\n                }\n\n                posPx.text = posPx.tail + textShift;\n\n                // constrain pixel/paper referenced so the draggers are at least\n                // partially visible\n                var maxPx = fullLayout[(axLetter === 'x') ? 'width' : 'height'];\n                if(axRef === 'paper') {\n                    posPx.head = Lib.constrain(posPx.head, 1, maxPx - 1);\n                }\n                if(tailRef === 'pixel') {\n                    var shiftPlus = -Math.max(posPx.tail - 3, posPx.text),\n                        shiftMinus = Math.min(posPx.tail + 3, posPx.text) - maxPx;\n                    if(shiftPlus > 0) {\n                        posPx.tail += shiftPlus;\n                        posPx.text += shiftPlus;\n                    }\n                    else if(shiftMinus > 0) {\n                        posPx.tail -= shiftMinus;\n                        posPx.text -= shiftMinus;\n                    }\n                }\n\n                posPx.tail += overallShift;\n                posPx.head += overallShift;\n            }\n            else {\n                // with no arrow, the text rotates and *then* we put the anchor\n                // relative to the new bounding box\n                textShift = annSize * shiftFraction(autoAlignFraction, anchor);\n                textPadShift = textShift;\n                posPx.text = basePx + textShift;\n            }\n\n            posPx.text += overallShift;\n            textShift += overallShift;\n            textPadShift += overallShift;\n\n            // padplus/minus are used by autorange\n            options['_' + axLetter + 'padplus'] = (annSize / 2) + textPadShift;\n            options['_' + axLetter + 'padminus'] = (annSize / 2) - textPadShift;\n\n            // size/shift are used during dragging\n            options['_' + axLetter + 'size'] = annSize;\n            options['_' + axLetter + 'shift'] = textShift;\n        });\n\n        if(annotationIsOffscreen) {\n            annTextGroupInner.remove();\n            return;\n        }\n\n        var xShift = 0;\n        var yShift = 0;\n\n        if(options.align !== 'left') {\n            xShift = (annWidth - textWidth) * (options.align === 'center' ? 0.5 : 1);\n        }\n        if(options.valign !== 'top') {\n            yShift = (annHeight - textHeight) * (options.valign === 'middle' ? 0.5 : 1);\n        }\n\n        if(hasMathjax) {\n            mathjaxGroup.select('svg').attr({\n                x: borderfull + xShift - 1,\n                y: borderfull + yShift\n            })\n            .call(Drawing.setClipUrl, isSizeConstrained ? annClipID : null);\n        }\n        else {\n            var texty = borderfull + yShift - anntextBB.top,\n                textx = borderfull + xShift - anntextBB.left;\n            annText.attr({\n                x: textx,\n                y: texty\n            })\n            .call(Drawing.setClipUrl, isSizeConstrained ? annClipID : null);\n            annText.selectAll('tspan.line').attr({y: texty, x: textx});\n        }\n\n        annTextClip.select('rect').call(Drawing.setRect, borderfull, borderfull,\n            annWidth, annHeight);\n\n        annTextBG.call(Drawing.setRect, borderwidth / 2, borderwidth / 2,\n            outerWidth - borderwidth, outerHeight - borderwidth);\n\n        annTextGroupInner.call(Drawing.setTranslate,\n            Math.round(annPosPx.x.text - outerWidth / 2),\n            Math.round(annPosPx.y.text - outerHeight / 2));\n\n        /*\n         * rotate text and background\n         * we already calculated the text center position *as rotated*\n         * because we needed that for autoranging anyway, so now whether\n         * we have an arrow or not, we rotate about the text center.\n         */\n        annTextGroup.attr({transform: 'rotate(' + textangle + ',' +\n                            annPosPx.x.text + ',' + annPosPx.y.text + ')'});\n\n        var annbase = 'annotations[' + index + ']';\n\n        /*\n         * add the arrow\n         * uses options[arrowwidth,arrowcolor,arrowhead] for styling\n         * dx and dy are normally zero, but when you are dragging the textbox\n         * while the head stays put, dx and dy are the pixel offsets\n         */\n        var drawArrow = function(dx, dy) {\n            d3.select(gd)\n                .selectAll('.annotation-arrow-g[data-index=\"' + index + '\"]')\n                .remove();\n\n            var headX = annPosPx.x.head,\n                headY = annPosPx.y.head,\n                tailX = annPosPx.x.tail + dx,\n                tailY = annPosPx.y.tail + dy,\n                textX = annPosPx.x.text + dx,\n                textY = annPosPx.y.text + dy,\n\n                // find the edge of the text box, where we'll start the arrow:\n                // create transform matrix to rotate the text box corners\n                transform = Lib.rotationXYMatrix(textangle, textX, textY),\n                applyTransform = Lib.apply2DTransform(transform),\n                applyTransform2 = Lib.apply2DTransform2(transform),\n\n                // calculate and transform bounding box\n                width = +annTextBG.attr('width'),\n                height = +annTextBG.attr('height'),\n                xLeft = textX - 0.5 * width,\n                xRight = xLeft + width,\n                yTop = textY - 0.5 * height,\n                yBottom = yTop + height,\n                edges = [\n                    [xLeft, yTop, xLeft, yBottom],\n                    [xLeft, yBottom, xRight, yBottom],\n                    [xRight, yBottom, xRight, yTop],\n                    [xRight, yTop, xLeft, yTop]\n                ].map(applyTransform2);\n\n            // Remove the line if it ends inside the box.  Use ray\n            // casting for rotated boxes: see which edges intersect a\n            // line from the arrowhead to far away and reduce with xor\n            // to get the parity of the number of intersections.\n            if(edges.reduce(function(a, x) {\n                return a ^\n                    !!lineIntersect(headX, headY, headX + 1e6, headY + 1e6,\n                            x[0], x[1], x[2], x[3]);\n            }, false)) {\n                // no line or arrow - so quit drawArrow now\n                return;\n            }\n\n            edges.forEach(function(x) {\n                var p = lineIntersect(tailX, tailY, headX, headY,\n                            x[0], x[1], x[2], x[3]);\n                if(p) {\n                    tailX = p.x;\n                    tailY = p.y;\n                }\n            });\n\n            var strokewidth = options.arrowwidth,\n                arrowColor = options.arrowcolor;\n\n            var arrowGroup = annGroup.append('g')\n                .style({opacity: Color.opacity(arrowColor)})\n                .classed('annotation-arrow-g', true)\n                .attr('data-index', String(index));\n\n            var arrow = arrowGroup.append('path')\n                .attr('d', 'M' + tailX + ',' + tailY + 'L' + headX + ',' + headY)\n                .style('stroke-width', strokewidth + 'px')\n                .call(Color.stroke, Color.rgb(arrowColor));\n\n            drawArrowHead(arrow, options.arrowhead, 'end', options.arrowsize, options.standoff);\n\n            // the arrow dragger is a small square right at the head, then a line to the tail,\n            // all expanded by a stroke width of 6px plus the arrow line width\n            if(gd._context.editable && arrow.node().parentNode) {\n                var arrowDragHeadX = headX;\n                var arrowDragHeadY = headY;\n                if(options.standoff) {\n                    var arrowLength = Math.sqrt(Math.pow(headX - tailX, 2) + Math.pow(headY - tailY, 2));\n                    arrowDragHeadX += options.standoff * (tailX - headX) / arrowLength;\n                    arrowDragHeadY += options.standoff * (tailY - headY) / arrowLength;\n                }\n                var arrowDrag = arrowGroup.append('path')\n                    .classed('annotation', true)\n                    .classed('anndrag', true)\n                    .attr({\n                        'data-index': String(index),\n                        d: 'M3,3H-3V-3H3ZM0,0L' + (tailX - arrowDragHeadX) + ',' + (tailY - arrowDragHeadY),\n                        transform: 'translate(' + arrowDragHeadX + ',' + arrowDragHeadY + ')'\n                    })\n                    .style('stroke-width', (strokewidth + 6) + 'px')\n                    .call(Color.stroke, 'rgba(0,0,0,0)')\n                    .call(Color.fill, 'rgba(0,0,0,0)');\n\n                var update,\n                    annx0,\n                    anny0;\n\n                // dragger for the arrow & head: translates the whole thing\n                // (head/tail/text) all together\n                dragElement.init({\n                    element: arrowDrag.node(),\n                    prepFn: function() {\n                        var pos = Drawing.getTranslate(annTextGroupInner);\n\n                        annx0 = pos.x;\n                        anny0 = pos.y;\n                        update = {};\n                        if(xa && xa.autorange) {\n                            update[xa._name + '.autorange'] = true;\n                        }\n                        if(ya && ya.autorange) {\n                            update[ya._name + '.autorange'] = true;\n                        }\n                    },\n                    moveFn: function(dx, dy) {\n                        var annxy0 = applyTransform(annx0, anny0),\n                            xcenter = annxy0[0] + dx,\n                            ycenter = annxy0[1] + dy;\n                        annTextGroupInner.call(Drawing.setTranslate, xcenter, ycenter);\n\n                        update[annbase + '.x'] = xa ?\n                            xa.p2r(xa.r2p(options.x) + dx) :\n                            (options.x + (dx / gs.w));\n                        update[annbase + '.y'] = ya ?\n                            ya.p2r(ya.r2p(options.y) + dy) :\n                            (options.y - (dy / gs.h));\n\n                        if(options.axref === options.xref) {\n                            update[annbase + '.ax'] = xa.p2r(xa.r2p(options.ax) + dx);\n                        }\n\n                        if(options.ayref === options.yref) {\n                            update[annbase + '.ay'] = ya.p2r(ya.r2p(options.ay) + dy);\n                        }\n\n                        arrowGroup.attr('transform', 'translate(' + dx + ',' + dy + ')');\n                        annTextGroup.attr({\n                            transform: 'rotate(' + textangle + ',' +\n                                   xcenter + ',' + ycenter + ')'\n                        });\n                    },\n                    doneFn: function(dragged) {\n                        if(dragged) {\n                            Plotly.relayout(gd, update);\n                            var notesBox = document.querySelector('.js-notes-box-panel');\n                            if(notesBox) notesBox.redraw(notesBox.selectedObj);\n                        }\n                    }\n                });\n            }\n        };\n\n        if(options.showarrow) drawArrow(0, 0);\n\n        // user dragging the annotation (text, not arrow)\n        if(gd._context.editable) {\n            var update,\n                baseTextTransform;\n\n            // dragger for the textbox: if there's an arrow, just drag the\n            // textbox and tail, leave the head untouched\n            dragElement.init({\n                element: annTextGroupInner.node(),\n                prepFn: function() {\n                    baseTextTransform = annTextGroup.attr('transform');\n                    update = {};\n                },\n                moveFn: function(dx, dy) {\n                    var csr = 'pointer';\n                    if(options.showarrow) {\n                        if(options.axref === options.xref) {\n                            update[annbase + '.ax'] = xa.p2r(xa.r2p(options.ax) + dx);\n                        } else {\n                            update[annbase + '.ax'] = options.ax + dx;\n                        }\n\n                        if(options.ayref === options.yref) {\n                            update[annbase + '.ay'] = ya.p2r(ya.r2p(options.ay) + dy);\n                        } else {\n                            update[annbase + '.ay'] = options.ay + dy;\n                        }\n\n                        drawArrow(dx, dy);\n                    }\n                    else {\n                        if(xa) update[annbase + '.x'] = options.x + dx / xa._m;\n                        else {\n                            var widthFraction = options._xsize / gs.w,\n                                xLeft = options.x + (options._xshift - options.xshift) / gs.w -\n                                    widthFraction / 2;\n\n                            update[annbase + '.x'] = dragElement.align(xLeft + dx / gs.w,\n                                widthFraction, 0, 1, options.xanchor);\n                        }\n\n                        if(ya) update[annbase + '.y'] = options.y + dy / ya._m;\n                        else {\n                            var heightFraction = options._ysize / gs.h,\n                                yBottom = options.y - (options._yshift + options.yshift) / gs.h -\n                                    heightFraction / 2;\n\n                            update[annbase + '.y'] = dragElement.align(yBottom - dy / gs.h,\n                                heightFraction, 0, 1, options.yanchor);\n                        }\n                        if(!xa || !ya) {\n                            csr = dragElement.getCursor(\n                                xa ? 0.5 : update[annbase + '.x'],\n                                ya ? 0.5 : update[annbase + '.y'],\n                                options.xanchor, options.yanchor\n                            );\n                        }\n                    }\n\n                    annTextGroup.attr({\n                        transform: 'translate(' + dx + ',' + dy + ')' + baseTextTransform\n                    });\n\n                    setCursor(annTextGroupInner, csr);\n                },\n                doneFn: function(dragged) {\n                    setCursor(annTextGroupInner);\n                    if(dragged) {\n                        Plotly.relayout(gd, update);\n                        var notesBox = document.querySelector('.js-notes-box-panel');\n                        if(notesBox) notesBox.redraw(notesBox.selectedObj);\n                    }\n                }\n            });\n        }\n    }\n\n    if(gd._context.editable) {\n        annText.call(svgTextUtils.makeEditable, annTextGroupInner)\n            .call(textLayout)\n            .on('edit', function(_text) {\n                options.text = _text;\n                this.attr({'data-unformatted': options.text});\n                this.call(textLayout);\n                var update = {};\n                update['annotations[' + index + '].text'] = options.text;\n                if(xa && xa.autorange) {\n                    update[xa._name + '.autorange'] = true;\n                }\n                if(ya && ya.autorange) {\n                    update[ya._name + '.autorange'] = true;\n                }\n                Plotly.relayout(gd, update);\n            });\n    }\n    else annText.call(textLayout);\n}\n\n// look for intersection of two line segments\n//   (1->2 and 3->4) - returns array [x,y] if they do, null if not\nfunction lineIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {\n    var a = x2 - x1,\n        b = x3 - x1,\n        c = x4 - x3,\n        d = y2 - y1,\n        e = y3 - y1,\n        f = y4 - y3,\n        det = a * f - c * d;\n    // parallel lines? intersection is undefined\n    // ignore the case where they are colinear\n    if(det === 0) return null;\n    var t = (b * f - c * e) / det,\n        u = (b * d - a * e) / det;\n    // segments do not intersect?\n    if(u < 0 || u > 1 || t < 0 || t > 1) return null;\n\n    return {x: x1 + a * t, y: y1 + d * t};\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/annotations/draw_arrow_head.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\nvar isNumeric = require('fast-isnumeric');\n\nvar Color = require('../color');\nvar Drawing = require('../drawing');\n\nvar ARROWPATHS = require('./arrow_paths');\n\n// add arrowhead(s) to a path or line d3 element el3\n// style: 1-6, first 5 are pointers, 6 is circle, 7 is square, 8 is none\n// ends is 'start', 'end' (default), 'start+end'\n// mag is magnification vs. default (default 1)\n\nmodule.exports = function drawArrowHead(el3, style, ends, mag, standoff) {\n    if(!isNumeric(mag)) mag = 1;\n    var el = el3.node(),\n        headStyle = ARROWPATHS[style||0];\n\n    if(typeof ends !== 'string' || !ends) ends = 'end';\n\n    var scale = (Drawing.getPx(el3, 'stroke-width') || 1) * mag,\n        stroke = el3.style('stroke') || Color.defaultLine,\n        opacity = el3.style('stroke-opacity') || 1,\n        doStart = ends.indexOf('start') >= 0,\n        doEnd = ends.indexOf('end') >= 0,\n        backOff = headStyle.backoff * scale + standoff,\n        start,\n        end,\n        startRot,\n        endRot;\n\n    if(el.nodeName === 'line') {\n        start = {x: +el3.attr('x1'), y: +el3.attr('y1')};\n        end = {x: +el3.attr('x2'), y: +el3.attr('y2')};\n\n        var dx = start.x - end.x,\n            dy = start.y - end.y;\n\n        startRot = Math.atan2(dy, dx);\n        endRot = startRot + Math.PI;\n        if(backOff) {\n            if(backOff * backOff > dx * dx + dy * dy) {\n                hideLine();\n                return;\n            }\n            var backOffX = backOff * Math.cos(startRot),\n                backOffY = backOff * Math.sin(startRot);\n\n            if(doStart) {\n                start.x -= backOffX;\n                start.y -= backOffY;\n                el3.attr({x1: start.x, y1: start.y});\n            }\n            if(doEnd) {\n                end.x += backOffX;\n                end.y += backOffY;\n                el3.attr({x2: end.x, y2: end.y});\n            }\n        }\n    }\n    else if(el.nodeName === 'path') {\n        var pathlen = el.getTotalLength(),\n            // using dash to hide the backOff region of the path.\n            // if we ever allow dash for the arrow we'll have to\n            // do better than this hack... maybe just manually\n            // combine the two\n            dashArray = '';\n\n        if(pathlen < backOff) {\n            hideLine();\n            return;\n        }\n\n        if(doStart) {\n            var start0 = el.getPointAtLength(0),\n                dstart = el.getPointAtLength(0.1);\n            startRot = Math.atan2(start0.y - dstart.y, start0.x - dstart.x);\n            start = el.getPointAtLength(Math.min(backOff, pathlen));\n            if(backOff) dashArray = '0px,' + backOff + 'px,';\n        }\n\n        if(doEnd) {\n            var end0 = el.getPointAtLength(pathlen),\n                dend = el.getPointAtLength(pathlen - 0.1);\n            endRot = Math.atan2(end0.y - dend.y, end0.x - dend.x);\n            end = el.getPointAtLength(Math.max(0, pathlen - backOff));\n\n            if(backOff) {\n                var shortening = dashArray ? 2 * backOff : backOff;\n                dashArray += (pathlen - shortening) + 'px,' + pathlen + 'px';\n            }\n        }\n        else if(dashArray) dashArray += pathlen + 'px';\n\n        if(dashArray) el3.style('stroke-dasharray', dashArray);\n    }\n\n    function hideLine() { el3.style('stroke-dasharray', '0px,100px'); }\n\n    function drawhead(p, rot) {\n        if(!headStyle.path) return;\n        if(style > 5) rot = 0; // don't rotate square or circle\n        d3.select(el.parentElement).append('path')\n            .attr({\n                'class': el3.attr('class'),\n                d: headStyle.path,\n                transform:\n                    'translate(' + p.x + ',' + p.y + ')' +\n                    'rotate(' + (rot * 180 / Math.PI) + ')' +\n                    'scale(' + scale + ')'\n            })\n            .style({\n                fill: stroke,\n                opacity: opacity,\n                'stroke-width': 0\n            });\n    }\n\n    if(doStart) drawhead(start, startRot);\n    if(doEnd) drawhead(end, endRot);\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/annotations/click.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Plotly = require('../../plotly');\n\n\nmodule.exports = {\n    hasClickToShow: hasClickToShow,\n    onClick: onClick\n};\n\n/*\n * hasClickToShow: does the given hoverData have ANY annotations which will\n * turn ON if we click here? (used by hover events to set cursor)\n *\n * gd: graphDiv\n * hoverData: a hoverData array, as included with the *plotly_hover* or\n *     *plotly_click* events in the `points` attribute\n *\n * returns: boolean\n */\nfunction hasClickToShow(gd, hoverData) {\n    var sets = getToggleSets(gd, hoverData);\n    return sets.on.length > 0 || sets.explicitOff.length > 0;\n}\n\n/*\n * onClick: perform the toggling (via Plotly.update) implied by clicking\n * at this hoverData\n *\n * gd: graphDiv\n * hoverData: a hoverData array, as included with the *plotly_hover* or\n *     *plotly_click* events in the `points` attribute\n *\n * returns: Promise that the update is complete\n */\nfunction onClick(gd, hoverData) {\n    var toggleSets = getToggleSets(gd, hoverData),\n        onSet = toggleSets.on,\n        offSet = toggleSets.off.concat(toggleSets.explicitOff),\n        update = {},\n        i;\n\n    if(!(onSet.length || offSet.length)) return;\n\n    for(i = 0; i < onSet.length; i++) {\n        update['annotations[' + onSet[i] + '].visible'] = true;\n    }\n\n    for(i = 0; i < offSet.length; i++) {\n        update['annotations[' + offSet[i] + '].visible'] = false;\n    }\n\n    return Plotly.update(gd, {}, update);\n}\n\n/*\n * getToggleSets: find the annotations which will turn on or off at this\n * hoverData\n *\n * gd: graphDiv\n * hoverData: a hoverData array, as included with the *plotly_hover* or\n *     *plotly_click* events in the `points` attribute\n *\n * returns: {\n *   on: Array (indices of annotations to turn on),\n *   off: Array (indices to turn off because you're not hovering on them),\n *   explicitOff: Array (indices to turn off because you *are* hovering on them)\n * }\n */\nfunction getToggleSets(gd, hoverData) {\n    var annotations = gd._fullLayout.annotations,\n        onSet = [],\n        offSet = [],\n        explicitOffSet = [],\n        hoverLen = (hoverData || []).length;\n\n    var i, j, anni, showMode, pointj, toggleType;\n\n    for(i = 0; i < annotations.length; i++) {\n        anni = annotations[i];\n        showMode = anni.clicktoshow;\n        if(showMode) {\n            for(j = 0; j < hoverLen; j++) {\n                pointj = hoverData[j];\n                if(pointj.xaxis._id === anni.xref &&\n                    pointj.yaxis._id === anni.yref &&\n                    pointj.xaxis.d2r(pointj.x) === anni._xclick &&\n                    pointj.yaxis.d2r(pointj.y) === anni._yclick\n                ) {\n                    // match! toggle this annotation\n                    // regardless of its clicktoshow mode\n                    // but if it's onout mode, off is implicit\n                    if(anni.visible) {\n                        if(showMode === 'onout') toggleType = offSet;\n                        else toggleType = explicitOffSet;\n                    }\n                    else {\n                        toggleType = onSet;\n                    }\n                    toggleType.push(i);\n                    break;\n                }\n            }\n\n            if(j === hoverLen) {\n                // no match - only turn this annotation OFF, and only if\n                // showmode is 'onout'\n                if(anni.visible && showMode === 'onout') offSet.push(i);\n            }\n        }\n    }\n\n    return {on: onSet, off: offSet, explicitOff: explicitOffSet};\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/annotations/convert_coords.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar toLogRange = require('../../lib/to_log_range');\n\n/*\n * convertCoords: when converting an axis between log and linear\n * you need to alter any annotations on that axis to keep them\n * pointing at the same data point.\n * In v2.0 this will become obsolete\n *\n * gd: the plot div\n * ax: the axis being changed\n * newType: the type it's getting\n * doExtra: function(attr, val) from inside relayout that sets the attribute.\n *     Use this to make the changes as it's aware if any other changes in the\n *     same relayout call should override this conversion.\n */\nmodule.exports = function convertCoords(gd, ax, newType, doExtra) {\n    ax = ax || {};\n\n    var toLog = (newType === 'log') && (ax.type === 'linear'),\n        fromLog = (newType === 'linear') && (ax.type === 'log');\n\n    if(!(toLog || fromLog)) return;\n\n    var annotations = gd._fullLayout.annotations,\n        axLetter = ax._id.charAt(0),\n        ann,\n        attrPrefix;\n\n    function convert(attr) {\n        var currentVal = ann[attr],\n            newVal = null;\n\n        if(toLog) newVal = toLogRange(currentVal, ax.range);\n        else newVal = Math.pow(10, currentVal);\n\n        // if conversion failed, delete the value so it gets a default value\n        if(!isNumeric(newVal)) newVal = null;\n\n        doExtra(attrPrefix + attr, newVal);\n    }\n\n    for(var i = 0; i < annotations.length; i++) {\n        ann = annotations[i];\n        attrPrefix = 'annotations[' + i + '].';\n\n        if(ann[axLetter + 'ref'] === ax._id) convert(axLetter);\n        if(ann['a' + axLetter + 'ref'] === ax._id) convert('a' + axLetter);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/annotations/defaults.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar handleArrayContainerDefaults = require('../../plots/array_container_defaults');\nvar handleAnnotationDefaults = require('./annotation_defaults');\n\n\nmodule.exports = function supplyLayoutDefaults(layoutIn, layoutOut) {\n    var opts = {\n        name: 'annotations',\n        handleItemDefaults: handleAnnotationDefaults\n    };\n\n    handleArrayContainerDefaults(layoutIn, layoutOut, opts);\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/legend/anchor_utils.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\n\n/**\n * Determine the position anchor property of x/y xanchor/yanchor components.\n *\n * - values < 1/3 align the low side at that fraction,\n * - values [1/3, 2/3] align the center at that fraction,\n * - values > 2/3 align the right at that fraction.\n */\n\nexports.isRightAnchor = function isRightAnchor(opts) {\n    return (\n        opts.xanchor === 'right' ||\n        (opts.xanchor === 'auto' && opts.x >= 2 / 3)\n    );\n};\n\nexports.isCenterAnchor = function isCenterAnchor(opts) {\n    return (\n        opts.xanchor === 'center' ||\n        (opts.xanchor === 'auto' && opts.x > 1 / 3 && opts.x < 2 / 3)\n    );\n};\n\nexports.isBottomAnchor = function isBottomAnchor(opts) {\n    return (\n        opts.yanchor === 'bottom' ||\n        (opts.yanchor === 'auto' && opts.y <= 1 / 3)\n    );\n};\n\nexports.isMiddleAnchor = function isMiddleAnchor(opts) {\n    return (\n        opts.yanchor === 'middle' ||\n        (opts.yanchor === 'auto' && opts.y > 1 / 3 && opts.y < 2 / 3)\n    );\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/legend/get_legend_data.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Registry = require('../../registry');\nvar helpers = require('./helpers');\n\n\nmodule.exports = function getLegendData(calcdata, opts) {\n    var lgroupToTraces = {},\n        lgroups = [],\n        hasOneNonBlankGroup = false,\n        slicesShown = {},\n        lgroupi = 0;\n\n    var i, j;\n\n    function addOneItem(legendGroup, legendItem) {\n        // each '' legend group is treated as a separate group\n        if(legendGroup === '' || !helpers.isGrouped(opts)) {\n            var uniqueGroup = '~~i' + lgroupi; // TODO: check this against fullData legendgroups?\n\n            lgroups.push(uniqueGroup);\n            lgroupToTraces[uniqueGroup] = [[legendItem]];\n            lgroupi++;\n        }\n        else if(lgroups.indexOf(legendGroup) === -1) {\n            lgroups.push(legendGroup);\n            hasOneNonBlankGroup = true;\n            lgroupToTraces[legendGroup] = [[legendItem]];\n        }\n        else lgroupToTraces[legendGroup].push([legendItem]);\n    }\n\n    // build an { legendgroup: [cd0, cd0], ... } object\n    for(i = 0; i < calcdata.length; i++) {\n        var cd = calcdata[i],\n            cd0 = cd[0],\n            trace = cd0.trace,\n            lgroup = trace.legendgroup;\n\n        if(!helpers.legendGetsTrace(trace) || !trace.showlegend) continue;\n\n        if(Registry.traceIs(trace, 'pie')) {\n            if(!slicesShown[lgroup]) slicesShown[lgroup] = {};\n\n            for(j = 0; j < cd.length; j++) {\n                var labelj = cd[j].label;\n\n                if(!slicesShown[lgroup][labelj]) {\n                    addOneItem(lgroup, {\n                        label: labelj,\n                        color: cd[j].color,\n                        i: cd[j].i,\n                        trace: trace\n                    });\n\n                    slicesShown[lgroup][labelj] = true;\n                }\n            }\n        }\n\n        else addOneItem(lgroup, cd0);\n    }\n\n    // won't draw a legend in this case\n    if(!lgroups.length) return [];\n\n    // rearrange lgroupToTraces into a d3-friendly array of arrays\n    var lgroupsLength = lgroups.length,\n        ltraces,\n        legendData;\n\n    if(hasOneNonBlankGroup && helpers.isGrouped(opts)) {\n        legendData = new Array(lgroupsLength);\n\n        for(i = 0; i < lgroupsLength; i++) {\n            ltraces = lgroupToTraces[lgroups[i]];\n            legendData[i] = helpers.isReversed(opts) ? ltraces.reverse() : ltraces;\n        }\n    }\n    else {\n        // collapse all groups into one if all groups are blank\n        legendData = [new Array(lgroupsLength)];\n\n        for(i = 0; i < lgroupsLength; i++) {\n            ltraces = lgroupToTraces[lgroups[i]][0];\n            legendData[0][helpers.isReversed(opts) ? lgroupsLength - i - 1 : i] = ltraces;\n        }\n        lgroupsLength = 1;\n    }\n\n    // needed in repositionLegend\n    opts._lgroupsLength = lgroupsLength;\n    return legendData;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/legend/helpers.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Registry = require('../../registry');\n\n\nexports.legendGetsTrace = function legendGetsTrace(trace) {\n    return trace.visible && Registry.traceIs(trace, 'showLegend');\n};\n\nexports.isGrouped = function isGrouped(legendLayout) {\n    return (legendLayout.traceorder || '').indexOf('grouped') !== -1;\n};\n\nexports.isVertical = function isVertical(legendLayout) {\n    return legendLayout.orientation !== 'h';\n};\n\nexports.isReversed = function isReversed(legendLayout) {\n    return (legendLayout.traceorder || '').indexOf('reversed') !== -1;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/rangeselector/button_attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n\nmodule.exports = {\n    step: {\n        valType: 'enumerated',\n        role: 'info',\n        values: ['month', 'year', 'day', 'hour', 'minute', 'second', 'all'],\n        dflt: 'month',\n        description: [\n            'The unit of measurement that the `count` value will set the range by.'\n        ].join(' ')\n    },\n    stepmode: {\n        valType: 'enumerated',\n        role: 'info',\n        values: ['backward', 'todate'],\n        dflt: 'backward',\n        description: [\n            'Sets the range update mode.',\n            'If *backward*, the range update shifts the start of range',\n            'back *count* times *step* milliseconds.',\n            'If *todate*, the range update shifts the start of range',\n            'back to the first timestamp from *count* times',\n            '*step* milliseconds back.',\n            'For example, with `step` set to *year* and `count` set to *1*',\n            'the range update shifts the start of the range back to',\n            'January 01 of the current year.',\n            'Month and year *todate* are currently available only',\n            'for the built-in (Gregorian) calendar.'\n        ].join(' ')\n    },\n    count: {\n        valType: 'number',\n        role: 'info',\n        min: 0,\n        dflt: 1,\n        description: [\n            'Sets the number of steps to take to update the range.',\n            'Use with `step` to specify the update interval.'\n        ].join(' ')\n    },\n    label: {\n        valType: 'string',\n        role: 'info',\n        description: 'Sets the text label to appear on the button.'\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/rangeselector/get_update_object.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\n\nmodule.exports = function getUpdateObject(axisLayout, buttonLayout) {\n    var axName = axisLayout._name;\n    var update = {};\n\n    if(buttonLayout.step === 'all') {\n        update[axName + '.autorange'] = true;\n    }\n    else {\n        var xrange = getXRange(axisLayout, buttonLayout);\n\n        update[axName + '.range[0]'] = xrange[0];\n        update[axName + '.range[1]'] = xrange[1];\n    }\n\n    return update;\n};\n\nfunction getXRange(axisLayout, buttonLayout) {\n    var currentRange = axisLayout.range;\n    var base = new Date(axisLayout.r2l(currentRange[1]));\n\n    var step = buttonLayout.step,\n        count = buttonLayout.count;\n\n    var range0;\n\n    switch(buttonLayout.stepmode) {\n        case 'backward':\n            range0 = axisLayout.l2r(+d3.time[step].utc.offset(base, -count));\n            break;\n\n        case 'todate':\n            var base2 = d3.time[step].utc.offset(base, -count);\n\n            range0 = axisLayout.l2r(+d3.time[step].utc.ceil(base2));\n            break;\n    }\n\n    var range1 = currentRange[1];\n\n    return [range0, range1];\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/shapes/shape_defaults.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar Axes = require('../../plots/cartesian/axes');\n\nvar attributes = require('./attributes');\nvar helpers = require('./helpers');\n\n\nmodule.exports = function handleShapeDefaults(shapeIn, shapeOut, fullLayout, opts, itemOpts) {\n    opts = opts || {};\n    itemOpts = itemOpts || {};\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(shapeIn, shapeOut, attributes, attr, dflt);\n    }\n\n    var visible = coerce('visible', !itemOpts.itemIsNotPlainObject);\n\n    if(!visible) return shapeOut;\n\n    coerce('layer');\n    coerce('opacity');\n    coerce('fillcolor');\n    coerce('line.color');\n    coerce('line.width');\n    coerce('line.dash');\n\n    var dfltType = shapeIn.path ? 'path' : 'rect',\n        shapeType = coerce('type', dfltType);\n\n    // positioning\n    var axLetters = ['x', 'y'];\n    for(var i = 0; i < 2; i++) {\n        var axLetter = axLetters[i],\n            gdMock = {_fullLayout: fullLayout};\n\n        // xref, yref\n        var axRef = Axes.coerceRef(shapeIn, shapeOut, gdMock, axLetter, '', 'paper');\n\n        if(shapeType !== 'path') {\n            var dflt0 = 0.25,\n                dflt1 = 0.75,\n                ax,\n                pos2r,\n                r2pos;\n\n            if(axRef !== 'paper') {\n                ax = Axes.getFromId(gdMock, axRef);\n                r2pos = helpers.rangeToShapePosition(ax);\n                pos2r = helpers.shapePositionToRange(ax);\n            }\n            else {\n                pos2r = r2pos = Lib.identity;\n            }\n\n            // hack until V2.0 when log has regular range behavior - make it look like other\n            // ranges to send to coerce, then put it back after\n            // this is all to give reasonable default position behavior on log axes, which is\n            // a pretty unimportant edge case so we could just ignore this.\n            var attr0 = axLetter + '0',\n                attr1 = axLetter + '1',\n                in0 = shapeIn[attr0],\n                in1 = shapeIn[attr1];\n            shapeIn[attr0] = pos2r(shapeIn[attr0], true);\n            shapeIn[attr1] = pos2r(shapeIn[attr1], true);\n\n            // x0, x1 (and y0, y1)\n            Axes.coercePosition(shapeOut, gdMock, coerce, axRef, attr0, dflt0);\n            Axes.coercePosition(shapeOut, gdMock, coerce, axRef, attr1, dflt1);\n\n            // hack part 2\n            shapeOut[attr0] = r2pos(shapeOut[attr0]);\n            shapeOut[attr1] = r2pos(shapeOut[attr1]);\n            shapeIn[attr0] = in0;\n            shapeIn[attr1] = in1;\n        }\n    }\n\n    if(shapeType === 'path') {\n        coerce('path');\n    }\n    else {\n        Lib.noneOrAll(shapeIn, shapeOut, ['x0', 'x1', 'y0', 'y1']);\n    }\n\n    return shapeOut;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/shapes/attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar annAttrs = require('../annotations/attributes');\nvar scatterLineAttrs = require('../../traces/scatter/attributes').line;\nvar dash = require('../drawing/attributes').dash;\nvar extendFlat = require('../../lib/extend').extendFlat;\n\nmodule.exports = {\n    _isLinkedToArray: 'shape',\n\n    visible: {\n        valType: 'boolean',\n        role: 'info',\n        dflt: true,\n        description: [\n            'Determines whether or not this shape is visible.'\n        ].join(' ')\n    },\n\n    type: {\n        valType: 'enumerated',\n        values: ['circle', 'rect', 'path', 'line'],\n        role: 'info',\n        description: [\n            'Specifies the shape type to be drawn.',\n\n            'If *line*, a line is drawn from (`x0`,`y0`) to (`x1`,`y1`)',\n\n            'If *circle*, a circle is drawn from',\n            '((`x0`+`x1`)/2, (`y0`+`y1`)/2))',\n            'with radius',\n            '(|(`x0`+`x1`)/2 - `x0`|, |(`y0`+`y1`)/2 -`y0`)|)',\n\n            'If *rect*, a rectangle is drawn linking',\n            '(`x0`,`y0`), (`x1`,`y0`), (`x1`,`y1`), (`x0`,`y1`), (`x0`,`y0`)',\n\n            'If *path*, draw a custom SVG path using `path`.'\n        ].join(' ')\n    },\n\n    layer: {\n        valType: 'enumerated',\n        values: ['below', 'above'],\n        dflt: 'above',\n        role: 'info',\n        description: 'Specifies whether shapes are drawn below or above traces.'\n    },\n\n    xref: extendFlat({}, annAttrs.xref, {\n        description: [\n            'Sets the shape\\'s x coordinate axis.',\n            'If set to an x axis id (e.g. *x* or *x2*), the `x` position',\n            'refers to an x coordinate',\n            'If set to *paper*, the `x` position refers to the distance from',\n            'the left side of the plotting area in normalized coordinates',\n            'where *0* (*1*) corresponds to the left (right) side.',\n            'If the axis `type` is *log*, then you must take the',\n            'log of your desired range.',\n            'If the axis `type` is *date*, then you must convert',\n            'the date to unix time in milliseconds.'\n        ].join(' ')\n    }),\n    x0: {\n        valType: 'any',\n        role: 'info',\n        description: [\n            'Sets the shape\\'s starting x position.',\n            'See `type` for more info.'\n        ].join(' ')\n    },\n    x1: {\n        valType: 'any',\n        role: 'info',\n        description: [\n            'Sets the shape\\'s end x position.',\n            'See `type` for more info.'\n        ].join(' ')\n    },\n\n    yref: extendFlat({}, annAttrs.yref, {\n        description: [\n            'Sets the annotation\\'s y coordinate axis.',\n            'If set to an y axis id (e.g. *y* or *y2*), the `y` position',\n            'refers to an y coordinate',\n            'If set to *paper*, the `y` position refers to the distance from',\n            'the bottom of the plotting area in normalized coordinates',\n            'where *0* (*1*) corresponds to the bottom (top).'\n        ].join(' ')\n    }),\n    y0: {\n        valType: 'any',\n        role: 'info',\n        description: [\n            'Sets the shape\\'s starting y position.',\n            'See `type` for more info.'\n        ].join(' ')\n    },\n    y1: {\n        valType: 'any',\n        role: 'info',\n        description: [\n            'Sets the shape\\'s end y position.',\n            'See `type` for more info.'\n        ].join(' ')\n    },\n\n    path: {\n        valType: 'string',\n        role: 'info',\n        description: [\n            'For `type` *path* - a valid SVG path but with the pixel values',\n            'replaced by data values. There are a few restrictions / quirks',\n            'only absolute instructions, not relative. So the allowed segments',\n            'are: M, L, H, V, Q, C, T, S, and Z',\n            'arcs (A) are not allowed because radius rx and ry are relative.',\n\n            'In the future we could consider supporting relative commands,',\n            'but we would have to decide on how to handle date and log axes.',\n            'Note that even as is, Q and C Bezier paths that are smooth on',\n            'linear axes may not be smooth on log, and vice versa.',\n            'no chained \"polybezier\" commands - specify the segment type for',\n            'each one.',\n\n            'On category axes, values are numbers scaled to the serial numbers',\n            'of categories because using the categories themselves there would',\n            'be no way to describe fractional positions',\n            'On data axes: because space and T are both normal components of path',\n            'strings, we can\\'t use either to separate date from time parts.',\n            'Therefore we\\'ll use underscore for this purpose:',\n            '2015-02-21_13:45:56.789'\n        ].join(' ')\n    },\n\n    opacity: {\n        valType: 'number',\n        min: 0,\n        max: 1,\n        dflt: 1,\n        role: 'info',\n        description: 'Sets the opacity of the shape.'\n    },\n    line: {\n        color: scatterLineAttrs.color,\n        width: scatterLineAttrs.width,\n        dash: dash,\n        role: 'info'\n    },\n    fillcolor: {\n        valType: 'color',\n        dflt: 'rgba(0,0,0,0)',\n        role: 'info',\n        description: [\n            'Sets the color filling the shape\\'s interior.'\n        ].join(' ')\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/components/updatemenus/scrollbox.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = ScrollBox;\n\nvar d3 = require('d3');\n\nvar Color = require('../color');\nvar Drawing = require('../drawing');\n\nvar Lib = require('../../lib');\n\n/**\n * Helper class to setup a scroll box\n *\n * @class\n * @param           gd          Plotly's graph div\n * @param           container   Container to be scroll-boxed (as a D3 selection)\n * @param {string}  id          Id for the clip path to implement the scroll box\n */\nfunction ScrollBox(gd, container, id) {\n    this.gd = gd;\n    this.container = container;\n    this.id = id;\n\n    // See ScrollBox.prototype.enable for further definition\n    this.position = null;  // scrollbox position\n    this.translateX = null;  // scrollbox horizontal translation\n    this.translateY = null;  // scrollbox vertical translation\n    this.hbar = null;  // horizontal scrollbar D3 selection\n    this.vbar = null;  // vertical scrollbar D3 selection\n\n    // <rect> element to capture pointer events\n    this.bg = this.container.selectAll('rect.scrollbox-bg').data([0]);\n\n    this.bg.exit()\n        .on('.drag', null)\n        .on('wheel', null)\n        .remove();\n\n    this.bg.enter().append('rect')\n        .classed('scrollbox-bg', true)\n        .style('pointer-events', 'all')\n        .attr({\n            opacity: 0,\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        });\n}\n\n// scroll bar dimensions\nScrollBox.barWidth = 2;\nScrollBox.barLength = 20;\nScrollBox.barRadius = 2;\nScrollBox.barPad = 1;\nScrollBox.barColor = '#808BA4';\n\n/**\n * If needed, setup a clip path and scrollbars\n *\n * @method\n * @param {Object}  position\n * @param {number}  position.l  Left side position (in pixels)\n * @param {number}  position.t  Top side (in pixels)\n * @param {number}  position.w  Width (in pixels)\n * @param {number}  position.h  Height (in pixels)\n * @param {string}  [position.direction='down']\n *                  Either 'down', 'left', 'right' or 'up'\n * @param {number}  [translateX=0]  Horizontal offset (in pixels)\n * @param {number}  [translateY=0]  Vertical offset (in pixels)\n */\nScrollBox.prototype.enable = function enable(position, translateX, translateY) {\n    var fullLayout = this.gd._fullLayout,\n        fullWidth = fullLayout.width,\n        fullHeight = fullLayout.height;\n\n    // compute position of scrollbox\n    this.position = position;\n\n    var l = this.position.l,\n        w = this.position.w,\n        t = this.position.t,\n        h = this.position.h,\n        direction = this.position.direction,\n        isDown = (direction === 'down'),\n        isLeft = (direction === 'left'),\n        isRight = (direction === 'right'),\n        isUp = (direction === 'up'),\n        boxW = w,\n        boxH = h,\n        boxL, boxR,\n        boxT, boxB;\n\n    if(!isDown && !isLeft && !isRight && !isUp) {\n        this.position.direction = 'down';\n        isDown = true;\n    }\n\n    var isVertical = isDown || isUp;\n    if(isVertical) {\n        boxL = l;\n        boxR = boxL + boxW;\n\n        if(isDown) {\n            // anchor to top side\n            boxT = t;\n            boxB = Math.min(boxT + boxH, fullHeight);\n            boxH = boxB - boxT;\n        }\n        else {\n            // anchor to bottom side\n            boxB = t + boxH;\n            boxT = Math.max(boxB - boxH, 0);\n            boxH = boxB - boxT;\n        }\n    }\n    else {\n        boxT = t;\n        boxB = boxT + boxH;\n\n        if(isLeft) {\n            // anchor to right side\n            boxR = l + boxW;\n            boxL = Math.max(boxR - boxW, 0);\n            boxW = boxR - boxL;\n        }\n        else {\n            // anchor to left side\n            boxL = l;\n            boxR = Math.min(boxL + boxW, fullWidth);\n            boxW = boxR - boxL;\n        }\n    }\n\n    this._box = {\n        l: boxL,\n        t: boxT,\n        w: boxW,\n        h: boxH\n    };\n\n    // compute position of horizontal scroll bar\n    var needsHorizontalScrollBar = (w > boxW),\n        hbarW = ScrollBox.barLength + 2 * ScrollBox.barPad,\n        hbarH = ScrollBox.barWidth + 2 * ScrollBox.barPad,\n        // draw horizontal scrollbar on the bottom side\n        hbarL = l,\n        hbarT = t + h;\n\n    if(hbarT + hbarH > fullHeight) hbarT = fullHeight - hbarH;\n\n    var hbar = this.container.selectAll('rect.scrollbar-horizontal').data(\n            (needsHorizontalScrollBar) ? [0] : []);\n\n    hbar.exit()\n        .on('.drag', null)\n        .remove();\n\n    hbar.enter().append('rect')\n        .classed('scrollbar-horizontal', true)\n        .call(Color.fill, ScrollBox.barColor);\n\n    if(needsHorizontalScrollBar) {\n        this.hbar = hbar.attr({\n            'rx': ScrollBox.barRadius,\n            'ry': ScrollBox.barRadius,\n            'x': hbarL,\n            'y': hbarT,\n            'width': hbarW,\n            'height': hbarH\n        });\n\n        // hbar center moves between hbarXMin and hbarXMin + hbarTranslateMax\n        this._hbarXMin = hbarL + hbarW / 2;\n        this._hbarTranslateMax = boxW - hbarW;\n    }\n    else {\n        delete this.hbar;\n        delete this._hbarXMin;\n        delete this._hbarTranslateMax;\n    }\n\n    // compute position of vertical scroll bar\n    var needsVerticalScrollBar = (h > boxH),\n        vbarW = ScrollBox.barWidth + 2 * ScrollBox.barPad,\n        vbarH = ScrollBox.barLength + 2 * ScrollBox.barPad,\n        // draw vertical scrollbar on the right side\n        vbarL = l + w,\n        vbarT = t;\n\n    if(vbarL + vbarW > fullWidth) vbarL = fullWidth - vbarW;\n\n    var vbar = this.container.selectAll('rect.scrollbar-vertical').data(\n            (needsVerticalScrollBar) ? [0] : []);\n\n    vbar.exit()\n        .on('.drag', null)\n        .remove();\n\n    vbar.enter().append('rect')\n        .classed('scrollbar-vertical', true)\n        .call(Color.fill, ScrollBox.barColor);\n\n    if(needsVerticalScrollBar) {\n        this.vbar = vbar.attr({\n            'rx': ScrollBox.barRadius,\n            'ry': ScrollBox.barRadius,\n            'x': vbarL,\n            'y': vbarT,\n            'width': vbarW,\n            'height': vbarH\n        });\n\n        // vbar center moves between vbarYMin and vbarYMin + vbarTranslateMax\n        this._vbarYMin = vbarT + vbarH / 2;\n        this._vbarTranslateMax = boxH - vbarH;\n    }\n    else {\n        delete this.vbar;\n        delete this._vbarYMin;\n        delete this._vbarTranslateMax;\n    }\n\n    // setup a clip path (if scroll bars are needed)\n    var clipId = this.id,\n        clipL = boxL - 0.5,\n        clipR = (needsVerticalScrollBar) ? boxR + vbarW + 0.5 : boxR + 0.5,\n        clipT = boxT - 0.5,\n        clipB = (needsHorizontalScrollBar) ? boxB + hbarH + 0.5 : boxB + 0.5;\n\n    var clipPath = fullLayout._topdefs.selectAll('#' + clipId)\n        .data((needsHorizontalScrollBar || needsVerticalScrollBar) ? [0] : []);\n\n    clipPath.exit().remove();\n\n    clipPath.enter()\n        .append('clipPath').attr('id', clipId)\n        .append('rect');\n\n    if(needsHorizontalScrollBar || needsVerticalScrollBar) {\n        this._clipRect = clipPath.select('rect').attr({\n            x: Math.floor(clipL),\n            y: Math.floor(clipT),\n            width: Math.ceil(clipR) - Math.floor(clipL),\n            height: Math.ceil(clipB) - Math.floor(clipT)\n        });\n\n        this.container.call(Drawing.setClipUrl, clipId);\n\n        this.bg.attr({\n            x: l,\n            y: t,\n            width: w,\n            height: h\n        });\n    }\n    else {\n        this.bg.attr({\n            width: 0,\n            height: 0\n        });\n        this.container\n            .on('wheel', null)\n            .on('.drag', null)\n            .call(Drawing.setClipUrl, null);\n        delete this._clipRect;\n    }\n\n    // set up drag listeners (if scroll bars are needed)\n    if(needsHorizontalScrollBar || needsVerticalScrollBar) {\n        var onBoxDrag = d3.behavior.drag()\n            .on('dragstart', function() {\n                d3.event.sourceEvent.preventDefault();\n            })\n            .on('drag', this._onBoxDrag.bind(this));\n\n        this.container\n            .on('wheel', null)\n            .on('wheel', this._onBoxWheel.bind(this))\n            .on('.drag', null)\n            .call(onBoxDrag);\n\n        var onBarDrag = d3.behavior.drag()\n            .on('dragstart', function() {\n                d3.event.sourceEvent.preventDefault();\n                d3.event.sourceEvent.stopPropagation();\n            })\n            .on('drag', this._onBarDrag.bind(this));\n\n        if(needsHorizontalScrollBar) {\n            this.hbar\n                .on('.drag', null)\n                .call(onBarDrag);\n        }\n\n        if(needsVerticalScrollBar) {\n            this.vbar\n                .on('.drag', null)\n                .call(onBarDrag);\n        }\n    }\n\n    // set scrollbox translation\n    this.setTranslate(translateX, translateY);\n};\n\n/**\n * If present, remove clip-path and scrollbars\n *\n * @method\n */\nScrollBox.prototype.disable = function disable() {\n    if(this.hbar || this.vbar) {\n        this.bg.attr({\n            width: 0,\n            height: 0\n        });\n        this.container\n            .on('wheel', null)\n            .on('.drag', null)\n            .call(Drawing.setClipUrl, null);\n        delete this._clipRect;\n    }\n\n    if(this.hbar) {\n        this.hbar.on('.drag', null);\n        this.hbar.remove();\n        delete this.hbar;\n        delete this._hbarXMin;\n        delete this._hbarTranslateMax;\n    }\n\n    if(this.vbar) {\n        this.vbar.on('.drag', null);\n        this.vbar.remove();\n        delete this.vbar;\n        delete this._vbarYMin;\n        delete this._vbarTranslateMax;\n    }\n};\n\n/**\n * Handles scroll box drag events\n *\n * @method\n */\nScrollBox.prototype._onBoxDrag = function onBarDrag() {\n    var translateX = this.translateX,\n        translateY = this.translateY;\n\n    if(this.hbar) {\n        translateX -= d3.event.dx;\n    }\n\n    if(this.vbar) {\n        translateY -= d3.event.dy;\n    }\n\n    this.setTranslate(translateX, translateY);\n};\n\n/**\n * Handles scroll box wheel events\n *\n * @method\n */\nScrollBox.prototype._onBoxWheel = function onBarWheel() {\n    var translateX = this.translateX,\n        translateY = this.translateY;\n\n    if(this.hbar) {\n        translateX += d3.event.deltaY;\n    }\n\n    if(this.vbar) {\n        translateY += d3.event.deltaY;\n    }\n\n    this.setTranslate(translateX, translateY);\n};\n\n/**\n * Handles scroll bar drag events\n *\n * @method\n */\nScrollBox.prototype._onBarDrag = function onBarDrag() {\n    var translateX = this.translateX,\n        translateY = this.translateY;\n\n    if(this.hbar) {\n        var xMin = translateX + this._hbarXMin,\n            xMax = xMin + this._hbarTranslateMax,\n            x = Lib.constrain(d3.event.x, xMin, xMax),\n            xf = (x - xMin) / (xMax - xMin);\n\n        var translateXMax = this.position.w - this._box.w;\n\n        translateX = xf * translateXMax;\n    }\n\n    if(this.vbar) {\n        var yMin = translateY + this._vbarYMin,\n            yMax = yMin + this._vbarTranslateMax,\n            y = Lib.constrain(d3.event.y, yMin, yMax),\n            yf = (y - yMin) / (yMax - yMin);\n\n        var translateYMax = this.position.h - this._box.h;\n\n        translateY = yf * translateYMax;\n    }\n\n    this.setTranslate(translateX, translateY);\n};\n\n/**\n * Set clip path and scroll bar translate transform\n *\n * @method\n * @param {number}  [translateX=0]  Horizontal offset (in pixels)\n * @param {number}  [translateY=0]  Vertical offset (in pixels)\n */\nScrollBox.prototype.setTranslate = function setTranslate(translateX, translateY) {\n    // store translateX and translateY (needed by mouse event handlers)\n    var translateXMax = this.position.w - this._box.w,\n        translateYMax = this.position.h - this._box.h;\n\n    translateX = Lib.constrain(translateX || 0, 0, translateXMax);\n    translateY = Lib.constrain(translateY || 0, 0, translateYMax);\n\n    this.translateX = translateX;\n    this.translateY = translateY;\n\n    this.container.call(Drawing.setTranslate,\n        this._box.l - this.position.l - translateX,\n        this._box.t - this.position.t - translateY);\n\n    if(this._clipRect) {\n        this._clipRect.attr({\n            x: Math.floor(this.position.l + translateX - 0.5),\n            y: Math.floor(this.position.t + translateY - 0.5)\n        });\n    }\n\n    if(this.hbar) {\n        var xf = translateX / translateXMax;\n\n        this.hbar.call(Drawing.setTranslate,\n            translateX + xf * this._hbarTranslateMax,\n            translateY);\n    }\n\n    if(this.vbar) {\n        var yf = translateY / translateYMax;\n\n        this.vbar.call(Drawing.setTranslate,\n            translateX,\n            translateY + yf * this._vbarTranslateMax);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/geo/geo.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\n/* global PlotlyGeoAssets:false */\n\nvar d3 = require('d3');\n\nvar Color = require('../../components/color');\nvar Drawing = require('../../components/drawing');\nvar Plots = require('../plots');\nvar Axes = require('../cartesian/axes');\nvar Fx = require('../cartesian/graph_interact');\n\nvar addProjectionsToD3 = require('./projections');\nvar createGeoScale = require('./set_scale');\nvar createGeoZoom = require('./zoom');\nvar createGeoZoomReset = require('./zoom_reset');\nvar constants = require('./constants');\n\nvar topojsonUtils = require('../../lib/topojson_utils');\nvar topojsonFeature = require('topojson-client').feature;\n\n// add a few projection types to d3.geo\naddProjectionsToD3(d3);\n\n\nfunction Geo(options) {\n    this.id = options.id;\n    this.graphDiv = options.graphDiv;\n    this.container = options.container;\n    this.topojsonURL = options.topojsonURL;\n\n    this.topojsonName = null;\n    this.topojson = null;\n\n    this.projectionType = null;\n    this.projection = null;\n\n    this.clipAngle = null;\n    this.setScale = null;\n    this.path = null;\n\n    this.zoom = null;\n    this.zoomReset = null;\n\n    this.makeFramework();\n\n    this.traceHash = {};\n}\n\nmodule.exports = Geo;\n\nvar proto = Geo.prototype;\n\nproto.plot = function(geoCalcData, fullLayout, promises) {\n    var _this = this,\n        geoLayout = fullLayout[_this.id],\n        graphSize = fullLayout._size;\n\n    var topojsonNameNew, topojsonPath;\n\n    // N.B. 'geoLayout' is unambiguous, no need for 'user' geo layout here\n\n    // TODO don't reset projection on all graph edits\n    _this.projection = null;\n\n    _this.setScale = createGeoScale(geoLayout, graphSize);\n    _this.makeProjection(geoLayout);\n    _this.makePath();\n    _this.adjustLayout(geoLayout, graphSize);\n\n    _this.zoom = createGeoZoom(_this, geoLayout);\n    _this.zoomReset = createGeoZoomReset(_this, geoLayout);\n    _this.mockAxis = createMockAxis(fullLayout);\n\n    _this.framework\n        .call(_this.zoom)\n        .on('dblclick.zoom', _this.zoomReset);\n\n    _this.framework.on('mousemove', function() {\n        var mouse = d3.mouse(this),\n            lonlat = _this.projection.invert(mouse);\n\n        if(!lonlat || isNaN(lonlat[0]) || isNaN(lonlat[1])) return;\n\n        var evt = d3.event;\n        evt.xpx = mouse[0];\n        evt.ypx = mouse[1];\n\n        _this.xaxis.c2p = function() { return mouse[0]; };\n        _this.xaxis.p2c = function() { return lonlat[0]; };\n        _this.yaxis.c2p = function() { return mouse[1]; };\n        _this.yaxis.p2c = function() { return lonlat[1]; };\n\n        Fx.hover(_this.graphDiv, evt, _this.id);\n    });\n\n    _this.framework.on('mouseout', function() {\n        Fx.loneUnhover(fullLayout._toppaper);\n    });\n\n    _this.framework.on('click', function() {\n        Fx.click(_this.graphDiv, d3.event);\n    });\n\n    topojsonNameNew = topojsonUtils.getTopojsonName(geoLayout);\n\n    if(_this.topojson === null || topojsonNameNew !== _this.topojsonName) {\n        _this.topojsonName = topojsonNameNew;\n\n        if(PlotlyGeoAssets.topojson[_this.topojsonName] !== undefined) {\n            _this.topojson = PlotlyGeoAssets.topojson[_this.topojsonName];\n            _this.onceTopojsonIsLoaded(geoCalcData, geoLayout);\n        }\n        else {\n            topojsonPath = topojsonUtils.getTopojsonPath(\n                _this.topojsonURL,\n                _this.topojsonName\n            );\n\n            promises.push(new Promise(function(resolve, reject) {\n                d3.json(topojsonPath, function(error, topojson) {\n                    if(error) {\n                        if(error.status === 404) {\n                            reject(new Error([\n                                'plotly.js could not find topojson file at',\n                                topojsonPath, '.',\n                                'Make sure the *topojsonURL* plot config option',\n                                'is set properly.'\n                            ].join(' ')));\n                        }\n                        else {\n                            reject(new Error([\n                                'unexpected error while fetching topojson file at',\n                                topojsonPath\n                            ].join(' ')));\n                        }\n                        return;\n                    }\n\n                    _this.topojson = topojson;\n                    PlotlyGeoAssets.topojson[_this.topojsonName] = topojson;\n\n                    _this.onceTopojsonIsLoaded(geoCalcData, geoLayout);\n                    resolve();\n                });\n            }));\n        }\n    }\n    else _this.onceTopojsonIsLoaded(geoCalcData, geoLayout);\n\n    // TODO handle topojson-is-loading case\n    // to avoid making multiple request while streaming\n};\n\nproto.onceTopojsonIsLoaded = function(geoCalcData, geoLayout) {\n    this.drawLayout(geoLayout);\n\n    Plots.generalUpdatePerTraceModule(this, geoCalcData, geoLayout);\n\n    this.render();\n};\n\nproto.makeProjection = function(geoLayout) {\n    var projLayout = geoLayout.projection,\n        projType = projLayout.type,\n        isNew = this.projection === null || projType !== this.projectionType,\n        projection;\n\n    if(isNew) {\n        this.projectionType = projType;\n        projection = this.projection = d3.geo[constants.projNames[projType]]();\n    }\n    else projection = this.projection;\n\n    projection\n        .translate(projLayout._translate0)\n        .precision(constants.precision);\n\n    if(!geoLayout._isAlbersUsa) {\n        projection\n            .rotate(projLayout._rotate)\n            .center(projLayout._center);\n    }\n\n    if(geoLayout._clipAngle) {\n        this.clipAngle = geoLayout._clipAngle;  // needed in proto.render\n        projection\n            .clipAngle(geoLayout._clipAngle - constants.clipPad);\n    }\n    else this.clipAngle = null;  // for graph edits\n\n    if(projLayout.parallels) {\n        projection\n            .parallels(projLayout.parallels);\n    }\n\n    if(isNew) this.setScale(projection);\n\n    projection\n        .translate(projLayout._translate)\n        .scale(projLayout._scale);\n};\n\nproto.makePath = function() {\n    this.path = d3.geo.path().projection(this.projection);\n};\n\nproto.makeFramework = function() {\n    var fullLayout = this.graphDiv._fullLayout;\n    var clipId = 'clip' + fullLayout._uid + this.id;\n\n    var defGroup = fullLayout._defs.selectAll('g.clips')\n        .data([0]);\n    defGroup.enter().append('g')\n        .classed('clips', true);\n\n    var clipDef = this.clipDef = defGroup.selectAll('#' + clipId)\n        .data([0]);\n\n    clipDef.enter().append('clipPath').attr('id', clipId)\n        .append('rect');\n\n    var framework = this.framework = d3.select(this.container).append('g');\n\n    framework\n        .attr('class', 'geo ' + this.id)\n        .style('pointer-events', 'all')\n        .call(Drawing.setClipUrl, clipId);\n\n    framework.append('g')\n        .attr('class', 'bglayer')\n        .append('rect');\n\n    framework.append('g').attr('class', 'baselayer');\n    framework.append('g').attr('class', 'choroplethlayer');\n    framework.append('g').attr('class', 'baselayeroverchoropleth');\n    framework.append('g').attr('class', 'scattergeolayer');\n\n    // N.B. disable dblclick zoom default\n    framework.on('dblclick.zoom', null);\n\n    this.xaxis = { _id: 'x' };\n    this.yaxis = { _id: 'y' };\n};\n\nproto.adjustLayout = function(geoLayout, graphSize) {\n    var domain = geoLayout.domain;\n\n    var left = graphSize.l + graphSize.w * domain.x[0] + geoLayout._marginX,\n        top = graphSize.t + graphSize.h * (1 - domain.y[1]) + geoLayout._marginY;\n\n    Drawing.setTranslate(this.framework, left, top);\n\n    var dimsAttrs = {\n        x: 0,\n        y: 0,\n        width: geoLayout._width,\n        height: geoLayout._height\n    };\n\n    this.clipDef.select('rect')\n        .attr(dimsAttrs);\n\n    this.framework.select('.bglayer').select('rect')\n        .attr(dimsAttrs)\n        .call(Color.fill, geoLayout.bgcolor);\n\n    this.xaxis._offset = left;\n    this.xaxis._length = geoLayout._width;\n\n    this.yaxis._offset = top;\n    this.yaxis._length = geoLayout._height;\n};\n\nproto.drawTopo = function(selection, layerName, geoLayout) {\n    if(geoLayout['show' + layerName] !== true) return;\n\n    var topojson = this.topojson,\n        datum = layerName === 'frame' ?\n            constants.sphereSVG :\n            topojsonFeature(topojson, topojson.objects[layerName]);\n\n    selection.append('g')\n        .datum(datum)\n        .attr('class', layerName)\n          .append('path')\n            .attr('class', 'basepath');\n};\n\nfunction makeGraticule(lonaxisRange, lataxisRange, step) {\n    return d3.geo.graticule()\n        .extent([\n            [lonaxisRange[0], lataxisRange[0]],\n            [lonaxisRange[1], lataxisRange[1]]\n        ])\n        .step(step);\n}\n\nproto.drawGraticule = function(selection, axisName, geoLayout) {\n    var axisLayout = geoLayout[axisName];\n\n    if(axisLayout.showgrid !== true) return;\n\n    var scopeDefaults = constants.scopeDefaults[geoLayout.scope],\n        lonaxisRange = scopeDefaults.lonaxisRange,\n        lataxisRange = scopeDefaults.lataxisRange,\n        step = axisName === 'lonaxis' ?\n            [axisLayout.dtick] :\n            [0, axisLayout.dtick],\n        graticule = makeGraticule(lonaxisRange, lataxisRange, step);\n\n    selection.append('g')\n        .datum(graticule)\n        .attr('class', axisName + 'graticule')\n            .append('path')\n                .attr('class', 'graticulepath');\n};\n\nproto.drawLayout = function(geoLayout) {\n    var gBaseLayer = this.framework.select('g.baselayer'),\n        baseLayers = constants.baseLayers,\n        axesNames = constants.axesNames,\n        layerName;\n\n    // TODO move to more d3-idiomatic pattern (that's work on replot)\n    // N.B. html('') does not work in IE11\n    gBaseLayer.selectAll('*').remove();\n\n    for(var i = 0; i < baseLayers.length; i++) {\n        layerName = baseLayers[i];\n\n        if(axesNames.indexOf(layerName) !== -1) {\n            this.drawGraticule(gBaseLayer, layerName, geoLayout);\n        }\n        else this.drawTopo(gBaseLayer, layerName, geoLayout);\n    }\n\n    this.styleLayout(geoLayout);\n};\n\nfunction styleFillLayer(selection, layerName, geoLayout) {\n    var layerAdj = constants.layerNameToAdjective[layerName];\n\n    selection.select('.' + layerName)\n        .selectAll('path')\n            .attr('stroke', 'none')\n            .call(Color.fill, geoLayout[layerAdj + 'color']);\n}\n\nfunction styleLineLayer(selection, layerName, geoLayout) {\n    var layerAdj = constants.layerNameToAdjective[layerName];\n\n    selection.select('.' + layerName)\n        .selectAll('path')\n            .attr('fill', 'none')\n            .call(Color.stroke, geoLayout[layerAdj + 'color'])\n            .call(Drawing.dashLine, '', geoLayout[layerAdj + 'width']);\n}\n\nfunction styleGraticule(selection, axisName, geoLayout) {\n    selection.select('.' + axisName + 'graticule')\n        .selectAll('path')\n            .attr('fill', 'none')\n            .call(Color.stroke, geoLayout[axisName].gridcolor)\n            .call(Drawing.dashLine, '', geoLayout[axisName].gridwidth);\n}\n\nproto.styleLayer = function(selection, layerName, geoLayout) {\n    var fillLayers = constants.fillLayers,\n        lineLayers = constants.lineLayers;\n\n    if(fillLayers.indexOf(layerName) !== -1) {\n        styleFillLayer(selection, layerName, geoLayout);\n    }\n    else if(lineLayers.indexOf(layerName) !== -1) {\n        styleLineLayer(selection, layerName, geoLayout);\n    }\n};\n\nproto.styleLayout = function(geoLayout) {\n    var gBaseLayer = this.framework.select('g.baselayer'),\n        baseLayers = constants.baseLayers,\n        axesNames = constants.axesNames,\n        layerName;\n\n    for(var i = 0; i < baseLayers.length; i++) {\n        layerName = baseLayers[i];\n\n        if(axesNames.indexOf(layerName) !== -1) {\n            styleGraticule(gBaseLayer, layerName, geoLayout);\n        }\n        else this.styleLayer(gBaseLayer, layerName, geoLayout);\n    }\n};\n\nproto.isLonLatOverEdges = function(lonlat) {\n    var clipAngle = this.clipAngle;\n\n    if(clipAngle === null) return false;\n\n    var p = this.projection.rotate(),\n        angle = d3.geo.distance(lonlat, [-p[0], -p[1]]),\n        maxAngle = clipAngle * Math.PI / 180;\n\n    return angle > maxAngle;\n};\n\n// [hot code path] (re)draw all paths which depend on the projection\nproto.render = function() {\n    var _this = this,\n        framework = _this.framework,\n        gChoropleth = framework.select('g.choroplethlayer'),\n        gScatterGeo = framework.select('g.scattergeolayer'),\n        path = _this.path;\n\n    function translatePoints(d) {\n        var lonlatPx = _this.projection(d.lonlat);\n        if(!lonlatPx) return null;\n\n        return 'translate(' + lonlatPx[0] + ',' + lonlatPx[1] + ')';\n    }\n\n    // hide paths over edges of clipped projections\n    function hideShowPoints(d) {\n        return _this.isLonLatOverEdges(d.lonlat) ? '0' : '1.0';\n    }\n\n    framework.selectAll('path.basepath').attr('d', path);\n    framework.selectAll('path.graticulepath').attr('d', path);\n\n    gChoropleth.selectAll('path.choroplethlocation').attr('d', path);\n    gChoropleth.selectAll('path.basepath').attr('d', path);\n\n    gScatterGeo.selectAll('path.js-line').attr('d', path);\n\n    if(_this.clipAngle !== null) {\n        gScatterGeo.selectAll('path.point')\n            .style('opacity', hideShowPoints)\n            .attr('transform', translatePoints);\n        gScatterGeo.selectAll('text')\n            .style('opacity', hideShowPoints)\n            .attr('transform', translatePoints);\n    }\n    else {\n        gScatterGeo.selectAll('path.point')\n            .attr('transform', translatePoints);\n        gScatterGeo.selectAll('text')\n            .attr('transform', translatePoints);\n    }\n};\n\n// create a mock axis used to format hover text\nfunction createMockAxis(fullLayout) {\n    var mockAxis = {\n        type: 'linear',\n        showexponent: 'all',\n        exponentformat: Axes.layoutAttributes.exponentformat.dflt\n    };\n\n    Axes.setConvert(mockAxis, fullLayout);\n    return mockAxis;\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/geo/projections.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n/*\n * Generated by https://github.com/etpinard/d3-geo-projection-picker\n *\n * which is hand-picks projection from https://github.com/d3/d3-geo-projection\n *\n * into a CommonJS require-able module.\n */\n\n'use strict';\n\n/* eslint-disable */\n\nfunction addProjectionsToD3(d3) {\n  d3.geo.project = function(object, projection) {\n    var stream = projection.stream;\n    if (!stream) throw new Error(\"not yet supported\");\n    return (object && d3_geo_projectObjectType.hasOwnProperty(object.type) ? d3_geo_projectObjectType[object.type] : d3_geo_projectGeometry)(object, stream);\n  };\n  function d3_geo_projectFeature(object, stream) {\n    return {\n      type: \"Feature\",\n      id: object.id,\n      properties: object.properties,\n      geometry: d3_geo_projectGeometry(object.geometry, stream)\n    };\n  }\n  function d3_geo_projectGeometry(geometry, stream) {\n    if (!geometry) return null;\n    if (geometry.type === \"GeometryCollection\") return {\n      type: \"GeometryCollection\",\n      geometries: object.geometries.map(function(geometry) {\n        return d3_geo_projectGeometry(geometry, stream);\n      })\n    };\n    if (!d3_geo_projectGeometryType.hasOwnProperty(geometry.type)) return null;\n    var sink = d3_geo_projectGeometryType[geometry.type];\n    d3.geo.stream(geometry, stream(sink));\n    return sink.result();\n  }\n  var d3_geo_projectObjectType = {\n    Feature: d3_geo_projectFeature,\n    FeatureCollection: function(object, stream) {\n      return {\n        type: \"FeatureCollection\",\n        features: object.features.map(function(feature) {\n          return d3_geo_projectFeature(feature, stream);\n        })\n      };\n    }\n  };\n  var d3_geo_projectPoints = [], d3_geo_projectLines = [];\n  var d3_geo_projectPoint = {\n    point: function(x, y) {\n      d3_geo_projectPoints.push([ x, y ]);\n    },\n    result: function() {\n      var result = !d3_geo_projectPoints.length ? null : d3_geo_projectPoints.length < 2 ? {\n        type: \"Point\",\n        coordinates: d3_geo_projectPoints[0]\n      } : {\n        type: \"MultiPoint\",\n        coordinates: d3_geo_projectPoints\n      };\n      d3_geo_projectPoints = [];\n      return result;\n    }\n  };\n  var d3_geo_projectLine = {\n    lineStart: d3_geo_projectNoop,\n    point: function(x, y) {\n      d3_geo_projectPoints.push([ x, y ]);\n    },\n    lineEnd: function() {\n      if (d3_geo_projectPoints.length) d3_geo_projectLines.push(d3_geo_projectPoints), \n      d3_geo_projectPoints = [];\n    },\n    result: function() {\n      var result = !d3_geo_projectLines.length ? null : d3_geo_projectLines.length < 2 ? {\n        type: \"LineString\",\n        coordinates: d3_geo_projectLines[0]\n      } : {\n        type: \"MultiLineString\",\n        coordinates: d3_geo_projectLines\n      };\n      d3_geo_projectLines = [];\n      return result;\n    }\n  };\n  var d3_geo_projectPolygon = {\n    polygonStart: d3_geo_projectNoop,\n    lineStart: d3_geo_projectNoop,\n    point: function(x, y) {\n      d3_geo_projectPoints.push([ x, y ]);\n    },\n    lineEnd: function() {\n      var n = d3_geo_projectPoints.length;\n      if (n) {\n        do d3_geo_projectPoints.push(d3_geo_projectPoints[0].slice()); while (++n < 4);\n        d3_geo_projectLines.push(d3_geo_projectPoints), d3_geo_projectPoints = [];\n      }\n    },\n    polygonEnd: d3_geo_projectNoop,\n    result: function() {\n      if (!d3_geo_projectLines.length) return null;\n      var polygons = [], holes = [];\n      d3_geo_projectLines.forEach(function(ring) {\n        if (d3_geo_projectClockwise(ring)) polygons.push([ ring ]); else holes.push(ring);\n      });\n      holes.forEach(function(hole) {\n        var point = hole[0];\n        polygons.some(function(polygon) {\n          if (d3_geo_projectContains(polygon[0], point)) {\n            polygon.push(hole);\n            return true;\n          }\n        }) || polygons.push([ hole ]);\n      });\n      d3_geo_projectLines = [];\n      return !polygons.length ? null : polygons.length > 1 ? {\n        type: \"MultiPolygon\",\n        coordinates: polygons\n      } : {\n        type: \"Polygon\",\n        coordinates: polygons[0]\n      };\n    }\n  };\n  var d3_geo_projectGeometryType = {\n    Point: d3_geo_projectPoint,\n    MultiPoint: d3_geo_projectPoint,\n    LineString: d3_geo_projectLine,\n    MultiLineString: d3_geo_projectLine,\n    Polygon: d3_geo_projectPolygon,\n    MultiPolygon: d3_geo_projectPolygon,\n    Sphere: d3_geo_projectPolygon\n  };\n  function d3_geo_projectNoop() {}\n  function d3_geo_projectClockwise(ring) {\n    if ((n = ring.length) < 4) return false;\n    var i = 0, n, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];\n    while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];\n    return area <= 0;\n  }\n  function d3_geo_projectContains(ring, point) {\n    var x = point[0], y = point[1], contains = false;\n    for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {\n      var pi = ring[i], xi = pi[0], yi = pi[1], pj = ring[j], xj = pj[0], yj = pj[1];\n      if (yi > y ^ yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) contains = !contains;\n    }\n    return contains;\n  }\n  var  = 1e-6, 2 =  * ,  = Math.PI, half =  / 2, sqrt = Math.sqrt(), radians =  / 180, degrees = 180 / ;\n  function sinci(x) {\n    return x ? x / Math.sin(x) : 1;\n  }\n  function sgn(x) {\n    return x > 0 ? 1 : x < 0 ? -1 : 0;\n  }\n  function asin(x) {\n    return x > 1 ? half : x < -1 ? -half : Math.asin(x);\n  }\n  function acos(x) {\n    return x > 1 ? 0 : x < -1 ?  : Math.acos(x);\n  }\n  function asqrt(x) {\n    return x > 0 ? Math.sqrt(x) : 0;\n  }\n  var projection = d3.geo.projection, projectionMutator = d3.geo.projectionMutator;\n  d3.geo.interrupt = function(project) {\n    var lobes = [ [ [ [ -, 0 ], [ 0, half ], [ , 0 ] ] ], [ [ [ -, 0 ], [ 0, -half ], [ , 0 ] ] ] ];\n    var bounds;\n    function forward(, ) {\n      var sign =  < 0 ? -1 : +1, hemilobes = lobes[+( < 0)];\n      for (var i = 0, n = hemilobes.length - 1; i < n &&  > hemilobes[i][2][0]; ++i) ;\n      var coordinates = project( - hemilobes[i][1][0], );\n      coordinates[0] += project(hemilobes[i][1][0], sign *  > sign * hemilobes[i][0][1] ? hemilobes[i][0][1] : )[0];\n      return coordinates;\n    }\n    function reset() {\n      bounds = lobes.map(function(hemilobes) {\n        return hemilobes.map(function(lobe) {\n          var x0 = project(lobe[0][0], lobe[0][1])[0], x1 = project(lobe[2][0], lobe[2][1])[0], y0 = project(lobe[1][0], lobe[0][1])[1], y1 = project(lobe[1][0], lobe[1][1])[1], t;\n          if (y0 > y1) t = y0, y0 = y1, y1 = t;\n          return [ [ x0, y0 ], [ x1, y1 ] ];\n        });\n      });\n    }\n    if (project.invert) forward.invert = function(x, y) {\n      var hemibounds = bounds[+(y < 0)], hemilobes = lobes[+(y < 0)];\n      for (var i = 0, n = hemibounds.length; i < n; ++i) {\n        var b = hemibounds[i];\n        if (b[0][0] <= x && x < b[1][0] && b[0][1] <= y && y < b[1][1]) {\n          var coordinates = project.invert(x - project(hemilobes[i][1][0], 0)[0], y);\n          coordinates[0] += hemilobes[i][1][0];\n          return pointEqual(forward(coordinates[0], coordinates[1]), [ x, y ]) ? coordinates : null;\n        }\n      }\n    };\n    var projection = d3.geo.projection(forward), stream_ = projection.stream;\n    projection.stream = function(stream) {\n      var rotate = projection.rotate(), rotateStream = stream_(stream), sphereStream = (projection.rotate([ 0, 0 ]), \n      stream_(stream));\n      projection.rotate(rotate);\n      rotateStream.sphere = function() {\n        d3.geo.stream(sphere(), sphereStream);\n      };\n      return rotateStream;\n    };\n    projection.lobes = function(_) {\n      if (!arguments.length) return lobes.map(function(lobes) {\n        return lobes.map(function(lobe) {\n          return [ [ lobe[0][0] * 180 / , lobe[0][1] * 180 /  ], [ lobe[1][0] * 180 / , lobe[1][1] * 180 /  ], [ lobe[2][0] * 180 / , lobe[2][1] * 180 /  ] ];\n        });\n      });\n      lobes = _.map(function(lobes) {\n        return lobes.map(function(lobe) {\n          return [ [ lobe[0][0] *  / 180, lobe[0][1] *  / 180 ], [ lobe[1][0] *  / 180, lobe[1][1] *  / 180 ], [ lobe[2][0] *  / 180, lobe[2][1] *  / 180 ] ];\n        });\n      });\n      reset();\n      return projection;\n    };\n    function sphere() {\n      var  = 1e-6, coordinates = [];\n      for (var i = 0, n = lobes[0].length; i < n; ++i) {\n        var lobe = lobes[0][i], 0 = lobe[0][0] * 180 / , 0 = lobe[0][1] * 180 / , 1 = lobe[1][1] * 180 / , 2 = lobe[2][0] * 180 / , 2 = lobe[2][1] * 180 / ;\n        coordinates.push(resample([ [ 0 + , 0 +  ], [ 0 + , 1 -  ], [ 2 - , 1 -  ], [ 2 - , 2 +  ] ], 30));\n      }\n      for (var i = lobes[1].length - 1; i >= 0; --i) {\n        var lobe = lobes[1][i], 0 = lobe[0][0] * 180 / , 0 = lobe[0][1] * 180 / , 1 = lobe[1][1] * 180 / , 2 = lobe[2][0] * 180 / , 2 = lobe[2][1] * 180 / ;\n        coordinates.push(resample([ [ 2 - , 2 -  ], [ 2 - , 1 +  ], [ 0 + , 1 +  ], [ 0 + , 0 -  ] ], 30));\n      }\n      return {\n        type: \"Polygon\",\n        coordinates: [ d3.merge(coordinates) ]\n      };\n    }\n    function resample(coordinates, m) {\n      var i = -1, n = coordinates.length, p0 = coordinates[0], p1, dx, dy, resampled = [];\n      while (++i < n) {\n        p1 = coordinates[i];\n        dx = (p1[0] - p0[0]) / m;\n        dy = (p1[1] - p0[1]) / m;\n        for (var j = 0; j < m; ++j) resampled.push([ p0[0] + j * dx, p0[1] + j * dy ]);\n        p0 = p1;\n      }\n      resampled.push(p1);\n      return resampled;\n    }\n    function pointEqual(a, b) {\n      return Math.abs(a[0] - b[0]) <  && Math.abs(a[1] - b[1]) < ;\n    }\n    return projection;\n  };\n  function eckert4(, ) {\n    var k = (2 + half) * Math.sin();\n     /= 2;\n    for (var i = 0,  = Infinity; i < 10 && Math.abs() > ; i++) {\n      var cos = Math.cos();\n       -=  = ( + Math.sin() * (cos + 2) - k) / (2 * cos * (1 + cos));\n    }\n    return [ 2 / Math.sqrt( * (4 + )) *  * (1 + Math.cos()), 2 * Math.sqrt( / (4 + )) * Math.sin() ];\n  }\n  eckert4.invert = function(x, y) {\n    var A = .5 * y * Math.sqrt((4 + ) / ), k = asin(A), c = Math.cos(k);\n    return [ x / (2 / Math.sqrt( * (4 + )) * (1 + c)), asin((k + A * (c + 2)) / (2 + half)) ];\n  };\n  (d3.geo.eckert4 = function() {\n    return projection(eckert4);\n  }).raw = eckert4;\n  var hammerAzimuthalEqualArea = d3.geo.azimuthalEqualArea.raw;\n  function hammer(A, B) {\n    if (arguments.length < 2) B = A;\n    if (B === 1) return hammerAzimuthalEqualArea;\n    if (B === Infinity) return hammerQuarticAuthalic;\n    function forward(, ) {\n      var coordinates = hammerAzimuthalEqualArea( / B, );\n      coordinates[0] *= A;\n      return coordinates;\n    }\n    forward.invert = function(x, y) {\n      var coordinates = hammerAzimuthalEqualArea.invert(x / A, y);\n      coordinates[0] *= B;\n      return coordinates;\n    };\n    return forward;\n  }\n  function hammerProjection() {\n    var B = 2, m = projectionMutator(hammer), p = m(B);\n    p.coefficient = function(_) {\n      if (!arguments.length) return B;\n      return m(B = +_);\n    };\n    return p;\n  }\n  function hammerQuarticAuthalic(, ) {\n    return [  * Math.cos() / Math.cos( /= 2), 2 * Math.sin() ];\n  }\n  hammerQuarticAuthalic.invert = function(x, y) {\n    var  = 2 * asin(y / 2);\n    return [ x * Math.cos( / 2) / Math.cos(),  ];\n  };\n  (d3.geo.hammer = hammerProjection).raw = hammer;\n  function kavrayskiy7(, ) {\n    return [ 3 *  / (2 * ) * Math.sqrt( *  / 3 -  * ),  ];\n  }\n  kavrayskiy7.invert = function(x, y) {\n    return [ 2 / 3 *  * x / Math.sqrt( *  / 3 - y * y), y ];\n  };\n  (d3.geo.kavrayskiy7 = function() {\n    return projection(kavrayskiy7);\n  }).raw = kavrayskiy7;\n  function miller(, ) {\n    return [ , 1.25 * Math.log(Math.tan( / 4 + .4 * )) ];\n  }\n  miller.invert = function(x, y) {\n    return [ x, 2.5 * Math.atan(Math.exp(.8 * y)) - .625 *  ];\n  };\n  (d3.geo.miller = function() {\n    return projection(miller);\n  }).raw = miller;\n  function mollweideBromley(Cp) {\n    return function() {\n      var Cpsin = Cp * Math.sin(), i = 30, ;\n      do  -=  = ( + Math.sin() - Cpsin) / (1 + Math.cos()); while (Math.abs() >  && --i > 0);\n      return  / 2;\n    };\n  }\n  function mollweideBromley(Cx, Cy, Cp) {\n    var  = mollweideBromley(Cp);\n    function forward(, ) {\n      return [ Cx *  * Math.cos( = ()), Cy * Math.sin() ];\n    }\n    forward.invert = function(x, y) {\n      var  = asin(y / Cy);\n      return [ x / (Cx * Math.cos()), asin((2 *  + Math.sin(2 * )) / Cp) ];\n    };\n    return forward;\n  }\n  var mollweide = mollweideBromley(), mollweide = mollweideBromley(Math.SQRT2 / half, Math.SQRT2, );\n  (d3.geo.mollweide = function() {\n    return projection(mollweide);\n  }).raw = mollweide;\n  function naturalEarth(, ) {\n    var 2 =  * , 4 = 2 * 2;\n    return [  * (.8707 - .131979 * 2 + 4 * (-.013791 + 4 * (.003971 * 2 - .001529 * 4))),  * (1.007226 + 2 * (.015085 + 4 * (-.044475 + .028874 * 2 - .005916 * 4))) ];\n  }\n  naturalEarth.invert = function(x, y) {\n    var  = y, i = 25, ;\n    do {\n      var 2 =  * , 4 = 2 * 2;\n       -=  = ( * (1.007226 + 2 * (.015085 + 4 * (-.044475 + .028874 * 2 - .005916 * 4))) - y) / (1.007226 + 2 * (.015085 * 3 + 4 * (-.044475 * 7 + .028874 * 9 * 2 - .005916 * 11 * 4)));\n    } while (Math.abs() >  && --i > 0);\n    return [ x / (.8707 + (2 =  * ) * (-.131979 + 2 * (-.013791 + 2 * 2 * 2 * (.003971 - .001529 * 2)))),  ];\n  };\n  (d3.geo.naturalEarth = function() {\n    return projection(naturalEarth);\n  }).raw = naturalEarth;\n  var robinsonConstants = [ [ .9986, -.062 ], [ 1, 0 ], [ .9986, .062 ], [ .9954, .124 ], [ .99, .186 ], [ .9822, .248 ], [ .973, .31 ], [ .96, .372 ], [ .9427, .434 ], [ .9216, .4958 ], [ .8962, .5571 ], [ .8679, .6176 ], [ .835, .6769 ], [ .7986, .7346 ], [ .7597, .7903 ], [ .7186, .8435 ], [ .6732, .8936 ], [ .6213, .9394 ], [ .5722, .9761 ], [ .5322, 1 ] ];\n  robinsonConstants.forEach(function(d) {\n    d[1] *= 1.0144;\n  });\n  function robinson(, ) {\n    var i = Math.min(18, Math.abs() * 36 / ), i0 = Math.floor(i), di = i - i0, ax = (k = robinsonConstants[i0])[0], ay = k[1], bx = (k = robinsonConstants[++i0])[0], by = k[1], cx = (k = robinsonConstants[Math.min(19, ++i0)])[0], cy = k[1], k;\n    return [  * (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2), ( > 0 ? half : -half) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2) ];\n  }\n  robinson.invert = function(x, y) {\n    var yy = y / half,  = yy * 90, i = Math.min(18, Math.abs( / 5)), i0 = Math.max(0, Math.floor(i));\n    do {\n      var ay = robinsonConstants[i0][1], by = robinsonConstants[i0 + 1][1], cy = robinsonConstants[Math.min(19, i0 + 2)][1], u = cy - ay, v = cy - 2 * by + ay, t = 2 * (Math.abs(yy) - by) / u, c = v / u, di = t * (1 - c * t * (1 - 2 * c * t));\n      if (di >= 0 || i0 === 1) {\n         = (y >= 0 ? 5 : -5) * (di + i);\n        var j = 50, ;\n        do {\n          i = Math.min(18, Math.abs() / 5);\n          i0 = Math.floor(i);\n          di = i - i0;\n          ay = robinsonConstants[i0][1];\n          by = robinsonConstants[i0 + 1][1];\n          cy = robinsonConstants[Math.min(19, i0 + 2)][1];\n           -= ( = (y >= 0 ? half : -half) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2) - y) * degrees;\n        } while (Math.abs() > 2 && --j > 0);\n        break;\n      }\n    } while (--i0 >= 0);\n    var ax = robinsonConstants[i0][0], bx = robinsonConstants[i0 + 1][0], cx = robinsonConstants[Math.min(19, i0 + 2)][0];\n    return [ x / (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2),  * radians ];\n  };\n  (d3.geo.robinson = function() {\n    return projection(robinson);\n  }).raw = robinson;\n  function sinusoidal(, ) {\n    return [  * Math.cos(),  ];\n  }\n  sinusoidal.invert = function(x, y) {\n    return [ x / Math.cos(y), y ];\n  };\n  (d3.geo.sinusoidal = function() {\n    return projection(sinusoidal);\n  }).raw = sinusoidal;\n  function aitoff(, ) {\n    var cos = Math.cos(), sinci = sinci(acos(cos * Math.cos( /= 2)));\n    return [ 2 * cos * Math.sin() * sinci, Math.sin() * sinci ];\n  }\n  aitoff.invert = function(x, y) {\n    if (x * x + 4 * y * y >  *  + ) return;\n    var  = x,  = y, i = 25;\n    do {\n      var sin = Math.sin(), sin_2 = Math.sin( / 2), cos_2 = Math.cos( / 2), sin = Math.sin(), cos = Math.cos(), sin_2 = Math.sin(2 * ), sin2 = sin * sin, cos2 = cos * cos, sin2_2 = sin_2 * sin_2, C = 1 - cos2 * cos_2 * cos_2, E = C ? acos(cos * cos_2) * Math.sqrt(F = 1 / C) : F = 0, F, fx = 2 * E * cos * sin_2 - x, fy = E * sin - y, x = F * (cos2 * sin2_2 + E * cos * cos_2 * sin2), x = F * (.5 * sin * sin_2 - E * 2 * sin * sin_2), y = F * .25 * (sin_2 * sin_2 - E * sin * cos2 * sin), y = F * (sin2 * cos_2 + E * sin2_2 * cos), denominator = x * y - y * x;\n      if (!denominator) break;\n      var  = (fy * x - fx * y) / denominator,  = (fx * y - fy * x) / denominator;\n       -= ,  -= ;\n    } while ((Math.abs() >  || Math.abs() > ) && --i > 0);\n    return [ ,  ];\n  };\n  (d3.geo.aitoff = function() {\n    return projection(aitoff);\n  }).raw = aitoff;\n  function winkel3(, ) {\n    var coordinates = aitoff(, );\n    return [ (coordinates[0] +  / half) / 2, (coordinates[1] + ) / 2 ];\n  }\n  winkel3.invert = function(x, y) {\n    var  = x,  = y, i = 25;\n    do {\n      var cos = Math.cos(), sin = Math.sin(), sin_2 = Math.sin(2 * ), sin2 = sin * sin, cos2 = cos * cos, sin = Math.sin(), cos_2 = Math.cos( / 2), sin_2 = Math.sin( / 2), sin2_2 = sin_2 * sin_2, C = 1 - cos2 * cos_2 * cos_2, E = C ? acos(cos * cos_2) * Math.sqrt(F = 1 / C) : F = 0, F, fx = .5 * (2 * E * cos * sin_2 +  / half) - x, fy = .5 * (E * sin + ) - y, x = .5 * F * (cos2 * sin2_2 + E * cos * cos_2 * sin2) + .5 / half, x = F * (sin * sin_2 / 4 - E * sin * sin_2), y = .125 * F * (sin_2 * sin_2 - E * sin * cos2 * sin), y = .5 * F * (sin2 * cos_2 + E * sin2_2 * cos) + .5, denominator = x * y - y * x,  = (fy * x - fx * y) / denominator,  = (fx * y - fy * x) / denominator;\n       -= ,  -= ;\n    } while ((Math.abs() >  || Math.abs() > ) && --i > 0);\n    return [ ,  ];\n  };\n  (d3.geo.winkel3 = function() {\n    return projection(winkel3);\n  }).raw = winkel3;\n}\n\nmodule.exports = addProjectionsToD3;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/geo/set_scale.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\n\nvar clipPad = require('./constants').clipPad;\n\nfunction createGeoScale(geoLayout, graphSize) {\n    var projLayout = geoLayout.projection,\n        lonaxisLayout = geoLayout.lonaxis,\n        lataxisLayout = geoLayout.lataxis,\n        geoDomain = geoLayout.domain,\n        frameWidth = geoLayout.framewidth || 0;\n\n    // width & height the geo div\n    var geoWidth = graphSize.w * (geoDomain.x[1] - geoDomain.x[0]),\n        geoHeight = graphSize.h * (geoDomain.y[1] - geoDomain.y[0]);\n\n    // add padding around range to avoid aliasing\n    var lon0 = lonaxisLayout.range[0] + clipPad,\n        lon1 = lonaxisLayout.range[1] - clipPad,\n        lat0 = lataxisLayout.range[0] + clipPad,\n        lat1 = lataxisLayout.range[1] - clipPad,\n        lonfull0 = lonaxisLayout._fullRange[0] + clipPad,\n        lonfull1 = lonaxisLayout._fullRange[1] - clipPad,\n        latfull0 = lataxisLayout._fullRange[0] + clipPad,\n        latfull1 = lataxisLayout._fullRange[1] - clipPad;\n\n    // initial translation (makes the math easier)\n    projLayout._translate0 = [\n        graphSize.l + geoWidth / 2, graphSize.t + geoHeight / 2\n    ];\n\n\n    // center of the projection is given by\n    // the lon/lat ranges and the rotate angle\n    var dlon = lon1 - lon0,\n        dlat = lat1 - lat0,\n        c0 = [lon0 + dlon / 2, lat0 + dlat / 2],\n        r = projLayout._rotate;\n\n    projLayout._center = [c0[0] + r[0], c0[1] + r[1]];\n\n    // needs a initial projection; it is called from makeProjection\n    var setScale = function(projection) {\n        var scale0 = projection.scale(),\n            translate0 = projLayout._translate0,\n            rangeBox = makeRangeBox(lon0, lat0, lon1, lat1),\n            fullRangeBox = makeRangeBox(lonfull0, latfull0, lonfull1, latfull1);\n\n        var scale, translate, bounds, fullBounds;\n\n        // Inspired by: http://stackoverflow.com/a/14654988/4068492\n        // using the path determine the bounds of the current map and use\n        // these to determine better values for the scale and translation\n\n        function getScale(bounds) {\n            return Math.min(\n                scale0 * geoWidth / (bounds[1][0] - bounds[0][0]),\n                scale0 * geoHeight / (bounds[1][1] - bounds[0][1])\n            );\n        }\n\n        // scale projection given how range box get deformed\n        // by the projection\n        bounds = getBounds(projection, rangeBox);\n        scale = getScale(bounds);\n\n        // similarly, get scale at full range\n        fullBounds = getBounds(projection, fullRangeBox);\n        projLayout._fullScale = getScale(fullBounds);\n\n        projection.scale(scale);\n\n        // translate the projection so that the top-left corner\n        // of the range box is at the top-left corner of the viewbox\n        bounds = getBounds(projection, rangeBox);\n        translate = [\n            translate0[0] - bounds[0][0] + frameWidth,\n            translate0[1] - bounds[0][1] + frameWidth\n        ];\n        projLayout._translate = translate;\n        projection.translate(translate);\n\n        // clip regions out of the range box\n        // (these are clipping along horizontal/vertical lines)\n        bounds = getBounds(projection, rangeBox);\n        if(!geoLayout._isAlbersUsa) projection.clipExtent(bounds);\n\n        // adjust scale one more time with the 'scale' attribute\n        scale = projLayout.scale * scale;\n\n        // set projection scale and save it\n        projLayout._scale = scale;\n\n        // save the effective width & height of the geo framework\n        geoLayout._width = Math.round(bounds[1][0]) + frameWidth;\n        geoLayout._height = Math.round(bounds[1][1]) + frameWidth;\n\n        // save the margin length induced by the map scaling\n        geoLayout._marginX = (geoWidth - Math.round(bounds[1][0])) / 2;\n        geoLayout._marginY = (geoHeight - Math.round(bounds[1][1])) / 2;\n    };\n\n    return setScale;\n}\n\nmodule.exports = createGeoScale;\n\n// polygon GeoJSON corresponding to lon/lat range box\n// with well-defined direction\nfunction makeRangeBox(lon0, lat0, lon1, lat1) {\n    var dlon4 = (lon1 - lon0) / 4;\n\n    // TODO is this enough to handle ALL cases?\n    // -- this makes scaling less precise than using d3.geo.graticule\n    //    as great circles can overshoot the boundary\n    //    (that's not a big deal I think)\n    return {\n        type: 'Polygon',\n        coordinates: [\n            [ [lon0, lat0],\n            [lon0, lat1],\n            [lon0 + dlon4, lat1],\n            [lon0 + 2 * dlon4, lat1],\n            [lon0 + 3 * dlon4, lat1],\n            [lon1, lat1],\n            [lon1, lat0],\n            [lon1 - dlon4, lat0],\n            [lon1 - 2 * dlon4, lat0],\n            [lon1 - 3 * dlon4, lat0],\n            [lon0, lat0] ]\n        ]\n    };\n}\n\n// bounds array [[top, left], [bottom, right]]\n// of the lon/lat range box\nfunction getBounds(projection, rangeBox) {\n    return d3.geo.path().projection(projection).bounds(rangeBox);\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/geo/zoom.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\n\nvar radians = Math.PI / 180,\n    degrees = 180 / Math.PI,\n    zoomstartStyle = { cursor: 'pointer' },\n    zoomendStyle = { cursor: 'auto' };\n\n\nfunction createGeoZoom(geo, geoLayout) {\n    var zoomConstructor;\n\n    if(geoLayout._isScoped) zoomConstructor = zoomScoped;\n    else if(geoLayout._clipAngle) zoomConstructor = zoomClipped;\n    else zoomConstructor = zoomNonClipped;\n\n    // TODO add a conic-specific zoom\n\n    return zoomConstructor(geo, geoLayout.projection);\n}\n\nmodule.exports = createGeoZoom;\n\n// common to all zoom types\nfunction initZoom(projection, projLayout) {\n    var fullScale = projLayout._fullScale;\n\n    return d3.behavior.zoom()\n        .translate(projection.translate())\n        .scale(projection.scale())\n        .scaleExtent([0.5 * fullScale, 100 * fullScale]);\n}\n\n// zoom for scoped projections\nfunction zoomScoped(geo, projLayout) {\n    var projection = geo.projection,\n        zoom = initZoom(projection, projLayout);\n\n    function handleZoomstart() {\n        d3.select(this).style(zoomstartStyle);\n    }\n\n    function handleZoom() {\n        projection\n            .scale(d3.event.scale)\n            .translate(d3.event.translate);\n\n        geo.render();\n    }\n\n    function handleZoomend() {\n        d3.select(this).style(zoomendStyle);\n    }\n\n    zoom\n        .on('zoomstart', handleZoomstart)\n        .on('zoom', handleZoom)\n        .on('zoomend', handleZoomend);\n\n    return zoom;\n}\n\n// zoom for non-clipped projections\nfunction zoomNonClipped(geo, projLayout) {\n    var projection = geo.projection,\n        zoom = initZoom(projection, projLayout);\n\n    var INSIDETOLORANCEPXS = 2;\n\n    var mouse0, rotate0, translate0, lastRotate, zoomPoint,\n        mouse1, rotate1, point1;\n\n    function position(x) { return projection.invert(x); }\n\n    function outside(x) {\n        var pt = projection(position(x));\n        return (Math.abs(pt[0] - x[0]) > INSIDETOLORANCEPXS ||\n                Math.abs(pt[1] - x[1]) > INSIDETOLORANCEPXS);\n    }\n\n    function handleZoomstart() {\n        d3.select(this).style(zoomstartStyle);\n\n        mouse0 = d3.mouse(this);\n        rotate0 = projection.rotate();\n        translate0 = projection.translate();\n        lastRotate = rotate0;\n        zoomPoint = position(mouse0);\n    }\n\n    function handleZoom() {\n        mouse1 = d3.mouse(this);\n\n        if(outside(mouse0)) {\n            zoom.scale(projection.scale());\n            zoom.translate(projection.translate());\n            return;\n        }\n\n        projection.scale(d3.event.scale);\n\n        projection.translate([translate0[0], d3.event.translate[1]]);\n\n        if(!zoomPoint) {\n            mouse0 = mouse1;\n            zoomPoint = position(mouse0);\n        }\n        else if(position(mouse1)) {\n            point1 = position(mouse1);\n            rotate1 = [lastRotate[0] + (point1[0] - zoomPoint[0]), rotate0[1], rotate0[2]];\n            projection.rotate(rotate1);\n            lastRotate = rotate1;\n        }\n\n        geo.render();\n    }\n\n    function handleZoomend() {\n        d3.select(this).style(zoomendStyle);\n\n        // or something like\n        // http://www.jasondavies.com/maps/gilbert/\n        // ... a little harder with multiple base layers\n    }\n\n    zoom\n        .on('zoomstart', handleZoomstart)\n        .on('zoom', handleZoom)\n        .on('zoomend', handleZoomend);\n\n    return zoom;\n}\n\n// zoom for clipped projections\n// inspired by https://www.jasondavies.com/maps/d3.geo.zoom.js\nfunction zoomClipped(geo, projLayout) {\n    var projection = geo.projection,\n        view = {r: projection.rotate(), k: projection.scale()},\n        zoom = initZoom(projection, projLayout),\n        event = d3_eventDispatch(zoom, 'zoomstart', 'zoom', 'zoomend'),\n        zooming = 0,\n        zoomOn = zoom.on;\n\n    var zoomPoint;\n\n    zoom.on('zoomstart', function() {\n        d3.select(this).style(zoomstartStyle);\n\n        var mouse0 = d3.mouse(this),\n            rotate0 = projection.rotate(),\n            lastRotate = rotate0,\n            translate0 = projection.translate(),\n            q = quaternionFromEuler(rotate0);\n\n        zoomPoint = position(projection, mouse0);\n\n        zoomOn.call(zoom, 'zoom', function() {\n            var mouse1 = d3.mouse(this);\n\n            projection.scale(view.k = d3.event.scale);\n\n            if(!zoomPoint) {\n                // if no zoomPoint, the mouse wasn't over the actual geography yet\n                // maybe this point is the start... we'll find out next time!\n                mouse0 = mouse1;\n                zoomPoint = position(projection, mouse0);\n            }\n            // check if the point is on the map\n            // if not, don't do anything new but scale\n            // if it is, then we can assume between will exist below\n            // so we don't need the 'bank' function, whatever that is.\n            // TODO: is this right?\n            else if(position(projection, mouse1)) {\n                // go back to original projection temporarily\n                // except for scale... that's kind of independent?\n                projection\n                    .rotate(rotate0)\n                    .translate(translate0);\n\n                // calculate the new params\n                var point1 = position(projection, mouse1),\n                    between = rotateBetween(zoomPoint, point1),\n                    newEuler = eulerFromQuaternion(multiply(q, between)),\n                    rotateAngles = view.r = unRoll(newEuler, zoomPoint, lastRotate);\n\n                if(!isFinite(rotateAngles[0]) || !isFinite(rotateAngles[1]) ||\n                   !isFinite(rotateAngles[2])) {\n                    rotateAngles = lastRotate;\n                }\n\n                // update the projection\n                projection.rotate(rotateAngles);\n                lastRotate = rotateAngles;\n            }\n\n            zoomed(event.of(this, arguments));\n        });\n\n        zoomstarted(event.of(this, arguments));\n    })\n    .on('zoomend', function() {\n        d3.select(this).style(zoomendStyle);\n        zoomOn.call(zoom, 'zoom', null);\n        zoomended(event.of(this, arguments));\n    })\n    .on('zoom.redraw', function() {\n        geo.render();\n    });\n\n    function zoomstarted(dispatch) {\n        if(!zooming++) dispatch({type: 'zoomstart'});\n    }\n\n    function zoomed(dispatch) {\n        dispatch({type: 'zoom'});\n    }\n\n    function zoomended(dispatch) {\n        if(!--zooming) dispatch({type: 'zoomend'});\n    }\n\n    return d3.rebind(zoom, event, 'on');\n}\n\n// -- helper functions for zoomClipped\n\nfunction position(projection, point) {\n    var spherical = projection.invert(point);\n    return spherical && isFinite(spherical[0]) && isFinite(spherical[1]) && cartesian(spherical);\n}\n\nfunction quaternionFromEuler(euler) {\n    var lambda = 0.5 * euler[0] * radians,\n        phi = 0.5 * euler[1] * radians,\n        gamma = 0.5 * euler[2] * radians,\n        sinLambda = Math.sin(lambda), cosLambda = Math.cos(lambda),\n        sinPhi = Math.sin(phi), cosPhi = Math.cos(phi),\n        sinGamma = Math.sin(gamma), cosGamma = Math.cos(gamma);\n    return [\n        cosLambda * cosPhi * cosGamma + sinLambda * sinPhi * sinGamma,\n        sinLambda * cosPhi * cosGamma - cosLambda * sinPhi * sinGamma,\n        cosLambda * sinPhi * cosGamma + sinLambda * cosPhi * sinGamma,\n        cosLambda * cosPhi * sinGamma - sinLambda * sinPhi * cosGamma\n    ];\n}\n\nfunction multiply(a, b) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],\n        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];\n    return [\n        a0 * b0 - a1 * b1 - a2 * b2 - a3 * b3,\n        a0 * b1 + a1 * b0 + a2 * b3 - a3 * b2,\n        a0 * b2 - a1 * b3 + a2 * b0 + a3 * b1,\n        a0 * b3 + a1 * b2 - a2 * b1 + a3 * b0\n    ];\n}\n\nfunction rotateBetween(a, b) {\n    if(!a || !b) return;\n    var axis = cross(a, b),\n        norm = Math.sqrt(dot(axis, axis)),\n        halfgamma = 0.5 * Math.acos(Math.max(-1, Math.min(1, dot(a, b)))),\n        k = Math.sin(halfgamma) / norm;\n    return norm && [Math.cos(halfgamma), axis[2] * k, -axis[1] * k, axis[0] * k];\n}\n\n// input:\n//   rotateAngles: a calculated set of Euler angles\n//   pt: a point (cartesian in 3-space) to keep fixed\n//   roll0: an initial roll, to be preserved\n// output:\n//   a set of Euler angles that preserve the projection of pt\n//     but set roll (output[2]) equal to roll0\n//     note that this doesn't depend on the particular projection,\n//     just on the rotation angles\nfunction unRoll(rotateAngles, pt, lastRotate) {\n    // calculate the fixed point transformed by these Euler angles\n    // but with the desired roll undone\n    var ptRotated = rotateCartesian(pt, 2, rotateAngles[0]);\n    ptRotated = rotateCartesian(ptRotated, 1, rotateAngles[1]);\n    ptRotated = rotateCartesian(ptRotated, 0, rotateAngles[2] - lastRotate[2]);\n\n    var x = pt[0],\n        y = pt[1],\n        z = pt[2],\n        f = ptRotated[0],\n        g = ptRotated[1],\n        h = ptRotated[2],\n\n        // the following essentially solves:\n        // ptRotated = rotateCartesian(rotateCartesian(pt, 2, newYaw), 1, newPitch)\n        // for newYaw and newPitch, as best it can\n        theta = Math.atan2(y, x) * degrees,\n        a = Math.sqrt(x * x + y * y),\n        b,\n        newYaw1;\n\n    if(Math.abs(g) > a) {\n        newYaw1 = (g > 0 ? 90 : -90) - theta;\n        b = 0;\n    } else {\n        newYaw1 = Math.asin(g / a) * degrees - theta;\n        b = Math.sqrt(a * a - g * g);\n    }\n\n    var newYaw2 = 180 - newYaw1 - 2 * theta,\n        newPitch1 = (Math.atan2(h, f) - Math.atan2(z, b)) * degrees,\n        newPitch2 = (Math.atan2(h, f) - Math.atan2(z, -b)) * degrees;\n\n    // which is closest to lastRotate[0,1]: newYaw/Pitch or newYaw2/Pitch2?\n    var dist1 = angleDistance(lastRotate[0], lastRotate[1], newYaw1, newPitch1),\n        dist2 = angleDistance(lastRotate[0], lastRotate[1], newYaw2, newPitch2);\n\n    if(dist1 <= dist2) return [newYaw1, newPitch1, lastRotate[2]];\n    else return [newYaw2, newPitch2, lastRotate[2]];\n}\n\nfunction angleDistance(yaw0, pitch0, yaw1, pitch1) {\n    var dYaw = angleMod(yaw1 - yaw0),\n        dPitch = angleMod(pitch1 - pitch0);\n    return Math.sqrt(dYaw * dYaw + dPitch * dPitch);\n}\n\n// reduce an angle in degrees to [-180,180]\nfunction angleMod(angle) {\n    return (angle % 360 + 540) % 360 - 180;\n}\n\n// rotate a cartesian vector\n// axis is 0 (x), 1 (y), or 2 (z)\n// angle is in degrees\nfunction rotateCartesian(vector, axis, angle) {\n    var angleRads = angle * radians,\n        vectorOut = vector.slice(),\n        ax1 = (axis === 0) ? 1 : 0,\n        ax2 = (axis === 2) ? 1 : 2,\n        cosa = Math.cos(angleRads),\n        sina = Math.sin(angleRads);\n\n    vectorOut[ax1] = vector[ax1] * cosa - vector[ax2] * sina;\n    vectorOut[ax2] = vector[ax2] * cosa + vector[ax1] * sina;\n\n    return vectorOut;\n}\nfunction eulerFromQuaternion(q) {\n    return [\n        Math.atan2(2 * (q[0] * q[1] + q[2] * q[3]), 1 - 2 * (q[1] * q[1] + q[2] * q[2])) * degrees,\n        Math.asin(Math.max(-1, Math.min(1, 2 * (q[0] * q[2] - q[3] * q[1])))) * degrees,\n        Math.atan2(2 * (q[0] * q[3] + q[1] * q[2]), 1 - 2 * (q[2] * q[2] + q[3] * q[3])) * degrees\n    ];\n}\n\nfunction cartesian(spherical) {\n    var lambda = spherical[0] * radians,\n        phi = spherical[1] * radians,\n        cosPhi = Math.cos(phi);\n    return [\n        cosPhi * Math.cos(lambda),\n        cosPhi * Math.sin(lambda),\n        Math.sin(phi)\n    ];\n}\n\nfunction dot(a, b) {\n    var s = 0;\n    for(var i = 0, n = a.length; i < n; ++i) s += a[i] * b[i];\n    return s;\n}\n\nfunction cross(a, b) {\n    return [\n        a[1] * b[2] - a[2] * b[1],\n        a[2] * b[0] - a[0] * b[2],\n        a[0] * b[1] - a[1] * b[0]\n    ];\n}\n\n// Like d3.dispatch, but for custom events abstracting native UI events. These\n// events have a target component (such as a brush), a target element (such as\n// the svg:g element containing the brush) and the standard arguments `d` (the\n// target element's data) and `i` (the selection index of the target element).\nfunction d3_eventDispatch(target) {\n    var i = 0,\n        n = arguments.length,\n        argumentz = [];\n\n    while(++i < n) argumentz.push(arguments[i]);\n\n    var dispatch = d3.dispatch.apply(null, argumentz);\n\n    // Creates a dispatch context for the specified `thiz` (typically, the target\n    // DOM element that received the source event) and `argumentz` (typically, the\n    // data `d` and index `i` of the target element). The returned function can be\n    // used to dispatch an event to any registered listeners; the function takes a\n    // single argument as input, being the event to dispatch. The event must have\n    // a \"type\" attribute which corresponds to a type registered in the\n    // constructor. This context will automatically populate the \"sourceEvent\" and\n    // \"target\" attributes of the event, as well as setting the `d3.event` global\n    // for the duration of the notification.\n    dispatch.of = function(thiz, argumentz) {\n        return function(e1) {\n            var e0;\n            try {\n                e0 = e1.sourceEvent = d3.event;\n                e1.target = target;\n                d3.event = e1;\n                dispatch[e1.type].apply(thiz, argumentz);\n            } finally {\n                d3.event = e0;\n            }\n        };\n    };\n\n    return dispatch;\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/geo/zoom_reset.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nmodule.exports = function createGeoZoomReset(geo, geoLayout) {\n    var projection = geo.projection,\n        zoom = geo.zoom;\n\n    var zoomReset = function() {\n        geo.makeProjection(geoLayout);\n        geo.makePath();\n\n        zoom.scale(projection.scale());\n        zoom.translate(projection.translate());\n\n        geo.render();\n    };\n\n    return zoomReset;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/gl2d/camera.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar mouseChange = require('mouse-change');\nvar mouseWheel = require('mouse-wheel');\nvar cartesianConstants = require('../cartesian/constants');\n\nmodule.exports = createCamera;\n\nfunction Camera2D(element, plot) {\n    this.element = element;\n    this.plot = plot;\n    this.mouseListener = null;\n    this.wheelListener = null;\n    this.lastInputTime = Date.now();\n    this.lastPos = [0, 0];\n    this.boxEnabled = false;\n    this.boxInited = false;\n    this.boxStart = [0, 0];\n    this.boxEnd = [0, 0];\n    this.dragStart = [0, 0];\n}\n\n\nfunction createCamera(scene) {\n    var element = scene.mouseContainer,\n        plot = scene.glplot,\n        result = new Camera2D(element, plot);\n\n    function unSetAutoRange() {\n        scene.xaxis.autorange = false;\n        scene.yaxis.autorange = false;\n    }\n\n    function getSubplotConstraint() {\n        // note: this assumes we only have one x and one y axis on this subplot\n        // when this constraint is lifted this block won't make sense\n        var constraints = scene.graphDiv._fullLayout._axisConstraintGroups;\n        var xaId = scene.xaxis._id;\n        var yaId = scene.yaxis._id;\n        for(var i = 0; i < constraints.length; i++) {\n            if(constraints[i][xaId] !== -1) {\n                if(constraints[i][yaId] !== -1) return true;\n                break;\n            }\n        }\n        return false;\n    }\n\n    result.mouseListener = mouseChange(element, function(buttons, x, y) {\n        var dataBox = scene.calcDataBox(),\n            viewBox = plot.viewBox;\n\n        var lastX = result.lastPos[0],\n            lastY = result.lastPos[1];\n\n        var MINDRAG = cartesianConstants.MINDRAG * plot.pixelRatio;\n        var MINZOOM = cartesianConstants.MINZOOM * plot.pixelRatio;\n\n        var dx, dy;\n\n        x *= plot.pixelRatio;\n        y *= plot.pixelRatio;\n\n        // mouseChange gives y about top; convert to about bottom\n        y = (viewBox[3] - viewBox[1]) - y;\n\n        function updateRange(i0, start, end) {\n            var range0 = Math.min(start, end),\n                range1 = Math.max(start, end);\n\n            if(range0 !== range1) {\n                dataBox[i0] = range0;\n                dataBox[i0 + 2] = range1;\n                result.dataBox = dataBox;\n                scene.setRanges(dataBox);\n            }\n            else {\n                scene.selectBox.selectBox = [0, 0, 1, 1];\n                scene.glplot.setDirty();\n            }\n        }\n\n        switch(scene.fullLayout.dragmode) {\n            case 'zoom':\n                if(buttons) {\n                    var dataX = x /\n                            (viewBox[2] - viewBox[0]) * (dataBox[2] - dataBox[0]) +\n                        dataBox[0];\n                    var dataY = y /\n                            (viewBox[3] - viewBox[1]) * (dataBox[3] - dataBox[1]) +\n                        dataBox[1];\n\n                    if(!result.boxInited) {\n                        result.boxStart[0] = dataX;\n                        result.boxStart[1] = dataY;\n                        result.dragStart[0] = x;\n                        result.dragStart[1] = y;\n                    }\n\n                    result.boxEnd[0] = dataX;\n                    result.boxEnd[1] = dataY;\n\n                    // we need to mark the box as initialized right away\n                    // so that we can tell the start and end pionts apart\n                    result.boxInited = true;\n\n                    // but don't actually enable the box until the cursor moves\n                    if(!result.boxEnabled && (\n                        result.boxStart[0] !== result.boxEnd[0] ||\n                        result.boxStart[1] !== result.boxEnd[1])\n                    ) {\n                        result.boxEnabled = true;\n                    }\n\n                    // constrain aspect ratio if the axes require it\n                    var smallDx = Math.abs(result.dragStart[0] - x) < MINZOOM;\n                    var smallDy = Math.abs(result.dragStart[1] - y) < MINZOOM;\n                    if(getSubplotConstraint() && !(smallDx && smallDy)) {\n                        dx = result.boxEnd[0] - result.boxStart[0];\n                        dy = result.boxEnd[1] - result.boxStart[1];\n                        var dydx = (dataBox[3] - dataBox[1]) / (dataBox[2] - dataBox[0]);\n\n                        if(Math.abs(dx * dydx) > Math.abs(dy)) {\n                            result.boxEnd[1] = result.boxStart[1] +\n                                Math.abs(dx) * dydx * (Math.sign(dy) || 1);\n\n                            // gl-select-box clips to the plot area bounds,\n                            // which breaks the axis constraint, so don't allow\n                            // this box to go out of bounds\n                            if(result.boxEnd[1] < dataBox[1]) {\n                                result.boxEnd[1] = dataBox[1];\n                                result.boxEnd[0] = result.boxStart[0] +\n                                    (dataBox[1] - result.boxStart[1]) / Math.abs(dydx);\n                            }\n                            else if(result.boxEnd[1] > dataBox[3]) {\n                                result.boxEnd[1] = dataBox[3];\n                                result.boxEnd[0] = result.boxStart[0] +\n                                    (dataBox[3] - result.boxStart[1]) / Math.abs(dydx);\n                            }\n                        }\n                        else {\n                            result.boxEnd[0] = result.boxStart[0] +\n                                Math.abs(dy) / dydx * (Math.sign(dx) || 1);\n\n                            if(result.boxEnd[0] < dataBox[0]) {\n                                result.boxEnd[0] = dataBox[0];\n                                result.boxEnd[1] = result.boxStart[1] +\n                                    (dataBox[0] - result.boxStart[0]) * Math.abs(dydx);\n                            }\n                            else if(result.boxEnd[0] > dataBox[2]) {\n                                result.boxEnd[0] = dataBox[2];\n                                result.boxEnd[1] = result.boxStart[1] +\n                                    (dataBox[2] - result.boxStart[0]) * Math.abs(dydx);\n                            }\n                        }\n                    }\n                    // otherwise clamp small changes to the origin so we get 1D zoom\n                    else {\n                        if(smallDx) result.boxEnd[0] = result.boxStart[0];\n                        if(smallDy) result.boxEnd[1] = result.boxStart[1];\n                    }\n                }\n                else if(result.boxEnabled) {\n                    dx = result.boxStart[0] !== result.boxEnd[0];\n                    dy = result.boxStart[1] !== result.boxEnd[1];\n                    if(dx || dy) {\n                        if(dx) {\n                            updateRange(0, result.boxStart[0], result.boxEnd[0]);\n                            scene.xaxis.autorange = false;\n                        }\n                        if(dy) {\n                            updateRange(1, result.boxStart[1], result.boxEnd[1]);\n                            scene.yaxis.autorange = false;\n                        }\n                        scene.relayoutCallback();\n                    }\n                    else {\n                        scene.glplot.setDirty();\n                    }\n                    result.boxEnabled = false;\n                    result.boxInited = false;\n                }\n                break;\n\n            case 'pan':\n                result.boxEnabled = false;\n                result.boxInited = false;\n\n                if(buttons) {\n                    if(!result.panning) {\n                        result.dragStart[0] = x;\n                        result.dragStart[1] = y;\n                    }\n\n                    if(Math.abs(result.dragStart[0] - x) < MINDRAG) x = result.dragStart[0];\n                    if(Math.abs(result.dragStart[1] - y) < MINDRAG) y = result.dragStart[1];\n\n                    dx = (lastX - x) * (dataBox[2] - dataBox[0]) /\n                        (plot.viewBox[2] - plot.viewBox[0]);\n                    dy = (lastY - y) * (dataBox[3] - dataBox[1]) /\n                        (plot.viewBox[3] - plot.viewBox[1]);\n\n                    dataBox[0] += dx;\n                    dataBox[2] += dx;\n                    dataBox[1] += dy;\n                    dataBox[3] += dy;\n\n                    scene.setRanges(dataBox);\n\n                    result.panning = true;\n                    result.lastInputTime = Date.now();\n                    unSetAutoRange();\n                    scene.cameraChanged();\n                    scene.handleAnnotations();\n                }\n                else if(result.panning) {\n                    result.panning = false;\n                    scene.relayoutCallback();\n                }\n                break;\n        }\n\n        result.lastPos[0] = x;\n        result.lastPos[1] = y;\n    });\n\n    result.wheelListener = mouseWheel(element, function(dx, dy) {\n        var dataBox = scene.calcDataBox(),\n            viewBox = plot.viewBox;\n\n        var lastX = result.lastPos[0],\n            lastY = result.lastPos[1];\n\n        switch(scene.fullLayout.dragmode) {\n            case 'zoom':\n                break;\n\n            case 'pan':\n                var scale = Math.exp(0.1 * dy / (viewBox[3] - viewBox[1]));\n\n                var cx = lastX /\n                        (viewBox[2] - viewBox[0]) * (dataBox[2] - dataBox[0]) +\n                    dataBox[0];\n                var cy = lastY /\n                        (viewBox[3] - viewBox[1]) * (dataBox[3] - dataBox[1]) +\n                    dataBox[1];\n\n                dataBox[0] = (dataBox[0] - cx) * scale + cx;\n                dataBox[2] = (dataBox[2] - cx) * scale + cx;\n                dataBox[1] = (dataBox[1] - cy) * scale + cy;\n                dataBox[3] = (dataBox[3] - cy) * scale + cy;\n\n                scene.setRanges(dataBox);\n\n                result.lastInputTime = Date.now();\n                unSetAutoRange();\n                scene.cameraChanged();\n                scene.handleAnnotations();\n                scene.relayoutCallback();\n                break;\n        }\n\n        return true;\n    });\n\n    return result;\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/gl2d/convert.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Plots = require('../plots');\nvar Axes = require('../cartesian/axes');\n\nvar convertHTMLToUnicode = require('../../lib/html2unicode');\nvar str2RGBArray = require('../../lib/str2rgbarray');\n\nfunction Axes2DOptions(scene) {\n    this.scene = scene;\n    this.gl = scene.gl;\n    this.pixelRatio = scene.pixelRatio;\n\n    this.screenBox = [0, 0, 1, 1];\n    this.viewBox = [0, 0, 1, 1];\n    this.dataBox = [-1, -1, 1, 1];\n\n    this.borderLineEnable = [false, false, false, false];\n    this.borderLineWidth = [1, 1, 1, 1];\n    this.borderLineColor = [\n        [0, 0, 0, 1],\n        [0, 0, 0, 1],\n        [0, 0, 0, 1],\n        [0, 0, 0, 1]\n    ];\n\n    this.ticks = [[], []];\n    this.tickEnable = [true, true, false, false];\n    this.tickPad = [15, 15, 15, 15];\n    this.tickAngle = [0, 0, 0, 0];\n    this.tickColor = [\n        [0, 0, 0, 1],\n        [0, 0, 0, 1],\n        [0, 0, 0, 1],\n        [0, 0, 0, 1]\n    ];\n    this.tickMarkLength = [0, 0, 0, 0];\n    this.tickMarkWidth = [0, 0, 0, 0];\n    this.tickMarkColor = [\n        [0, 0, 0, 1],\n        [0, 0, 0, 1],\n        [0, 0, 0, 1],\n        [0, 0, 0, 1]\n    ];\n\n    this.labels = ['x', 'y'];\n    this.labelEnable = [true, true, false, false];\n    this.labelAngle = [0, Math.PI / 2, 0, 3.0 * Math.PI / 2];\n    this.labelPad = [15, 15, 15, 15];\n    this.labelSize = [12, 12];\n    this.labelFont = ['sans-serif', 'sans-serif'];\n    this.labelColor = [\n        [0, 0, 0, 1],\n        [0, 0, 0, 1],\n        [0, 0, 0, 1],\n        [0, 0, 0, 1]\n    ];\n\n    this.title = '';\n    this.titleEnable = true;\n    this.titleCenter = [0, 0, 0, 0];\n    this.titleAngle = 0;\n    this.titleColor = [0, 0, 0, 1];\n    this.titleFont = 'sans-serif';\n    this.titleSize = 18;\n\n    this.gridLineEnable = [true, true];\n    this.gridLineColor = [\n        [0, 0, 0, 0.5],\n        [0, 0, 0, 0.5]\n    ];\n    this.gridLineWidth = [1, 1];\n\n    this.zeroLineEnable = [true, true];\n    this.zeroLineWidth = [1, 1];\n    this.zeroLineColor = [\n        [0, 0, 0, 1],\n        [0, 0, 0, 1]\n    ];\n\n    this.borderColor = [0, 0, 0, 0];\n    this.backgroundColor = [0, 0, 0, 0];\n\n    this.static = this.scene.staticPlot;\n}\n\nvar proto = Axes2DOptions.prototype;\n\nvar AXES = ['xaxis', 'yaxis'];\n\nproto.merge = function(options) {\n\n    // titles are rendered in SVG\n    this.titleEnable = false;\n    this.backgroundColor = str2RGBArray(options.plot_bgcolor);\n\n    var axisName, ax, axTitle, axMirror;\n    var hasAxisInDfltPos, hasAxisInAltrPos, hasSharedAxis, mirrorLines, mirrorTicks;\n    var i, j;\n\n    for(i = 0; i < 2; ++i) {\n        axisName = AXES[i];\n\n        // get options relevant to this subplot,\n        // '_name' is e.g. xaxis, xaxis2, yaxis, yaxis4 ...\n        ax = options[this.scene[axisName]._name];\n\n        axTitle = /Click to enter .+ title/.test(ax.title) ? '' : ax.title;\n\n        for(j = 0; j <= 2; j += 2) {\n            this.labelEnable[i + j] = false;\n            this.labels[i + j] = convertHTMLToUnicode(axTitle);\n            this.labelColor[i + j] = str2RGBArray(ax.titlefont.color);\n            this.labelFont[i + j] = ax.titlefont.family;\n            this.labelSize[i + j] = ax.titlefont.size;\n            this.labelPad[i + j] = this.getLabelPad(axisName, ax);\n\n            this.tickEnable[i + j] = false;\n            this.tickColor[i + j] = str2RGBArray((ax.tickfont || {}).color);\n            this.tickAngle[i + j] = (ax.tickangle === 'auto') ?\n                0 :\n                Math.PI * -ax.tickangle / 180;\n            this.tickPad[i + j] = this.getTickPad(ax);\n\n            this.tickMarkLength[i + j] = 0;\n            this.tickMarkWidth[i + j] = ax.tickwidth || 0;\n            this.tickMarkColor[i + j] = str2RGBArray(ax.tickcolor);\n\n            this.borderLineEnable[i + j] = false;\n            this.borderLineColor[i + j] = str2RGBArray(ax.linecolor);\n            this.borderLineWidth[i + j] = ax.linewidth || 0;\n        }\n\n        hasSharedAxis = this.hasSharedAxis(ax);\n        hasAxisInDfltPos = this.hasAxisInDfltPos(axisName, ax) && !hasSharedAxis;\n        hasAxisInAltrPos = this.hasAxisInAltrPos(axisName, ax) && !hasSharedAxis;\n\n        axMirror = ax.mirror || false;\n        mirrorLines = hasSharedAxis ?\n            (String(axMirror).indexOf('all') !== -1) :  // 'all' or 'allticks'\n            !!axMirror;                                 // all but false\n        mirrorTicks = hasSharedAxis ?\n            (axMirror === 'allticks') :\n            (String(axMirror).indexOf('ticks') !== -1); // 'ticks' or 'allticks'\n\n        // Axis titles and tick labels can only appear of one side of the scene\n        //  and are never show on subplots that share existing axes.\n\n        if(hasAxisInDfltPos) this.labelEnable[i] = true;\n        else if(hasAxisInAltrPos) this.labelEnable[i + 2] = true;\n\n        if(hasAxisInDfltPos) this.tickEnable[i] = ax.showticklabels;\n        else if(hasAxisInAltrPos) this.tickEnable[i + 2] = ax.showticklabels;\n\n        // Grid lines and ticks can appear on both sides of the scene\n        //  and can appear on subplot that share existing axes via `ax.mirror`.\n\n        if(hasAxisInDfltPos || mirrorLines) this.borderLineEnable[i] = ax.showline;\n        if(hasAxisInAltrPos || mirrorLines) this.borderLineEnable[i + 2] = ax.showline;\n\n        if(hasAxisInDfltPos || mirrorTicks) this.tickMarkLength[i] = this.getTickMarkLength(ax);\n        if(hasAxisInAltrPos || mirrorTicks) this.tickMarkLength[i + 2] = this.getTickMarkLength(ax);\n\n        this.gridLineEnable[i] = ax.showgrid;\n        this.gridLineColor[i] = str2RGBArray(ax.gridcolor);\n        this.gridLineWidth[i] = ax.gridwidth;\n\n        this.zeroLineEnable[i] = ax.zeroline;\n        this.zeroLineColor[i] = str2RGBArray(ax.zerolinecolor);\n        this.zeroLineWidth[i] = ax.zerolinewidth;\n    }\n};\n\n// is an axis shared with an already-drawn subplot ?\nproto.hasSharedAxis = function(ax) {\n    var scene = this.scene,\n        subplotIds = Plots.getSubplotIds(scene.fullLayout, 'gl2d'),\n        list = Axes.findSubplotsWithAxis(subplotIds, ax);\n\n    // if index === 0, then the subplot is already drawn as subplots\n    // are drawn in order.\n    return (list.indexOf(scene.id) !== 0);\n};\n\n// has an axis in default position (i.e. bottom/left) ?\nproto.hasAxisInDfltPos = function(axisName, ax) {\n    var axSide = ax.side;\n\n    if(axisName === 'xaxis') return (axSide === 'bottom');\n    else if(axisName === 'yaxis') return (axSide === 'left');\n};\n\n// has an axis in alternate position (i.e. top/right) ?\nproto.hasAxisInAltrPos = function(axisName, ax) {\n    var axSide = ax.side;\n\n    if(axisName === 'xaxis') return (axSide === 'top');\n    else if(axisName === 'yaxis') return (axSide === 'right');\n};\n\nproto.getLabelPad = function(axisName, ax) {\n    var offsetBase = 1.5,\n        fontSize = ax.titlefont.size,\n        showticklabels = ax.showticklabels;\n\n    if(axisName === 'xaxis') {\n        return (ax.side === 'top') ?\n            -10 + fontSize * (offsetBase + (showticklabels ? 1 : 0)) :\n            -10 + fontSize * (offsetBase + (showticklabels ? 0.5 : 0));\n    }\n    else if(axisName === 'yaxis') {\n        return (ax.side === 'right') ?\n            10 + fontSize * (offsetBase + (showticklabels ? 1 : 0.5)) :\n            10 + fontSize * (offsetBase + (showticklabels ? 0.5 : 0));\n    }\n};\n\nproto.getTickPad = function(ax) {\n    return (ax.ticks === 'outside') ? 10 + ax.ticklen : 15;\n};\n\nproto.getTickMarkLength = function(ax) {\n    if(!ax.ticks) return 0;\n\n    var ticklen = ax.ticklen;\n\n    return (ax.ticks === 'inside') ? -ticklen : ticklen;\n};\n\n\nfunction createAxes2D(scene) {\n    return new Axes2DOptions(scene);\n}\n\nmodule.exports = createAxes2D;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/gl2d/scene2d.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Registry = require('../../registry');\nvar Axes = require('../../plots/cartesian/axes');\nvar Fx = require('../../plots/cartesian/graph_interact');\n\nvar createPlot2D = require('gl-plot2d');\nvar createSpikes = require('gl-spikes2d');\nvar createSelectBox = require('gl-select-box');\nvar getContext = require('webgl-context');\n\nvar createOptions = require('./convert');\nvar createCamera = require('./camera');\nvar convertHTMLToUnicode = require('../../lib/html2unicode');\nvar showNoWebGlMsg = require('../../lib/show_no_webgl_msg');\nvar enforceAxisConstraints = require('../../plots/cartesian/constraints');\n\nvar AXES = ['xaxis', 'yaxis'];\nvar STATIC_CANVAS, STATIC_CONTEXT;\n\n\nfunction Scene2D(options, fullLayout) {\n    this.container = options.container;\n    this.graphDiv = options.graphDiv;\n    this.pixelRatio = options.plotGlPixelRatio || window.devicePixelRatio;\n    this.id = options.id;\n    this.staticPlot = !!options.staticPlot;\n\n    this.fullData = null;\n    this.updateRefs(fullLayout);\n\n    this.makeFramework();\n\n    // update options\n    this.glplotOptions = createOptions(this);\n    this.glplotOptions.merge(fullLayout);\n\n    // create the plot\n    this.glplot = createPlot2D(this.glplotOptions);\n\n    // create camera\n    this.camera = createCamera(this);\n\n    // trace set\n    this.traces = {};\n\n    // create axes spikes\n    this.spikes = createSpikes(this.glplot);\n\n    this.selectBox = createSelectBox(this.glplot, {\n        innerFill: false,\n        outerFill: true\n    });\n\n    // last button state\n    this.lastButtonState = 0;\n\n    // last pick result\n    this.pickResult = null;\n\n    this.bounds = [Infinity, Infinity, -Infinity, -Infinity];\n\n    // flag to stop render loop\n    this.stopped = false;\n\n    // redraw the plot\n    this.redraw = this.draw.bind(this);\n    this.redraw();\n}\n\nmodule.exports = Scene2D;\n\nvar proto = Scene2D.prototype;\n\nproto.makeFramework = function() {\n\n    // create canvas and gl context\n    if(this.staticPlot) {\n        if(!STATIC_CONTEXT) {\n            STATIC_CANVAS = document.createElement('canvas');\n\n            STATIC_CONTEXT = getContext({\n                canvas: STATIC_CANVAS,\n                preserveDrawingBuffer: false,\n                premultipliedAlpha: true,\n                antialias: true\n            });\n\n            if(!STATIC_CONTEXT) {\n                throw new Error('Error creating static canvas/context for image server');\n            }\n        }\n\n        this.canvas = STATIC_CANVAS;\n        this.gl = STATIC_CONTEXT;\n    }\n    else {\n        var liveCanvas = document.createElement('canvas');\n\n        var gl = getContext({\n            canvas: liveCanvas,\n            premultipliedAlpha: true\n        });\n\n        if(!gl) showNoWebGlMsg(this);\n\n        this.canvas = liveCanvas;\n        this.gl = gl;\n    }\n\n    // position the canvas\n    var canvas = this.canvas;\n\n    canvas.style.width = '100%';\n    canvas.style.height = '100%';\n    canvas.style.position = 'absolute';\n    canvas.style.top = '0px';\n    canvas.style.left = '0px';\n    canvas.style['pointer-events'] = 'none';\n\n    this.updateSize(canvas);\n\n    // disabling user select on the canvas\n    // sanitizes double-clicks interactions\n    // ref: https://github.com/plotly/plotly.js/issues/744\n    canvas.className += 'user-select-none';\n\n    // create SVG container for hover text\n    var svgContainer = this.svgContainer = document.createElementNS(\n        'http://www.w3.org/2000/svg',\n        'svg');\n    svgContainer.style.position = 'absolute';\n    svgContainer.style.top = svgContainer.style.left = '0px';\n    svgContainer.style.width = svgContainer.style.height = '100%';\n    svgContainer.style['z-index'] = 20;\n    svgContainer.style['pointer-events'] = 'none';\n\n    // create div to catch the mouse event\n    var mouseContainer = this.mouseContainer = document.createElement('div');\n    mouseContainer.style.position = 'absolute';\n\n    // append canvas, hover svg and mouse div to container\n    var container = this.container;\n    container.appendChild(canvas);\n    container.appendChild(svgContainer);\n    container.appendChild(mouseContainer);\n};\n\nproto.toImage = function(format) {\n    if(!format) format = 'png';\n\n    this.stopped = true;\n    if(this.staticPlot) this.container.appendChild(STATIC_CANVAS);\n\n    // update canvas size\n    this.updateSize(this.canvas);\n\n    // force redraw\n    this.glplot.setDirty();\n    this.glplot.draw();\n\n    // grab context and yank out pixels\n    var gl = this.glplot.gl,\n        w = gl.drawingBufferWidth,\n        h = gl.drawingBufferHeight;\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n    var pixels = new Uint8Array(w * h * 4);\n    gl.readPixels(0, 0, w, h, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n\n    // flip pixels\n    for(var j = 0, k = h - 1; j < k; ++j, --k) {\n        for(var i = 0; i < w; ++i) {\n            for(var l = 0; l < 4; ++l) {\n                var tmp = pixels[4 * (w * j + i) + l];\n                pixels[4 * (w * j + i) + l] = pixels[4 * (w * k + i) + l];\n                pixels[4 * (w * k + i) + l] = tmp;\n            }\n        }\n    }\n\n    var canvas = document.createElement('canvas');\n    canvas.width = w;\n    canvas.height = h;\n\n    var context = canvas.getContext('2d');\n    var imageData = context.createImageData(w, h);\n    imageData.data.set(pixels);\n    context.putImageData(imageData, 0, 0);\n\n    var dataURL;\n\n    switch(format) {\n        case 'jpeg':\n            dataURL = canvas.toDataURL('image/jpeg');\n            break;\n        case 'webp':\n            dataURL = canvas.toDataURL('image/webp');\n            break;\n        default:\n            dataURL = canvas.toDataURL('image/png');\n    }\n\n    if(this.staticPlot) this.container.removeChild(STATIC_CANVAS);\n\n    return dataURL;\n};\n\nproto.updateSize = function(canvas) {\n    if(!canvas) canvas = this.canvas;\n\n    var pixelRatio = this.pixelRatio,\n        fullLayout = this.fullLayout;\n\n    var width = fullLayout.width,\n        height = fullLayout.height,\n        pixelWidth = Math.ceil(pixelRatio * width) |0,\n        pixelHeight = Math.ceil(pixelRatio * height) |0;\n\n    // check for resize\n    if(canvas.width !== pixelWidth || canvas.height !== pixelHeight) {\n        canvas.width = pixelWidth;\n        canvas.height = pixelHeight;\n    }\n\n    // make sure plots render right thing\n    if(this.redraw) this.redraw();\n\n    return canvas;\n};\n\nproto.computeTickMarks = function() {\n    this.xaxis.setScale();\n    this.yaxis.setScale();\n\n    // override _length from backward compatibility\n    // even though setScale 'should' give the correct result\n    this.xaxis._length =\n        this.glplot.viewBox[2] - this.glplot.viewBox[0];\n    this.yaxis._length =\n        this.glplot.viewBox[3] - this.glplot.viewBox[1];\n\n    var nextTicks = [\n        Axes.calcTicks(this.xaxis),\n        Axes.calcTicks(this.yaxis)\n    ];\n\n    for(var j = 0; j < 2; ++j) {\n        for(var i = 0; i < nextTicks[j].length; ++i) {\n            // coercing tick value (may not be a string) to a string\n            nextTicks[j][i].text = convertHTMLToUnicode(nextTicks[j][i].text + '');\n        }\n    }\n\n    return nextTicks;\n};\n\nfunction compareTicks(a, b) {\n    for(var i = 0; i < 2; ++i) {\n        var aticks = a[i],\n            bticks = b[i];\n\n        if(aticks.length !== bticks.length) return true;\n\n        for(var j = 0; j < aticks.length; ++j) {\n            if(aticks[j].x !== bticks[j].x) return true;\n        }\n    }\n\n    return false;\n}\n\nproto.updateRefs = function(newFullLayout) {\n    this.fullLayout = newFullLayout;\n\n    var spmatch = Axes.subplotMatch,\n        xaxisName = 'xaxis' + this.id.match(spmatch)[1],\n        yaxisName = 'yaxis' + this.id.match(spmatch)[2];\n\n    this.xaxis = this.fullLayout[xaxisName];\n    this.yaxis = this.fullLayout[yaxisName];\n};\n\nproto.relayoutCallback = function() {\n    var graphDiv = this.graphDiv,\n        xaxis = this.xaxis,\n        yaxis = this.yaxis,\n        layout = graphDiv.layout;\n\n    // update user layout\n    layout.xaxis.autorange = xaxis.autorange;\n    layout.xaxis.range = xaxis.range.slice(0);\n    layout.yaxis.autorange = yaxis.autorange;\n    layout.yaxis.range = yaxis.range.slice(0);\n\n    // make a meaningful value to be passed on to the possible 'plotly_relayout' subscriber(s)\n    // scene.camera has no many useful projection or scale information\n    // helps determine which one is the latest input (if async)\n    var update = {\n        lastInputTime: this.camera.lastInputTime\n    };\n\n    update[xaxis._name] = xaxis.range.slice(0);\n    update[yaxis._name] = yaxis.range.slice(0);\n\n    graphDiv.emit('plotly_relayout', update);\n};\n\nproto.cameraChanged = function() {\n    var camera = this.camera;\n\n    this.glplot.setDataBox(this.calcDataBox());\n\n    var nextTicks = this.computeTickMarks();\n    var curTicks = this.glplotOptions.ticks;\n\n    if(compareTicks(nextTicks, curTicks)) {\n        this.glplotOptions.ticks = nextTicks;\n        this.glplotOptions.dataBox = camera.dataBox;\n        this.glplot.update(this.glplotOptions);\n        this.handleAnnotations();\n    }\n};\n\nproto.handleAnnotations = function() {\n    var gd = this.graphDiv,\n        annotations = this.fullLayout.annotations;\n\n    for(var i = 0; i < annotations.length; i++) {\n        var ann = annotations[i];\n\n        if(ann.xref === this.xaxis._id && ann.yref === this.yaxis._id) {\n            Registry.getComponentMethod('annotations', 'drawOne')(gd, i);\n        }\n    }\n};\n\nproto.destroy = function() {\n    var traces = this.traces;\n\n    if(traces) {\n        Object.keys(traces).map(function(key) {\n            traces[key].dispose();\n            delete traces[key];\n        });\n    }\n\n    this.glplot.dispose();\n\n    if(!this.staticPlot) this.container.removeChild(this.canvas);\n    this.container.removeChild(this.svgContainer);\n    this.container.removeChild(this.mouseContainer);\n\n    this.fullData = null;\n    this.glplot = null;\n    this.stopped = true;\n};\n\nproto.plot = function(fullData, calcData, fullLayout) {\n    var glplot = this.glplot;\n\n    this.updateRefs(fullLayout);\n    this.updateTraces(fullData, calcData);\n\n    var width = fullLayout.width,\n        height = fullLayout.height;\n\n    this.updateSize(this.canvas);\n\n    var options = this.glplotOptions;\n    options.merge(fullLayout);\n    options.screenBox = [0, 0, width, height];\n\n    var size = fullLayout._size,\n        domainX = this.xaxis.domain,\n        domainY = this.yaxis.domain;\n\n    options.viewBox = [\n        size.l + domainX[0] * size.w,\n        size.b + domainY[0] * size.h,\n        (width - size.r) - (1 - domainX[1]) * size.w,\n        (height - size.t) - (1 - domainY[1]) * size.h\n    ];\n\n    this.mouseContainer.style.width = size.w * (domainX[1] - domainX[0]) + 'px';\n    this.mouseContainer.style.height = size.h * (domainY[1] - domainY[0]) + 'px';\n    this.mouseContainer.height = size.h * (domainY[1] - domainY[0]);\n    this.mouseContainer.style.left = size.l + domainX[0] * size.w + 'px';\n    this.mouseContainer.style.top = size.t + (1 - domainY[1]) * size.h + 'px';\n\n    var bounds = this.bounds;\n    bounds[0] = bounds[1] = Infinity;\n    bounds[2] = bounds[3] = -Infinity;\n\n    var traceIds = Object.keys(this.traces);\n    var ax, i;\n\n    for(i = 0; i < traceIds.length; ++i) {\n        var traceObj = this.traces[traceIds[i]];\n\n        for(var k = 0; k < 2; ++k) {\n            bounds[k] = Math.min(bounds[k], traceObj.bounds[k]);\n            bounds[k + 2] = Math.max(bounds[k + 2], traceObj.bounds[k + 2]);\n        }\n    }\n\n    for(i = 0; i < 2; ++i) {\n        if(bounds[i] > bounds[i + 2]) {\n            bounds[i] = -1;\n            bounds[i + 2] = 1;\n        }\n\n        ax = this[AXES[i]];\n        ax._length = options.viewBox[i + 2] - options.viewBox[i];\n\n        Axes.doAutoRange(ax);\n        ax.setScale();\n    }\n\n    var mockLayout = {\n        _axisConstraintGroups: this.graphDiv._fullLayout._axisConstraintGroups,\n        xaxis: this.xaxis,\n        yaxis: this.yaxis\n    };\n    enforceAxisConstraints({_fullLayout: mockLayout});\n\n    options.ticks = this.computeTickMarks();\n\n    options.dataBox = this.calcDataBox();\n\n    options.merge(fullLayout);\n    glplot.update(options);\n\n    // force redraw so that promise is returned when rendering is completed\n    this.glplot.draw();\n};\n\nproto.calcDataBox = function() {\n    var xaxis = this.xaxis,\n        yaxis = this.yaxis,\n        xrange = xaxis.range,\n        yrange = yaxis.range,\n        xr2l = xaxis.r2l,\n        yr2l = yaxis.r2l;\n\n    return [xr2l(xrange[0]), yr2l(yrange[0]), xr2l(xrange[1]), yr2l(yrange[1])];\n};\n\nproto.setRanges = function(dataBox) {\n    var xaxis = this.xaxis,\n        yaxis = this.yaxis,\n        xl2r = xaxis.l2r,\n        yl2r = yaxis.l2r;\n\n    xaxis.range = [xl2r(dataBox[0]), xl2r(dataBox[2])];\n    yaxis.range = [yl2r(dataBox[1]), yl2r(dataBox[3])];\n};\n\nproto.updateTraces = function(fullData, calcData) {\n    var traceIds = Object.keys(this.traces);\n    var i, j, fullTrace;\n\n    this.fullData = fullData;\n\n    // remove empty traces\n    trace_id_loop:\n    for(i = 0; i < traceIds.length; i++) {\n        var oldUid = traceIds[i],\n            oldTrace = this.traces[oldUid];\n\n        for(j = 0; j < fullData.length; j++) {\n            fullTrace = fullData[j];\n\n            if(fullTrace.uid === oldUid && fullTrace.type === oldTrace.type) {\n                continue trace_id_loop;\n            }\n        }\n\n        oldTrace.dispose();\n        delete this.traces[oldUid];\n    }\n\n    // update / create trace objects\n    for(i = 0; i < fullData.length; i++) {\n        fullTrace = fullData[i];\n        var calcTrace = calcData[i],\n            traceObj = this.traces[fullTrace.uid];\n\n        if(traceObj) traceObj.update(fullTrace, calcTrace);\n        else {\n            traceObj = fullTrace._module.plot(this, fullTrace, calcTrace);\n            this.traces[fullTrace.uid] = traceObj;\n        }\n    }\n\n    // order object per traces\n    this.glplot.objects.sort(function(a, b) {\n        return a._trace.index - b._trace.index;\n    });\n\n};\n\nproto.emitPointAction = function(nextSelection, eventType) {\n    var uid = nextSelection.trace.uid;\n    var trace;\n\n    for(var i = 0; i < this.fullData.length; i++) {\n        if(this.fullData[i].uid === uid) {\n            trace = this.fullData[i];\n        }\n    }\n\n    this.graphDiv.emit(eventType, {\n        points: [{\n            x: nextSelection.traceCoord[0],\n            y: nextSelection.traceCoord[1],\n            curveNumber: trace.index,\n            pointNumber: nextSelection.pointIndex,\n            data: trace._input,\n            fullData: this.fullData,\n            xaxis: this.xaxis,\n            yaxis: this.yaxis\n        }]\n    });\n};\n\nproto.draw = function() {\n    if(this.stopped) return;\n\n    requestAnimationFrame(this.redraw);\n\n    var glplot = this.glplot,\n        camera = this.camera,\n        mouseListener = camera.mouseListener,\n        mouseUp = this.lastButtonState === 1 && mouseListener.buttons === 0,\n        fullLayout = this.fullLayout;\n\n    this.lastButtonState = mouseListener.buttons;\n\n    this.cameraChanged();\n\n    var x = mouseListener.x * glplot.pixelRatio;\n    var y = this.canvas.height - glplot.pixelRatio * mouseListener.y;\n\n    var result;\n\n    if(camera.boxEnabled && fullLayout.dragmode === 'zoom') {\n        this.selectBox.enabled = true;\n\n        var selectBox = this.selectBox.selectBox = [\n            Math.min(camera.boxStart[0], camera.boxEnd[0]),\n            Math.min(camera.boxStart[1], camera.boxEnd[1]),\n            Math.max(camera.boxStart[0], camera.boxEnd[0]),\n            Math.max(camera.boxStart[1], camera.boxEnd[1])\n        ];\n\n        // 1D zoom\n        for(var i = 0; i < 2; i++) {\n            if(camera.boxStart[i] === camera.boxEnd[i]) {\n                selectBox[i] = glplot.dataBox[i];\n                selectBox[i + 2] = glplot.dataBox[i + 2];\n            }\n        }\n\n        glplot.setDirty();\n    }\n    else if(!camera.panning) {\n        this.selectBox.enabled = false;\n\n        var size = fullLayout._size,\n            domainX = this.xaxis.domain,\n            domainY = this.yaxis.domain;\n\n        result = glplot.pick(\n            (x / glplot.pixelRatio) + size.l + domainX[0] * size.w,\n            (y / glplot.pixelRatio) - (size.t + (1 - domainY[1]) * size.h)\n        );\n\n        var nextSelection = result && result.object._trace.handlePick(result);\n\n        if(nextSelection && mouseUp) {\n            this.emitPointAction(nextSelection, 'plotly_click');\n        }\n\n        if(result && result.object._trace.hoverinfo !== 'skip' && fullLayout.hovermode) {\n\n            if(nextSelection && (\n                !this.lastPickResult ||\n                this.lastPickResult.traceUid !== nextSelection.trace.uid ||\n                this.lastPickResult.dataCoord[0] !== nextSelection.dataCoord[0] ||\n                this.lastPickResult.dataCoord[1] !== nextSelection.dataCoord[1])\n            ) {\n                var selection = nextSelection;\n\n                this.lastPickResult = {\n                    traceUid: nextSelection.trace ? nextSelection.trace.uid : null,\n                    dataCoord: nextSelection.dataCoord.slice()\n                };\n                this.spikes.update({ center: result.dataCoord });\n\n                selection.screenCoord = [\n                    ((glplot.viewBox[2] - glplot.viewBox[0]) *\n                    (result.dataCoord[0] - glplot.dataBox[0]) /\n                        (glplot.dataBox[2] - glplot.dataBox[0]) + glplot.viewBox[0]) /\n                            glplot.pixelRatio,\n                    (this.canvas.height - (glplot.viewBox[3] - glplot.viewBox[1]) *\n                    (result.dataCoord[1] - glplot.dataBox[1]) /\n                        (glplot.dataBox[3] - glplot.dataBox[1]) - glplot.viewBox[1]) /\n                            glplot.pixelRatio\n                ];\n\n                // this needs to happen before the next block that deletes traceCoord data\n                // also it's important to copy, otherwise data is lost by the time event data is read\n                this.emitPointAction(nextSelection, 'plotly_hover');\n\n                var hoverinfo = selection.hoverinfo;\n                if(hoverinfo !== 'all') {\n                    var parts = hoverinfo.split('+');\n                    if(parts.indexOf('x') === -1) selection.traceCoord[0] = undefined;\n                    if(parts.indexOf('y') === -1) selection.traceCoord[1] = undefined;\n                    if(parts.indexOf('z') === -1) selection.traceCoord[2] = undefined;\n                    if(parts.indexOf('text') === -1) selection.textLabel = undefined;\n                    if(parts.indexOf('name') === -1) selection.name = undefined;\n                }\n\n                Fx.loneHover({\n                    x: selection.screenCoord[0],\n                    y: selection.screenCoord[1],\n                    xLabel: this.hoverFormatter('xaxis', selection.traceCoord[0]),\n                    yLabel: this.hoverFormatter('yaxis', selection.traceCoord[1]),\n                    zLabel: selection.traceCoord[2],\n                    text: selection.textLabel,\n                    name: selection.name,\n                    color: selection.color\n                }, {\n                    container: this.svgContainer\n                });\n            }\n        }\n    }\n\n    // Remove hover effects if we're not over a point OR\n    // if we're zooming or panning (in which case result is not set)\n    if(!result && this.lastPickResult) {\n        this.spikes.update({});\n        this.lastPickResult = null;\n        this.graphDiv.emit('plotly_unhover');\n        Fx.loneUnhover(this.svgContainer);\n    }\n\n    glplot.draw();\n};\n\nproto.hoverFormatter = function(axisName, val) {\n    if(val === undefined) return undefined;\n\n    var axis = this[axisName];\n    return Axes.tickText(axis, axis.c2l(val), 'hover').text;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/gl3d/project.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nfunction xformMatrix(m, v) {\n    var out = [0, 0, 0, 0];\n    var i, j;\n\n    for(i = 0; i < 4; ++i) {\n        for(j = 0; j < 4; ++j) {\n            out[j] += m[4 * i + j] * v[i];\n        }\n    }\n\n    return out;\n}\n\nfunction project(camera, v) {\n    var p = xformMatrix(camera.projection,\n        xformMatrix(camera.view,\n        xformMatrix(camera.model, [v[0], v[1], v[2], 1])));\n    return p;\n}\n\nmodule.exports = project;\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/mapbox/convert_text_opts.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Lib = require('../../lib');\n\n\n/**\n * Convert plotly.js 'textposition' to mapbox-gl 'anchor' and 'offset'\n * (with the help of the icon size).\n *\n * @param {string} textpostion : plotly.js textposition value\n * @param {number} iconSize : plotly.js icon size (e.g. marker.size for traces)\n *\n * @return {object}\n *      - anchor\n *      - offset\n */\nmodule.exports = function convertTextOpts(textposition, iconSize) {\n    var parts = textposition.split(' '),\n        vPos = parts[0],\n        hPos = parts[1];\n\n    // ballpack values\n    var factor = Array.isArray(iconSize) ? Lib.mean(iconSize) : iconSize,\n        xInc = 0.5 + (factor / 100),\n        yInc = 1.5 + (factor / 100);\n\n    var anchorVals = ['', ''],\n        offset = [0, 0];\n\n    switch(vPos) {\n        case 'top':\n            anchorVals[0] = 'top';\n            offset[1] = -yInc;\n            break;\n        case 'bottom':\n            anchorVals[0] = 'bottom';\n            offset[1] = yInc;\n            break;\n    }\n\n    switch(hPos) {\n        case 'left':\n            anchorVals[1] = 'right';\n            offset[0] = -xInc;\n            break;\n        case 'right':\n            anchorVals[1] = 'left';\n            offset[0] = xInc;\n            break;\n    }\n\n    // Mapbox text-anchor must be one of:\n    //  center, left, right, top, bottom,\n    //  top-left, top-right, bottom-left, bottom-right\n\n    var anchor;\n    if(anchorVals[0] && anchorVals[1]) anchor = anchorVals.join('-');\n    else if(anchorVals[0]) anchor = anchorVals[0];\n    else if(anchorVals[1]) anchor = anchorVals[1];\n    else anchor = 'center';\n\n    return { anchor: anchor, offset: offset };\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/mapbox/layers.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar convertTextOpts = require('./convert_text_opts');\n\n\nfunction MapboxLayer(mapbox, index) {\n    this.mapbox = mapbox;\n    this.map = mapbox.map;\n\n    this.uid = mapbox.uid + '-' + 'layer' + index;\n\n    this.idSource = this.uid + '-source';\n    this.idLayer = this.uid + '-layer';\n\n    // some state variable to check if a remove/add step is needed\n    this.sourceType = null;\n    this.source = null;\n    this.layerType = null;\n    this.below = null;\n\n    // is layer currently visible\n    this.visible = false;\n}\n\nvar proto = MapboxLayer.prototype;\n\nproto.update = function update(opts) {\n    if(!this.visible) {\n\n        // IMPORTANT: must create source before layer to not cause errors\n        this.updateSource(opts);\n        this.updateLayer(opts);\n    }\n    else if(this.needsNewSource(opts)) {\n\n        // IMPORTANT: must delete layer before source to not cause errors\n        this.updateLayer(opts);\n        this.updateSource(opts);\n    }\n    else if(this.needsNewLayer(opts)) {\n        this.updateLayer(opts);\n    }\n\n    this.updateStyle(opts);\n\n    this.visible = isVisible(opts);\n};\n\nproto.needsNewSource = function(opts) {\n\n    // for some reason changing layer to 'fill' or 'symbol'\n    // w/o changing the source throws an exception in mapbox-gl 0.18 ;\n    // stay safe and make new source on type changes\n\n    return (\n        this.sourceType !== opts.sourcetype ||\n        this.source !== opts.source ||\n        this.layerType !== opts.type\n    );\n};\n\nproto.needsNewLayer = function(opts) {\n    return (\n        this.layerType !== opts.type ||\n        this.below !== opts.below\n    );\n};\n\nproto.updateSource = function(opts) {\n    var map = this.map;\n\n    if(map.getSource(this.idSource)) map.removeSource(this.idSource);\n\n    this.sourceType = opts.sourcetype;\n    this.source = opts.source;\n\n    if(!isVisible(opts)) return;\n\n    var sourceOpts = convertSourceOpts(opts);\n\n    map.addSource(this.idSource, sourceOpts);\n};\n\nproto.updateLayer = function(opts) {\n    var map = this.map;\n\n    if(map.getLayer(this.idLayer)) map.removeLayer(this.idLayer);\n\n    this.layerType = opts.type;\n\n    if(!isVisible(opts)) return;\n\n    map.addLayer({\n        id: this.idLayer,\n        source: this.idSource,\n        'source-layer': opts.sourcelayer || '',\n        type: opts.type\n    }, opts.below);\n\n    // the only way to make a layer invisible is to remove it\n    var layoutOpts = { visibility: 'visible' };\n    this.mapbox.setOptions(this.idLayer, 'setLayoutProperty', layoutOpts);\n};\n\nproto.updateStyle = function(opts) {\n    var convertedOpts = convertOpts(opts);\n\n    if(isVisible(opts)) {\n        this.mapbox.setOptions(this.idLayer, 'setLayoutProperty', convertedOpts.layout);\n        this.mapbox.setOptions(this.idLayer, 'setPaintProperty', convertedOpts.paint);\n    }\n};\n\nproto.dispose = function dispose() {\n    var map = this.map;\n\n    map.removeLayer(this.idLayer);\n    map.removeSource(this.idSource);\n};\n\nfunction isVisible(opts) {\n    var source = opts.source;\n\n    return (\n        Lib.isPlainObject(source) ||\n        (typeof source === 'string' && source.length > 0)\n    );\n}\n\nfunction convertOpts(opts) {\n    var layout = {},\n        paint = {};\n\n    switch(opts.type) {\n\n        case 'circle':\n            Lib.extendFlat(paint, {\n                'circle-radius': opts.circle.radius,\n                'circle-color': opts.color,\n                'circle-opacity': opts.opacity\n            });\n            break;\n\n        case 'line':\n            Lib.extendFlat(paint, {\n                'line-width': opts.line.width,\n                'line-color': opts.color,\n                'line-opacity': opts.opacity\n            });\n            break;\n\n        case 'fill':\n            Lib.extendFlat(paint, {\n                'fill-color': opts.color,\n                'fill-outline-color': opts.fill.outlinecolor,\n                'fill-opacity': opts.opacity\n\n                // no way to pass specify outline width at the moment\n            });\n            break;\n\n        case 'symbol':\n            var symbol = opts.symbol,\n                textOpts = convertTextOpts(symbol.textposition, symbol.iconsize);\n\n            Lib.extendFlat(layout, {\n                'icon-image': symbol.icon + '-15',\n                'icon-size': symbol.iconsize / 10,\n\n                'text-field': symbol.text,\n                'text-size': symbol.textfont.size,\n                'text-anchor': textOpts.anchor,\n                'text-offset': textOpts.offset\n\n                // TODO font family\n                // 'text-font': symbol.textfont.family.split(', '),\n            });\n\n            Lib.extendFlat(paint, {\n                'icon-color': opts.color,\n                'text-color': symbol.textfont.color,\n                'text-opacity': opts.opacity\n            });\n            break;\n    }\n\n    return { layout: layout, paint: paint };\n}\n\nfunction convertSourceOpts(opts) {\n    var sourceType = opts.sourcetype,\n        source = opts.source,\n        sourceOpts = { type: sourceType },\n        isSourceAString = (typeof source === 'string'),\n        field;\n\n    if(sourceType === 'geojson') field = 'data';\n    else if(sourceType === 'vector') {\n        field = isSourceAString ? 'url' : 'tiles';\n    }\n\n    sourceOpts[field] = source;\n\n    return sourceOpts;\n}\n\nmodule.exports = function createMapboxLayer(mapbox, index, opts) {\n    var mapboxLayer = new MapboxLayer(mapbox, index);\n\n    mapboxLayer.update(opts);\n\n    return mapboxLayer;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/mapbox/mapbox.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar mapboxgl = require('mapbox-gl');\n\nvar Fx = require('../cartesian/graph_interact');\nvar Lib = require('../../lib');\nvar constants = require('./constants');\nvar layoutAttributes = require('./layout_attributes');\nvar createMapboxLayer = require('./layers');\n\n\nfunction Mapbox(opts) {\n    this.id = opts.id;\n    this.gd = opts.gd;\n    this.container = opts.container;\n    this.isStatic = opts.staticPlot;\n\n    var fullLayout = opts.fullLayout;\n\n    // unique id for this Mapbox instance\n    this.uid = fullLayout._uid + '-' + this.id;\n\n    // full mapbox options (N.B. needs to be updated on every updates)\n    this.opts = fullLayout[this.id];\n\n    // create framework on instantiation for a smoother first plot call\n    this.div = null;\n    this.xaxis = null;\n    this.yaxis = null;\n    this.createFramework(fullLayout);\n\n    // state variables used to infer how and what to update\n    this.map = null;\n    this.accessToken = null;\n    this.styleObj = null;\n    this.traceHash = {};\n    this.layerList = [];\n}\n\nvar proto = Mapbox.prototype;\n\nmodule.exports = function createMapbox(opts) {\n    var mapbox = new Mapbox(opts);\n\n    return mapbox;\n};\n\nproto.plot = function(calcData, fullLayout, promises) {\n    var self = this;\n\n    // feed in new mapbox options\n    var opts = self.opts = fullLayout[this.id];\n\n    // remove map and create a new map if access token has change\n    if(self.map && (opts.accesstoken !== self.accessToken)) {\n        self.map.remove();\n        self.map = null;\n        self.styleObj = null;\n        self.traceHash = [];\n        self.layerList = {};\n    }\n\n    var promise;\n\n    if(!self.map) {\n        promise = new Promise(function(resolve, reject) {\n            self.createMap(calcData, fullLayout, resolve, reject);\n        });\n    }\n    else {\n        promise = new Promise(function(resolve, reject) {\n            self.updateMap(calcData, fullLayout, resolve, reject);\n        });\n    }\n\n    promises.push(promise);\n};\n\nproto.createMap = function(calcData, fullLayout, resolve, reject) {\n    var self = this,\n        gd = self.gd,\n        opts = self.opts;\n\n    // store style id and URL or object\n    var styleObj = self.styleObj = getStyleObj(opts.style);\n\n    // store access token associated with this map\n    self.accessToken = opts.accesstoken;\n\n    // create the map!\n    var map = self.map = new mapboxgl.Map({\n        container: self.div,\n\n        style: styleObj.style,\n        center: convertCenter(opts.center),\n        zoom: opts.zoom,\n        bearing: opts.bearing,\n        pitch: opts.pitch,\n\n        interactive: !self.isStatic,\n        preserveDrawingBuffer: self.isStatic\n    });\n\n    // clear navigation container\n    var className = constants.controlContainerClassName;\n    var controlContainer = self.div.getElementsByClassName(className)[0];\n    self.div.removeChild(controlContainer);\n\n    // make sure canvas does not inherit left and top css\n    map._canvas.canvas.style.left = '0px';\n    map._canvas.canvas.style.top = '0px';\n\n    self.rejectOnError(reject);\n\n    map.once('load', function() {\n        self.updateData(calcData);\n        self.updateLayout(fullLayout);\n\n        self.resolveOnRender(resolve);\n    });\n\n    // keep track of pan / zoom in user layout and emit relayout event\n    map.on('moveend', function(eventData) {\n        if(!self.map) return;\n\n        var view = self.getView();\n\n        opts._input.center = opts.center = view.center;\n        opts._input.zoom = opts.zoom = view.zoom;\n        opts._input.bearing = opts.bearing = view.bearing;\n        opts._input.pitch = opts.pitch = view.pitch;\n\n        // 'moveend' gets triggered by map.setCenter, map.setZoom,\n        // map.setBearing and map.setPitch.\n        //\n        // Here, we make sure that 'plotly_relayout' is\n        // triggered here only when the 'moveend' originates from a\n        // mouse target (filtering out API calls) to not\n        // duplicate 'plotly_relayout' events.\n\n        if(eventData.originalEvent) {\n            var update = {};\n            update[self.id] = Lib.extendFlat({}, view);\n            gd.emit('plotly_relayout', update);\n        }\n    });\n\n    map.on('mousemove', function(evt) {\n        var bb = self.div.getBoundingClientRect();\n\n        // some hackery to get Fx.hover to work\n\n        evt.clientX = evt.point.x + bb.left;\n        evt.clientY = evt.point.y + bb.top;\n\n        evt.target.getBoundingClientRect = function() { return bb; };\n\n        self.xaxis.p2c = function() { return evt.lngLat.lng; };\n        self.yaxis.p2c = function() { return evt.lngLat.lat; };\n\n        Fx.hover(gd, evt, self.id);\n    });\n\n    map.on('click', function(evt) {\n        Fx.click(gd, evt.originalEvent);\n    });\n\n    function unhover() {\n        Fx.loneUnhover(fullLayout._toppaper);\n    }\n\n    map.on('dragstart', unhover);\n    map.on('zoomstart', unhover);\n};\n\nproto.updateMap = function(calcData, fullLayout, resolve, reject) {\n    var self = this,\n        map = self.map;\n\n    self.rejectOnError(reject);\n\n    var styleObj = getStyleObj(self.opts.style);\n\n    if(self.styleObj.id !== styleObj.id) {\n        self.styleObj = styleObj;\n        map.setStyle(styleObj.style);\n\n        map.style.once('load', function() {\n\n            // need to rebuild trace layers on reload\n            // to avoid 'lost event' errors\n            self.traceHash = {};\n\n            self.updateData(calcData);\n            self.updateLayout(fullLayout);\n\n            self.resolveOnRender(resolve);\n        });\n    }\n    else {\n        self.updateData(calcData);\n        self.updateLayout(fullLayout);\n\n        self.resolveOnRender(resolve);\n    }\n};\n\nproto.updateData = function(calcData) {\n    var traceHash = this.traceHash;\n\n    var traceObj, trace, i, j;\n\n    // update or create trace objects\n    for(i = 0; i < calcData.length; i++) {\n        var calcTrace = calcData[i];\n\n        trace = calcTrace[0].trace;\n        traceObj = traceHash[trace.uid];\n\n        if(traceObj) traceObj.update(calcTrace);\n        else if(trace._module) {\n            traceHash[trace.uid] = trace._module.plot(this, calcTrace);\n        }\n    }\n\n    // remove empty trace objects\n    var ids = Object.keys(traceHash);\n    id_loop:\n    for(i = 0; i < ids.length; i++) {\n        var id = ids[i];\n\n        for(j = 0; j < calcData.length; j++) {\n            trace = calcData[j][0].trace;\n\n            if(id === trace.uid) continue id_loop;\n        }\n\n        traceObj = traceHash[id];\n        traceObj.dispose();\n        delete traceHash[id];\n    }\n};\n\nproto.updateLayout = function(fullLayout) {\n    var map = this.map,\n        opts = this.opts;\n\n    map.setCenter(convertCenter(opts.center));\n    map.setZoom(opts.zoom);\n    map.setBearing(opts.bearing);\n    map.setPitch(opts.pitch);\n\n    this.updateLayers();\n    this.updateFramework(fullLayout);\n    this.map.resize();\n};\n\nproto.resolveOnRender = function(resolve) {\n    var map = this.map;\n\n    map.on('render', function onRender() {\n        if(map.loaded()) {\n            map.off('render', onRender);\n            resolve();\n        }\n    });\n};\n\nproto.rejectOnError = function(reject) {\n    var map = this.map;\n\n    function handler() {\n        reject(new Error(constants.mapOnErrorMsg));\n    }\n\n    map.once('error', handler);\n    map.once('style.error', handler);\n    map.once('source.error', handler);\n    map.once('tile.error', handler);\n    map.once('layer.error', handler);\n};\n\nproto.createFramework = function(fullLayout) {\n    var self = this;\n\n    var div = self.div = document.createElement('div');\n\n    div.id = self.uid;\n    div.style.position = 'absolute';\n\n    self.container.appendChild(div);\n\n    // create mock x/y axes for hover routine\n\n    self.xaxis = {\n        _id: 'x',\n        c2p: function(v) { return self.project(v).x; }\n    };\n\n    self.yaxis = {\n        _id: 'y',\n        c2p: function(v) { return self.project(v).y; }\n    };\n\n    self.updateFramework(fullLayout);\n};\n\nproto.updateFramework = function(fullLayout) {\n    var domain = fullLayout[this.id].domain,\n        size = fullLayout._size;\n\n    var style = this.div.style;\n\n    // TODO Is this correct? It seems to get the map zoom level wrong?\n\n    style.width = size.w * (domain.x[1] - domain.x[0]) + 'px';\n    style.height = size.h * (domain.y[1] - domain.y[0]) + 'px';\n    style.left = size.l + domain.x[0] * size.w + 'px';\n    style.top = size.t + (1 - domain.y[1]) * size.h + 'px';\n\n    this.xaxis._offset = size.l + domain.x[0] * size.w;\n    this.xaxis._length = size.w * (domain.x[1] - domain.x[0]);\n\n    this.yaxis._offset = size.t + (1 - domain.y[1]) * size.h;\n    this.yaxis._length = size.h * (domain.y[1] - domain.y[0]);\n};\n\nproto.updateLayers = function() {\n    var opts = this.opts,\n        layers = opts.layers,\n        layerList = this.layerList,\n        i;\n\n    // if the layer arrays don't match,\n    // don't try to be smart,\n    // delete them all, and start all over.\n\n    if(layers.length !== layerList.length) {\n        for(i = 0; i < layerList.length; i++) {\n            layerList[i].dispose();\n        }\n\n        layerList = this.layerList = [];\n\n        for(i = 0; i < layers.length; i++) {\n            layerList.push(createMapboxLayer(this, i, layers[i]));\n        }\n    }\n    else {\n        for(i = 0; i < layers.length; i++) {\n            layerList[i].update(layers[i]);\n        }\n    }\n};\n\nproto.destroy = function() {\n    if(this.map) {\n        this.map.remove();\n        this.map = null;\n    }\n    this.container.removeChild(this.div);\n};\n\nproto.toImage = function() {\n    return this.map.getCanvas().toDataURL();\n};\n\n// convenience wrapper to create blank GeoJSON sources\n// and avoid 'invalid GeoJSON' errors\nproto.initSource = function(idSource) {\n    var blank = {\n        type: 'geojson',\n        data: {\n            type: 'Feature',\n            geometry: {\n                type: 'Point',\n                coordinates: []\n            }\n        }\n    };\n\n    return this.map.addSource(idSource, blank);\n};\n\n// convenience wrapper to set data of GeoJSON sources\nproto.setSourceData = function(idSource, data) {\n    this.map.getSource(idSource).setData(data);\n};\n\n// convenience wrapper to create set multiple layer\n// 'layout' or 'paint options at once.\nproto.setOptions = function(id, methodName, opts) {\n    var map = this.map,\n        keys = Object.keys(opts);\n\n    for(var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n\n        map[methodName](id, key, opts[key]);\n    }\n};\n\n// convenience method to project a [lon, lat] array to pixel coords\nproto.project = function(v) {\n    return this.map.project(new mapboxgl.LngLat(v[0], v[1]));\n};\n\n// get map's current view values in plotly.js notation\nproto.getView = function() {\n    var map = this.map;\n\n    var mapCenter = map.getCenter(),\n        center = { lon: mapCenter.lng, lat: mapCenter.lat };\n\n    return {\n        center: center,\n        zoom: map.getZoom(),\n        bearing: map.getBearing(),\n        pitch: map.getPitch()\n    };\n};\n\nfunction getStyleObj(val) {\n    var styleValues = layoutAttributes.style.values,\n        styleDflt = layoutAttributes.style.dflt,\n        styleObj = {};\n\n    if(Lib.isPlainObject(val)) {\n        styleObj.id = val.id;\n        styleObj.style = val;\n    }\n    else if(typeof val === 'string') {\n        styleObj.id = val;\n        styleObj.style = (styleValues.indexOf(val) !== -1) ?\n             convertStyleVal(val) :\n             val;\n    }\n    else {\n        styleObj.id = styleDflt;\n        styleObj.style = convertStyleVal(styleDflt);\n    }\n\n    return styleObj;\n}\n\n// if style is part of the 'official' mapbox values, add URL prefix and suffix\nfunction convertStyleVal(val) {\n    return constants.styleUrlPrefix + val + '-' + constants.styleUrlSuffix;\n}\n\nfunction convertCenter(center) {\n    return [center.lon, center.lat];\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/polar/axis_attributes.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar axesAttrs = require('../cartesian/layout_attributes');\nvar extendFlat = require('../../lib/extend').extendFlat;\n\nvar domainAttr = extendFlat({}, axesAttrs.domain, {\n    description: [\n        'Polar chart subplots are not supported yet.',\n        'This key has currently no effect.'\n    ].join(' ')\n});\n\nfunction mergeAttrs(axisName, nonCommonAttrs) {\n    var commonAttrs = {\n        showline: {\n            valType: 'boolean',\n            role: 'style',\n            description: [\n                'Determines whether or not the line bounding this',\n                axisName, 'axis',\n                'will be shown on the figure.'\n            ].join(' ')\n        },\n        showticklabels: {\n            valType: 'boolean',\n            role: 'style',\n            description: [\n                'Determines whether or not the',\n                axisName, 'axis ticks',\n                'will feature tick labels.'\n            ].join(' ')\n        },\n        tickorientation: {\n            valType: 'enumerated',\n            values: ['horizontal', 'vertical'],\n            role: 'style',\n            description: [\n                'Sets the orientation (from the paper perspective)',\n                'of the', axisName, 'axis tick labels.'\n            ].join(' ')\n        },\n        ticklen: {\n            valType: 'number',\n            min: 0,\n            role: 'style',\n            description: [\n                'Sets the length of the tick lines on this', axisName, 'axis.'\n            ].join(' ')\n        },\n        tickcolor: {\n            valType: 'color',\n            role: 'style',\n            description: [\n                'Sets the color of the tick lines on this', axisName, 'axis.'\n            ].join(' ')\n        },\n        ticksuffix: {\n            valType: 'string',\n            role: 'style',\n            description: [\n                'Sets the length of the tick lines on this', axisName, 'axis.'\n            ].join(' ')\n        },\n        endpadding: {\n            valType: 'number',\n            role: 'style'\n        },\n        visible: {\n            valType: 'boolean',\n            role: 'info',\n            description: [\n                'Determines whether or not this axis will be visible.'\n            ].join(' ')\n        }\n    };\n\n    return extendFlat({}, nonCommonAttrs, commonAttrs);\n}\n\nmodule.exports = {\n    radialaxis: mergeAttrs('radial', {\n        range: {\n            valType: 'info_array',\n            role: 'info',\n            items: [\n                { valType: 'number' },\n                { valType: 'number' }\n            ],\n            description: [\n                'Defines the start and end point of this radial axis.'\n            ].join(' ')\n        },\n        domain: domainAttr,\n        orientation: {\n            valType: 'number',\n            role: 'style',\n            description: [\n                'Sets the orientation (an angle with respect to the origin)',\n                'of the radial axis.'\n            ].join(' ')\n        }\n    }),\n\n    angularaxis: mergeAttrs('angular', {\n        range: {\n            valType: 'info_array',\n            role: 'info',\n            items: [\n                { valType: 'number', dflt: 0 },\n                { valType: 'number', dflt: 360 }\n            ],\n            description: [\n                'Defines the start and end point of this angular axis.'\n            ].join(' ')\n        },\n        domain: domainAttr\n    }),\n\n    // attributes that appear at layout root\n    layout: {\n        direction: {\n            valType: 'enumerated',\n            values: ['clockwise', 'counterclockwise'],\n            role: 'info',\n            description: [\n                'For polar plots only.',\n                'Sets the direction corresponding to positive angles.'\n            ].join(' ')\n        },\n        orientation: {\n            valType: 'angle',\n            role: 'info',\n            description: [\n                'For polar plots only.',\n                'Rotates the entire polar by the given angle.'\n            ].join(' ')\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/plots/ternary/ternary.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\nvar tinycolor = require('tinycolor2');\n\nvar Plotly = require('../../plotly');\nvar Lib = require('../../lib');\nvar Color = require('../../components/color');\nvar Drawing = require('../../components/drawing');\nvar setConvert = require('../cartesian/set_convert');\nvar extendFlat = require('../../lib/extend').extendFlat;\nvar Plots = require('../plots');\nvar Axes = require('../cartesian/axes');\nvar dragElement = require('../../components/dragelement');\nvar Titles = require('../../components/titles');\nvar prepSelect = require('../cartesian/select');\nvar constants = require('../cartesian/constants');\nvar fx = require('../cartesian/graph_interact');\n\n\nfunction Ternary(options, fullLayout) {\n    this.id = options.id;\n    this.graphDiv = options.graphDiv;\n    this.init(fullLayout);\n    this.makeFramework();\n}\n\nmodule.exports = Ternary;\n\nvar proto = Ternary.prototype;\n\nproto.init = function(fullLayout) {\n    this.container = fullLayout._ternarylayer;\n    this.defs = fullLayout._defs;\n    this.layoutId = fullLayout._uid;\n    this.traceHash = {};\n};\n\nproto.plot = function(ternaryCalcData, fullLayout) {\n    var _this = this,\n        ternaryLayout = fullLayout[_this.id],\n        graphSize = fullLayout._size;\n\n    _this.adjustLayout(ternaryLayout, graphSize);\n\n    Plots.generalUpdatePerTraceModule(_this, ternaryCalcData, ternaryLayout);\n\n    _this.layers.plotbg.select('path').call(Color.fill, ternaryLayout.bgcolor);\n};\n\nproto.makeFramework = function() {\n    var _this = this;\n\n    var defGroup = _this.defs.selectAll('g.clips')\n        .data([0]);\n    defGroup.enter().append('g')\n        .classed('clips', true);\n\n    // clippath for this ternary subplot\n    var clipId = 'clip' + _this.layoutId + _this.id;\n    _this.clipDef = defGroup.selectAll('#' + clipId)\n        .data([0]);\n    _this.clipDef.enter().append('clipPath').attr('id', clipId)\n        .append('path').attr('d', 'M0,0Z');\n\n    // container for everything in this ternary subplot\n    _this.plotContainer = _this.container.selectAll('g.' + _this.id)\n        .data([0]);\n    _this.plotContainer.enter().append('g')\n        .classed(_this.id, true);\n\n    _this.layers = {};\n\n    // inside that container, we have one container for the data, and\n    // one each for the three axes around it.\n    var plotLayers = [\n        'draglayer',\n        'plotbg',\n        'backplot',\n        'grids',\n        'frontplot',\n        'zoom',\n        'aaxis', 'baxis', 'caxis', 'axlines'\n    ];\n    var toplevel = _this.plotContainer.selectAll('g.toplevel')\n        .data(plotLayers);\n    toplevel.enter().append('g')\n        .attr('class', function(d) { return 'toplevel ' + d; })\n        .each(function(d) {\n            var s = d3.select(this);\n            _this.layers[d] = s;\n\n            // containers for different trace types.\n            // NOTE - this is different from cartesian, where all traces\n            // are in front of grids. Here I'm putting maps behind the grids\n            // so the grids will always be visible if they're requested.\n            // Perhaps we want that for cartesian too?\n            if(d === 'frontplot') s.append('g').classed('scatterlayer', true);\n            else if(d === 'backplot') s.append('g').classed('maplayer', true);\n            else if(d === 'plotbg') s.append('path').attr('d', 'M0,0Z');\n            else if(d === 'axlines') {\n                s.selectAll('path').data(['aline', 'bline', 'cline'])\n                    .enter().append('path').each(function(d) {\n                        d3.select(this).classed(d, true);\n                    });\n            }\n        });\n\n    var grids = _this.plotContainer.select('.grids').selectAll('g.grid')\n        .data(['agrid', 'bgrid', 'cgrid']);\n    grids.enter().append('g')\n        .attr('class', function(d) { return 'grid ' + d; })\n        .each(function(d) { _this.layers[d] = d3.select(this); });\n\n    _this.plotContainer.selectAll('.backplot,.frontplot,.grids')\n        .call(Drawing.setClipUrl, clipId);\n\n    if(!_this.graphDiv._context.staticPlot) {\n        _this.initInteractions();\n    }\n};\n\nvar w_over_h = Math.sqrt(4 / 3);\n\nproto.adjustLayout = function(ternaryLayout, graphSize) {\n    var _this = this,\n        domain = ternaryLayout.domain,\n        xDomainCenter = (domain.x[0] + domain.x[1]) / 2,\n        yDomainCenter = (domain.y[0] + domain.y[1]) / 2,\n        xDomain = domain.x[1] - domain.x[0],\n        yDomain = domain.y[1] - domain.y[0],\n        wmax = xDomain * graphSize.w,\n        hmax = yDomain * graphSize.h,\n        sum = ternaryLayout.sum,\n        amin = ternaryLayout.aaxis.min,\n        bmin = ternaryLayout.baxis.min,\n        cmin = ternaryLayout.caxis.min;\n\n    var x0, y0, w, h, xDomainFinal, yDomainFinal;\n\n    if(wmax > w_over_h * hmax) {\n        h = hmax;\n        w = h * w_over_h;\n    }\n    else {\n        w = wmax;\n        h = w / w_over_h;\n    }\n\n    xDomainFinal = xDomain * w / wmax;\n    yDomainFinal = yDomain * h / hmax;\n\n    x0 = graphSize.l + graphSize.w * xDomainCenter - w / 2;\n    y0 = graphSize.t + graphSize.h * (1 - yDomainCenter) - h / 2;\n\n    _this.x0 = x0;\n    _this.y0 = y0;\n    _this.w = w;\n    _this.h = h;\n    _this.sum = sum;\n\n    // set up the x and y axis objects we'll use to lay out the points\n    _this.xaxis = {\n        type: 'linear',\n        range: [amin + 2 * cmin - sum, sum - amin - 2 * bmin],\n        domain: [\n            xDomainCenter - xDomainFinal / 2,\n            xDomainCenter + xDomainFinal / 2\n        ],\n        _id: 'x'\n    };\n    setConvert(_this.xaxis, _this.graphDiv._fullLayout);\n    _this.xaxis.setScale();\n\n    _this.yaxis = {\n        type: 'linear',\n        range: [amin, sum - bmin - cmin],\n        domain: [\n            yDomainCenter - yDomainFinal / 2,\n            yDomainCenter + yDomainFinal / 2\n        ],\n        _id: 'y'\n    };\n    setConvert(_this.yaxis, _this.graphDiv._fullLayout);\n    _this.yaxis.setScale();\n\n    // set up the modified axes for tick drawing\n    var yDomain0 = _this.yaxis.domain[0];\n\n    // aaxis goes up the left side. Set it up as a y axis, but with\n    // fictitious angles and domain, but then rotate and translate\n    // it into place at the end\n    var aaxis = _this.aaxis = extendFlat({}, ternaryLayout.aaxis, {\n        visible: true,\n        range: [amin, sum - bmin - cmin],\n        side: 'left',\n        _counterangle: 30,\n        // tickangle = 'auto' means 0 anyway for a y axis, need to coerce to 0 here\n        // so we can shift by 30.\n        tickangle: (+ternaryLayout.aaxis.tickangle || 0) - 30,\n        domain: [yDomain0, yDomain0 + yDomainFinal * w_over_h],\n        _axislayer: _this.layers.aaxis,\n        _gridlayer: _this.layers.agrid,\n        _pos: 0, // _this.xaxis.domain[0] * graphSize.w,\n        _id: 'y',\n        _length: w,\n        _gridpath: 'M0,0l' + h + ',-' + (w / 2)\n    });\n    setConvert(aaxis, _this.graphDiv._fullLayout);\n    aaxis.setScale();\n\n    // baxis goes across the bottom (backward). We can set it up as an x axis\n    // without any enclosing transformation.\n    var baxis = _this.baxis = extendFlat({}, ternaryLayout.baxis, {\n        visible: true,\n        range: [sum - amin - cmin, bmin],\n        side: 'bottom',\n        _counterangle: 30,\n        domain: _this.xaxis.domain,\n        _axislayer: _this.layers.baxis,\n        _gridlayer: _this.layers.bgrid,\n        _counteraxis: _this.aaxis,\n        _pos: 0, // (1 - yDomain0) * graphSize.h,\n        _id: 'x',\n        _length: w,\n        _gridpath: 'M0,0l-' + (w / 2) + ',-' + h\n    });\n    setConvert(baxis, _this.graphDiv._fullLayout);\n    baxis.setScale();\n    aaxis._counteraxis = baxis;\n\n    // caxis goes down the right side. Set it up as a y axis, with\n    // post-transformation similar to aaxis\n    var caxis = _this.caxis = extendFlat({}, ternaryLayout.caxis, {\n        visible: true,\n        range: [sum - amin - bmin, cmin],\n        side: 'right',\n        _counterangle: 30,\n        tickangle: (+ternaryLayout.caxis.tickangle || 0) + 30,\n        domain: [yDomain0, yDomain0 + yDomainFinal * w_over_h],\n        _axislayer: _this.layers.caxis,\n        _gridlayer: _this.layers.cgrid,\n        _counteraxis: _this.baxis,\n        _pos: 0, // _this.xaxis.domain[1] * graphSize.w,\n        _id: 'y',\n        _length: w,\n        _gridpath: 'M0,0l-' + h + ',' + (w / 2)\n    });\n    setConvert(caxis, _this.graphDiv._fullLayout);\n    caxis.setScale();\n\n    var triangleClip = 'M' + x0 + ',' + (y0 + h) + 'h' + w + 'l-' + (w / 2) + ',-' + h + 'Z';\n    _this.clipDef.select('path').attr('d', triangleClip);\n    _this.layers.plotbg.select('path').attr('d', triangleClip);\n\n    var plotTransform = 'translate(' + x0 + ',' + y0 + ')';\n    _this.plotContainer.selectAll('.scatterlayer,.maplayer,.zoom')\n        .attr('transform', plotTransform);\n\n    // TODO: shift axes to accommodate linewidth*sin(30) tick mark angle\n\n    var bTransform = 'translate(' + x0 + ',' + (y0 + h) + ')';\n\n    _this.layers.baxis.attr('transform', bTransform);\n    _this.layers.bgrid.attr('transform', bTransform);\n\n    var aTransform = 'translate(' + (x0 + w / 2) + ',' + y0 + ')rotate(30)';\n    _this.layers.aaxis.attr('transform', aTransform);\n    _this.layers.agrid.attr('transform', aTransform);\n\n    var cTransform = 'translate(' + (x0 + w / 2) + ',' + y0 + ')rotate(-30)';\n    _this.layers.caxis.attr('transform', cTransform);\n    _this.layers.cgrid.attr('transform', cTransform);\n\n    _this.drawAxes(true);\n\n    // remove crispEdges - all the off-square angles in ternary plots\n    // make these counterproductive.\n    _this.plotContainer.selectAll('.crisp').classed('crisp', false);\n\n    var axlines = _this.layers.axlines;\n    axlines.select('.aline')\n        .attr('d', aaxis.showline ?\n            'M' + x0 + ',' + (y0 + h) + 'l' + (w / 2) + ',-' + h : 'M0,0')\n        .call(Color.stroke, aaxis.linecolor || '#000')\n        .style('stroke-width', (aaxis.linewidth || 0) + 'px');\n    axlines.select('.bline')\n        .attr('d', baxis.showline ?\n            'M' + x0 + ',' + (y0 + h) + 'h' + w : 'M0,0')\n        .call(Color.stroke, baxis.linecolor || '#000')\n        .style('stroke-width', (baxis.linewidth || 0) + 'px');\n    axlines.select('.cline')\n        .attr('d', caxis.showline ?\n            'M' + (x0 + w / 2) + ',' + y0 + 'l' + (w / 2) + ',' + h : 'M0,0')\n        .call(Color.stroke, caxis.linecolor || '#000')\n        .style('stroke-width', (caxis.linewidth || 0) + 'px');\n};\n\nproto.drawAxes = function(doTitles) {\n    var _this = this,\n        gd = _this.graphDiv,\n        titlesuffix = _this.id.substr(7) + 'title',\n        aaxis = _this.aaxis,\n        baxis = _this.baxis,\n        caxis = _this.caxis;\n    // 3rd arg true below skips titles, so we can configure them\n    // correctly later on.\n    Axes.doTicks(gd, aaxis, true);\n    Axes.doTicks(gd, baxis, true);\n    Axes.doTicks(gd, caxis, true);\n\n    if(doTitles) {\n        var apad = Math.max(aaxis.showticklabels ? aaxis.tickfont.size / 2 : 0,\n            (caxis.showticklabels ? caxis.tickfont.size * 0.75 : 0) +\n            (caxis.ticks === 'outside' ? caxis.ticklen * 0.87 : 0));\n        Titles.draw(gd, 'a' + titlesuffix, {\n            propContainer: aaxis,\n            propName: _this.id + '.aaxis.title',\n            dfltName: 'Component A',\n            attributes: {\n                x: _this.x0 + _this.w / 2,\n                y: _this.y0 - aaxis.titlefont.size / 3 - apad,\n                'text-anchor': 'middle'\n            }\n        });\n\n        var bpad = (baxis.showticklabels ? baxis.tickfont.size : 0) +\n            (baxis.ticks === 'outside' ? baxis.ticklen : 0) + 3;\n\n        Titles.draw(gd, 'b' + titlesuffix, {\n            propContainer: baxis,\n            propName: _this.id + '.baxis.title',\n            dfltName: 'Component B',\n            attributes: {\n                x: _this.x0 - bpad,\n                y: _this.y0 + _this.h + baxis.titlefont.size * 0.83 + bpad,\n                'text-anchor': 'middle'\n            }\n        });\n\n        Titles.draw(gd, 'c' + titlesuffix, {\n            propContainer: caxis,\n            propName: _this.id + '.caxis.title',\n            dfltName: 'Component C',\n            attributes: {\n                x: _this.x0 + _this.w + bpad,\n                y: _this.y0 + _this.h + caxis.titlefont.size * 0.83 + bpad,\n                'text-anchor': 'middle'\n            }\n        });\n    }\n};\n\n// hard coded paths for zoom corners\n// uses the same sizing as cartesian, length is MINZOOM/2, width is 3px\nvar CLEN = constants.MINZOOM / 2 + 0.87;\nvar BLPATH = 'm-0.87,.5h' + CLEN + 'v3h-' + (CLEN + 5.2) +\n    'l' + (CLEN / 2 + 2.6) + ',-' + (CLEN * 0.87 + 4.5) +\n    'l2.6,1.5l-' + (CLEN / 2) + ',' + (CLEN * 0.87) + 'Z';\nvar BRPATH = 'm0.87,.5h-' + CLEN + 'v3h' + (CLEN + 5.2) +\n    'l-' + (CLEN / 2 + 2.6) + ',-' + (CLEN * 0.87 + 4.5) +\n    'l-2.6,1.5l' + (CLEN / 2) + ',' + (CLEN * 0.87) + 'Z';\nvar TOPPATH = 'm0,1l' + (CLEN / 2) + ',' + (CLEN * 0.87) +\n    'l2.6,-1.5l-' + (CLEN / 2 + 2.6) + ',-' + (CLEN * 0.87 + 4.5) +\n    'l-' + (CLEN / 2 + 2.6) + ',' + (CLEN * 0.87 + 4.5) +\n    'l2.6,1.5l' + (CLEN / 2) + ',-' + (CLEN * 0.87) + 'Z';\nvar STARTMARKER = 'm0.5,0.5h5v-2h-5v-5h-2v5h-5v2h5v5h2Z';\n\n// I guess this could be shared with cartesian... but for now it's separate.\nvar SHOWZOOMOUTTIP = true;\n\nproto.initInteractions = function() {\n    var _this = this,\n        dragger = _this.layers.plotbg.select('path').node(),\n        gd = _this.graphDiv,\n        zoomContainer = _this.layers.zoom;\n\n    // use plotbg for the main interactions\n    var dragOptions = {\n        element: dragger,\n        gd: gd,\n        plotinfo: {plot: zoomContainer},\n        doubleclick: doubleClick,\n        subplot: _this.id,\n        prepFn: function(e, startX, startY) {\n            // these aren't available yet when initInteractions\n            // is called\n            dragOptions.xaxes = [_this.xaxis];\n            dragOptions.yaxes = [_this.yaxis];\n            var dragModeNow = gd._fullLayout.dragmode;\n            if(e.shiftKey) {\n                if(dragModeNow === 'pan') dragModeNow = 'zoom';\n                else dragModeNow = 'pan';\n            }\n\n            if(dragModeNow === 'lasso') dragOptions.minDrag = 1;\n            else dragOptions.minDrag = undefined;\n\n            if(dragModeNow === 'zoom') {\n                dragOptions.moveFn = zoomMove;\n                dragOptions.doneFn = zoomDone;\n                zoomPrep(e, startX, startY);\n            }\n            else if(dragModeNow === 'pan') {\n                dragOptions.moveFn = plotDrag;\n                dragOptions.doneFn = dragDone;\n                panPrep();\n                clearSelect();\n            }\n            else if(dragModeNow === 'select' || dragModeNow === 'lasso') {\n                prepSelect(e, startX, startY, dragOptions, dragModeNow);\n            }\n        }\n    };\n\n    var x0, y0, mins0, span0, mins, lum, path0, dimmed, zb, corners;\n\n    function zoomPrep(e, startX, startY) {\n        var dragBBox = dragger.getBoundingClientRect();\n        x0 = startX - dragBBox.left;\n        y0 = startY - dragBBox.top;\n        mins0 = {\n            a: _this.aaxis.range[0],\n            b: _this.baxis.range[1],\n            c: _this.caxis.range[1]\n        };\n        mins = mins0;\n        span0 = _this.aaxis.range[1] - mins0.a;\n        lum = tinycolor(_this.graphDiv._fullLayout[_this.id].bgcolor).getLuminance();\n        path0 = 'M0,' + _this.h + 'L' + (_this.w / 2) + ', 0L' + _this.w + ',' + _this.h + 'Z';\n        dimmed = false;\n\n        zb = zoomContainer.append('path')\n            .attr('class', 'zoombox')\n            .style({\n                'fill': lum > 0.2 ? 'rgba(0,0,0,0)' : 'rgba(255,255,255,0)',\n                'stroke-width': 0\n            })\n            .attr('d', path0);\n\n        corners = zoomContainer.append('path')\n            .attr('class', 'zoombox-corners')\n            .style({\n                fill: Color.background,\n                stroke: Color.defaultLine,\n                'stroke-width': 1,\n                opacity: 0\n            })\n            .attr('d', 'M0,0Z');\n\n        clearSelect();\n    }\n\n    function getAFrac(x, y) { return 1 - (y / _this.h); }\n    function getBFrac(x, y) { return 1 - ((x + (_this.h - y) / Math.sqrt(3)) / _this.w); }\n    function getCFrac(x, y) { return ((x - (_this.h - y) / Math.sqrt(3)) / _this.w); }\n\n    function zoomMove(dx0, dy0) {\n        var x1 = x0 + dx0,\n            y1 = y0 + dy0,\n            afrac = Math.max(0, Math.min(1, getAFrac(x0, y0), getAFrac(x1, y1))),\n            bfrac = Math.max(0, Math.min(1, getBFrac(x0, y0), getBFrac(x1, y1))),\n            cfrac = Math.max(0, Math.min(1, getCFrac(x0, y0), getCFrac(x1, y1))),\n            xLeft = ((afrac / 2) + cfrac) * _this.w,\n            xRight = (1 - (afrac / 2) - bfrac) * _this.w,\n            xCenter = (xLeft + xRight) / 2,\n            xSpan = xRight - xLeft,\n            yBottom = (1 - afrac) * _this.h,\n            yTop = yBottom - xSpan / w_over_h;\n\n        if(xSpan < constants.MINZOOM) {\n            mins = mins0;\n            zb.attr('d', path0);\n            corners.attr('d', 'M0,0Z');\n        }\n        else {\n            mins = {\n                a: mins0.a + afrac * span0,\n                b: mins0.b + bfrac * span0,\n                c: mins0.c + cfrac * span0\n            };\n            zb.attr('d', path0 + 'M' + xLeft + ',' + yBottom +\n                'H' + xRight + 'L' + xCenter + ',' + yTop +\n                'L' + xLeft + ',' + yBottom + 'Z');\n            corners.attr('d', 'M' + x0 + ',' + y0 + STARTMARKER +\n                'M' + xLeft + ',' + yBottom + BLPATH +\n                'M' + xRight + ',' + yBottom + BRPATH +\n                'M' + xCenter + ',' + yTop + TOPPATH);\n        }\n\n        if(!dimmed) {\n            zb.transition()\n                .style('fill', lum > 0.2 ? 'rgba(0,0,0,0.4)' :\n                    'rgba(255,255,255,0.3)')\n                .duration(200);\n            corners.transition()\n                .style('opacity', 1)\n                .duration(200);\n            dimmed = true;\n        }\n    }\n\n    function zoomDone(dragged, numClicks) {\n        if(mins === mins0) {\n            if(numClicks === 2) doubleClick();\n\n            return removeZoombox(gd);\n        }\n\n        removeZoombox(gd);\n\n        var attrs = {};\n        attrs[_this.id + '.aaxis.min'] = mins.a;\n        attrs[_this.id + '.baxis.min'] = mins.b;\n        attrs[_this.id + '.caxis.min'] = mins.c;\n\n        Plotly.relayout(gd, attrs);\n\n        if(SHOWZOOMOUTTIP && gd.data && gd._context.showTips) {\n            Lib.notifier('Double-click to<br>zoom back out', 'long');\n            SHOWZOOMOUTTIP = false;\n        }\n    }\n\n    function panPrep() {\n        mins0 = {\n            a: _this.aaxis.range[0],\n            b: _this.baxis.range[1],\n            c: _this.caxis.range[1]\n        };\n        mins = mins0;\n    }\n\n    function plotDrag(dx, dy) {\n        var dxScaled = dx / _this.xaxis._m,\n            dyScaled = dy / _this.yaxis._m;\n        mins = {\n            a: mins0.a - dyScaled,\n            b: mins0.b + (dxScaled + dyScaled) / 2,\n            c: mins0.c - (dxScaled - dyScaled) / 2\n        };\n        var minsorted = [mins.a, mins.b, mins.c].sort(),\n            minindices = {\n                a: minsorted.indexOf(mins.a),\n                b: minsorted.indexOf(mins.b),\n                c: minsorted.indexOf(mins.c)\n            };\n        if(minsorted[0] < 0) {\n            if(minsorted[1] + minsorted[0] / 2 < 0) {\n                minsorted[2] += minsorted[0] + minsorted[1];\n                minsorted[0] = minsorted[1] = 0;\n            }\n            else {\n                minsorted[2] += minsorted[0] / 2;\n                minsorted[1] += minsorted[0] / 2;\n                minsorted[0] = 0;\n            }\n            mins = {\n                a: minsorted[minindices.a],\n                b: minsorted[minindices.b],\n                c: minsorted[minindices.c]\n            };\n            dy = (mins0.a - mins.a) * _this.yaxis._m;\n            dx = (mins0.c - mins.c - mins0.b + mins.b) * _this.xaxis._m;\n        }\n\n        // move the data (translate, don't redraw)\n        var plotTransform = 'translate(' + (_this.x0 + dx) + ',' + (_this.y0 + dy) + ')';\n        _this.plotContainer.selectAll('.scatterlayer,.maplayer')\n            .attr('transform', plotTransform);\n\n        // move the ticks\n        _this.aaxis.range = [mins.a, _this.sum - mins.b - mins.c];\n        _this.baxis.range = [_this.sum - mins.a - mins.c, mins.b];\n        _this.caxis.range = [_this.sum - mins.a - mins.b, mins.c];\n\n        _this.drawAxes(false);\n        _this.plotContainer.selectAll('.crisp').classed('crisp', false);\n    }\n\n    function dragDone(dragged, numClicks) {\n        if(dragged) {\n            var attrs = {};\n            attrs[_this.id + '.aaxis.min'] = mins.a;\n            attrs[_this.id + '.baxis.min'] = mins.b;\n            attrs[_this.id + '.caxis.min'] = mins.c;\n\n            Plotly.relayout(gd, attrs);\n        }\n        else if(numClicks === 2) doubleClick();\n    }\n\n    function clearSelect() {\n        // until we get around to persistent selections, remove the outline\n        // here. The selection itself will be removed when the plot redraws\n        // at the end.\n        _this.plotContainer.selectAll('.select-outline').remove();\n    }\n\n    function doubleClick() {\n        var attrs = {};\n        attrs[_this.id + '.aaxis.min'] = 0;\n        attrs[_this.id + '.baxis.min'] = 0;\n        attrs[_this.id + '.caxis.min'] = 0;\n        gd.emit('plotly_doubleclick', null);\n        Plotly.relayout(gd, attrs);\n    }\n\n    // finally, set up hover and click\n    // these event handlers must already be set before dragElement.init\n    // so it can stash them and override them.\n    dragger.onmousemove = function(evt) {\n        fx.hover(gd, evt, _this.id);\n        gd._fullLayout._lasthover = dragger;\n        gd._fullLayout._hoversubplot = _this.id;\n    };\n\n    dragger.onmouseout = function(evt) {\n        if(gd._dragging) return;\n\n        dragElement.unhover(gd, evt);\n    };\n\n    dragger.onclick = function(evt) {\n        fx.click(gd, evt);\n    };\n\n    dragElement.init(dragOptions);\n};\n\nfunction removeZoombox(gd) {\n    d3.select(gd)\n        .selectAll('.zoombox,.js-zoombox-backdrop,.js-zoombox-menu,.zoombox-corners')\n        .remove();\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/bar/arrays_to_calcdata.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar mergeArray = require('../../lib').mergeArray;\n\n\n// arrayOk attributes, merge them into calcdata array\nmodule.exports = function arraysToCalcdata(cd, trace) {\n    mergeArray(trace.text, cd, 'tx');\n    mergeArray(trace.hovertext, cd, 'htx');\n\n    var marker = trace.marker;\n    if(marker) {\n        mergeArray(marker.opacity, cd, 'mo');\n        mergeArray(marker.color, cd, 'mc');\n\n        var markerLine = marker.line;\n        if(markerLine) {\n            mergeArray(markerLine.color, cd, 'mlc');\n            mergeArray(markerLine.width, cd, 'mlw');\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/bar/hover.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Fx = require('../../plots/cartesian/graph_interact');\nvar ErrorBars = require('../../components/errorbars');\nvar Color = require('../../components/color');\n\n\nmodule.exports = function hoverPoints(pointData, xval, yval, hovermode) {\n    var cd = pointData.cd;\n    var trace = cd[0].trace;\n    var t = cd[0].t;\n    var xa = pointData.xa;\n    var ya = pointData.ya;\n\n    var posVal, thisBarMinPos, thisBarMaxPos, minPos, maxPos, dx, dy;\n\n    var positionFn = function(di) {\n        return Fx.inbox(minPos(di) - posVal, maxPos(di) - posVal);\n    };\n\n    if(trace.orientation === 'h') {\n        posVal = yval;\n        thisBarMinPos = function(di) { return di.y - di.w / 2; };\n        thisBarMaxPos = function(di) { return di.y + di.w / 2; };\n        dx = function(di) {\n            // add a gradient so hovering near the end of a\n            // bar makes it a little closer match\n            return Fx.inbox(di.b - xval, di.x - xval) + (di.x - xval) / (di.x - di.b);\n        };\n        dy = positionFn;\n    }\n    else {\n        posVal = xval;\n        thisBarMinPos = function(di) { return di.x - di.w / 2; };\n        thisBarMaxPos = function(di) { return di.x + di.w / 2; };\n        dy = function(di) {\n            return Fx.inbox(di.b - yval, di.y - yval) + (di.y - yval) / (di.y - di.b);\n        };\n        dx = positionFn;\n    }\n\n    minPos = (hovermode === 'closest') ?\n        thisBarMinPos :\n        function(di) {\n            /*\n             * In compare mode, accept a bar if you're on it *or* its group.\n             * Nearly always it's the group that matters, but in case the bar\n             * was explicitly set wider than its group we'd better accept the\n             * whole bar.\n             */\n            return Math.min(thisBarMinPos(di), di.p - t.bargroupwidth / 2);\n        };\n\n    maxPos = (hovermode === 'closest') ?\n        thisBarMaxPos :\n        function(di) {\n            return Math.max(thisBarMaxPos(di), di.p + t.bargroupwidth / 2);\n        };\n\n    var distfn = Fx.getDistanceFunction(hovermode, dx, dy);\n    Fx.getClosest(cd, distfn, pointData);\n\n    // skip the rest (for this trace) if we didn't find a close point\n    if(pointData.index === false) return;\n\n    // the closest data point\n    var index = pointData.index,\n        di = cd[index],\n        mc = di.mcc || trace.marker.color,\n        mlc = di.mlcc || trace.marker.line.color,\n        mlw = di.mlw || trace.marker.line.width;\n    if(Color.opacity(mc)) pointData.color = mc;\n    else if(Color.opacity(mlc) && mlw) pointData.color = mlc;\n\n    var size = (trace.base) ? di.b + di.s : di.s;\n    if(trace.orientation === 'h') {\n        pointData.x0 = pointData.x1 = xa.c2p(di.x, true);\n        pointData.xLabelVal = size;\n\n        pointData.y0 = ya.c2p(minPos(di), true);\n        pointData.y1 = ya.c2p(maxPos(di), true);\n        pointData.yLabelVal = di.p;\n    }\n    else {\n        pointData.y0 = pointData.y1 = ya.c2p(di.y, true);\n        pointData.yLabelVal = size;\n\n        pointData.x0 = xa.c2p(minPos(di), true);\n        pointData.x1 = xa.c2p(maxPos(di), true);\n        pointData.xLabelVal = di.p;\n    }\n\n    if(di.htx) pointData.text = di.htx;\n    else if(trace.hovertext) pointData.text = trace.hovertext;\n    else if(di.tx) pointData.text = di.tx;\n    else if(trace.text) pointData.text = trace.text;\n\n    ErrorBars.hoverInfo(di, trace, pointData);\n\n    return [pointData];\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/bar/set_positions.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nvar Registry = require('../../registry');\nvar Axes = require('../../plots/cartesian/axes');\nvar Sieve = require('./sieve.js');\n\n/*\n * Bar chart stacking/grouping positioning and autoscaling calculations\n * for each direction separately calculate the ranges and positions\n * note that this handles histograms too\n * now doing this one subplot at a time\n */\n\nmodule.exports = function setPositions(gd, plotinfo) {\n    var xa = plotinfo.xaxis,\n        ya = plotinfo.yaxis;\n\n    var fullTraces = gd._fullData,\n        calcTraces = gd.calcdata,\n        calcTracesHorizontal = [],\n        calcTracesVertical = [],\n        i;\n    for(i = 0; i < fullTraces.length; i++) {\n        var fullTrace = fullTraces[i];\n        if(\n            fullTrace.visible === true &&\n            Registry.traceIs(fullTrace, 'bar') &&\n            fullTrace.xaxis === xa._id &&\n            fullTrace.yaxis === ya._id\n        ) {\n            if(fullTrace.orientation === 'h') {\n                calcTracesHorizontal.push(calcTraces[i]);\n            }\n            else {\n                calcTracesVertical.push(calcTraces[i]);\n            }\n        }\n    }\n\n    setGroupPositions(gd, xa, ya, calcTracesVertical);\n    setGroupPositions(gd, ya, xa, calcTracesHorizontal);\n};\n\n\nfunction setGroupPositions(gd, pa, sa, calcTraces) {\n    if(!calcTraces.length) return;\n\n    var barmode = gd._fullLayout.barmode,\n        overlay = (barmode === 'overlay'),\n        group = (barmode === 'group'),\n        excluded,\n        included,\n        i, calcTrace, fullTrace;\n\n    if(overlay) {\n        setGroupPositionsInOverlayMode(gd, pa, sa, calcTraces);\n    }\n    else if(group) {\n        // exclude from the group those traces for which the user set an offset\n        excluded = [];\n        included = [];\n        for(i = 0; i < calcTraces.length; i++) {\n            calcTrace = calcTraces[i];\n            fullTrace = calcTrace[0].trace;\n\n            if(fullTrace.offset === undefined) included.push(calcTrace);\n            else excluded.push(calcTrace);\n        }\n\n        if(included.length) {\n            setGroupPositionsInGroupMode(gd, pa, sa, included);\n        }\n        if(excluded.length) {\n            setGroupPositionsInOverlayMode(gd, pa, sa, excluded);\n        }\n    }\n    else {\n        // exclude from the stack those traces for which the user set a base\n        excluded = [];\n        included = [];\n        for(i = 0; i < calcTraces.length; i++) {\n            calcTrace = calcTraces[i];\n            fullTrace = calcTrace[0].trace;\n\n            if(fullTrace.base === undefined) included.push(calcTrace);\n            else excluded.push(calcTrace);\n        }\n\n        if(included.length) {\n            setGroupPositionsInStackOrRelativeMode(gd, pa, sa, included);\n        }\n        if(excluded.length) {\n            setGroupPositionsInOverlayMode(gd, pa, sa, excluded);\n        }\n    }\n}\n\n\nfunction setGroupPositionsInOverlayMode(gd, pa, sa, calcTraces) {\n    var barnorm = gd._fullLayout.barnorm,\n        separateNegativeValues = false,\n        dontMergeOverlappingData = !barnorm;\n\n    // update position axis and set bar offsets and widths\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n\n        var sieve = new Sieve(\n            [calcTrace], separateNegativeValues, dontMergeOverlappingData\n        );\n\n        // set bar offsets and widths, and update position axis\n        setOffsetAndWidth(gd, pa, sieve);\n\n        // set bar bases and sizes, and update size axis\n        //\n        // (note that `setGroupPositionsInOverlayMode` handles the case barnorm\n        // is defined, because this function is also invoked for traces that\n        // can't be grouped or stacked)\n        if(barnorm) {\n            sieveBars(gd, sa, sieve);\n            normalizeBars(gd, sa, sieve);\n        }\n        else {\n            setBaseAndTop(gd, sa, sieve);\n        }\n    }\n}\n\n\nfunction setGroupPositionsInGroupMode(gd, pa, sa, calcTraces) {\n    var fullLayout = gd._fullLayout,\n        barnorm = fullLayout.barnorm,\n        separateNegativeValues = false,\n        dontMergeOverlappingData = !barnorm,\n        sieve = new Sieve(\n                calcTraces, separateNegativeValues, dontMergeOverlappingData\n            );\n\n    // set bar offsets and widths, and update position axis\n    setOffsetAndWidthInGroupMode(gd, pa, sieve);\n\n    // set bar bases and sizes, and update size axis\n    if(barnorm) {\n        sieveBars(gd, sa, sieve);\n        normalizeBars(gd, sa, sieve);\n    }\n    else {\n        setBaseAndTop(gd, sa, sieve);\n    }\n}\n\n\nfunction setGroupPositionsInStackOrRelativeMode(gd, pa, sa, calcTraces) {\n    var fullLayout = gd._fullLayout,\n        barmode = fullLayout.barmode,\n        stack = (barmode === 'stack'),\n        relative = (barmode === 'relative'),\n        barnorm = gd._fullLayout.barnorm,\n        separateNegativeValues = relative,\n        dontMergeOverlappingData = !(barnorm || stack || relative),\n        sieve = new Sieve(\n                calcTraces, separateNegativeValues, dontMergeOverlappingData\n            );\n\n    // set bar offsets and widths, and update position axis\n    setOffsetAndWidth(gd, pa, sieve);\n\n    // set bar bases and sizes, and update size axis\n    stackBars(gd, sa, sieve);\n\n    // flag the outmost bar (for text display purposes)\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n\n        for(var j = 0; j < calcTrace.length; j++) {\n            var bar = calcTrace[j];\n\n            if(bar.s === BADNUM) continue;\n\n            var isOutmostBar = ((bar.b + bar.s) === sieve.get(bar.p, bar.s));\n            if(isOutmostBar) bar._outmost = true;\n        }\n    }\n\n    // Note that marking the outmost bars has to be done\n    // before `normalizeBars` changes `bar.b` and `bar.s`.\n    if(barnorm) normalizeBars(gd, sa, sieve);\n}\n\n\nfunction setOffsetAndWidth(gd, pa, sieve) {\n    var fullLayout = gd._fullLayout,\n        bargap = fullLayout.bargap,\n        bargroupgap = fullLayout.bargroupgap,\n        minDiff = sieve.minDiff,\n        calcTraces = sieve.traces,\n        i, calcTrace, calcTrace0,\n        t;\n\n    // set bar offsets and widths\n    var barGroupWidth = minDiff * (1 - bargap),\n        barWidthPlusGap = barGroupWidth,\n        barWidth = barWidthPlusGap * (1 - bargroupgap);\n\n    // computer bar group center and bar offset\n    var offsetFromCenter = -barWidth / 2;\n\n    for(i = 0; i < calcTraces.length; i++) {\n        calcTrace = calcTraces[i];\n        calcTrace0 = calcTrace[0];\n\n        // store bar width and offset for this trace\n        t = calcTrace0.t;\n        t.barwidth = barWidth;\n        t.poffset = offsetFromCenter;\n        t.bargroupwidth = barGroupWidth;\n    }\n\n    // stack bars that only differ by rounding\n    sieve.binWidth = calcTraces[0][0].t.barwidth / 100;\n\n    // if defined, apply trace offset and width\n    applyAttributes(sieve);\n\n    // store the bar center in each calcdata item\n    setBarCenterAndWidth(gd, pa, sieve);\n\n    // update position axes\n    updatePositionAxis(gd, pa, sieve);\n}\n\n\nfunction setOffsetAndWidthInGroupMode(gd, pa, sieve) {\n    var fullLayout = gd._fullLayout,\n        bargap = fullLayout.bargap,\n        bargroupgap = fullLayout.bargroupgap,\n        positions = sieve.positions,\n        distinctPositions = sieve.distinctPositions,\n        minDiff = sieve.minDiff,\n        calcTraces = sieve.traces,\n        i, calcTrace, calcTrace0,\n        t;\n\n    // if there aren't any overlapping positions,\n    // let them have full width even if mode is group\n    var overlap = (positions.length !== distinctPositions.length);\n\n    var nTraces = calcTraces.length,\n        barGroupWidth = minDiff * (1 - bargap),\n        barWidthPlusGap = (overlap) ? barGroupWidth / nTraces : barGroupWidth,\n        barWidth = barWidthPlusGap * (1 - bargroupgap);\n\n    for(i = 0; i < nTraces; i++) {\n        calcTrace = calcTraces[i];\n        calcTrace0 = calcTrace[0];\n\n        // computer bar group center and bar offset\n        var offsetFromCenter = (overlap) ?\n                ((2 * i + 1 - nTraces) * barWidthPlusGap - barWidth) / 2 :\n                -barWidth / 2;\n\n        // store bar width and offset for this trace\n        t = calcTrace0.t;\n        t.barwidth = barWidth;\n        t.poffset = offsetFromCenter;\n        t.bargroupwidth = barGroupWidth;\n    }\n\n    // stack bars that only differ by rounding\n    sieve.binWidth = calcTraces[0][0].t.barwidth / 100;\n\n    // if defined, apply trace width\n    applyAttributes(sieve);\n\n    // store the bar center in each calcdata item\n    setBarCenterAndWidth(gd, pa, sieve);\n\n    // update position axes\n    updatePositionAxis(gd, pa, sieve, overlap);\n}\n\n\nfunction applyAttributes(sieve) {\n    var calcTraces = sieve.traces,\n        i, calcTrace, calcTrace0, fullTrace,\n        j,\n        t;\n\n    for(i = 0; i < calcTraces.length; i++) {\n        calcTrace = calcTraces[i];\n        calcTrace0 = calcTrace[0];\n        fullTrace = calcTrace0.trace;\n        t = calcTrace0.t;\n\n        var offset = fullTrace.offset,\n            initialPoffset = t.poffset,\n            newPoffset;\n\n        if(Array.isArray(offset)) {\n            // if offset is an array, then clone it into t.poffset.\n            newPoffset = offset.slice(0, calcTrace.length);\n\n            // guard against non-numeric items\n            for(j = 0; j < newPoffset.length; j++) {\n                if(!isNumeric(newPoffset[j])) {\n                    newPoffset[j] = initialPoffset;\n                }\n            }\n\n            // if the length of the array is too short,\n            // then extend it with the initial value of t.poffset\n            for(j = newPoffset.length; j < calcTrace.length; j++) {\n                newPoffset.push(initialPoffset);\n            }\n\n            t.poffset = newPoffset;\n        }\n        else if(offset !== undefined) {\n            t.poffset = offset;\n        }\n\n        var width = fullTrace.width,\n            initialBarwidth = t.barwidth;\n\n        if(Array.isArray(width)) {\n            // if width is an array, then clone it into t.barwidth.\n            var newBarwidth = width.slice(0, calcTrace.length);\n\n            // guard against non-numeric items\n            for(j = 0; j < newBarwidth.length; j++) {\n                if(!isNumeric(newBarwidth[j])) newBarwidth[j] = initialBarwidth;\n            }\n\n            // if the length of the array is too short,\n            // then extend it with the initial value of t.barwidth\n            for(j = newBarwidth.length; j < calcTrace.length; j++) {\n                newBarwidth.push(initialBarwidth);\n            }\n\n            t.barwidth = newBarwidth;\n\n            // if user didn't set offset,\n            // then correct t.poffset to ensure bars remain centered\n            if(offset === undefined) {\n                newPoffset = [];\n                for(j = 0; j < calcTrace.length; j++) {\n                    newPoffset.push(\n                        initialPoffset + (initialBarwidth - newBarwidth[j]) / 2\n                    );\n                }\n                t.poffset = newPoffset;\n            }\n        }\n        else if(width !== undefined) {\n            t.barwidth = width;\n\n            // if user didn't set offset,\n            // then correct t.poffset to ensure bars remain centered\n            if(offset === undefined) {\n                t.poffset = initialPoffset + (initialBarwidth - width) / 2;\n            }\n        }\n    }\n}\n\n\nfunction setBarCenterAndWidth(gd, pa, sieve) {\n    var calcTraces = sieve.traces,\n        pLetter = getAxisLetter(pa);\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i],\n            t = calcTrace[0].t,\n            poffset = t.poffset,\n            poffsetIsArray = Array.isArray(poffset),\n            barwidth = t.barwidth,\n            barwidthIsArray = Array.isArray(barwidth);\n\n        for(var j = 0; j < calcTrace.length; j++) {\n            var calcBar = calcTrace[j];\n\n            // store the actual bar width and position, for use by hover\n            var width = calcBar.w = (barwidthIsArray) ? barwidth[j] : barwidth;\n            calcBar[pLetter] = calcBar.p +\n                ((poffsetIsArray) ? poffset[j] : poffset) +\n                width / 2;\n\n\n        }\n    }\n}\n\n\nfunction updatePositionAxis(gd, pa, sieve, allowMinDtick) {\n    var calcTraces = sieve.traces,\n        distinctPositions = sieve.distinctPositions,\n        distinctPositions0 = distinctPositions[0],\n        minDiff = sieve.minDiff,\n        vpad = minDiff / 2;\n\n    Axes.minDtick(pa, minDiff, distinctPositions0, allowMinDtick);\n\n    // If the user set the bar width or the offset,\n    // then bars can be shifted away from their positions\n    // and widths can be larger than minDiff.\n    //\n    // Here, we compute pMin and pMax to expand the position axis,\n    // so that all bars are fully within the axis range.\n    var pMin = Math.min.apply(Math, distinctPositions) - vpad,\n        pMax = Math.max.apply(Math, distinctPositions) + vpad;\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i],\n            calcTrace0 = calcTrace[0],\n            fullTrace = calcTrace0.trace;\n\n        if(fullTrace.width === undefined && fullTrace.offset === undefined) {\n            continue;\n        }\n\n        var t = calcTrace0.t,\n            poffset = t.poffset,\n            barwidth = t.barwidth,\n            poffsetIsArray = Array.isArray(poffset),\n            barwidthIsArray = Array.isArray(barwidth);\n\n        for(var j = 0; j < calcTrace.length; j++) {\n            var calcBar = calcTrace[j],\n                calcBarOffset = (poffsetIsArray) ? poffset[j] : poffset,\n                calcBarWidth = (barwidthIsArray) ? barwidth[j] : barwidth,\n                p = calcBar.p,\n                l = p + calcBarOffset,\n                r = l + calcBarWidth;\n\n            pMin = Math.min(pMin, l);\n            pMax = Math.max(pMax, r);\n        }\n    }\n\n    Axes.expand(pa, [pMin, pMax], {padded: false});\n}\n\nfunction expandRange(range, newValue) {\n    if(isNumeric(range[0])) range[0] = Math.min(range[0], newValue);\n    else range[0] = newValue;\n\n    if(isNumeric(range[1])) range[1] = Math.max(range[1], newValue);\n    else range[1] = newValue;\n}\n\nfunction setBaseAndTop(gd, sa, sieve) {\n    // store these bar bases and tops in calcdata\n    // and make sure the size axis includes zero,\n    // along with the bases and tops of each bar.\n    var traces = sieve.traces,\n        sLetter = getAxisLetter(sa),\n        s0 = sa.l2c(sa.c2l(0)),\n        sRange = [s0, s0];\n\n    for(var i = 0; i < traces.length; i++) {\n        var trace = traces[i];\n\n        for(var j = 0; j < trace.length; j++) {\n            var bar = trace[j],\n                barBase = bar.b,\n                barTop = barBase + bar.s;\n\n            bar[sLetter] = barTop;\n\n            if(isNumeric(sa.c2l(barTop))) expandRange(sRange, barTop);\n            if(isNumeric(sa.c2l(barBase))) expandRange(sRange, barBase);\n        }\n    }\n\n    Axes.expand(sa, sRange, {tozero: true, padded: true});\n}\n\n\nfunction stackBars(gd, sa, sieve) {\n    var fullLayout = gd._fullLayout,\n        barnorm = fullLayout.barnorm,\n        sLetter = getAxisLetter(sa),\n        traces = sieve.traces,\n        i, trace,\n        j, bar;\n\n    var s0 = sa.l2c(sa.c2l(0)),\n        sRange = [s0, s0];\n\n    for(i = 0; i < traces.length; i++) {\n        trace = traces[i];\n\n        for(j = 0; j < trace.length; j++) {\n            bar = trace[j];\n\n            if(bar.s === BADNUM) continue;\n\n            // stack current bar and get previous sum\n            var barBase = sieve.put(bar.p, bar.b + bar.s),\n                barTop = barBase + bar.b + bar.s;\n\n            // store the bar base and top in each calcdata item\n            bar.b = barBase;\n            bar[sLetter] = barTop;\n\n            if(!barnorm) {\n                if(isNumeric(sa.c2l(barTop))) expandRange(sRange, barTop);\n                if(isNumeric(sa.c2l(barBase))) expandRange(sRange, barBase);\n            }\n        }\n    }\n\n    // if barnorm is set, let normalizeBars update the axis range\n    if(!barnorm) Axes.expand(sa, sRange, {tozero: true, padded: true});\n}\n\n\nfunction sieveBars(gd, sa, sieve) {\n    var traces = sieve.traces;\n\n    for(var i = 0; i < traces.length; i++) {\n        var trace = traces[i];\n\n        for(var j = 0; j < trace.length; j++) {\n            var bar = trace[j];\n\n            if(bar.s !== BADNUM) sieve.put(bar.p, bar.b + bar.s);\n        }\n    }\n}\n\n\nfunction normalizeBars(gd, sa, sieve) {\n    // Note:\n    //\n    // normalizeBars requires that either sieveBars or stackBars has been\n    // previously invoked.\n\n    var traces = sieve.traces,\n        sLetter = getAxisLetter(sa),\n        sTop = (gd._fullLayout.barnorm === 'fraction') ? 1 : 100,\n        sTiny = sTop / 1e9, // in case of rounding error in sum\n        sMin = sa.l2c(sa.c2l(0)),\n        sMax = (gd._fullLayout.barmode === 'stack') ? sTop : sMin,\n        sRange = [sMin, sMax],\n        padded = false;\n\n    function maybeExpand(newValue) {\n        if(isNumeric(sa.c2l(newValue)) &&\n            ((newValue < sMin - sTiny) || (newValue > sMax + sTiny) || !isNumeric(sMin))\n        ) {\n            padded = true;\n            expandRange(sRange, newValue);\n        }\n    }\n\n    for(var i = 0; i < traces.length; i++) {\n        var trace = traces[i];\n\n        for(var j = 0; j < trace.length; j++) {\n            var bar = trace[j];\n\n            if(bar.s === BADNUM) continue;\n\n            var scale = Math.abs(sTop / sieve.get(bar.p, bar.s));\n            bar.b *= scale;\n            bar.s *= scale;\n\n            var barBase = bar.b,\n                barTop = barBase + bar.s;\n            bar[sLetter] = barTop;\n\n            maybeExpand(barTop);\n            maybeExpand(barBase);\n        }\n    }\n\n    // update range of size axis\n    Axes.expand(sa, sRange, {tozero: true, padded: padded});\n}\n\n\nfunction getAxisLetter(ax) {\n    return ax._id.charAt(0);\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/bar/sieve.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = Sieve;\n\nvar Lib = require('../../lib');\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\n/**\n * Helper class to sieve data from traces into bins\n *\n * @class\n * @param {Array}   traces\n *                  Array of calculated traces\n * @param {boolean} [separateNegativeValues]\n *                  If true, then split data at the same position into a bar\n *                  for positive values and another for negative values\n * @param {boolean} [dontMergeOverlappingData]\n *                  If true, then don't merge overlapping bars into a single bar\n */\nfunction Sieve(traces, separateNegativeValues, dontMergeOverlappingData) {\n    this.traces = traces;\n    this.separateNegativeValues = separateNegativeValues;\n    this.dontMergeOverlappingData = dontMergeOverlappingData;\n\n    var positions = [];\n    for(var i = 0; i < traces.length; i++) {\n        var trace = traces[i];\n        for(var j = 0; j < trace.length; j++) {\n            var bar = trace[j];\n            if(bar.p !== BADNUM) positions.push(bar.p);\n        }\n    }\n    this.positions = positions;\n\n    var dv = Lib.distinctVals(this.positions);\n    this.distinctPositions = dv.vals;\n    this.minDiff = dv.minDiff;\n\n    this.binWidth = this.minDiff;\n\n    this.bins = {};\n}\n\n/**\n * Sieve datum\n *\n * @method\n * @param {number} position\n * @param {number} value\n * @returns {number} Previous bin value\n */\nSieve.prototype.put = function put(position, value) {\n    var label = this.getLabel(position, value),\n        oldValue = this.bins[label] || 0;\n\n    this.bins[label] = oldValue + value;\n\n    return oldValue;\n};\n\n/**\n * Get current bin value for a given datum\n *\n * @method\n * @param {number} position  Position of datum\n * @param {number} [value]   Value of datum\n *                           (required if this.separateNegativeValues is true)\n * @returns {number} Current bin value\n */\nSieve.prototype.get = function put(position, value) {\n    var label = this.getLabel(position, value);\n    return this.bins[label] || 0;\n};\n\n/**\n * Get bin label for a given datum\n *\n * @method\n * @param {number} position  Position of datum\n * @param {number} [value]   Value of datum\n *                           (required if this.separateNegativeValues is true)\n * @returns {string} Bin label\n * (prefixed with a 'v' if value is negative and this.separateNegativeValues is\n * true; otherwise prefixed with '^')\n */\nSieve.prototype.getLabel = function getLabel(position, value) {\n    var prefix = (value < 0 && this.separateNegativeValues) ? 'v' : '^',\n        label = (this.dontMergeOverlappingData) ?\n            position :\n            Math.round(position / this.binWidth);\n    return prefix + label;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/bar/style_defaults.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Color = require('../../components/color');\nvar hasColorscale = require('../../components/colorscale/has_colorscale');\nvar colorscaleDefaults = require('../../components/colorscale/defaults');\n\n\nmodule.exports = function handleStyleDefaults(traceIn, traceOut, coerce, defaultColor, layout) {\n    coerce('marker.color', defaultColor);\n\n    if(hasColorscale(traceIn, 'marker')) {\n        colorscaleDefaults(\n            traceIn, traceOut, layout, coerce, {prefix: 'marker.', cLetter: 'c'}\n        );\n    }\n\n    coerce('marker.line.color', Color.defaultLine);\n\n    if(hasColorscale(traceIn, 'marker.line')) {\n        colorscaleDefaults(\n            traceIn, traceOut, layout, coerce, {prefix: 'marker.line.', cLetter: 'c'}\n        );\n    }\n\n    coerce('marker.line.width');\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/candlestick/transform.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar helpers = require('../ohlc/helpers');\n\nexports.moduleType = 'transform';\n\nexports.name = 'candlestick';\n\nexports.attributes = {};\n\nexports.supplyDefaults = function(transformIn, traceOut, layout, traceIn) {\n    helpers.clearEphemeralTransformOpts(traceIn);\n    helpers.copyOHLC(transformIn, traceOut);\n\n    return transformIn;\n};\n\nexports.transform = function transform(dataIn, state) {\n    var dataOut = [];\n\n    for(var i = 0; i < dataIn.length; i++) {\n        var traceIn = dataIn[i];\n\n        if(traceIn.type !== 'candlestick') {\n            dataOut.push(traceIn);\n            continue;\n        }\n\n        dataOut.push(\n            makeTrace(traceIn, state, 'increasing'),\n            makeTrace(traceIn, state, 'decreasing')\n        );\n    }\n\n    helpers.addRangeSlider(dataOut, state.layout);\n\n    return dataOut;\n};\n\nfunction makeTrace(traceIn, state, direction) {\n    var traceOut = {\n        type: 'box',\n        boxpoints: false,\n\n        visible: traceIn.visible,\n        hoverinfo: traceIn.hoverinfo,\n        opacity: traceIn.opacity,\n        xaxis: traceIn.xaxis,\n        yaxis: traceIn.yaxis,\n\n        transforms: helpers.makeTransform(traceIn, state, direction)\n    };\n\n    // the rest of below may not have been coerced\n\n    var directionOpts = traceIn[direction];\n\n    if(directionOpts) {\n        Lib.extendFlat(traceOut, {\n\n            // to make autotype catch date axes soon!!\n            x: traceIn.x || [0],\n            xcalendar: traceIn.xcalendar,\n\n            // concat low and high to get correct autorange\n            y: [].concat(traceIn.low).concat(traceIn.high),\n\n            whiskerwidth: traceIn.whiskerwidth,\n            text: traceIn.text,\n\n            name: directionOpts.name,\n            showlegend: directionOpts.showlegend,\n            line: directionOpts.line,\n            fillcolor: directionOpts.fillcolor\n        });\n    }\n\n    return traceOut;\n}\n\nexports.calcTransform = function calcTransform(gd, trace, opts) {\n    var direction = opts.direction,\n        filterFn = helpers.getFilterFn(direction);\n\n    var open = trace.open,\n        high = trace.high,\n        low = trace.low,\n        close = trace.close;\n\n    var len = open.length,\n        x = [],\n        y = [];\n\n    var appendX = trace._fullInput.x ?\n        function(i) {\n            var v = trace.x[i];\n            x.push(v, v, v, v, v, v);\n        } :\n        function(i) {\n            x.push(i, i, i, i, i, i);\n        };\n\n    var appendY = function(o, h, l, c) {\n        y.push(l, o, c, c, c, h);\n    };\n\n    for(var i = 0; i < len; i++) {\n        if(filterFn(open[i], close[i])) {\n            appendX(i);\n            appendY(open[i], high[i], low[i], close[i]);\n        }\n    }\n\n    trace.x = x;\n    trace.y = y;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/ohlc/helpers.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Lib = require('../../lib');\n\n// This routine gets called during the trace supply-defaults step.\n//\n// This is a hacky way to make 'ohlc' and 'candlestick' trace types\n// go through the transform machinery.\n//\n// Note that, we must mutate user data (here traceIn) as opposed\n// to full data (here traceOut) as - at the moment - transform\n// defaults (which are called after trace defaults) start\n// from a clear transforms container. The mutations inflicted are\n// cleared in exports.clearEphemeralTransformOpts.\nexports.pushDummyTransformOpts = function(traceIn, traceOut) {\n    var transformOpts = {\n\n        // give dummy transform the same type as trace\n        type: traceOut.type,\n\n        // track ephemeral transforms in user data\n        _ephemeral: true\n    };\n\n    if(Array.isArray(traceIn.transforms)) {\n        traceIn.transforms.push(transformOpts);\n    }\n    else {\n        traceIn.transforms = [transformOpts];\n    }\n};\n\n// This routine gets called during the transform supply-defaults step\n// where it clears ephemeral transform opts in user data\n// and effectively put back user date in its pre-supplyDefaults state.\nexports.clearEphemeralTransformOpts = function(traceIn) {\n    var transformsIn = traceIn.transforms;\n\n    if(!Array.isArray(transformsIn)) return;\n\n    for(var i = 0; i < transformsIn.length; i++) {\n        if(transformsIn[i]._ephemeral) transformsIn.splice(i, 1);\n    }\n\n    if(transformsIn.length === 0) delete traceIn.transforms;\n};\n\n// This routine gets called during the transform supply-defaults step\n// where it passes 'ohlc' and 'candlestick' attributes\n// (found the transform container via exports.makeTransform)\n// to the traceOut container such that they can\n// be compatible with filter and groupby transforms.\n//\n// Note that this routine only has an effect during the\n// second round of transform defaults done on generated traces\nexports.copyOHLC = function(container, traceOut) {\n    if(container.open) traceOut.open = container.open;\n    if(container.high) traceOut.high = container.high;\n    if(container.low) traceOut.low = container.low;\n    if(container.close) traceOut.close = container.close;\n};\n\n// This routine gets called during the applyTransform step.\n//\n// We need to track trace attributes and which direction\n// ('increasing' or 'decreasing')\n// the generated correspond to for the calcTransform step.\n//\n// To make sure that the attributes reach the calcTransform,\n// store it in the transform opts object.\nexports.makeTransform = function(traceIn, state, direction) {\n    var out = Lib.extendFlat([], traceIn.transforms);\n\n    out[state.transformIndex] = {\n        type: traceIn.type,\n        direction: direction,\n\n        // these are copied to traceOut during exports.copyOHLC\n        open: traceIn.open,\n        high: traceIn.high,\n        low: traceIn.low,\n        close: traceIn.close\n    };\n\n    return out;\n};\n\nexports.getFilterFn = function(direction) {\n    switch(direction) {\n        case 'increasing':\n            return function(o, c) { return o <= c; };\n\n        case 'decreasing':\n            return function(o, c) { return o > c; };\n    }\n};\n\nexports.addRangeSlider = function(data, layout) {\n    var hasOneVisibleTrace = false;\n\n    for(var i = 0; i < data.length; i++) {\n        if(data[i].visible === true) {\n            hasOneVisibleTrace = true;\n            break;\n        }\n    }\n\n    if(hasOneVisibleTrace) {\n        if(!layout.xaxis) layout.xaxis = {};\n        if(!layout.xaxis.rangeslider) layout.xaxis.rangeslider = {};\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/carpet/axis_aligned_line.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n/* This function retrns a set of control points that define a curve aligned along\n * either the a or b axis. Exactly one of a or b must be an array defining the range\n * spanned.\n *\n * Honestly this is the most complicated function I've implemente here so far because\n * of the way it handles knot insertion and direction/axis-agnostic slices.\n */\nmodule.exports = function(carpet, carpetcd, a, b) {\n    var idx, tangent, tanIsoIdx, tanIsoPar, segment, refidx;\n    var p0, p1, v0, v1, start, end, range;\n\n    var axis = Array.isArray(a) ? 'a' : 'b';\n    var ax = axis === 'a' ? carpet.aaxis : carpet.baxis;\n    var smoothing = ax.smoothing;\n    var toIdx = axis === 'a' ? carpet.a2i : carpet.b2j;\n    var pt = axis === 'a' ? a : b;\n    var iso = axis === 'a' ? b : a;\n    var n = axis === 'a' ? carpetcd.a.length : carpetcd.b.length;\n    var m = axis === 'a' ? carpetcd.b.length : carpetcd.a.length;\n    var isoIdx = Math.floor(axis === 'a' ? carpet.b2j(iso) : carpet.a2i(iso));\n\n    var xy = axis === 'a' ? function(value) {\n        return carpet.evalxy([], value, isoIdx);\n    } : function(value) {\n        return carpet.evalxy([], isoIdx, value);\n    };\n\n    if(smoothing) {\n        tanIsoIdx = Math.max(0, Math.min(m - 2, isoIdx));\n        tanIsoPar = isoIdx - tanIsoIdx;\n        tangent = axis === 'a' ? function(i, ti) {\n            return carpet.dxydi([], i, tanIsoIdx, ti, tanIsoPar);\n        } : function(j, tj) {\n            return carpet.dxydj([], tanIsoIdx, j, tanIsoPar, tj);\n        };\n    }\n\n    var vstart = toIdx(pt[0]);\n    var vend = toIdx(pt[1]);\n\n    // So that we can make this work in two directions, flip all of the\n    // math functions if the direction is from higher to lower indices:\n    //\n    // Note that the tolerance is directional!\n    var dir = vstart < vend ? 1 : -1;\n    var tol = (vend - vstart) * 1e-8;\n    var dirfloor = dir > 0 ? Math.floor : Math.ceil;\n    var dirceil = dir > 0 ? Math.ceil : Math.floor;\n    var dirmin = dir > 0 ? Math.min : Math.max;\n    var dirmax = dir > 0 ? Math.max : Math.min;\n\n    var idx0 = dirfloor(vstart + tol);\n    var idx1 = dirceil(vend - tol);\n\n    p0 = xy(vstart);\n    var segments = [[p0]];\n\n    for(idx = idx0; idx * dir < idx1 * dir; idx += dir) {\n        segment = [];\n        start = dirmax(vstart, idx);\n        end = dirmin(vend, idx + dir);\n        range = end - start;\n\n        // In order to figure out which cell we're in for the derivative (remember,\n        // the derivatives are *not* constant across grid lines), let's just average\n        // the start and end points. This cuts out just a tiny bit of logic and\n        // there's really no computational difference:\n        refidx = Math.max(0, Math.min(n - 2, Math.floor(0.5 * (start + end))));\n\n        p1 = xy(end);\n        if(smoothing) {\n            v0 = tangent(refidx, start - refidx);\n            v1 = tangent(refidx, end - refidx);\n\n            segment.push([\n                p0[0] + v0[0] / 3 * range,\n                p0[1] + v0[1] / 3 * range\n            ]);\n\n            segment.push([\n                p1[0] - v1[0] / 3 * range,\n                p1[1] - v1[1] / 3 * range\n            ]);\n        }\n\n        segment.push(p1);\n\n        segments.push(segment);\n        p0 = p1;\n    }\n\n    return segments;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/carpet/lookup_carpetid.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n/*\n * Given a trace, look up the carpet axis by carpet.\n */\nmodule.exports = function(gd, trace) {\n    var n = gd._fullData.length;\n    var firstAxis;\n    for(var i = 0; i < n; i++) {\n        var maybeCarpet = gd._fullData[i];\n\n        if(maybeCarpet.index === trace.index) continue;\n\n        if(maybeCarpet.type === 'carpet') {\n            if(!firstAxis) {\n                firstAxis = maybeCarpet;\n            }\n\n            if(maybeCarpet.carpet === trace.carpet) {\n                return maybeCarpet;\n            }\n        }\n    }\n\n    return firstAxis;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/carpet/smooth_fill_array.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n/*\n * Fill in a 1D array via linear interpolation. This *is* the basis, so we\n * don't have to scale this by some basis as we do for the 2D version. That\n * makes this much simpler. Just loop over it and do the best we can to fill\n * the array.\n */\nmodule.exports = function smoothFillArray(data) {\n    var i, i0, i1;\n    var n = data.length;\n\n    for(i = 0; i < n; i++) {\n        if(data[i] !== undefined) {\n            i0 = i;\n            break;\n        }\n    }\n\n    for(i = n - 1; i >= 0; i--) {\n        if(data[i] !== undefined) {\n            i1 = i;\n            break;\n        }\n    }\n\n    if(i0 === undefined) {\n        // Fill with zeros and return early;\n        for(i = 0; i < n; i++) {\n            data[i] = 0;\n        }\n\n        return data;\n    } else if(i0 === i1) {\n        // Only one data point so can't extrapolate. Fill with it and return early:\n        for(i = 0; i < n; i++) {\n            data[i] = data[i0];\n        }\n\n        return data;\n    }\n\n    var iA = i0;\n    var iB;\n    var m, b, dA, dB;\n\n    // Fill in interior data. When we land on an undefined point,\n    // look ahead until the next defined point and then fill in linearly:\n    for(i = i0; i < i1; i++) {\n        if(data[i] === undefined) {\n            iA = iB = i;\n            while(iB < i1 && data[iB] === undefined) iB++;\n\n            dA = data[iA - 1];\n            dB = data[iB];\n\n            // Lots of variables, but it's just mx + b:\n            m = (dB - dA) / (iB - iA + 1);\n            b = dA + (1 - iA) * m;\n\n            // Note that this *does* increment the outer loop counter. Worried a linter\n            // might complain, but it's the whole point in this case:\n            for(i = iA; i < iB; i++) {\n                data[i] = m * i + b;\n            }\n\n            i = iA = iB;\n        }\n    }\n\n    // Fill in up to the first data point:\n    if(i0 > 0) {\n        m = data[i0 + 1] - data[i0];\n        b = data[i0];\n        for(i = 0; i < i0; i++) {\n            data[i] = m * (i - i0) + b;\n        }\n    }\n\n    // Fill in after the last data point:\n    if(i1 < n - 1) {\n        m = data[i1] - data[i1 - 1];\n        b = data[i1];\n        for(i = i1 + 1; i < n; i++) {\n            data[i] = m * (i - i1) + b;\n        }\n    }\n\n    return data;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/choropleth/event_data.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nmodule.exports = function eventData(out, pt) {\n    out.location = pt.location;\n    out.z = pt.z;\n\n    return out;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/contourcarpet/close_boundaries.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = function(pathinfo, operation, perimeter, trace) {\n    // Abandon all hope, ye who enter here.\n    var i, v1, v2;\n    var na = trace.a.length;\n    var nb = trace.b.length;\n    var z = trace.z;\n\n    var boundaryMax = -Infinity;\n    var boundaryMin = Infinity;\n\n    for(i = 0; i < nb; i++) {\n        boundaryMin = Math.min(boundaryMin, z[i][0]);\n        boundaryMin = Math.min(boundaryMin, z[i][na - 1]);\n        boundaryMax = Math.max(boundaryMax, z[i][0]);\n        boundaryMax = Math.max(boundaryMax, z[i][na - 1]);\n    }\n\n    for(i = 1; i < na - 1; i++) {\n        boundaryMin = Math.min(boundaryMin, z[0][i]);\n        boundaryMin = Math.min(boundaryMin, z[nb - 1][i]);\n        boundaryMax = Math.max(boundaryMax, z[0][i]);\n        boundaryMax = Math.max(boundaryMax, z[nb - 1][i]);\n    }\n\n    switch(operation) {\n        case '>':\n        case '>=':\n            if(trace.contours.value > boundaryMax) {\n                pathinfo[0].prefixBoundary = true;\n            }\n            break;\n        case '<':\n        case '<=':\n            if(trace.contours.value < boundaryMin) {\n                pathinfo[0].prefixBoundary = true;\n            }\n            break;\n        case '[]':\n        case '()':\n            v1 = Math.min.apply(null, trace.contours.value);\n            v2 = Math.max.apply(null, trace.contours.value);\n            if(v2 < boundaryMin) {\n                pathinfo[0].prefixBoundary = true;\n            }\n            if(v1 > boundaryMax) {\n                pathinfo[0].prefixBoundary = true;\n            }\n            break;\n        case '][':\n        case ')(':\n            v1 = Math.min.apply(null, trace.contours.value);\n            v2 = Math.max.apply(null, trace.contours.value);\n            if(v1 < boundaryMin && v2 > boundaryMax) {\n                pathinfo[0].prefixBoundary = true;\n            }\n            break;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/contourcarpet/constraint_mapping.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar constants = require('./constants');\nvar isNumeric = require('fast-isnumeric');\n\n// This syntax conforms to the existing filter transform syntax, but we don't care\n// about open vs. closed intervals for simply drawing contours constraints:\nmodule.exports['[]'] = makeRangeSettings('[]');\nmodule.exports['()'] = makeRangeSettings('()');\nmodule.exports['[)'] = makeRangeSettings('[)');\nmodule.exports['(]'] = makeRangeSettings('(]');\n\n// Inverted intervals simply flip the sign:\nmodule.exports[']['] = makeRangeSettings('][');\nmodule.exports[')('] = makeRangeSettings(')(');\nmodule.exports[')['] = makeRangeSettings(')[');\nmodule.exports[']('] = makeRangeSettings('](');\n\nmodule.exports['>'] = makeInequalitySettings('>');\nmodule.exports['>='] = makeInequalitySettings('>=');\nmodule.exports['<'] = makeInequalitySettings('<');\nmodule.exports['<='] = makeInequalitySettings('<=');\nmodule.exports['='] = makeInequalitySettings('=');\n\n// This does not in any way shape or form support calendars. It's adapted from\n// transforms/filter.js.\nfunction coerceValue(operation, value) {\n    var hasArrayValue = Array.isArray(value);\n\n    var coercedValue;\n\n    function coerce(value) {\n        return isNumeric(value) ? (+value) : null;\n    }\n\n    if(constants.INEQUALITY_OPS.indexOf(operation) !== -1) {\n        coercedValue = hasArrayValue ? coerce(value[0]) : coerce(value);\n    } else if(constants.INTERVAL_OPS.indexOf(operation) !== -1) {\n        coercedValue = hasArrayValue ?\n            [coerce(value[0]), coerce(value[1])] :\n            [coerce(value), coerce(value)];\n    } else if(constants.SET_OPS.indexOf(operation) !== -1) {\n        coercedValue = hasArrayValue ? value.map(coerce) : [coerce(value)];\n    }\n\n    return coercedValue;\n}\n\n// Returns a parabola scaled so that the min/max is either +/- 1 and zero at the two values\n// provided. The data is mapped by this function when constructing intervals so that it's\n// very easy to construct contours as normal.\nfunction makeRangeSettings(operation) {\n    return function(value) {\n        value = coerceValue(operation, value);\n\n        // Ensure proper ordering:\n        var min = Math.min(value[0], value[1]);\n        var max = Math.max(value[0], value[1]);\n\n        return {\n            start: min,\n            end: max,\n            size: max - min\n        };\n    };\n}\n\nfunction makeInequalitySettings(operation) {\n    return function(value) {\n        value = coerceValue(operation, value);\n\n        return {\n            start: value,\n            end: Infinity,\n            size: Infinity\n        };\n    };\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/contourcarpet/constants.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = {\n    INEQUALITY_OPS: ['=', '<', '>=', '>', '<='],\n    INTERVAL_OPS: ['[]', '()', '[)', '(]', '][', ')(', '](', ')['],\n    SET_OPS: ['{}', '}{']\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/contourcarpet/constraint_value_defaults.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar constraintMapping = require('./constraint_mapping');\nvar isNumeric = require('fast-isnumeric');\n\nmodule.exports = function(coerce, contours) {\n    var zvalue;\n    var scalarValuedOps = ['=', '<', '<=', '>', '>='];\n\n    if(scalarValuedOps.indexOf(contours.operation) === -1) {\n        // Requires an array of two numbers:\n        coerce('contours.value', [0, 1]);\n\n        if(!Array.isArray(contours.value)) {\n            if(isNumeric(contours.value)) {\n                zvalue = parseFloat(contours.value);\n                contours.value = [zvalue, zvalue + 1];\n            }\n        } else if(contours.value.length > 2) {\n            contours.value = contours.value.slice(2);\n        } else if(contours.length === 0) {\n            contours.value = [0, 1];\n        } else if(contours.length < 2) {\n            zvalue = parseFloat(contours.value[0]);\n            contours.value = [zvalue, zvalue + 1];\n        } else {\n            contours.value = [\n                parseFloat(contours.value[0]),\n                parseFloat(contours.value[1])\n            ];\n        }\n    } else {\n        // Requires a single scalar:\n        coerce('contours.value', 0);\n\n        if(!isNumeric(contours.value)) {\n            if(Array.isArray(contours.value)) {\n                contours.value = parseFloat(contours.value[0]);\n            } else {\n                contours.value = 0;\n            }\n        }\n    }\n\n    var map = constraintMapping[contours.operation](contours.value);\n\n    contours.start = map.start;\n    contours.end = map.end;\n    contours.size = map.size;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/contourcarpet/convert_to_constraints.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\n\n// The contour extraction is great, except it totally fails for constraints because we\n// need weird range loops and flipped contours instead of the usual format. This function\n// does some weird manipulation of the extracted pathinfo data such that it magically\n// draws contours correctly *as* constraints.\nmodule.exports = function(pathinfo, operation) {\n    var i, pi0, pi1;\n\n    var op0 = function(arr) { return arr.reverse(); };\n    var op1 = function(arr) { return arr; };\n\n    switch(operation) {\n        case '][':\n        case ')[':\n        case '](':\n        case ')(':\n            var tmp = op0;\n            op0 = op1;\n            op1 = tmp;\n            // It's a nice rule, except this definitely *is* what's intended here.\n            /* eslint-disable: no-fallthrough */\n        case '[]':\n        case '[)':\n        case '(]':\n        case '()':\n            /* eslint-enable: no-fallthrough */\n            if(pathinfo.length !== 2) {\n                Lib.warn('Contour data invalid for the specified inequality range operation.');\n                return;\n            }\n\n            // In this case there should be exactly two contour levels in pathinfo. We\n            // simply concatenate the info into one pathinfo and flip all of the data\n            // in one. This will draw the contour as closed.\n            pi0 = pathinfo[0];\n            pi1 = pathinfo[1];\n\n            for(i = 0; i < pi0.edgepaths.length; i++) {\n                pi0.edgepaths[i] = op0(pi0.edgepaths[i]);\n            }\n\n            for(i = 0; i < pi0.paths.length; i++) {\n                pi0.paths[i] = op0(pi0.paths[i]);\n            }\n\n            while(pi1.edgepaths.length) {\n                pi0.edgepaths.push(op1(pi1.edgepaths.shift()));\n            }\n            while(pi1.paths.length) {\n                pi0.paths.push(op1(pi1.paths.shift()));\n            }\n            pathinfo.pop();\n\n            break;\n        case '>=':\n        case '>':\n            if(pathinfo.length !== 1) {\n                Lib.warn('Contour data invalid for the specified inequality operation.');\n                return;\n            }\n\n            // In this case there should be exactly two contour levels in pathinfo. We\n            // simply concatenate the info into one pathinfo and flip all of the data\n            // in one. This will draw the contour as closed.\n            pi0 = pathinfo[0];\n\n            for(i = 0; i < pi0.edgepaths.length; i++) {\n                pi0.edgepaths[i] = op0(pi0.edgepaths[i]);\n            }\n\n            for(i = 0; i < pi0.paths.length; i++) {\n                pi0.paths[i] = op0(pi0.paths[i]);\n            }\n            break;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/contourcarpet/empty_pathinfo.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\n\nmodule.exports = function emptyPathinfo(contours, plotinfo, cd0) {\n    var cs = contours.size;\n    var pathinfo = [];\n\n    var carpet = cd0.trace.carpetTrace;\n\n    for(var ci = contours.start; ci < contours.end + cs / 10; ci += cs) {\n        pathinfo.push({\n            level: ci,\n            // all the cells with nontrivial marching index\n            crossings: {},\n            // starting points on the edges of the lattice for each contour\n            starts: [],\n            // all unclosed paths (may have less items than starts,\n            // if a path is closed by rounding)\n            edgepaths: [],\n            // all closed paths\n            paths: [],\n            // store axes so we can convert to px\n            xaxis: carpet.aaxis,\n            yaxis: carpet.baxis,\n            // full data arrays to use for interpolation\n            x: cd0.a,\n            y: cd0.b,\n            z: cd0.z,\n            smoothing: cd0.trace.line.smoothing\n        });\n\n        if(pathinfo.length > 1000) {\n            Lib.warn('Too many contours, clipping at 1000', contours);\n            break;\n        }\n    }\n    return pathinfo;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/contourcarpet/join_all_paths.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Drawing = require('../../components/drawing');\nvar axisAlignedLine = require('../carpet/axis_aligned_line');\nvar Lib = require('../../lib');\n// var map1dArray = require('../carpet/map_1d_array');\n// var makepath = require('../carpet/makepath');\n\nmodule.exports = function joinAllPaths(trace, pi, perimeter, ab2p, carpet, carpetcd, xa, ya) {\n    var i;\n    var fullpath = '';\n\n    var startsleft = pi.edgepaths.map(function(v, i) { return i; });\n    var newloop = true;\n    var endpt, newendpt, cnt, nexti, possiblei, addpath;\n\n    var atol = Math.abs(perimeter[0][0] - perimeter[2][0]) * 1e-4;\n    var btol = Math.abs(perimeter[0][1] - perimeter[2][1]) * 1e-4;\n\n    function istop(pt) { return Math.abs(pt[1] - perimeter[0][1]) < btol; }\n    function isbottom(pt) { return Math.abs(pt[1] - perimeter[2][1]) < btol; }\n    function isleft(pt) { return Math.abs(pt[0] - perimeter[0][0]) < atol; }\n    function isright(pt) { return Math.abs(pt[0] - perimeter[2][0]) < atol; }\n\n    function pathto(pt0, pt1) {\n        var i, j, segments, axis;\n        var path = '';\n\n        if((istop(pt0) && !isright(pt0)) || (isbottom(pt0) && !isleft(pt0))) {\n            axis = carpet.aaxis;\n            segments = axisAlignedLine(carpet, carpetcd, [pt0[0], pt1[0]], 0.5 * (pt0[1] + pt1[1]));\n        } else {\n            axis = carpet.baxis;\n            segments = axisAlignedLine(carpet, carpetcd, 0.5 * (pt0[0] + pt1[0]), [pt0[1], pt1[1]]);\n        }\n\n        for(i = 1; i < segments.length; i++) {\n            path += axis.smoothing ? 'C' : 'L';\n            for(j = 0; j < segments[i].length; j++) {\n                var pt = segments[i][j];\n                path += [xa.c2p(pt[0]), ya.c2p(pt[1])] + ' ';\n            }\n        }\n\n        return path;\n    }\n\n    i = 0;\n    endpt = null;\n    while(startsleft.length) {\n        var startpt = pi.edgepaths[i][0];\n\n        if(endpt) {\n            fullpath += pathto(endpt, startpt);\n        }\n\n        addpath = Drawing.smoothopen(pi.edgepaths[i].map(ab2p), pi.smoothing);\n        fullpath += newloop ? addpath : addpath.replace(/^M/, 'L');\n        startsleft.splice(startsleft.indexOf(i), 1);\n        endpt = pi.edgepaths[i][pi.edgepaths[i].length - 1];\n        nexti = -1;\n\n        // now loop through sides, moving our endpoint until we find a new start\n        for(cnt = 0; cnt < 4; cnt++) { // just to prevent infinite loops\n            if(!endpt) {\n                Lib.log('Missing end?', i, pi);\n                break;\n            }\n\n            if(istop(endpt) && !isright(endpt)) {\n                newendpt = perimeter[1]; // left top ---> right top\n            } else if(isleft(endpt)) {\n                newendpt = perimeter[0]; // left bottom ---> left top\n            } else if(isbottom(endpt)) {\n                newendpt = perimeter[3]; // right bottom\n            } else if(isright(endpt)) {\n                newendpt = perimeter[2]; // left bottom\n            }\n\n            for(possiblei = 0; possiblei < pi.edgepaths.length; possiblei++) {\n                var ptNew = pi.edgepaths[possiblei][0];\n                // is ptNew on the (horz. or vert.) segment from endpt to newendpt?\n                if(Math.abs(endpt[0] - newendpt[0]) < atol) {\n                    if(Math.abs(endpt[0] - ptNew[0]) < atol && (ptNew[1] - endpt[1]) * (newendpt[1] - ptNew[1]) >= 0) {\n                        newendpt = ptNew;\n                        nexti = possiblei;\n                    }\n                } else if(Math.abs(endpt[1] - newendpt[1]) < btol) {\n                    if(Math.abs(endpt[1] - ptNew[1]) < btol && (ptNew[0] - endpt[0]) * (newendpt[0] - ptNew[0]) >= 0) {\n                        newendpt = ptNew;\n                        nexti = possiblei;\n                    }\n                } else {\n                    Lib.log('endpt to newendpt is not vert. or horz.', endpt, newendpt, ptNew);\n                }\n            }\n\n            if(nexti >= 0) break;\n            fullpath += pathto(endpt, newendpt);\n            endpt = newendpt;\n        }\n\n        if(nexti === pi.edgepaths.length) {\n            Lib.log('unclosed perimeter path');\n            break;\n        }\n\n        i = nexti;\n\n        // if we closed back on a loop we already included,\n        // close it and start a new loop\n        newloop = (startsleft.indexOf(i) === -1);\n        if(newloop) {\n            i = startsleft[0];\n            fullpath += pathto(endpt, newendpt) + 'Z';\n            endpt = null;\n        }\n    }\n\n    // finally add the interior paths\n    for(i = 0; i < pi.paths.length; i++) {\n        fullpath += Drawing.smoothclosed(pi.paths[i].map(ab2p), pi.smoothing);\n    }\n\n    return fullpath;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/contourcarpet/map_pathinfo.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = function mapPathinfo(pathinfo, map) {\n    var i, j, k, pi, pedgepaths, ppaths, pedgepath, ppath, path;\n\n    for(i = 0; i < pathinfo.length; i++) {\n        pi = pathinfo[i];\n        pedgepaths = pi.pedgepaths = [];\n        ppaths = pi.ppaths = [];\n        for(j = 0; j < pi.edgepaths.length; j++) {\n            path = pi.edgepaths[j];\n            pedgepath = [];\n            for(k = 0; k < path.length; k++) {\n                pedgepath[k] = map(path[k]);\n            }\n            pedgepaths.push(pedgepath);\n        }\n        for(j = 0; j < pi.paths.length; j++) {\n            path = pi.paths[j];\n            ppath = [];\n            for(k = 0; k < path.length; k++) {\n                ppath[k] = map(path[k]);\n            }\n            ppaths.push(ppath);\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/contour/colorbar.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Plots = require('../../plots/plots');\nvar drawColorbar = require('../../components/colorbar/draw');\n\nvar makeColorMap = require('./make_color_map');\nvar endPlus = require('./end_plus');\n\n\nmodule.exports = function colorbar(gd, cd) {\n    var trace = cd[0].trace,\n        cbId = 'cb' + trace.uid;\n\n    gd._fullLayout._infolayer.selectAll('.' + cbId).remove();\n\n    if(!trace.showscale) {\n        Plots.autoMargin(gd, cbId);\n        return;\n    }\n\n    var cb = drawColorbar(gd, cbId);\n    cd[0].t.cb = cb;\n\n    var contours = trace.contours,\n        line = trace.line,\n        cs = contours.size || 1,\n        coloring = contours.coloring;\n\n    var colorMap = makeColorMap(trace, {isColorbar: true});\n\n    if(coloring === 'heatmap') {\n        cb.filllevels({\n            start: trace.zmin,\n            end: trace.zmax,\n            size: (trace.zmax - trace.zmin) / 254\n        });\n    }\n\n    cb.fillcolor((coloring === 'fill' || coloring === 'heatmap') ? colorMap : '')\n        .line({\n            color: coloring === 'lines' ? colorMap : line.color,\n            width: contours.showlines !== false ? line.width : 0,\n            dash: line.dash\n        })\n        .levels({\n            start: contours.start,\n            end: endPlus(contours),\n            size: cs\n        })\n        .options(trace.colorbar)();\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/contour/make_color_map.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\nvar Colorscale = require('../../components/colorscale');\nvar endPlus = require('./end_plus');\n\nmodule.exports = function makeColorMap(trace) {\n    var contours = trace.contours,\n        start = contours.start,\n        end = endPlus(contours),\n        cs = contours.size || 1,\n        nc = Math.floor((end - start) / cs) + 1,\n        extra = contours.coloring === 'lines' ? 0 : 1;\n\n    if(!isFinite(cs)) {\n        cs = 1;\n        nc = 1;\n    }\n\n    var scl = trace.colorscale,\n        len = scl.length;\n\n    var domain = new Array(len),\n        range = new Array(len);\n\n    var si, i;\n\n    if(contours.coloring === 'heatmap') {\n        if(trace.zauto && trace.autocontour === false) {\n            trace.zmin = start - cs / 2;\n            trace.zmax = trace.zmin + nc * cs;\n        }\n\n        for(i = 0; i < len; i++) {\n            si = scl[i];\n\n            domain[i] = si[0] * (trace.zmax - trace.zmin) + trace.zmin;\n            range[i] = si[1];\n        }\n\n        // do the contours extend beyond the colorscale?\n        // if so, extend the colorscale with constants\n        var zRange = d3.extent([trace.zmin, trace.zmax, contours.start,\n                contours.start + cs * (nc - 1)]),\n            zmin = zRange[trace.zmin < trace.zmax ? 0 : 1],\n            zmax = zRange[trace.zmin < trace.zmax ? 1 : 0];\n\n        if(zmin !== trace.zmin) {\n            domain.splice(0, 0, zmin);\n            range.splice(0, 0, Range[0]);\n        }\n\n        if(zmax !== trace.zmax) {\n            domain.push(zmax);\n            range.push(range[range.length - 1]);\n        }\n    }\n    else {\n        for(i = 0; i < len; i++) {\n            si = scl[i];\n\n            domain[i] = (si[0] * (nc + extra - 1) - (extra / 2)) * cs + start;\n            range[i] = si[1];\n        }\n    }\n\n    return Colorscale.makeColorScaleFunc({\n        domain: domain,\n        range: range,\n    }, {\n        noNumericCheck: true\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/contour/end_plus.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\n/*\n * tiny helper to move the end of the contours a little to prevent\n * losing the last contour to rounding errors\n */\nmodule.exports = function endPlus(contours) {\n    return contours.end + contours.size / 1e6;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/contour/contours_defaults.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar attributes = require('./attributes');\n\nmodule.exports = function handleContourDefaults(traceIn, traceOut, coerce) {\n    var contourStart = Lib.coerce2(traceIn, traceOut, attributes, 'contours.start');\n    var contourEnd = Lib.coerce2(traceIn, traceOut, attributes, 'contours.end');\n    var missingEnd = (contourStart === false) || (contourEnd === false);\n\n    // normally we only need size if autocontour is off. But contour.calc\n    // pushes its calculated contour size back to the input trace, so for\n    // things like restyle that can call supplyDefaults without calc\n    // after the initial draw, we can just reuse the previous calculation\n    var contourSize = coerce('contours.size');\n    var autoContour;\n\n    if(missingEnd) autoContour = traceOut.autocontour = true;\n    else autoContour = coerce('autocontour', false);\n\n    if(autoContour || !contourSize) coerce('ncontours');\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/contour/find_all_paths.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar constants = require('./constants');\n\nmodule.exports = function findAllPaths(pathinfo, xtol, ytol) {\n    var cnt,\n        startLoc,\n        i,\n        pi,\n        j;\n\n    // Default just passes these values through as they were before:\n    xtol = xtol || 0.01;\n    ytol = ytol || 0.01;\n\n    for(i = 0; i < pathinfo.length; i++) {\n        pi = pathinfo[i];\n\n        for(j = 0; j < pi.starts.length; j++) {\n            startLoc = pi.starts[j];\n            makePath(pi, startLoc, 'edge', xtol, ytol);\n        }\n\n        cnt = 0;\n        while(Object.keys(pi.crossings).length && cnt < 10000) {\n            cnt++;\n            startLoc = Object.keys(pi.crossings)[0].split(',').map(Number);\n            makePath(pi, startLoc, undefined, xtol, ytol);\n        }\n        if(cnt === 10000) Lib.log('Infinite loop in contour?');\n    }\n};\n\nfunction equalPts(pt1, pt2, xtol, ytol) {\n    return Math.abs(pt1[0] - pt2[0]) < xtol &&\n           Math.abs(pt1[1] - pt2[1]) < ytol;\n}\n\nfunction ptDist(pt1, pt2) {\n    var dx = pt1[0] - pt2[0],\n        dy = pt1[1] - pt2[1];\n    return Math.sqrt(dx * dx + dy * dy);\n}\n\nfunction makePath(pi, loc, edgeflag, xtol, ytol) {\n    var startLocStr = loc.join(',');\n    var locStr = startLocStr;\n    var mi = pi.crossings[locStr];\n    var marchStep = startStep(mi, edgeflag, loc);\n    // start by going backward a half step and finding the crossing point\n    var pts = [getInterpPx(pi, loc, [-marchStep[0], -marchStep[1]])];\n    var startStepStr = marchStep.join(',');\n    var m = pi.z.length;\n    var n = pi.z[0].length;\n    var cnt;\n\n    // now follow the path\n    for(cnt = 0; cnt < 10000; cnt++) { // just to avoid infinite loops\n        if(mi > 20) {\n            mi = constants.CHOOSESADDLE[mi][(marchStep[0] || marchStep[1]) < 0 ? 0 : 1];\n            pi.crossings[locStr] = constants.SADDLEREMAINDER[mi];\n        }\n        else {\n            delete pi.crossings[locStr];\n        }\n\n        marchStep = constants.NEWDELTA[mi];\n        if(!marchStep) {\n            Lib.log('Found bad marching index:', mi, loc, pi.level);\n            break;\n        }\n\n        // find the crossing a half step forward, and then take the full step\n        pts.push(getInterpPx(pi, loc, marchStep));\n        loc[0] += marchStep[0];\n        loc[1] += marchStep[1];\n\n        // don't include the same point multiple times\n        if(equalPts(pts[pts.length - 1], pts[pts.length - 2], xtol, ytol)) pts.pop();\n        locStr = loc.join(',');\n\n        var atEdge = (marchStep[0] && (loc[0] < 0 || loc[0] > n - 2)) ||\n                (marchStep[1] && (loc[1] < 0 || loc[1] > m - 2)),\n            closedLoop = (locStr === startLocStr) && (marchStep.join(',') === startStepStr);\n\n        // have we completed a loop, or reached an edge?\n        if((closedLoop) || (edgeflag && atEdge)) break;\n\n        mi = pi.crossings[locStr];\n    }\n\n    if(cnt === 10000) {\n        Lib.log('Infinite loop in contour?');\n    }\n    var closedpath = equalPts(pts[0], pts[pts.length - 1], xtol, ytol),\n        totaldist = 0,\n        distThresholdFactor = 0.2 * pi.smoothing,\n        alldists = [],\n        cropstart = 0,\n        distgroup,\n        cnt2,\n        cnt3,\n        newpt,\n        ptcnt,\n        ptavg,\n        thisdist;\n\n    // check for points that are too close together (<1/5 the average dist,\n    // less if less smoothed) and just take the center (or avg of center 2)\n    // this cuts down on funny behavior when a point is very close to a contour level\n    for(cnt = 1; cnt < pts.length; cnt++) {\n        thisdist = ptDist(pts[cnt], pts[cnt - 1]);\n        totaldist += thisdist;\n        alldists.push(thisdist);\n    }\n\n    var distThreshold = totaldist / alldists.length * distThresholdFactor;\n\n    function getpt(i) { return pts[i % pts.length]; }\n\n    for(cnt = pts.length - 2; cnt >= cropstart; cnt--) {\n        distgroup = alldists[cnt];\n        if(distgroup < distThreshold) {\n            cnt3 = 0;\n            for(cnt2 = cnt - 1; cnt2 >= cropstart; cnt2--) {\n                if(distgroup + alldists[cnt2] < distThreshold) {\n                    distgroup += alldists[cnt2];\n                }\n                else break;\n            }\n\n            // closed path with close points wrapping around the boundary?\n            if(closedpath && cnt === pts.length - 2) {\n                for(cnt3 = 0; cnt3 < cnt2; cnt3++) {\n                    if(distgroup + alldists[cnt3] < distThreshold) {\n                        distgroup += alldists[cnt3];\n                    }\n                    else break;\n                }\n            }\n            ptcnt = cnt - cnt2 + cnt3 + 1;\n            ptavg = Math.floor((cnt + cnt2 + cnt3 + 2) / 2);\n\n            // either endpoint included: keep the endpoint\n            if(!closedpath && cnt === pts.length - 2) newpt = pts[pts.length - 1];\n            else if(!closedpath && cnt2 === -1) newpt = pts[0];\n\n            // odd # of points - just take the central one\n            else if(ptcnt % 2) newpt = getpt(ptavg);\n\n            // even # of pts - average central two\n            else {\n                newpt = [(getpt(ptavg)[0] + getpt(ptavg + 1)[0]) / 2,\n                    (getpt(ptavg)[1] + getpt(ptavg + 1)[1]) / 2];\n            }\n\n            pts.splice(cnt2 + 1, cnt - cnt2 + 1, newpt);\n            cnt = cnt2 + 1;\n            if(cnt3) cropstart = cnt3;\n            if(closedpath) {\n                if(cnt === pts.length - 2) pts[cnt3] = pts[pts.length - 1];\n                else if(cnt === 0) pts[pts.length - 1] = pts[0];\n            }\n        }\n    }\n    pts.splice(0, cropstart);\n\n    // don't return single-point paths (ie all points were the same\n    // so they got deleted?)\n    if(pts.length < 2) return;\n    else if(closedpath) {\n        pts.pop();\n        pi.paths.push(pts);\n    }\n    else {\n        if(!edgeflag) {\n            Lib.log('Unclosed interior contour?',\n                pi.level, startLocStr, pts.join('L'));\n        }\n\n        // edge path - does it start where an existing edge path ends, or vice versa?\n        var merged = false;\n        pi.edgepaths.forEach(function(edgepath, edgei) {\n            if(!merged && equalPts(edgepath[0], pts[pts.length - 1], xtol, ytol)) {\n                pts.pop();\n                merged = true;\n\n                // now does it ALSO meet the end of another (or the same) path?\n                var doublemerged = false;\n                pi.edgepaths.forEach(function(edgepath2, edgei2) {\n                    if(!doublemerged && equalPts(\n                            edgepath2[edgepath2.length - 1], pts[0], xtol, ytol)) {\n                        doublemerged = true;\n                        pts.splice(0, 1);\n                        pi.edgepaths.splice(edgei, 1);\n                        if(edgei2 === edgei) {\n                            // the path is now closed\n                            pi.paths.push(pts.concat(edgepath2));\n                        }\n                        else {\n                            pi.edgepaths[edgei2] =\n                                pi.edgepaths[edgei2].concat(pts, edgepath2);\n                        }\n                    }\n                });\n                if(!doublemerged) {\n                    pi.edgepaths[edgei] = pts.concat(edgepath);\n                }\n            }\n        });\n        pi.edgepaths.forEach(function(edgepath, edgei) {\n            if(!merged && equalPts(edgepath[edgepath.length - 1], pts[0], xtol, ytol)) {\n                pts.splice(0, 1);\n                pi.edgepaths[edgei] = edgepath.concat(pts);\n                merged = true;\n            }\n        });\n\n        if(!merged) pi.edgepaths.push(pts);\n    }\n}\n\n// special function to get the marching step of the\n// first point in the path (leading to loc)\nfunction startStep(mi, edgeflag, loc) {\n    var dx = 0,\n        dy = 0;\n    if(mi > 20 && edgeflag) {\n        // these saddles start at +/- x\n        if(mi === 208 || mi === 1114) {\n            // if we're starting at the left side, we must be going right\n            dx = loc[0] === 0 ? 1 : -1;\n        }\n        else {\n            // if we're starting at the bottom, we must be going up\n            dy = loc[1] === 0 ? 1 : -1;\n        }\n    }\n    else if(constants.BOTTOMSTART.indexOf(mi) !== -1) dy = 1;\n    else if(constants.LEFTSTART.indexOf(mi) !== -1) dx = 1;\n    else if(constants.TOPSTART.indexOf(mi) !== -1) dy = -1;\n    else dx = -1;\n    return [dx, dy];\n}\n\nfunction getInterpPx(pi, loc, step) {\n    var locx = loc[0] + Math.max(step[0], 0),\n        locy = loc[1] + Math.max(step[1], 0),\n        zxy = pi.z[locy][locx],\n        xa = pi.xaxis,\n        ya = pi.yaxis;\n\n    if(step[1]) {\n        var dx = (pi.level - zxy) / (pi.z[locy][locx + 1] - zxy);\n\n        return [xa.c2p((1 - dx) * pi.x[locx] + dx * pi.x[locx + 1], true),\n            ya.c2p(pi.y[locy], true)];\n    }\n    else {\n        var dy = (pi.level - zxy) / (pi.z[locy + 1][locx] - zxy);\n        return [xa.c2p(pi.x[locx], true),\n            ya.c2p((1 - dy) * pi.y[locy] + dy * pi.y[locy + 1], true)];\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/contour/constants.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n// some constants to help with marching squares algorithm\n// where does the path start for each index?\nmodule.exports.BOTTOMSTART = [1, 9, 13, 104, 713];\nmodule.exports.TOPSTART = [4, 6, 7, 104, 713];\nmodule.exports.LEFTSTART = [8, 12, 14, 208, 1114];\nmodule.exports.RIGHTSTART = [2, 3, 11, 208, 1114];\n\n// which way [dx,dy] do we leave a given index?\n// saddles are already disambiguated\nmodule.exports.NEWDELTA = [\n    null, [-1, 0], [0, -1], [-1, 0],\n    [1, 0], null, [0, -1], [-1, 0],\n    [0, 1], [0, 1], null, [0, 1],\n    [1, 0], [1, 0], [0, -1]\n];\n\n// for each saddle, the first index here is used\n// for dx||dy<0, the second for dx||dy>0\nmodule.exports.CHOOSESADDLE = {\n    104: [4, 1],\n    208: [2, 8],\n    713: [7, 13],\n    1114: [11, 14]\n};\n\n// after one index has been used for a saddle, which do we\n// substitute to be used up later?\nmodule.exports.SADDLEREMAINDER = {1: 4, 2: 8, 4: 1, 7: 13, 8: 2, 11: 14, 13: 7, 14: 11};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/contour/make_crossings.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar constants = require('./constants');\n\n// Calculate all the marching indices, for ALL levels at once.\n// since we want to be exhaustive we'll check for contour crossings\n// at every intersection, rather than just following a path\n// TODO: shorten the inner loop to only the relevant levels\nmodule.exports = function makeCrossings(pathinfo) {\n    var z = pathinfo[0].z,\n        m = z.length,\n        n = z[0].length, // we already made sure z isn't ragged in interp2d\n        twoWide = m === 2 || n === 2,\n        xi,\n        yi,\n        startIndices,\n        ystartIndices,\n        label,\n        corners,\n        mi,\n        pi,\n        i;\n\n    for(yi = 0; yi < m - 1; yi++) {\n        ystartIndices = [];\n        if(yi === 0) ystartIndices = ystartIndices.concat(constants.BOTTOMSTART);\n        if(yi === m - 2) ystartIndices = ystartIndices.concat(constants.TOPSTART);\n\n        for(xi = 0; xi < n - 1; xi++) {\n            startIndices = ystartIndices.slice();\n            if(xi === 0) startIndices = startIndices.concat(constants.LEFTSTART);\n            if(xi === n - 2) startIndices = startIndices.concat(constants.RIGHTSTART);\n\n            label = xi + ',' + yi;\n            corners = [[z[yi][xi], z[yi][xi + 1]],\n                       [z[yi + 1][xi], z[yi + 1][xi + 1]]];\n            for(i = 0; i < pathinfo.length; i++) {\n                pi = pathinfo[i];\n                mi = getMarchingIndex(pi.level, corners);\n                if(!mi) continue;\n\n                pi.crossings[label] = mi;\n                if(startIndices.indexOf(mi) !== -1) {\n                    pi.starts.push([xi, yi]);\n                    if(twoWide && startIndices.indexOf(mi,\n                            startIndices.indexOf(mi) + 1) !== -1) {\n                        // the same square has starts from opposite sides\n                        // it's not possible to have starts on opposite edges\n                        // of a corner, only a start and an end...\n                        // but if the array is only two points wide (either way)\n                        // you can have starts on opposite sides.\n                        pi.starts.push([xi, yi]);\n                    }\n                }\n            }\n        }\n    }\n};\n\n// modified marching squares algorithm,\n// so we disambiguate the saddle points from the start\n// and we ignore the cases with no crossings\n// the index I'm using is based on:\n// http://en.wikipedia.org/wiki/Marching_squares\n// except that the saddles bifurcate and I represent them\n// as the decimal combination of the two appropriate\n// non-saddle indices\nfunction getMarchingIndex(val, corners) {\n    var mi = (corners[0][0] > val ? 0 : 1) +\n             (corners[0][1] > val ? 0 : 2) +\n             (corners[1][1] > val ? 0 : 4) +\n             (corners[1][0] > val ? 0 : 8);\n    if(mi === 5 || mi === 10) {\n        var avg = (corners[0][0] + corners[0][1] +\n                   corners[1][0] + corners[1][1]) / 4;\n        // two peaks with a big valley\n        if(val > avg) return (mi === 5) ? 713 : 1114;\n        // two valleys with a big ridge\n        return (mi === 5) ? 104 : 208;\n    }\n    return (mi === 15) ? 0 : mi;\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/heatmap/find_empties.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar maxRowLength = require('./max_row_length');\n\n/* Return a list of empty points in 2D array z\n * each empty point z[i][j] gives an array [i, j, neighborCount]\n * neighborCount is the count of 4 nearest neighbors that DO exist\n * this is to give us an order of points to evaluate for interpolation.\n * if no neighbors exist, we iteratively look for neighbors that HAVE\n * neighbors, and add a fractional neighborCount\n */\nmodule.exports = function findEmpties(z) {\n    var empties = [],\n        neighborHash = {},\n        noNeighborList = [],\n        nextRow = z[0],\n        row = [],\n        blank = [0, 0, 0],\n        rowLength = maxRowLength(z),\n        prevRow,\n        i,\n        j,\n        thisPt,\n        p,\n        neighborCount,\n        newNeighborHash,\n        foundNewNeighbors;\n\n    for(i = 0; i < z.length; i++) {\n        prevRow = row;\n        row = nextRow;\n        nextRow = z[i + 1] || [];\n        for(j = 0; j < rowLength; j++) {\n            if(row[j] === undefined) {\n                neighborCount = (row[j - 1] !== undefined ? 1 : 0) +\n                    (row[j + 1] !== undefined ? 1 : 0) +\n                    (prevRow[j] !== undefined ? 1 : 0) +\n                    (nextRow[j] !== undefined ? 1 : 0);\n\n                if(neighborCount) {\n                    // for this purpose, don't count off-the-edge points\n                    // as undefined neighbors\n                    if(i === 0) neighborCount++;\n                    if(j === 0) neighborCount++;\n                    if(i === z.length - 1) neighborCount++;\n                    if(j === row.length - 1) neighborCount++;\n\n                    // if all neighbors that could exist do, we don't\n                    // need this for finding farther neighbors\n                    if(neighborCount < 4) {\n                        neighborHash[[i, j]] = [i, j, neighborCount];\n                    }\n\n                    empties.push([i, j, neighborCount]);\n                }\n                else noNeighborList.push([i, j]);\n            }\n        }\n    }\n\n    while(noNeighborList.length) {\n        newNeighborHash = {};\n        foundNewNeighbors = false;\n\n        // look for cells that now have neighbors but didn't before\n        for(p = noNeighborList.length - 1; p >= 0; p--) {\n            thisPt = noNeighborList[p];\n            i = thisPt[0];\n            j = thisPt[1];\n\n            neighborCount = ((neighborHash[[i - 1, j]] || blank)[2] +\n                (neighborHash[[i + 1, j]] || blank)[2] +\n                (neighborHash[[i, j - 1]] || blank)[2] +\n                (neighborHash[[i, j + 1]] || blank)[2]) / 20;\n\n            if(neighborCount) {\n                newNeighborHash[thisPt] = [i, j, neighborCount];\n                noNeighborList.splice(p, 1);\n                foundNewNeighbors = true;\n            }\n        }\n\n        if(!foundNewNeighbors) {\n            throw 'findEmpties iterated with no new neighbors';\n        }\n\n        // put these new cells into the main neighbor list\n        for(thisPt in newNeighborHash) {\n            neighborHash[thisPt] = newNeighborHash[thisPt];\n            empties.push(newNeighborHash[thisPt]);\n        }\n    }\n\n    // sort the full list in descending order of neighbor count\n    return empties.sort(function(a, b) { return b[2] - a[2]; });\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/heatmap/max_row_length.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nmodule.exports = function maxRowLength(z) {\n    var len = 0;\n\n    for(var i = 0; i < z.length; i++) {\n        len = Math.max(len, z[i].length);\n    }\n\n    return len;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/heatmap/interp2d.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\n\nvar INTERPTHRESHOLD = 1e-2,\n    NEIGHBORSHIFTS = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n\nfunction correctionOvershoot(maxFractionalChange) {\n    // start with less overshoot, until we know it's converging,\n    // then ramp up the overshoot for faster convergence\n    return 0.5 - 0.25 * Math.min(1, maxFractionalChange * 0.5);\n}\n\nmodule.exports = function interp2d(z, emptyPoints, savedInterpZ) {\n    // fill in any missing data in 2D array z using an iterative\n    // poisson equation solver with zero-derivative BC at edges\n    // amazingly, this just amounts to repeatedly averaging all the existing\n    // nearest neighbors (at least if we don't take x/y scaling into account)\n    var maxFractionalChange = 1,\n        i,\n        thisPt;\n\n    if(Array.isArray(savedInterpZ)) {\n        for(i = 0; i < emptyPoints.length; i++) {\n            thisPt = emptyPoints[i];\n            z[thisPt[0]][thisPt[1]] = savedInterpZ[thisPt[0]][thisPt[1]];\n        }\n    }\n    else {\n        // one pass to fill in a starting value for all the empties\n        iterateInterp2d(z, emptyPoints);\n    }\n\n    // we're don't need to iterate lone empties - remove them\n    for(i = 0; i < emptyPoints.length; i++) {\n        if(emptyPoints[i][2] < 4) break;\n    }\n    // but don't remove these points from the original array,\n    // we'll use them for masking, so make a copy.\n    emptyPoints = emptyPoints.slice(i);\n\n    for(i = 0; i < 100 && maxFractionalChange > INTERPTHRESHOLD; i++) {\n        maxFractionalChange = iterateInterp2d(z, emptyPoints,\n            correctionOvershoot(maxFractionalChange));\n    }\n    if(maxFractionalChange > INTERPTHRESHOLD) {\n        Lib.log('interp2d didn\\'t converge quickly', maxFractionalChange);\n    }\n\n    return z;\n};\n\nfunction iterateInterp2d(z, emptyPoints, overshoot) {\n    var maxFractionalChange = 0,\n        thisPt,\n        i,\n        j,\n        p,\n        q,\n        neighborShift,\n        neighborRow,\n        neighborVal,\n        neighborCount,\n        neighborSum,\n        initialVal,\n        minNeighbor,\n        maxNeighbor;\n\n    for(p = 0; p < emptyPoints.length; p++) {\n        thisPt = emptyPoints[p];\n        i = thisPt[0];\n        j = thisPt[1];\n        initialVal = z[i][j];\n        neighborSum = 0;\n        neighborCount = 0;\n\n        for(q = 0; q < 4; q++) {\n            neighborShift = NEIGHBORSHIFTS[q];\n            neighborRow = z[i + neighborShift[0]];\n            if(!neighborRow) continue;\n            neighborVal = neighborRow[j + neighborShift[1]];\n            if(neighborVal !== undefined) {\n                if(neighborSum === 0) {\n                    minNeighbor = maxNeighbor = neighborVal;\n                }\n                else {\n                    minNeighbor = Math.min(minNeighbor, neighborVal);\n                    maxNeighbor = Math.max(maxNeighbor, neighborVal);\n                }\n                neighborCount++;\n                neighborSum += neighborVal;\n            }\n        }\n\n        if(neighborCount === 0) {\n            throw 'iterateInterp2d order is wrong: no defined neighbors';\n        }\n\n        // this is the laplace equation interpolation:\n        // each point is just the average of its neighbors\n        // note that this ignores differential x/y scaling\n        // which I think is the right approach, since we\n        // don't know what that scaling means\n        z[i][j] = neighborSum / neighborCount;\n\n        if(initialVal === undefined) {\n            if(neighborCount < 4) maxFractionalChange = 1;\n        }\n        else {\n            // we can make large empty regions converge faster\n            // if we overshoot the change vs the previous value\n            z[i][j] = (1 + overshoot) * z[i][j] - overshoot * initialVal;\n\n            if(maxNeighbor > minNeighbor) {\n                maxFractionalChange = Math.max(maxFractionalChange,\n                    Math.abs(z[i][j] - initialVal) / (maxNeighbor - minNeighbor));\n            }\n        }\n    }\n\n    return maxFractionalChange;\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/heatmap/make_bound_array.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Registry = require('../../registry');\n\nmodule.exports = function makeBoundArray(trace, arrayIn, v0In, dvIn, numbricks, ax) {\n    var arrayOut = [],\n        isContour = Registry.traceIs(trace, 'contour'),\n        isHist = Registry.traceIs(trace, 'histogram'),\n        isGL2D = Registry.traceIs(trace, 'gl2d'),\n        v0,\n        dv,\n        i;\n\n    var isArrayOfTwoItemsOrMore = Array.isArray(arrayIn) && arrayIn.length > 1;\n\n    if(isArrayOfTwoItemsOrMore && !isHist && (ax.type !== 'category')) {\n        var len = arrayIn.length;\n\n        // given vals are brick centers\n        // hopefully length === numbricks, but use this method even if too few are supplied\n        // and extend it linearly based on the last two points\n        if(len <= numbricks) {\n            // contour plots only want the centers\n            if(isContour || isGL2D) arrayOut = arrayIn.slice(0, numbricks);\n            else if(numbricks === 1) {\n                arrayOut = [arrayIn[0] - 0.5, arrayIn[0] + 0.5];\n            }\n            else {\n                arrayOut = [1.5 * arrayIn[0] - 0.5 * arrayIn[1]];\n\n                for(i = 1; i < len; i++) {\n                    arrayOut.push((arrayIn[i - 1] + arrayIn[i]) * 0.5);\n                }\n\n                arrayOut.push(1.5 * arrayIn[len - 1] - 0.5 * arrayIn[len - 2]);\n            }\n\n            if(len < numbricks) {\n                var lastPt = arrayOut[arrayOut.length - 1],\n                    delta = lastPt - arrayOut[arrayOut.length - 2];\n\n                for(i = len; i < numbricks; i++) {\n                    lastPt += delta;\n                    arrayOut.push(lastPt);\n                }\n            }\n        }\n        else {\n            // hopefully length === numbricks+1, but do something regardless:\n            // given vals are brick boundaries\n            return isContour ?\n                arrayIn.slice(0, numbricks) :  // we must be strict for contours\n                arrayIn.slice(0, numbricks + 1);\n        }\n    }\n    else {\n        dv = dvIn || 1;\n\n        var calendar = trace[ax._id.charAt(0) + 'calendar'];\n\n        if(isHist || ax.type === 'category') v0 = ax.r2c(v0In, 0, calendar) || 0;\n        else if(Array.isArray(arrayIn) && arrayIn.length === 1) v0 = arrayIn[0];\n        else if(v0In === undefined) v0 = 0;\n        else v0 = ax.d2c(v0In, 0, calendar);\n\n        for(i = (isContour || isGL2D) ? 0 : -0.5; i < numbricks; i++) {\n            arrayOut.push(v0 + dv * i);\n        }\n    }\n\n    return arrayOut;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/heatmap/xyz_defaults.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Registry = require('../../registry');\nvar hasColumns = require('./has_columns');\n\n\nmodule.exports = function handleXYZDefaults(traceIn, traceOut, coerce, layout, xName, yName) {\n    var z = coerce('z');\n    xName = xName || 'x';\n    yName = yName || 'y';\n    var x, y;\n\n    if(z === undefined || !z.length) return 0;\n\n    if(hasColumns(traceIn)) {\n        x = coerce(xName);\n        y = coerce(yName);\n\n        // column z must be accompanied by xName and yName arrays\n        if(!x || !y) return 0;\n    }\n    else {\n        x = coordDefaults(xName, coerce);\n        y = coordDefaults(yName, coerce);\n\n        // TODO put z validation elsewhere\n        if(!isValidZ(z)) return 0;\n\n        coerce('transpose');\n    }\n\n    var handleCalendarDefaults = Registry.getComponentMethod('calendars', 'handleTraceDefaults');\n    handleCalendarDefaults(traceIn, traceOut, [xName, yName], layout);\n\n    return traceOut.z.length;\n};\n\nfunction coordDefaults(coordStr, coerce) {\n    var coord = coerce(coordStr),\n        coordType = coord ?\n            coerce(coordStr + 'type', 'array') :\n            'scaled';\n\n    if(coordType === 'scaled') {\n        coerce(coordStr + '0');\n        coerce('d' + coordStr);\n    }\n\n    return coord;\n}\n\nfunction isValidZ(z) {\n    var allRowsAreArrays = true,\n        oneRowIsFilled = false,\n        hasOneNumber = false,\n        zi;\n\n    /*\n     * Without this step:\n     *\n     * hasOneNumber = false breaks contour but not heatmap\n     * allRowsAreArrays = false breaks contour but not heatmap\n     * oneRowIsFilled = false breaks both\n     */\n\n    for(var i = 0; i < z.length; i++) {\n        zi = z[i];\n        if(!Array.isArray(zi)) {\n            allRowsAreArrays = false;\n            break;\n        }\n        if(zi.length > 0) oneRowIsFilled = true;\n        for(var j = 0; j < zi.length; j++) {\n            if(isNumeric(zi[j])) {\n                hasOneNumber = true;\n                break;\n            }\n        }\n    }\n\n    return (allRowsAreArrays && oneRowIsFilled && hasOneNumber);\n}\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/heatmap/has_columns.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nmodule.exports = function(trace) {\n    return !Array.isArray(trace.z[0]);\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/histogram2d/sample_defaults.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Registry = require('../../registry');\nvar handleBinDefaults = require('../histogram/bin_defaults');\n\n\nmodule.exports = function handleSampleDefaults(traceIn, traceOut, coerce, layout) {\n    var x = coerce('x'),\n        y = coerce('y');\n\n    // we could try to accept x0 and dx, etc...\n    // but that's a pretty weird use case.\n    // for now require both x and y explicitly specified.\n    if(!(x && x.length && y && y.length)) {\n        traceOut.visible = false;\n        return;\n    }\n\n    var handleCalendarDefaults = Registry.getComponentMethod('calendars', 'handleTraceDefaults');\n    handleCalendarDefaults(traceIn, traceOut, ['x', 'y'], layout);\n\n    // if marker.color is an array, we can use it in aggregation instead of z\n    var hasAggregationData = coerce('z') || coerce('marker.color');\n\n    if(hasAggregationData) coerce('histfunc');\n\n    var binDirections = ['x', 'y'];\n    handleBinDefaults(traceIn, traceOut, coerce, binDirections);\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/histogram/bin_defaults.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\n\nmodule.exports = function handleBinDefaults(traceIn, traceOut, coerce, binDirections) {\n    coerce('histnorm');\n\n    binDirections.forEach(function(binDirection) {\n        /*\n         * Because date axes have string values for start and end,\n         * and string options for size, we cannot validate these attributes\n         * now. We will do this during calc (immediately prior to binning)\n         * in ./clean_bins, and push the cleaned values back to _fullData.\n         */\n        coerce(binDirection + 'bins.start');\n        coerce(binDirection + 'bins.end');\n        coerce(binDirection + 'bins.size');\n        coerce('autobin' + binDirection);\n        coerce('nbins' + binDirection);\n    });\n\n    return traceOut;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/histogram/average.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\n\nmodule.exports = function doAvg(size, counts) {\n    var nMax = size.length,\n        total = 0;\n    for(var i = 0; i < nMax; i++) {\n        if(counts[i]) {\n            size[i] /= counts[i];\n            total += size[i];\n        }\n        else size[i] = null;\n    }\n    return total;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/histogram/bin_functions.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\n\nmodule.exports = {\n    count: function(n, i, size) {\n        size[n]++;\n        return 1;\n    },\n\n    sum: function(n, i, size, counterData) {\n        var v = counterData[i];\n        if(isNumeric(v)) {\n            v = Number(v);\n            size[n] += v;\n            return v;\n        }\n        return 0;\n    },\n\n    avg: function(n, i, size, counterData, counts) {\n        var v = counterData[i];\n        if(isNumeric(v)) {\n            v = Number(v);\n            size[n] += v;\n            counts[n]++;\n        }\n        return 0;\n    },\n\n    min: function(n, i, size, counterData) {\n        var v = counterData[i];\n        if(isNumeric(v)) {\n            v = Number(v);\n            if(!isNumeric(size[n])) {\n                size[n] = v;\n                return v;\n            }\n            else if(size[n] > v) {\n                var delta = v - size[n];\n                size[n] = v;\n                return delta;\n            }\n        }\n        return 0;\n    },\n\n    max: function(n, i, size, counterData) {\n        var v = counterData[i];\n        if(isNumeric(v)) {\n            v = Number(v);\n            if(!isNumeric(size[n])) {\n                size[n] = v;\n                return v;\n            }\n            else if(size[n] < v) {\n                var delta = v - size[n];\n                size[n] = v;\n                return delta;\n            }\n        }\n        return 0;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/histogram/clean_bins.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\nvar isNumeric = require('fast-isnumeric');\nvar cleanDate = require('../../lib').cleanDate;\nvar constants = require('../../constants/numerical');\nvar ONEDAY = constants.ONEDAY;\nvar BADNUM = constants.BADNUM;\n\n/*\n * cleanBins: validate attributes autobin[xy] and [xy]bins.(start, end, size)\n * Mutates trace so all these attributes are valid.\n *\n * Normally this kind of thing would happen during supplyDefaults, but\n * in this case we need to know the axis type, and axis type isn't set until\n * after trace supplyDefaults are completed. So this gets called during the\n * calc step, when data are inserted into bins.\n */\nmodule.exports = function cleanBins(trace, ax, binDirection) {\n    var axType = ax.type,\n        binAttr = binDirection + 'bins',\n        bins = trace[binAttr];\n\n    if(!bins) bins = trace[binAttr] = {};\n\n    var cleanBound = (axType === 'date') ?\n        function(v) { return (v || v === 0) ? cleanDate(v, BADNUM, bins.calendar) : null; } :\n        function(v) { return isNumeric(v) ? Number(v) : null; };\n\n    bins.start = cleanBound(bins.start);\n    bins.end = cleanBound(bins.end);\n\n    // logic for bin size is very similar to dtick (cartesian/tick_value_defaults)\n    // but without the extra string options for log axes\n    // ie the only strings we accept are M<n> for months\n    var sizeDflt = (axType === 'date') ? ONEDAY : 1,\n        binSize = bins.size;\n\n    if(isNumeric(binSize)) {\n        bins.size = (binSize > 0) ? Number(binSize) : sizeDflt;\n    }\n    else if(typeof binSize !== 'string') {\n        bins.size = sizeDflt;\n    }\n    else {\n        // date special case: \"M<n>\" gives bins every (integer) n months\n        var prefix = binSize.charAt(0),\n            sizeNum = binSize.substr(1);\n\n        sizeNum = isNumeric(sizeNum) ? Number(sizeNum) : 0;\n        if((sizeNum <= 0) || !(\n                axType === 'date' && prefix === 'M' && sizeNum === Math.round(sizeNum)\n            )) {\n            bins.size = sizeDflt;\n        }\n    }\n\n    var autoBinAttr = 'autobin' + binDirection;\n\n    if(typeof trace[autoBinAttr] !== 'boolean') {\n        trace[autoBinAttr] = !(\n            (bins.start || bins.start === 0) &&\n            (bins.end || bins.end === 0)\n        );\n    }\n\n    if(!trace[autoBinAttr]) delete trace['nbins' + binDirection];\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/histogram/norm_functions.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\n\nmodule.exports = {\n    percent: function(size, total) {\n        var nMax = size.length,\n            norm = 100 / total;\n        for(var n = 0; n < nMax; n++) size[n] *= norm;\n    },\n    probability: function(size, total) {\n        var nMax = size.length;\n        for(var n = 0; n < nMax; n++) size[n] /= total;\n    },\n    density: function(size, total, inc, yinc) {\n        var nMax = size.length;\n        yinc = yinc || 1;\n        for(var n = 0; n < nMax; n++) size[n] *= inc[n] * yinc;\n    },\n    'probability density': function(size, total, inc, yinc) {\n        var nMax = size.length;\n        if(yinc) total /= yinc;\n        for(var n = 0; n < nMax; n++) size[n] *= inc[n] / total;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/ohlc/direction_defaults.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\n\nmodule.exports = function handleDirectionDefaults(traceIn, traceOut, coerce, direction) {\n    coerce(direction + '.showlegend');\n\n    // trace-wide *showlegend* overrides direction *showlegend*\n    if(traceIn.showlegend === false) {\n        traceOut[direction].showlegend = false;\n    }\n\n    var nameDflt = traceOut.name + ' - ' + direction;\n\n    coerce(direction + '.name', nameDflt);\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/ohlc/ohlc_defaults.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Registry = require('../../registry');\n\n\nmodule.exports = function handleOHLC(traceIn, traceOut, coerce, layout) {\n    var len;\n\n    var x = coerce('x'),\n        open = coerce('open'),\n        high = coerce('high'),\n        low = coerce('low'),\n        close = coerce('close');\n\n    var handleCalendarDefaults = Registry.getComponentMethod('calendars', 'handleTraceDefaults');\n    handleCalendarDefaults(traceIn, traceOut, ['x'], layout);\n\n    len = Math.min(open.length, high.length, low.length, close.length);\n\n    if(x) {\n        len = Math.min(len, x.length);\n        if(len < x.length) traceOut.x = x.slice(0, len);\n    }\n\n    if(len < open.length) traceOut.open = open.slice(0, len);\n    if(len < high.length) traceOut.high = high.slice(0, len);\n    if(len < low.length) traceOut.low = low.slice(0, len);\n    if(len < close.length) traceOut.close = close.slice(0, len);\n\n    return len;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/parcoords/base_plot.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\nvar Plots = require('../../plots/plots');\nvar parcoordsPlot = require('./plot');\nvar xmlnsNamespaces = require('../../constants/xmlns_namespaces');\nvar c = require('./constants');\n\nexports.name = 'parcoords';\n\nexports.attr = 'type';\n\nexports.plot = function(gd) {\n    var calcData = Plots.getSubplotCalcData(gd.calcdata, 'parcoords', 'parcoords');\n    if(calcData.length) parcoordsPlot(gd, calcData);\n};\n\nexports.clean = function(newFullData, newFullLayout, oldFullData, oldFullLayout) {\n    var hadParcoords = (oldFullLayout._has && oldFullLayout._has('parcoords'));\n    var hasParcoords = (newFullLayout._has && newFullLayout._has('parcoords'));\n\n    if(hadParcoords && !hasParcoords) {\n        oldFullLayout._paperdiv.selectAll('.parcoords-line-layers').remove();\n        oldFullLayout._paperdiv.selectAll('.parcoords-line-layers').remove();\n        oldFullLayout._paperdiv.selectAll('.parcoords').remove();\n        oldFullLayout._paperdiv.selectAll('.parcoords').remove();\n        oldFullLayout._glimages.selectAll('*').remove();\n    }\n};\n\nexports.toSVG = function(gd) {\n\n    var imageRoot = gd._fullLayout._glimages;\n    var root = d3.selectAll('.svg-container');\n    var canvases = root.filter(function(d, i) {return i === root.size() - 1;})\n        .selectAll('.parcoords-lines.context, .parcoords-lines.focus');\n\n    function canvasToImage(d) {\n        var canvas = this;\n        var imageData = canvas.toDataURL('image/png');\n        var image = imageRoot.append('svg:image');\n        var size = gd._fullLayout._size;\n        var domain = gd._fullData[d.model.key].domain;\n\n        image.attr({\n            xmlns: xmlnsNamespaces.svg,\n            'xlink:href': imageData,\n            x: size.l + size.w * domain.x[0] - c.overdrag,\n            y: size.t + size.h * (1 - domain.y[1]),\n            width: (domain.x[1] - domain.x[0]) * size.w + 2 * c.overdrag,\n            height: (domain.y[1] - domain.y[0]) * size.h,\n            preserveAspectRatio: 'none'\n        });\n    }\n\n    canvases.each(canvasToImage);\n\n    // Chrome / Safari bug workaround - browser apparently loses connection to the defined pattern\n    // Without the workaround, these browsers 'lose' the filter brush styling (color etc.) after a snapshot\n    // on a subsequent interaction.\n    // Firefox works fine without this workaround\n    window.setTimeout(function() {\n        d3.selectAll('#filterBarPattern')\n            .attr('id', 'filterBarPattern');\n    }, 60);\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/parcoords/plot.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar parcoords = require('./parcoords');\n\nmodule.exports = function plot(gd, cdparcoords) {\n\n    var fullLayout = gd._fullLayout;\n    var svg = fullLayout._paper;\n    var root = fullLayout._paperdiv;\n\n    var gdDimensions = {};\n    var gdDimensionsOriginalOrder = {};\n\n    var size = fullLayout._size;\n\n    cdparcoords.forEach(function(d, i) {\n        gdDimensions[i] = gd.data[i].dimensions;\n        gdDimensionsOriginalOrder[i] = gd.data[i].dimensions.slice();\n    });\n\n    var filterChanged = function(i, originalDimensionIndex, newRange) {\n\n        // Have updated `constraintrange` data on `gd.data` and raise `Plotly.restyle` event\n        // without having to incur heavy UI blocking due to an actual `Plotly.restyle` call\n\n        var gdDimension = gdDimensionsOriginalOrder[i][originalDimensionIndex];\n        var gdConstraintRange = gdDimension.constraintrange;\n\n        if(!gdConstraintRange || gdConstraintRange.length !== 2) {\n            gdConstraintRange = gdDimension.constraintrange = [];\n        }\n        gdConstraintRange[0] = newRange[0];\n        gdConstraintRange[1] = newRange[1];\n\n        gd.emit('plotly_restyle');\n    };\n\n    var hover = function(eventData) {\n        gd.emit('plotly_hover', eventData);\n    };\n\n    var unhover = function(eventData) {\n        gd.emit('plotly_unhover', eventData);\n    };\n\n    var axesMoved = function(i, visibleIndices) {\n\n        // Have updated order data on `gd.data` and raise `Plotly.restyle` event\n        // without having to incur heavy UI blocking due to an actual `Plotly.restyle` call\n\n        function visible(dimension) {return !('visible' in dimension) || dimension.visible;}\n\n        function newIdx(visibleIndices, orig, dim) {\n            var origIndex = orig.indexOf(dim);\n            var currentIndex = visibleIndices.indexOf(origIndex);\n            if(currentIndex === -1) {\n                // invisible dimensions initially go to the end\n                currentIndex += orig.length;\n            }\n            return currentIndex;\n        }\n\n        function sorter(orig) {\n            return function sorter(d1, d2) {\n                var i1 = newIdx(visibleIndices, orig, d1);\n                var i2 = newIdx(visibleIndices, orig, d2);\n                return i1 - i2;\n            };\n        }\n\n        // drag&drop sorting of the visible dimensions\n        var orig = sorter(gdDimensionsOriginalOrder[i].filter(visible));\n        gdDimensions[i].sort(orig);\n\n        // invisible dimensions are not interpreted in the context of drag&drop sorting as an invisible dimension\n        // cannot be dragged; they're interspersed into their original positions by this subsequent merging step\n        gdDimensionsOriginalOrder[i].filter(function(d) {return !visible(d);})\n             .sort(function(d) {\n                 // subsequent splicing to be done left to right, otherwise indices may be incorrect\n                 return gdDimensionsOriginalOrder[i].indexOf(d);\n             })\n            .forEach(function(d) {\n                gdDimensions[i].splice(gdDimensions[i].indexOf(d), 1); // remove from the end\n                gdDimensions[i].splice(gdDimensionsOriginalOrder[i].indexOf(d), 0, d); // insert at original index\n            });\n\n        gd.emit('plotly_restyle');\n    };\n\n    parcoords(\n        root,\n        svg,\n        cdparcoords,\n        {\n            width: size.w,\n            height: size.h,\n            margin: {\n                t: size.t,\n                r: size.r,\n                b: size.b,\n                l: size.l\n            }\n        },\n        {\n            filterChanged: filterChanged,\n            hover: hover,\n            unhover: unhover,\n            axesMoved: axesMoved\n        });\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/parcoords/parcoords.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar lineLayerMaker = require('./lines');\nvar c = require('./constants');\nvar Lib = require('../../lib');\nvar d3 = require('d3');\n\n\nfunction keyFun(d) {return d.key;}\n\nfunction repeat(d) {return [d];}\n\nfunction visible(dimension) {return !('visible' in dimension) || dimension.visible;}\n\nfunction dimensionExtent(dimension) {\n\n    var lo = dimension.range ? dimension.range[0] : d3.min(dimension.values);\n    var hi = dimension.range ? dimension.range[1] : d3.max(dimension.values);\n\n    if(isNaN(lo) || !isFinite(lo)) {\n        lo = 0;\n    }\n\n    if(isNaN(hi) || !isFinite(hi)) {\n        hi = 0;\n    }\n\n    // avoid a degenerate (zero-width) domain\n    if(lo === hi) {\n        if(lo === void(0)) {\n            lo = 0;\n            hi = 1;\n        } else if(lo === 0) {\n            // no use to multiplying zero, so add/subtract in this case\n            lo -= 1;\n            hi += 1;\n        } else {\n            // this keeps the range in the order of magnitude of the data\n            lo *= 0.9;\n            hi *= 1.1;\n        }\n    }\n\n    return [lo, hi];\n}\n\nfunction ordinalScaleSnap(scale, v) {\n    var i, a, prevDiff, prevValue, diff;\n    for(i = 0, a = scale.range(), prevDiff = Infinity, prevValue = a[0], diff; i < a.length; i++) {\n        if((diff = Math.abs(a[i] - v)) > prevDiff) {\n            return prevValue;\n        }\n        prevDiff = diff;\n        prevValue = a[i];\n    }\n    return a[a.length - 1];\n}\n\nfunction domainScale(height, padding, dimension) {\n    var extent = dimensionExtent(dimension);\n    return dimension.tickvals ?\n        d3.scale.ordinal()\n            .domain(dimension.tickvals)\n            .range(dimension.tickvals\n                .map(function(d) {return (d - extent[0]) / (extent[1] - extent[0]);})\n                .map(function(d) {return (height - padding + d * (padding - (height - padding)));})) :\n        d3.scale.linear()\n            .domain(extent)\n            .range([height - padding, padding]);\n}\n\nfunction unitScale(height, padding) {return d3.scale.linear().range([height - padding, padding]);}\nfunction domainToUnitScale(dimension) {return d3.scale.linear().domain(dimensionExtent(dimension));}\n\nfunction ordinalScale(dimension) {\n    var extent = dimensionExtent(dimension);\n    return dimension.tickvals && d3.scale.ordinal()\n            .domain(dimension.tickvals)\n            .range(dimension.tickvals.map(function(d) {return (d - extent[0]) / (extent[1] - extent[0]);}));\n}\n\nfunction unitToColorScale(cscale) {\n\n    var colorStops = cscale.map(function(d) {return d[0];});\n    var colorStrings = cscale.map(function(d) {return d[1];});\n    var colorTuples = colorStrings.map(function(c) {return d3.rgb(c);});\n    var prop = function(n) {return function(o) {return o[n];};};\n\n    // We can't use d3 color interpolation as we may have non-uniform color palette raster\n    // (various color stop distances).\n    var polylinearUnitScales = 'rgb'.split('').map(function(key) {\n        return d3.scale.linear()\n            .clamp(true)\n            .domain(colorStops)\n            .range(colorTuples.map(prop(key)));\n    });\n\n    return function(d) {\n        return polylinearUnitScales.map(function(s) {\n            return s(d);\n        });\n    };\n}\n\nfunction unwrap(d) {\n    return d[0]; // plotly data structure convention\n}\n\nfunction model(layout, d, i) {\n    var cd0 = unwrap(d),\n        trace = cd0.trace,\n        lineColor = cd0.lineColor,\n        cscale = cd0.cscale,\n        line = trace.line,\n        domain = trace.domain,\n        dimensions = trace.dimensions,\n        width = layout.width;\n\n    var lines = Lib.extendDeep({}, line, {\n        color: lineColor.map(domainToUnitScale({values: lineColor, range: [line.cmin, line.cmax]})),\n        blockLineCount: c.blockLineCount,\n        canvasOverdrag: c.overdrag * c.canvasPixelRatio\n    });\n\n    var groupWidth = Math.floor(width * (domain.x[1] - domain.x[0]));\n    var groupHeight = Math.floor(layout.height * (domain.y[1] - domain.y[0]));\n\n    var pad = layout.margin || {l: 80, r: 80, t: 100, b: 80};\n    var rowContentWidth = groupWidth;\n    var rowHeight = groupHeight;\n\n    return {\n        key: i,\n        colCount: dimensions.filter(visible).length,\n        dimensions: dimensions,\n        tickDistance: c.tickDistance,\n        unitToColor: unitToColorScale(cscale),\n        lines: lines,\n        translateX: domain.x[0] * width,\n        translateY: layout.height - domain.y[1] * layout.height,\n        pad: pad,\n        canvasWidth: rowContentWidth * c.canvasPixelRatio + 2 * lines.canvasOverdrag,\n        canvasHeight: rowHeight * c.canvasPixelRatio,\n        width: rowContentWidth,\n        height: rowHeight,\n        canvasPixelRatio: c.canvasPixelRatio\n    };\n}\n\nfunction viewModel(model) {\n\n    var width = model.width;\n    var height = model.height;\n    var dimensions = model.dimensions;\n    var canvasPixelRatio = model.canvasPixelRatio;\n\n    var xScale = function(d) {return width * d / Math.max(1, model.colCount - 1);};\n\n    var unitPad = c.verticalPadding / (height * canvasPixelRatio);\n    var unitPadScale = (1 - 2 * unitPad);\n    var paddedUnitScale = function(d) {return unitPad + unitPadScale * d;};\n\n    var viewModel = {\n        key: model.key,\n        xScale: xScale,\n        model: model\n    };\n\n    var uniqueKeys = {};\n\n    viewModel.dimensions = dimensions.filter(visible).map(function(dimension, i) {\n        var domainToUnit = domainToUnitScale(dimension);\n        var foundKey = uniqueKeys[dimension.label];\n        uniqueKeys[dimension.label] = (foundKey || 0) + 1;\n        var key = dimension.label + (foundKey ? '__' + foundKey : '');\n        return {\n            key: key,\n            label: dimension.label,\n            tickFormat: dimension.tickformat,\n            tickvals: dimension.tickvals,\n            ticktext: dimension.ticktext,\n            ordinal: !!dimension.tickvals,\n            scatter: c.scatter || dimension.scatter,\n            xIndex: i,\n            crossfilterDimensionIndex: i,\n            visibleIndex: dimension._index,\n            height: height,\n            values: dimension.values,\n            paddedUnitValues: dimension.values.map(domainToUnit).map(paddedUnitScale),\n            xScale: xScale,\n            x: xScale(i),\n            canvasX: xScale(i) * canvasPixelRatio,\n            unitScale: unitScale(height, c.verticalPadding),\n            domainScale: domainScale(height, c.verticalPadding, dimension),\n            ordinalScale: ordinalScale(dimension),\n            domainToUnitScale: domainToUnit,\n            filter: dimension.constraintrange ? dimension.constraintrange.map(domainToUnit) : [0, 1],\n            parent: viewModel,\n            model: model\n        };\n    });\n\n    return viewModel;\n}\n\nfunction lineLayerModel(vm) {\n    return c.layers.map(function(key) {\n        return {\n            key: key,\n            context: key === 'contextLineLayer',\n            pick: key === 'pickLineLayer',\n            viewModel: vm,\n            model: vm.model\n        };\n    });\n}\n\nfunction styleExtentTexts(selection) {\n    selection\n        .classed('axisExtentText', true)\n        .attr('text-anchor', 'middle')\n        .style('font-weight', 100)\n        .style('font-size', '10px')\n        .style('cursor', 'default')\n        .style('user-select', 'none');\n}\n\nmodule.exports = function(root, svg, styledData, layout, callbacks) {\n\n    var domainBrushing = false;\n    var linePickActive = true;\n\n    function enterSvgDefs(root) {\n        var defs = root.selectAll('defs')\n            .data(repeat, keyFun);\n\n        defs.enter()\n            .append('defs');\n\n        var filterBarPattern = defs.selectAll('#filterBarPattern')\n            .data(repeat, keyFun);\n\n        filterBarPattern.enter()\n            .append('pattern')\n            .attr('id', 'filterBarPattern')\n            .attr('patternUnits', 'userSpaceOnUse');\n\n        filterBarPattern\n            .attr('x', -c.bar.width)\n            .attr('width', c.bar.capturewidth)\n            .attr('height', function(d) {return d.model.height;});\n\n        var filterBarPatternGlyph = filterBarPattern.selectAll('rect')\n            .data(repeat, keyFun);\n\n        filterBarPatternGlyph.enter()\n            .append('rect')\n            .attr('shape-rendering', 'crispEdges');\n\n        filterBarPatternGlyph\n            .attr('height', function(d) {return d.model.height;})\n            .attr('width', c.bar.width)\n            .attr('x', c.bar.width / 2)\n            .attr('fill', c.bar.fillcolor)\n            .attr('fill-opacity', c.bar.fillopacity)\n            .attr('stroke', c.bar.strokecolor)\n            .attr('stroke-opacity', c.bar.strokeopacity)\n            .attr('stroke-width', c.bar.strokewidth);\n    }\n\n    var vm = styledData\n        .filter(function(d) { return unwrap(d).trace.visible; })\n        .map(model.bind(0, layout))\n        .map(viewModel);\n\n    root.selectAll('.parcoords-line-layers').remove();\n\n    var parcoordsLineLayers = root.selectAll('.parcoords-line-layers')\n        .data(vm, keyFun);\n\n    parcoordsLineLayers.enter()\n        .insert('div', '.' + svg.attr('class').split(' ').join(' .')) // not hardcoding .main-svg\n        .classed('parcoords-line-layers', true)\n        .style('box-sizing', 'content-box');\n\n    parcoordsLineLayers\n        .style('transform', function(d) {\n            return 'translate(' + (d.model.translateX - c.overdrag) + 'px,' + d.model.translateY + 'px)';\n        });\n\n    var parcoordsLineLayer = parcoordsLineLayers.selectAll('.parcoords-lines')\n        .data(lineLayerModel, keyFun);\n\n    var tweakables = {renderers: [], dimensions: []};\n\n    var lastHovered = null;\n\n    parcoordsLineLayer.enter()\n        .append('canvas')\n        .attr('class', function(d) {return 'parcoords-lines ' + (d.context ? 'context' : d.pick ? 'pick' : 'focus');})\n        .style('box-sizing', 'content-box')\n        .style('float', 'left')\n        .style('clear', 'both')\n        .style('left', 0)\n        .style('overflow', 'visible')\n        .style('position', function(d, i) {return i > 0 ? 'absolute' : 'absolute';})\n        .filter(function(d) {return d.pick;})\n        .on('mousemove', function(d) {\n            if(linePickActive && d.lineLayer && callbacks && callbacks.hover) {\n                var event = d3.event;\n                var cw = this.width;\n                var ch = this.height;\n                var pointer = d3.mouse(this);\n                var x = pointer[0];\n                var y = pointer[1];\n\n                if(x < 0 || y < 0 || x >= cw || y >= ch) {\n                    return;\n                }\n                var pixel = d.lineLayer.readPixel(x, ch - 1 - y);\n                var found = pixel[3] !== 0;\n                // inverse of the calcPickColor in `lines.js`; detailed comment there\n                var curveNumber = found ? pixel[2] + 256 * (pixel[1] + 256 * pixel[0]) : null;\n                var eventData = {\n                    x: x,\n                    y: y,\n                    clientX: event.clientX,\n                    clientY: event.clientY,\n                    dataIndex: d.model.key,\n                    curveNumber: curveNumber\n                };\n                if(curveNumber !== lastHovered) { // don't unnecessarily repeat the same hit (or miss)\n                    if(found) {\n                        callbacks.hover(eventData);\n                    } else if(callbacks.unhover) {\n                        callbacks.unhover(eventData);\n                    }\n                    lastHovered = curveNumber;\n                }\n            }\n        });\n\n    parcoordsLineLayer\n        .style('margin', function(d) {\n            var p = d.model.pad;\n            return p.t + 'px ' + p.r + 'px ' + p.b + 'px ' + p.l + 'px';\n        })\n        .attr('width', function(d) {return d.model.canvasWidth;})\n        .attr('height', function(d) {return d.model.canvasHeight;})\n        .style('width', function(d) {return (d.model.width + 2 * c.overdrag) + 'px';})\n        .style('height', function(d) {return d.model.height + 'px';})\n        .style('opacity', function(d) {return d.pick ? 0.01 : 1;});\n\n    svg.style('background', 'rgba(255, 255, 255, 0)');\n    var parcoordsControlOverlay = svg.selectAll('.parcoords')\n        .data(vm, keyFun);\n\n    parcoordsControlOverlay.exit().remove();\n\n    parcoordsControlOverlay.enter()\n        .append('g')\n        .classed('parcoords', true)\n        .attr('overflow', 'visible')\n        .style('box-sizing', 'content-box')\n        .style('position', 'absolute')\n        .style('left', 0)\n        .style('overflow', 'visible')\n        .style('shape-rendering', 'crispEdges')\n        .style('pointer-events', 'none')\n        .call(enterSvgDefs);\n\n    parcoordsControlOverlay\n        .attr('width', function(d) {return d.model.width + d.model.pad.l + d.model.pad.r;})\n        .attr('height', function(d) {return d.model.height + d.model.pad.t + d.model.pad.b;})\n        .attr('transform', function(d) {\n            return 'translate(' + d.model.translateX + ',' + d.model.translateY + ')';\n        });\n\n    var parcoordsControlView = parcoordsControlOverlay.selectAll('.parcoordsControlView')\n        .data(repeat, keyFun);\n\n    parcoordsControlView.enter()\n        .append('g')\n        .classed('parcoordsControlView', true)\n        .style('box-sizing', 'content-box');\n\n    parcoordsControlView\n        .attr('transform', function(d) {return 'translate(' + d.model.pad.l + ',' + d.model.pad.t + ')';});\n\n    var yAxis = parcoordsControlView.selectAll('.yAxis')\n        .data(function(vm) {return vm.dimensions;}, keyFun);\n\n    function someFiltersActive(view) {\n        return view.dimensions.some(function(p) {return p.filter[0] !== 0 || p.filter[1] !== 1;});\n    }\n\n    function updatePanelLayoutParcoords(yAxis, vm) {\n        var panels = vm.panels || (vm.panels = []);\n        var yAxes = yAxis.each(function(d) {return d;})[vm.key].map(function(e) {return e.__data__;});\n        var panelCount = yAxes.length - 1;\n        var rowCount = 1;\n        for(var row = 0; row < rowCount; row++) {\n            for(var p = 0; p < panelCount; p++) {\n                var panel = panels[p + row * panelCount] || (panels[p + row * panelCount] = {});\n                var dim1 = yAxes[p];\n                var dim2 = yAxes[p + 1];\n                panel.dim1 = dim1;\n                panel.dim2 = dim2;\n                panel.canvasX = dim1.canvasX;\n                panel.panelSizeX = dim2.canvasX - dim1.canvasX;\n                panel.panelSizeY = vm.model.canvasHeight / rowCount;\n                panel.y = row * panel.panelSizeY;\n                panel.canvasY = vm.model.canvasHeight - panel.y - panel.panelSizeY;\n            }\n        }\n    }\n\n    function updatePanelLayoutScatter(yAxis, vm) {\n        var panels = vm.panels || (vm.panels = []);\n        var yAxes = yAxis.each(function(d) {return d;})[vm.key].map(function(e) {return e.__data__;});\n        var panelCount = yAxes.length - 1;\n        var rowCount = panelCount;\n        for(var row = 0; row < panelCount; row++) {\n            for(var p = 0; p < panelCount; p++) {\n                var panel = panels[p + row * panelCount] || (panels[p + row * panelCount] = {});\n                var dim1 = yAxes[p];\n                var dim2 = yAxes[p + 1];\n                panel.dim1 = yAxes[row + 1];\n                panel.dim2 = dim2;\n                panel.canvasX = dim1.canvasX;\n                panel.panelSizeX = dim2.canvasX - dim1.canvasX;\n                panel.panelSizeY = vm.model.canvasHeight / rowCount;\n                panel.y = row * panel.panelSizeY;\n                panel.canvasY = vm.model.canvasHeight - panel.y - panel.panelSizeY;\n            }\n        }\n    }\n\n    function updatePanelLayout(yAxis, vm) {\n        return (c.scatter ? updatePanelLayoutScatter : updatePanelLayoutParcoords)(yAxis, vm);\n    }\n\n    yAxis.enter()\n        .append('g')\n        .classed('yAxis', true)\n        .each(function(d) {tweakables.dimensions.push(d);});\n\n    parcoordsControlView.each(function(vm) {\n        updatePanelLayout(yAxis, vm);\n    });\n\n    parcoordsLineLayer\n        .each(function(d) {\n            d.lineLayer = lineLayerMaker(this, d.model.lines, d.model.canvasWidth, d.model.canvasHeight, d.viewModel.dimensions, d.viewModel.panels, d.model.unitToColor, d.context, d.pick, c.scatter);\n            d.viewModel[d.key] = d.lineLayer;\n            tweakables.renderers.push(function() {d.lineLayer.render(d.viewModel.panels, true);});\n            d.lineLayer.render(d.viewModel.panels, !d.context);\n        });\n\n    yAxis\n        .attr('transform', function(d) {return 'translate(' + d.xScale(d.xIndex) + ', 0)';});\n\n    yAxis\n        .call(d3.behavior.drag()\n            .origin(function(d) {return d;})\n            .on('drag', function(d) {\n                var p = d.parent;\n                linePickActive = false;\n                if(domainBrushing) {\n                    return;\n                }\n                d.x = Math.max(-c.overdrag, Math.min(d.model.width + c.overdrag, d3.event.x));\n                d.canvasX = d.x * d.model.canvasPixelRatio;\n                yAxis\n                    .sort(function(a, b) {return a.x - b.x;})\n                    .each(function(dd, i) {\n                        dd.xIndex = i;\n                        dd.x = d === dd ? dd.x : dd.xScale(dd.xIndex);\n                        dd.canvasX = dd.x * dd.model.canvasPixelRatio;\n                    });\n\n                updatePanelLayout(yAxis, p);\n\n                yAxis.filter(function(dd) {return Math.abs(d.xIndex - dd.xIndex) !== 0;})\n                    .attr('transform', function(d) {return 'translate(' + d.xScale(d.xIndex) + ', 0)';});\n                d3.select(this).attr('transform', 'translate(' + d.x + ', 0)');\n                yAxis.each(function(dd, i, ii) {if(ii === d.parent.key) p.dimensions[i] = dd;});\n                p.contextLineLayer && p.contextLineLayer.render(p.panels, false, !someFiltersActive(p));\n                p.focusLineLayer.render && p.focusLineLayer.render(p.panels);\n            })\n            .on('dragend', function(d) {\n                var p = d.parent;\n                if(domainBrushing) {\n                    if(domainBrushing === 'ending') {\n                        domainBrushing = false;\n                    }\n                    return;\n                }\n                d.x = d.xScale(d.xIndex);\n                d.canvasX = d.x * d.model.canvasPixelRatio;\n                updatePanelLayout(yAxis, p);\n                d3.select(this)\n                    .attr('transform', function(d) {return 'translate(' + d.x + ', 0)';});\n                p.contextLineLayer && p.contextLineLayer.render(p.panels, false, !someFiltersActive(p));\n                p.focusLineLayer && p.focusLineLayer.render(p.panels);\n                p.pickLineLayer && p.pickLineLayer.render(p.panels, true);\n                linePickActive = true;\n\n                if(callbacks && callbacks.axesMoved) {\n                    callbacks.axesMoved(p.key, p.dimensions.map(function(dd) {return dd.crossfilterDimensionIndex;}));\n                }\n            })\n        );\n\n    yAxis.exit()\n        .remove();\n\n    var axisOverlays = yAxis.selectAll('.axisOverlays')\n        .data(repeat, keyFun);\n\n    axisOverlays.enter()\n        .append('g')\n        .classed('axisOverlays', true);\n\n    axisOverlays.selectAll('.axis').remove();\n\n    var axis = axisOverlays.selectAll('.axis')\n        .data(repeat, keyFun);\n\n    axis.enter()\n        .append('g')\n        .classed('axis', true);\n\n    axis\n        .each(function(d) {\n            var wantedTickCount = d.model.height / d.model.tickDistance;\n            var scale = d.domainScale;\n            var sdom = scale.domain();\n            var texts = d.ticktext;\n            d3.select(this)\n                .call(d3.svg.axis()\n                    .orient('left')\n                    .tickSize(4)\n                    .outerTickSize(2)\n                    .ticks(wantedTickCount, d.tickFormat) // works for continuous scales only...\n                    .tickValues(d.ordinal ? // and this works for ordinal scales\n                        sdom.map(function(d, i) {return texts && texts[i] || d;}) :\n                        null)\n                    .tickFormat(d.ordinal ? function(d) {return d;} : null)\n                    .scale(scale));\n        });\n\n    axis\n        .selectAll('.domain, .tick')\n        .attr('fill', 'none')\n        .attr('stroke', 'black')\n        .attr('stroke-opacity', 0.25)\n        .attr('stroke-width', '1px');\n\n    axis\n        .selectAll('text')\n        .style('font-weight', 100)\n        .style('font-size', '10px')\n        .style('fill', 'black')\n        .style('fill-opacity', 1)\n        .style('stroke', 'none')\n        .style('text-shadow', '1px 1px 1px #fff, -1px -1px 1px #fff, 1px -1px 1px #fff, -1px 1px 1px #fff')\n        .style('cursor', 'default')\n        .style('user-select', 'none');\n\n    var axisHeading = axisOverlays.selectAll('.axisHeading')\n        .data(repeat, keyFun);\n\n    axisHeading.enter()\n        .append('g')\n        .classed('axisHeading', true);\n\n    var axisTitle = axisHeading.selectAll('.axisTitle')\n        .data(repeat, keyFun);\n\n    axisTitle.enter()\n        .append('text')\n        .classed('axisTitle', true)\n        .attr('text-anchor', 'middle')\n        .style('font-family', 'sans-serif')\n        .style('font-size', '10px')\n        .style('cursor', 'ew-resize')\n        .style('user-select', 'none')\n        .style('pointer-events', 'auto');\n\n    axisTitle\n        .attr('transform', 'translate(0,' + -c.axisTitleOffset + ')')\n        .text(function(d) {return d.label;});\n\n    var axisExtent = axisOverlays.selectAll('.axisExtent')\n        .data(repeat, keyFun);\n\n    axisExtent.enter()\n        .append('g')\n        .classed('axisExtent', true);\n\n    var axisExtentTop = axisExtent.selectAll('.axisExtentTop')\n        .data(repeat, keyFun);\n\n    axisExtentTop.enter()\n        .append('g')\n        .classed('axisExtentTop', true);\n\n    axisExtentTop\n        .attr('transform', 'translate(' + 0 + ',' + -c.axisExtentOffset + ')');\n\n    var axisExtentTopText = axisExtentTop.selectAll('.axisExtentTopText')\n        .data(repeat, keyFun);\n\n    function formatExtreme(d) {\n        return d.ordinal ? function() {return '';} : d3.format(d.tickFormat);\n    }\n\n    axisExtentTopText.enter()\n        .append('text')\n        .classed('axisExtentTopText', true)\n        .attr('alignment-baseline', 'after-edge')\n        .call(styleExtentTexts);\n\n    axisExtentTopText\n        .text(function(d) {return formatExtreme(d)(d.domainScale.domain().slice(-1)[0]);});\n\n    var axisExtentBottom = axisExtent.selectAll('.axisExtentBottom')\n        .data(repeat, keyFun);\n\n    axisExtentBottom.enter()\n        .append('g')\n        .classed('axisExtentBottom', true);\n\n    axisExtentBottom\n        .attr('transform', function(d) {return 'translate(' + 0 + ',' + (d.model.height + c.axisExtentOffset) + ')';});\n\n    var axisExtentBottomText = axisExtentBottom.selectAll('.axisExtentBottomText')\n        .data(repeat, keyFun);\n\n    axisExtentBottomText.enter()\n        .append('text')\n        .classed('axisExtentBottomText', true)\n        .attr('alignment-baseline', 'before-edge')\n        .call(styleExtentTexts);\n\n    axisExtentBottomText\n        .text(function(d) {return formatExtreme(d)(d.domainScale.domain()[0]);});\n\n    var axisBrush = axisOverlays.selectAll('.axisBrush')\n        .data(repeat, keyFun);\n\n    var axisBrushEnter = axisBrush.enter()\n        .append('g')\n        .classed('axisBrush', true);\n\n    axisBrush\n        .each(function(d) {\n            if(!d.brush) {\n                d.brush = d3.svg.brush()\n                    .y(d.unitScale)\n                    .on('brushstart', axisBrushStarted)\n                    .on('brush', axisBrushMoved)\n                    .on('brushend', axisBrushEnded);\n                if(d.filter[0] !== 0 || d.filter[1] !== 1) {\n                    d.brush.extent(d.filter);\n                }\n                d3.select(this).call(d.brush);\n            }\n        });\n\n    axisBrushEnter\n        .selectAll('rect')\n        .attr('x', -c.bar.capturewidth / 2)\n        .attr('width', c.bar.capturewidth);\n\n    axisBrushEnter\n        .selectAll('rect.extent')\n        .attr('fill', 'url(#filterBarPattern)')\n        .style('cursor', 'ns-resize')\n        .filter(function(d) {return d.filter[0] === 0 && d.filter[1] === 1;})\n        .attr('y', -100); //  // zero-size rectangle pointer issue workaround\n\n    axisBrushEnter\n        .selectAll('.resize rect')\n        .attr('height', c.bar.handleheight)\n        .attr('opacity', 0)\n        .style('visibility', 'visible');\n\n    axisBrushEnter\n        .selectAll('.resize.n rect')\n        .style('cursor', 'n-resize')\n        .attr('y', c.bar.handleoverlap - c.bar.handleheight);\n\n    axisBrushEnter\n        .selectAll('.resize.s rect')\n        .style('cursor', 's-resize')\n        .attr('y', c.bar.handleoverlap);\n\n    var justStarted = false;\n    var contextShown = false;\n\n    function axisBrushStarted() {\n        justStarted = true;\n        domainBrushing = true;\n    }\n\n    function axisBrushMoved(dimension) {\n        linePickActive = false;\n        var p = dimension.parent;\n        var extent = dimension.brush.extent();\n        var dimensions = p.dimensions;\n        var filter = dimensions[dimension.xIndex].filter;\n        var reset = justStarted && (extent[0] === extent[1]);\n        if(reset) {\n            dimension.brush.clear();\n            d3.select(this).select('rect.extent').attr('y', -100); // zero-size rectangle pointer issue workaround\n        }\n        var newExtent = reset ? [0, 1] : extent.slice();\n        if(newExtent[0] !== filter[0] || newExtent[1] !== filter[1]) {\n            dimensions[dimension.xIndex].filter = newExtent;\n            p.focusLineLayer && p.focusLineLayer.render(p.panels, true);\n            var filtersActive = someFiltersActive(p);\n            if(!contextShown && filtersActive) {\n                p.contextLineLayer && p.contextLineLayer.render(p.panels, true);\n                contextShown = true;\n            } else if(contextShown && !filtersActive) {\n                p.contextLineLayer && p.contextLineLayer.render(p.panels, true, true);\n                contextShown = false;\n            }\n        }\n        justStarted = false;\n    }\n\n    function axisBrushEnded(dimension) {\n        var p = dimension.parent;\n        var extent = dimension.brush.extent();\n        var empty = extent[0] === extent[1];\n        var dimensions = p.dimensions;\n        var f = dimensions[dimension.xIndex].filter;\n        if(!empty && dimension.ordinal) {\n            f[0] = ordinalScaleSnap(dimension.ordinalScale, f[0]);\n            f[1] = ordinalScaleSnap(dimension.ordinalScale, f[1]);\n            if(f[0] === f[1]) {\n                f[0] = Math.max(0, f[0] - 0.05);\n                f[1] = Math.min(1, f[1] + 0.05);\n            }\n            d3.select(this).transition().duration(150).call(dimension.brush.extent(f));\n            p.focusLineLayer.render(p.panels, true);\n        }\n        p.pickLineLayer && p.pickLineLayer.render(p.panels, true);\n        linePickActive = true;\n        domainBrushing = 'ending';\n        if(callbacks && callbacks.filterChanged) {\n            var invScale = dimension.domainToUnitScale.invert;\n\n            // update gd.data as if a Plotly.restyle were fired\n            var newRange = f.map(invScale);\n            callbacks.filterChanged(p.key, dimension.visibleIndex, newRange);\n        }\n    }\n\n    return tweakables;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/parcoords/lines.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar createREGL = require('regl');\nvar glslify = require('glslify');\nvar verticalPadding = require('./constants').verticalPadding;\nvar vertexShaderSource = glslify('./shaders/vertex.glsl');\nvar pickVertexShaderSource = glslify('./shaders/pick_vertex.glsl');\nvar fragmentShaderSource = glslify('./shaders/fragment.glsl');\n\nvar depthLimitEpsilon = 1e-6; // don't change; otherwise near/far plane lines are lost\n\nvar gpuDimensionCount = 64;\nvar sectionVertexCount = 2;\nvar vec4NumberCount = 4;\n\nvar contextColor = [119, 119, 119]; // middle gray to not drawn the focus; looks good on a black or white background\n\nvar dummyPixel = new Uint8Array(4);\nvar pickPixel = new Uint8Array(4);\n\nfunction ensureDraw(regl) {\n    regl.read({\n        x: 0,\n        y: 0,\n        width: 1,\n        height: 1,\n        data: dummyPixel\n    });\n}\n\nfunction clear(regl, x, y, width, height) {\n    var gl = regl._gl;\n    gl.enable(gl.SCISSOR_TEST);\n    gl.scissor(x, y, width, height);\n    regl.clear({color: [0, 0, 0, 0], depth: 1}); // clearing is done in scissored panel only\n}\n\nfunction renderBlock(regl, glAes, renderState, blockLineCount, sampleCount, item) {\n\n    var rafKey = item.key;\n\n    function render(blockNumber) {\n\n        var count;\n\n        count = Math.min(blockLineCount, sampleCount - blockNumber * blockLineCount);\n\n        item.offset = sectionVertexCount * blockNumber * blockLineCount;\n        item.count = sectionVertexCount * count;\n        if(blockNumber === 0) {\n            window.cancelAnimationFrame(renderState.currentRafs[rafKey]); // stop drawing possibly stale glyphs before clearing\n            delete renderState.currentRafs[rafKey];\n            clear(regl, item.scissorX, item.scissorY, item.scissorWidth, item.viewBoxSize[1]);\n        }\n\n        if(renderState.clearOnly) {\n            return;\n        }\n\n        glAes(item);\n\n        if(blockNumber * blockLineCount + count < sampleCount) {\n            renderState.currentRafs[rafKey] = window.requestAnimationFrame(function() {\n                render(blockNumber + 1);\n            });\n        }\n\n        renderState.drawCompleted = false;\n    }\n\n    if(!renderState.drawCompleted) {\n        ensureDraw(regl);\n        renderState.drawCompleted = true;\n    }\n\n    // start with rendering item 0; recursion handles the rest\n    render(0);\n}\n\nfunction adjustDepth(d) {\n    // WebGL matrix operations use floats with limited precision, potentially causing a number near a border of [0, 1]\n    // to end up slightly outside the border. With an epsilon, we reduce the chance that a line gets clipped by the\n    // near or the far plane.\n    return Math.max(depthLimitEpsilon, Math.min(1 - depthLimitEpsilon, d));\n}\n\nfunction palette(unitToColor, context, opacity) {\n    var result = [];\n    for(var j = 0; j < 256; j++) {\n        var c = unitToColor(j / 255);\n        result.push((context ? contextColor : c).concat(opacity));\n    }\n\n    return result;\n}\n\n// Maps the sample index [0...sampleCount - 1] to a range of [0, 1] as the shader expects colors in the [0, 1] range.\n// but first it shifts the sample index by 0, 8 or 16 bits depending on rgbIndex [0..2]\n// with the end result that each line will be of a unique color, making it possible for the pick handler\n// to uniquely identify which line is hovered over (bijective mapping).\n// The inverse, i.e. readPixel is invoked from 'parcoords.js'\nfunction calcPickColor(j, rgbIndex) {\n    return (j >>> 8 * rgbIndex) % 256 / 255;\n}\n\nfunction makePoints(sampleCount, dimensionCount, dimensions, color) {\n\n    var points = [];\n    for(var j = 0; j < sampleCount; j++) {\n        for(var i = 0; i < gpuDimensionCount; i++) {\n            points.push(i < dimensionCount ?\n                dimensions[i].paddedUnitValues[j] :\n                i === (gpuDimensionCount - 1) ?\n                    adjustDepth(color[j]) :\n                    i >= gpuDimensionCount - 4 ?\n                        calcPickColor(j, gpuDimensionCount - 2 - i) :\n                        0.5);\n        }\n    }\n\n    return points;\n}\n\nfunction makeVecAttr(sampleCount, points, vecIndex) {\n\n    var i, j, k;\n    var pointPairs = [];\n\n    for(j = 0; j < sampleCount; j++) {\n        for(k = 0; k < sectionVertexCount; k++) {\n            for(i = 0; i < vec4NumberCount; i++) {\n                pointPairs.push(points[j * gpuDimensionCount + vecIndex * vec4NumberCount + i]);\n                if(vecIndex * vec4NumberCount + i === gpuDimensionCount - 1 && k % 2 === 0) {\n                    pointPairs[pointPairs.length - 1] *= -1;\n                }\n            }\n        }\n    }\n\n    return pointPairs;\n}\n\nfunction makeAttributes(sampleCount, points) {\n\n    var vecIndices = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];\n    var vectors = vecIndices.map(function(vecIndex) {return makeVecAttr(sampleCount, points, vecIndex);});\n\n    var attributes = {};\n    vectors.forEach(function(v, vecIndex) {\n        attributes['p' + vecIndex.toString(16)] = v;\n    });\n\n    return attributes;\n}\n\nfunction valid(i, offset, panelCount) {\n    return i + offset <= panelCount;\n}\n\nmodule.exports = function(canvasGL, lines, canvasWidth, canvasHeight, initialDimensions, initialPanels, unitToColor, context, pick, scatter) {\n\n    var renderState = {\n        currentRafs: {},\n        drawCompleted: true,\n        clearOnly: false\n    };\n\n    var initialDims = initialDimensions.slice();\n\n    var dimensionCount = initialDims.length;\n    var sampleCount = initialDims[0] ? initialDims[0].values.length : 0;\n\n    var focusAlphaBlending = context;\n\n    var color = pick ? lines.color.map(function(_, i) {return i / lines.color.length;}) : lines.color;\n    var contextOpacity = Math.max(1 / 255, Math.pow(1 / color.length, 1 / 3));\n    var overdrag = lines.canvasOverdrag;\n\n    var panelCount = initialPanels.length;\n\n    var points = makePoints(sampleCount, dimensionCount, initialDims, color);\n    var attributes = makeAttributes(sampleCount, points);\n\n    var regl = createREGL({\n        canvas: canvasGL,\n        attributes: {\n            preserveDrawingBuffer: true,\n            antialias: !pick\n        }\n    });\n\n    var paletteTexture = regl.texture({\n        shape: [256, 1],\n        format: 'rgba',\n        type: 'uint8',\n        mag: 'nearest',\n        min: 'nearest',\n        data: palette(unitToColor, context, Math.round((context ? contextOpacity : 1) * 255))\n    });\n\n    var glAes = regl({\n\n        profile: false,\n\n        blend: {\n            enable: focusAlphaBlending,\n            func: {\n                srcRGB: 'src alpha',\n                dstRGB: 'one minus src alpha',\n                srcAlpha: 1,\n                dstAlpha: 1 // 'one minus src alpha'\n            },\n            equation: {\n                rgb: 'add',\n                alpha: 'add'\n            },\n            color: [0, 0, 0, 0]\n        },\n\n        depth: {\n            enable: !focusAlphaBlending,\n            mask: true,\n            func: 'less',\n            range: [0, 1]\n        },\n\n        // for polygons\n        cull: {\n            enable: true,\n            face: 'back'\n        },\n\n        scissor: {\n            enable: true,\n            box: {\n                x: regl.prop('scissorX'),\n                y: regl.prop('scissorY'),\n                width: regl.prop('scissorWidth'),\n                height: regl.prop('scissorHeight')\n            }\n        },\n\n        dither: false,\n\n        vert: pick ? pickVertexShaderSource : vertexShaderSource,\n\n        frag: fragmentShaderSource,\n\n        primitive: 'lines',\n        lineWidth: 1,\n        attributes: attributes,\n        uniforms: {\n            resolution: regl.prop('resolution'),\n            viewBoxPosition: regl.prop('viewBoxPosition'),\n            viewBoxSize: regl.prop('viewBoxSize'),\n            dim1A: regl.prop('dim1A'),\n            dim2A: regl.prop('dim2A'),\n            dim1B: regl.prop('dim1B'),\n            dim2B: regl.prop('dim2B'),\n            dim1C: regl.prop('dim1C'),\n            dim2C: regl.prop('dim2C'),\n            dim1D: regl.prop('dim1D'),\n            dim2D: regl.prop('dim2D'),\n            loA: regl.prop('loA'),\n            hiA: regl.prop('hiA'),\n            loB: regl.prop('loB'),\n            hiB: regl.prop('hiB'),\n            loC: regl.prop('loC'),\n            hiC: regl.prop('hiC'),\n            loD: regl.prop('loD'),\n            hiD: regl.prop('hiD'),\n            palette: paletteTexture,\n            colorClamp: regl.prop('colorClamp'),\n            scatter: regl.prop('scatter')\n        },\n        offset: regl.prop('offset'),\n        count: regl.prop('count')\n    });\n\n    var colorClamp = [0, 1];\n\n    function setColorDomain(unitDomain) {\n        colorClamp[0] = unitDomain[0];\n        colorClamp[1] = unitDomain[1];\n    }\n\n    var previousAxisOrder = [];\n\n    function makeItem(i, ii, x, y, panelSizeX, canvasPanelSizeY, crossfilterDimensionIndex, scatter, I, leftmost, rightmost) {\n        var loHi, abcd, d, index;\n        var leftRight = [i, ii];\n        var filterEpsilon = verticalPadding / canvasPanelSizeY;\n\n        var dims = [0, 1].map(function() {return [0, 1, 2, 3].map(function() {return new Float32Array(16);});});\n        var lims = [0, 1].map(function() {return [0, 1, 2, 3].map(function() {return new Float32Array(16);});});\n\n        for(loHi = 0; loHi < 2; loHi++) {\n            index = leftRight[loHi];\n            for(abcd = 0; abcd < 4; abcd++) {\n                for(d = 0; d < 16; d++) {\n                    var dimP = d + 16 * abcd;\n                    dims[loHi][abcd][d] = d + 16 * abcd === index ? 1 : 0;\n                    lims[loHi][abcd][d] = (!context && valid(d, 16 * abcd, panelCount) ? initialDims[dimP === 0 ? 0 : 1 + ((dimP - 1) % (initialDims.length - 1))].filter[loHi] : loHi) + (2 * loHi - 1) * filterEpsilon;\n                }\n            }\n        }\n\n        return {\n            key: crossfilterDimensionIndex,\n            resolution: [canvasWidth, canvasHeight],\n            viewBoxPosition: [x + overdrag, y],\n            viewBoxSize: [panelSizeX, canvasPanelSizeY],\n            i: i,\n            ii: ii,\n\n            dim1A: dims[0][0],\n            dim1B: dims[0][1],\n            dim1C: dims[0][2],\n            dim1D: dims[0][3],\n            dim2A: dims[1][0],\n            dim2B: dims[1][1],\n            dim2C: dims[1][2],\n            dim2D: dims[1][3],\n\n            loA: lims[0][0],\n            loB: lims[0][1],\n            loC: lims[0][2],\n            loD: lims[0][3],\n            hiA: lims[1][0],\n            hiB: lims[1][1],\n            hiC: lims[1][2],\n            hiD: lims[1][3],\n\n            colorClamp: colorClamp,\n            scatter: scatter || 0,\n            scissorX: I === leftmost ? 0 : x + overdrag,\n            scissorWidth: (I === rightmost ? canvasWidth - x + overdrag : panelSizeX + 0.5) + (I === leftmost ? x + overdrag : 0),\n            scissorY: y,\n            scissorHeight: canvasPanelSizeY\n        };\n    }\n\n    function renderGLParcoords(panels, setChanged, clearOnly) {\n\n        var I;\n\n        var leftmost, rightmost, lowestX = Infinity, highestX = -Infinity;\n\n        for(I = 0; I < panelCount; I++) {\n            if(panels[I].dim2.canvasX > highestX) {\n                highestX = panels[I].dim2.canvasX;\n                rightmost = I;\n            }\n            if(panels[I].dim1.canvasX < lowestX) {\n                lowestX = panels[I].dim1.canvasX;\n                leftmost = I;\n            }\n        }\n\n        if(panelCount === 0) {\n            // clear canvas here, as the panel iteration below will not enter the loop body\n            clear(regl, 0, 0, canvasWidth, canvasHeight);\n        }\n\n        for(I = 0; I < panelCount; I++) {\n            var panel = panels[I];\n            var dim1 = panel.dim1;\n            var i = dim1.crossfilterDimensionIndex;\n            var x = panel.canvasX;\n            var y = panel.canvasY;\n            var dim2 = panel.dim2;\n            var ii = dim2.crossfilterDimensionIndex;\n            var panelSizeX = panel.panelSizeX;\n            var panelSizeY = panel.panelSizeY;\n            var xTo = x + panelSizeX;\n            if(setChanged || !previousAxisOrder[i] || previousAxisOrder[i][0] !== x || previousAxisOrder[i][1] !== xTo) {\n                previousAxisOrder[i] = [x, xTo];\n                var item = makeItem(i, ii, x, y, panelSizeX, panelSizeY, dim1.crossfilterDimensionIndex, scatter || dim1.scatter ? 1 : 0, I, leftmost, rightmost);\n                renderState.clearOnly = clearOnly;\n                renderBlock(regl, glAes, renderState, setChanged ? lines.blockLineCount : sampleCount, sampleCount, item);\n            }\n        }\n    }\n\n    function readPixel(canvasX, canvasY) {\n        regl.read({\n            x: canvasX,\n            y: canvasY,\n            width: 1,\n            height: 1,\n            data: pickPixel\n        });\n        return pickPixel;\n    }\n\n    function readPixels(canvasX, canvasY, width, height) {\n        var pixelArray = new Uint8Array(4 * width * height);\n        regl.read({\n            x: canvasX,\n            y: canvasY,\n            width: width,\n            height: height,\n            data: pixelArray\n        });\n        return pixelArray;\n    }\n\n    return {\n        setColorDomain: setColorDomain,\n        render: renderGLParcoords,\n        readPixel: readPixel,\n        readPixels: readPixels,\n        destroy: regl.destroy\n    };\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/parcoords/constants.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n\nmodule.exports = {\n    maxDimensionCount: 60, // this cannot be increased without WebGL code refactoring\n    overdrag: 45,\n    verticalPadding: 2, // otherwise, horizontal lines on top or bottom are of lower width\n    tickDistance: 50,\n    canvasPixelRatio: 1,\n    blockLineCount: 5000,\n    scatter: false,\n    layers: ['contextLineLayer', 'focusLineLayer', 'pickLineLayer'],\n    axisTitleOffset: 28,\n    axisExtentOffset: 10,\n    bar: {\n        width: 4, // Visible width of the filter bar\n        capturewidth: 10, // Mouse-sensitive width for interaction (Fitts law)\n        fillcolor: 'magenta', // Color of the filter bar fill\n        fillopacity: 1, // Filter bar fill opacity\n        strokecolor: 'white', // Color of the filter bar side lines\n        strokeopacity: 1, // Filter bar side stroke opacity\n        strokewidth: 1, // Filter bar side stroke width in pixels\n        handleheight: 16, // Height of the filter bar vertical resize areas on top and bottom\n        handleopacity: 1, // Opacity of the filter bar vertical resize areas on top and bottom\n        handleoverlap: 0 // A larger than 0 value causes overlaps with the filter bar, represented as pixels.'\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/scatter/clean_data.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\n\n// remove opacity for any trace that has a fill or is filled to\nmodule.exports = function cleanData(fullData) {\n    for(var i = 0; i < fullData.length; i++) {\n        var tracei = fullData[i];\n        if(tracei.type !== 'scatter') continue;\n\n        var filli = tracei.fill;\n        if(filli === 'none' || filli === 'toself') continue;\n\n        tracei.opacity = undefined;\n\n        if(filli === 'tonexty' || filli === 'tonextx') {\n            for(var j = i - 1; j >= 0; j--) {\n                var tracej = fullData[j];\n\n                if((tracej.type === 'scatter') &&\n                        (tracej.xaxis === tracei.xaxis) &&\n                        (tracej.yaxis === tracei.yaxis)) {\n                    tracej.opacity = undefined;\n                    break;\n                }\n            }\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/scatter/colorscale_calc.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar hasColorscale = require('../../components/colorscale/has_colorscale');\nvar calcColorscale = require('../../components/colorscale/calc');\n\nvar subTypes = require('./subtypes');\n\n\nmodule.exports = function calcMarkerColorscale(trace) {\n    if(subTypes.hasLines(trace) && hasColorscale(trace, 'line')) {\n        calcColorscale(trace, trace.line.color, 'line', 'c');\n    }\n\n    if(subTypes.hasMarkers(trace)) {\n        if(hasColorscale(trace, 'marker')) {\n            calcColorscale(trace, trace.marker.color, 'marker', 'c');\n        }\n        if(hasColorscale(trace, 'marker.line')) {\n            calcColorscale(trace, trace.marker.line.color, 'marker.line', 'c');\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/scatter/fillcolor_defaults.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Color = require('../../components/color');\n\n\nmodule.exports = function fillColorDefaults(traceIn, traceOut, defaultColor, coerce) {\n    var inheritColorFromMarker = false;\n\n    if(traceOut.marker) {\n        // don't try to inherit a color array\n        var markerColor = traceOut.marker.color,\n            markerLineColor = (traceOut.marker.line || {}).color;\n\n        if(markerColor && !Array.isArray(markerColor)) {\n            inheritColorFromMarker = markerColor;\n        }\n        else if(markerLineColor && !Array.isArray(markerLineColor)) {\n            inheritColorFromMarker = markerLineColor;\n        }\n    }\n\n    coerce('fillcolor', Color.addOpacity(\n        (traceOut.line || {}).color ||\n        inheritColorFromMarker ||\n        defaultColor, 0.5\n    ));\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/scatter/get_trace_color.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Color = require('../../components/color');\nvar subtypes = require('./subtypes');\n\n\nmodule.exports = function getTraceColor(trace, di) {\n    var lc, tc;\n\n    // TODO: text modes\n\n    if(trace.mode === 'lines') {\n        lc = trace.line.color;\n        return (lc && Color.opacity(lc)) ?\n            lc : trace.fillcolor;\n    }\n    else if(trace.mode === 'none') {\n        return trace.fill ? trace.fillcolor : '';\n    }\n    else {\n        var mc = di.mcc || (trace.marker || {}).color,\n            mlc = di.mlcc || ((trace.marker || {}).line || {}).color;\n\n        tc = (mc && Color.opacity(mc)) ? mc :\n            (mlc && Color.opacity(mlc) &&\n                (di.mlw || ((trace.marker || {}).line || {}).width)) ? mlc : '';\n\n        if(tc) {\n            // make sure the points aren't TOO transparent\n            if(Color.opacity(tc) < 0.3) {\n                return Color.addOpacity(tc, 0.3);\n            }\n            else return tc;\n        }\n        else {\n            lc = (trace.line || {}).color;\n            return (lc && Color.opacity(lc) &&\n                subtypes.hasLines(trace) && trace.line.width) ?\n                    lc : trace.fillcolor;\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/scatter/line_defaults.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar hasColorscale = require('../../components/colorscale/has_colorscale');\nvar colorscaleDefaults = require('../../components/colorscale/defaults');\n\n\nmodule.exports = function lineDefaults(traceIn, traceOut, defaultColor, layout, coerce, opts) {\n    var markerColor = (traceIn.marker || {}).color;\n\n    coerce('line.color', defaultColor);\n\n    if(hasColorscale(traceIn, 'line')) {\n        colorscaleDefaults(traceIn, traceOut, layout, coerce, {prefix: 'line.', cLetter: 'c'});\n    }\n    else {\n        var lineColorDflt = (Array.isArray(markerColor) ? false : markerColor) || defaultColor;\n        coerce('line.color', lineColorDflt);\n    }\n\n    coerce('line.width');\n    if(!(opts || {}).noDash) coerce('line.dash');\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/scatter/line_points.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\n\nmodule.exports = function linePoints(d, opts) {\n    var xa = opts.xaxis,\n        ya = opts.yaxis,\n        simplify = opts.simplify,\n        connectGaps = opts.connectGaps,\n        baseTolerance = opts.baseTolerance,\n        linear = opts.linear,\n        segments = [],\n        minTolerance = 0.2, // fraction of tolerance \"so close we don't even consider it a new point\"\n        pts = new Array(d.length),\n        pti = 0,\n        i,\n\n        // pt variables are pixel coordinates [x,y] of one point\n        clusterStartPt, // these four are the outputs of clustering on a line\n        clusterEndPt,\n        clusterHighPt,\n        clusterLowPt,\n        thisPt, // \"this\" is the next point we're considering adding to the cluster\n\n        clusterRefDist,\n        clusterHighFirst, // did we encounter the high point first, then a low point, or vice versa?\n        clusterUnitVector, // the first two points in the cluster determine its unit vector\n                           // so the second is always in the \"High\" direction\n        thisVector, // the pixel delta from clusterStartPt\n\n        // val variables are (signed) pixel distances along the cluster vector\n        clusterHighVal,\n        clusterLowVal,\n        thisVal,\n\n        // deviation variables are (signed) pixel distances normal to the cluster vector\n        clusterMinDeviation,\n        clusterMaxDeviation,\n        thisDeviation;\n\n    if(!simplify) {\n        baseTolerance = minTolerance = -1;\n    }\n\n    // turn one calcdata point into pixel coordinates\n    function getPt(index) {\n        var x = xa.c2p(d[index].x),\n            y = ya.c2p(d[index].y);\n        if(x === BADNUM || y === BADNUM) return false;\n        return [x, y];\n    }\n\n    // if we're off-screen, increase tolerance over baseTolerance\n    function getTolerance(pt) {\n        var xFrac = pt[0] / xa._length,\n            yFrac = pt[1] / ya._length;\n        return (1 + 10 * Math.max(0, -xFrac, xFrac - 1, -yFrac, yFrac - 1)) * baseTolerance;\n    }\n\n    function ptDist(pt1, pt2) {\n        var dx = pt1[0] - pt2[0],\n            dy = pt1[1] - pt2[1];\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    // loop over ALL points in this trace\n    for(i = 0; i < d.length; i++) {\n        clusterStartPt = getPt(i);\n        if(!clusterStartPt) continue;\n\n        pti = 0;\n        pts[pti++] = clusterStartPt;\n\n        // loop over one segment of the trace\n        for(i++; i < d.length; i++) {\n            clusterHighPt = getPt(i);\n            if(!clusterHighPt) {\n                if(connectGaps) continue;\n                else break;\n            }\n\n            // can't decimate if nonlinear line shape\n            // TODO: we *could* decimate [hv]{2,3} shapes if we restricted clusters to horz or vert again\n            // but spline would be verrry awkward to decimate\n            if(!linear) {\n                pts[pti++] = clusterHighPt;\n                continue;\n            }\n\n            clusterRefDist = ptDist(clusterHighPt, clusterStartPt);\n\n            if(clusterRefDist < getTolerance(clusterHighPt) * minTolerance) continue;\n\n            clusterUnitVector = [\n                (clusterHighPt[0] - clusterStartPt[0]) / clusterRefDist,\n                (clusterHighPt[1] - clusterStartPt[1]) / clusterRefDist\n            ];\n\n            clusterLowPt = clusterStartPt;\n            clusterHighVal = clusterRefDist;\n            clusterLowVal = clusterMinDeviation = clusterMaxDeviation = 0;\n            clusterHighFirst = false;\n            clusterEndPt = clusterHighPt;\n\n            // loop over one cluster of points that collapse onto one line\n            for(i++; i < d.length; i++) {\n                thisPt = getPt(i);\n                if(!thisPt) {\n                    if(connectGaps) continue;\n                    else break;\n                }\n                thisVector = [\n                    thisPt[0] - clusterStartPt[0],\n                    thisPt[1] - clusterStartPt[1]\n                ];\n                // cross product (or dot with normal to the cluster vector)\n                thisDeviation = thisVector[0] * clusterUnitVector[1] - thisVector[1] * clusterUnitVector[0];\n                clusterMinDeviation = Math.min(clusterMinDeviation, thisDeviation);\n                clusterMaxDeviation = Math.max(clusterMaxDeviation, thisDeviation);\n\n                if(clusterMaxDeviation - clusterMinDeviation > getTolerance(thisPt)) break;\n\n                clusterEndPt = thisPt;\n                thisVal = thisVector[0] * clusterUnitVector[0] + thisVector[1] * clusterUnitVector[1];\n\n                if(thisVal > clusterHighVal) {\n                    clusterHighVal = thisVal;\n                    clusterHighPt = thisPt;\n                    clusterHighFirst = false;\n                } else if(thisVal < clusterLowVal) {\n                    clusterLowVal = thisVal;\n                    clusterLowPt = thisPt;\n                    clusterHighFirst = true;\n                }\n            }\n\n            // insert this cluster into pts\n            // we've already inserted the start pt, now check if we have high and low pts\n            if(clusterHighFirst) {\n                pts[pti++] = clusterHighPt;\n                if(clusterEndPt !== clusterLowPt) pts[pti++] = clusterLowPt;\n            } else {\n                if(clusterLowPt !== clusterStartPt) pts[pti++] = clusterLowPt;\n                if(clusterEndPt !== clusterHighPt) pts[pti++] = clusterHighPt;\n            }\n            // and finally insert the end pt\n            pts[pti++] = clusterEndPt;\n\n            // have we reached the end of this segment?\n            if(i >= d.length || !thisPt) break;\n\n            // otherwise we have an out-of-cluster point to insert as next clusterStartPt\n            pts[pti++] = thisPt;\n            clusterStartPt = thisPt;\n        }\n\n        segments.push(pts.slice(0, pti));\n    }\n\n    return segments;\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/scatter/line_shape_defaults.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\n\n// common to 'scatter' and 'scatterternary'\nmodule.exports = function handleLineShapeDefaults(traceIn, traceOut, coerce) {\n    var shape = coerce('line.shape');\n    if(shape === 'spline') coerce('line.smoothing');\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/scatter/link_traces.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = function linkTraces(gd, plotinfo, cdscatter) {\n    var cd, trace;\n    var prevtrace = null;\n\n    for(var i = 0; i < cdscatter.length; ++i) {\n        cd = cdscatter[i];\n        trace = cd[0].trace;\n\n        // Note: The check which ensures all cdscatter here are for the same axis and\n        // are either cartesian or scatterternary has been removed. This code assumes\n        // the passed scattertraces have been filtered to the proper plot types and\n        // the proper subplots.\n        if(trace.visible === true) {\n            trace._nexttrace = null;\n\n            if(['tonextx', 'tonexty', 'tonext'].indexOf(trace.fill) !== -1) {\n                trace._prevtrace = prevtrace;\n\n                if(prevtrace) {\n                    prevtrace._nexttrace = trace;\n                }\n            }\n\n            prevtrace = trace;\n        } else {\n            trace._prevtrace = trace._nexttrace = null;\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/scatter/marker_defaults.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Color = require('../../components/color');\nvar hasColorscale = require('../../components/colorscale/has_colorscale');\nvar colorscaleDefaults = require('../../components/colorscale/defaults');\n\nvar subTypes = require('./subtypes');\n\n\nmodule.exports = function markerDefaults(traceIn, traceOut, defaultColor, layout, coerce, opts) {\n    var isBubble = subTypes.isBubble(traceIn),\n        lineColor = (traceIn.line || {}).color,\n        defaultMLC;\n\n    // marker.color inherit from line.color (even if line.color is an array)\n    if(lineColor) defaultColor = lineColor;\n\n    coerce('marker.symbol');\n    coerce('marker.opacity', isBubble ? 0.7 : 1);\n    coerce('marker.size');\n\n    coerce('marker.color', defaultColor);\n    if(hasColorscale(traceIn, 'marker')) {\n        colorscaleDefaults(traceIn, traceOut, layout, coerce, {prefix: 'marker.', cLetter: 'c'});\n    }\n\n    if(!(opts || {}).noLine) {\n        // if there's a line with a different color than the marker, use\n        // that line color as the default marker line color\n        // (except when it's an array)\n        // mostly this is for transparent markers to behave nicely\n        if(lineColor && !Array.isArray(lineColor) && (traceOut.marker.color !== lineColor)) {\n            defaultMLC = lineColor;\n        }\n        else if(isBubble) defaultMLC = Color.background;\n        else defaultMLC = Color.defaultLine;\n\n        coerce('marker.line.color', defaultMLC);\n        if(hasColorscale(traceIn, 'marker.line')) {\n            colorscaleDefaults(traceIn, traceOut, layout, coerce, {prefix: 'marker.line.', cLetter: 'c'});\n        }\n\n        coerce('marker.line.width', isBubble ? 1 : 0);\n    }\n\n    if(isBubble) {\n        coerce('marker.sizeref');\n        coerce('marker.sizemin');\n        coerce('marker.sizemode');\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-plotly.js/node_modules/plotly.js/src/traces/scatter/text_defaults.js":"/**\n* Copyright 2012-2017, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Lib = require('../../lib');\n\n\n// common to 'scatter', 'scatter3d' and 'scattergeo'\nmodule.exports = function(traceIn, traceOut, layout, coerce) {\n    coerce('textposition');\n    Lib.coerceFont(coerce, 'textfont', layout.font);\n};\n"}